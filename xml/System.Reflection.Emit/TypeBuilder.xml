<Type Name="TypeBuilder" FullName="System.Reflection.Emit.TypeBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30471008" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TypeBuilder extends System.Reflection.TypeInfo implements class System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.TypeBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeBuilder&#xA;Inherits TypeInfo&#xA;Implements _TypeBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeBuilder sealed : System::Reflection::TypeInfo, System::Runtime::InteropServices::_TypeBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._TypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Определяет и создает новые экземпляры классов во время выполнения.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder> корневой класс, используемый для создания динамических классов во время выполнения. Она предоставляет набор подпрограмм, которые используются для определения классов, добавления методов и полей и создания класса в модуле. Новый <xref:System.Reflection.Emit.TypeBuilder> могут создаваться из динамического модуля, вызвав <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> метод, возвращающий <xref:System.Reflection.Emit.TypeBuilder> объекта.  
  
 Порождение отражения предоставляет следующие возможности для определения типов:  
  
-   Определение класса или интерфейса с заданным именем.  
  
-   Определение класса или интерфейса с заданным именем и атрибутами.  
  
-   Определение класса с заданным именем, атрибутами и базового класса.  
  
-   Определение класса с заданным именем, атрибутов, базового класса и набор интерфейсов, реализуемых в классе.  
  
-   Определение класса с заданным именем, атрибутов, базового класса и упаковочный размер.  
  
-   Определение класса с заданным именем, атрибутов, базового класса и размера класса в целом.  
  
-   Определение класса с заданным именем, атрибутов, базового класса, упаковочный размер и размер класса в целом.  
  
 Чтобы создать тип массива, тип указателя или тип byref для неполного типа, представленного <xref:System.Reflection.Emit.TypeBuilder> , используйте <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> метода <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> метод, или <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> метода, соответственно.  
  
 Прежде чем использовать тип, <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> метод должен вызываться. **CreateType** завершения создания типа. Следующий за вызовом **CreateType**, вызывающий объект может создать экземпляр типа с помощью <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> метода и вызывать члены типа с помощью <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> метод. Это ошибка для вызова методов, изменяющих реализацию типа после **CreateType** был вызван. Например общеязыковая среда выполнения создает исключение, если вызывающий объект пытается добавить новые элементы к типу.  
  
 Инициализатор класса создается с помощью <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> метод. **DefineTypeInitializer** возвращает <xref:System.Reflection.Emit.ConstructorBuilder> объекта.  
  
 Вложенные типы определяются путем вызова одного из <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> методы.  
  
## <a name="attributes"></a>Атрибуты  
 <xref:System.Reflection.Emit.TypeBuilder> Класс использует <xref:System.Reflection.TypeAttributes> перечисления для указания характеристики типа должен быть создан:  
  
-   Интерфейсы задаются с помощью <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> и <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> атрибуты.  
  
-   Конкретные классы (классы, которые не могут быть расширены) задаются с помощью <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> атрибута.  
  
-   Несколько атрибутов определяют видимость типов. См. в описании <xref:System.Reflection.TypeAttributes> перечисления.  
  
-   Если <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> указан, загрузчик классов располагает поля в порядке их считывания из метаданных. Загрузчик классов считает, что заданный размер, но не учитывает любые заданные смещения полей. Метаданные сохраняет порядок, в котором создаются определения полей. Даже при объединении метаданные не будет переупорядочивать определения полей. Загрузчик будет поддерживать только если указанное поле смещения <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> указано.  
  
## <a name="known-issues"></a>Известные проблемы  
  
-   Порождение отражения не проверяет, реализовал ли неабстрактный класс, реализующий интерфейс, все методы, объявленные в интерфейсе. Тем не менее если класс не реализует все методы, объявленные в интерфейсе, среда выполнения не загружается класс.  
  
-   Несмотря на то что <xref:System.Reflection.Emit.TypeBuilder> является производным от <xref:System.Type>, некоторые из абстрактных методов, определенных в <xref:System.Type> класс еще не полностью реализованы в <xref:System.Reflection.Emit.TypeBuilder> класса. Эти вызовы <xref:System.Reflection.Emit.TypeBuilder> методы создают исключение <xref:System.NotSupportedException> исключение. Необходимые функции можно получить путем получения созданного типа с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и отражения полученного типа.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. В первом примере показано, как создать динамический тип с полем, конструктор, свойство и метод. Во втором примере создает метод динамически из введенных пользователем данных.  
  
 **Один пример**  
  
 В следующем примере кода показано определение динамическую сборку с одним модулем. Модуль в этой сборке содержит один тип `MyDynamicType`, который имеет закрытое поле, свойство, которое возвращает и задает закрытое поле, конструкторы, которые инициируют закрытое поле и метод, который умножает число на предоставленный пользователем на закрытое поле значение и возвращает результат.  
  
 <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> Поле указано при создании сборки. Сразу же использовать код сборки и сборка сохраняется на диск, чтобы можно было проанализировать с помощью [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) или использовать в другой программе.  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 **Второй пример**  
  
 В следующем образце кода показано, как построить динамический тип с помощью `TypeBuilder`.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">Выполняемое действие безопасности, например Demand, Assert и т. д.</param>
        <param name="pset">Набор разрешений, к которому применяется действие.</param>
        <summary>Добавляет декларативную безопасность в этот тип.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `AddDeclarativeSecurity` может быть вызван несколько раз для каждого вызова, указав действие по обеспечению безопасности (например, требование, Assert или Deny) и набор разрешений, применяемых к данному действию.  
  
> [!NOTE]
>  В .NET Framework версий 1.0, 1.1 и 2.0 декларативные атрибуты безопасности применении к типу с помощью этого метода, хранятся в старом формате метаданных XML.  
  
   
  
## Examples  
 В следующем примере показано использование `AddDeclarativeSecurity` метод, чтобы добавить требование безопасности для <xref:System.Security.Permissions.SecurityPermission> с <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> флаг динамический тип с именем `MyDynamicClass`, в сборке с именем EmittedExample.dll. В примере получается выходные данные консоли; После запуска, можно использовать [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) для изучения EmittedExample.dll. В `MyDynamicClass`откройте `.class public auto ansi` инструкцию, чтобы увидеть декларативного разрешения.  
  
 [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CPP/typebuilder_adddeclarativesecurity.cpp#1)]
 [!code-csharp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CS/typebuilder_adddeclarativesecurity.cs#1)]
 [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/VB/typebuilder_adddeclarativesecurity.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Недопустимый параметр <paramref name="action" /> (недопустимы значения <see langword="RequestMinimum" />, <see langword="RequestOptional" /> и <see langword="RequestRefuse" />).</exception>
        <exception cref="T:System.InvalidOperationException">Содержащий тип был создан с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - или -  
  
 Набор разрешений <paramref name="pset" /> содержит действие, добавленное ранее с помощью <see langword="AddDeclarativeSecurity" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="pset" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public void AddInterfaceImplementation (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInterfaceImplementation(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInterfaceImplementation (interfaceType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInterfaceImplementation(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Интерфейс, реализуемый данным типом.</param>
        <summary>Добавляет интерфейс, реализуемый данным типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем образце кода демонстрируется реализация интерфейса для динамически созданного типа с помощью `AddInterfaceImplementation`.  
  
 [!code-cpp[TypeBuilder_Sample_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#3)]
 [!code-csharp[TypeBuilder_Sample_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#3)]
 [!code-vb[TypeBuilder_Sample_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="interfaceType" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает динамическую сборку, которая содержит определение данного типа.</summary>
        <value>Только для чтения. Извлекает динамическую сборку, которая содержит определение данного типа.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает полное имя этого типа, дополненное отображаемым именем сборки.</summary>
        <value>Только для чтения. Полное имя этого типа, дополненное отображаемым именем сборки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Формат возвращаемой строки представляет собой объединение полного имени типа (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) и отображаемое имя сборки (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), разделив их запятой и пробелом.  
  
 В разделе <xref:System.Reflection.AssemblyName> описание формата отображаемого имени сборки.  
  
## <a name="version-information"></a>Сведения о версии  
 В .NET Framework версий 1.0 и 1.1 значение этого свойства не включает культуры или открытого ключа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает базовый тип этого типа.</summary>
        <value>Только для чтения. Возвращает базовый тип этого типа.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateType">
      <MemberSignature Language="C#" Value="public Type CreateType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type CreateType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateType" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ CreateType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает объект <see cref="T:System.Type" /> для этого класса. После определения полей и методов в классе вызывается метод <see langword="CreateType" /> для загрузки его объекта <see langword="Type" />.</summary>
        <returns>Возвращает новый объект <see cref="T:System.Type" /> для этого класса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот тип является вложенным типом, <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> метод должен вызываться для включающего типа, прежде чем он будет вызван на вложенный тип.  
  
 Если текущий тип является производным от неполного типа или реализует неполные интерфейсы, вызовите <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> метод для родительского типа и типов интерфейса перед вызовом этого метода для текущего типа.  
  
 Если включающий тип содержит поле, которое является типом значения, определенные как вложенный тип (например, поля, представляет собой перечисление, определенные как вложенный тип), вызов <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> метод для включающего типа создаст <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> событий. Это так, как загрузчик не удается определить размер включающего типа до завершения вложенного типа. Вызывающий объект должен быть определен обработчик для <xref:System.AppDomain.TypeResolve> событий для завершения определения вложенного типа путем вызова <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> на <xref:System.Reflection.Emit.TypeBuilder> объект, предоставляющий вложенный тип. В примере кода для этого раздела показано, как определить такие обработчик событий.  
  
 Тип создается только один раз, независимо от того, как много раз <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> вызывается метод. Возвращает все вызовы, такой же <xref:System.Type> объекта.  
  
   
  
## Examples  
 В следующем примере кода показано, как определить обработчик событий для <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> событий для вызова <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> метод для вложенного типа во время <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> вызова для включающего типа.  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CPP/nestedenum.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CS/nestedenum.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/VB/nestedenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Включающий тип не создан.  
  
 - или -  
  
 Этот тип не является абстрактным, а содержит абстрактный метод.  
  
 - или -  
  
 Этот тип не является абстрактным классом или интерфейсом, а содержит метод без тела метода.</exception>
        <exception cref="T:System.NotSupportedException">Тип содержит неверный код на языке MSIL.  
  
 - или -  
  
 Конечный адрес ветвления задан с использованием однобайтового смещения, но он находится на расстоянии более 127 байт от ветви.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось загрузить тип. Например, он содержит метод <see langword="static" />, имеющий соглашение о вызовах <see cref="F:System.Reflection.CallingConventions.HasThis" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTypeInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeInfo CreateTypeInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.TypeInfo CreateTypeInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTypeInfo () As TypeInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::TypeInfo ^ CreateTypeInfo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает объект <see cref="T:System.Reflection.TypeInfo" />, представляющий этот тип.</summary>
        <returns>Объект, представляющий этот тип.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает метод, который объявил текущий параметр универсального типа.</summary>
        <value>Объект <see cref="T:System.Reflection.MethodBase" />, представляющий метод, который объявил текущий тип, если текущий тип является параметром универсального типа; в противном случае — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  При порождении кода, представленного параметром универсального типа <xref:System.Reflection.Emit.GenericTypeParameterBuilder> объекта, а не <xref:System.Reflection.Emit.TypeBuilder> объекта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает тип, объявивший этот тип.</summary>
        <value>Только для чтения. Тип, объявивший этот тип.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineConstructor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет новый конструктор в динамический тип.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="attributes">Атрибуты конструктора.</param>
        <param name="callingConvention">Соглашение о вызовах конструктора.</param>
        <param name="parameterTypes">Типы параметров конструктора.</param>
        <summary>Добавляет в тип новый конструктор с заданными атрибутами и сигнатурой.</summary>
        <returns>Определенный конструктор.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не определить конструктор для динамического типа, автоматически предоставляется конструктор по умолчанию, и он вызывает конструктор базового класса по умолчанию.  
  
 Если определить конструктор для динамического типа, конструктор по умолчанию не предоставляется. Имеются следующие параметры для конструктора по умолчанию в дополнение к определенному вами конструктору:  
  
-   Если требуется конструктор по умолчанию, который просто вызывает конструктор по умолчанию базового класса, можно использовать <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> метод, чтобы создать его (и при необходимости ограничить доступ к нему). Предоставляет реализацию этого конструктора по умолчанию. В противном случае исключение при попытке использовать конструктор. Исключение не возникает, когда <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> вызывается метод.  
  
-   Если конструктор по умолчанию, который выполняет нечто большее, нежели просто вызов конструктора по умолчанию базового класса или другого конструктора, которая вызывает базовый класс или, производящий другие полностью, необходимо использовать <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> метод для ее создания, и предоставить собственную реализацию.  
  
   
  
## Examples  
 В следующем образце кода показано использование `DefineConstructor` для установки определенной подписи и атрибутов конструктора на динамическом типе и возврата соответствующего <xref:System.Reflection.Emit.ConstructorBuilder> для заполнения MSIL.  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes, class System.Type[][] requiredCustomModifiers, class System.Type[][] optionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type(), requiredCustomModifiers As Type()(), optionalCustomModifiers As Type()()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="attributes">Атрибуты конструктора.</param>
        <param name="callingConvention">Соглашение о вызовах конструктора.</param>
        <param name="parameterTypes">Типы параметров конструктора.</param>
        <param name="requiredCustomModifiers">Массив массивов типов. Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</param>
        <param name="optionalCustomModifiers">Массив массивов типов. Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</param>
        <summary>Добавляет в тип новый конструктор с заданными атрибутами, сигнатурой и настраиваемыми модификаторами.</summary>
        <returns>Определенный конструктор.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка предназначен для разработки управляемых компиляторов.  
  
> [!NOTE]
>  Дополнительные сведения о настраиваемых модификаторов см. в документации объектах. Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Размер <paramref name="requiredCustomModifiers" /> или <paramref name="optionalCustomModifiers" /> не равен размеру <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - или -  
  
 Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDefaultConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDefaultConstructor (attributes As MethodAttributes) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineDefaultConstructor(System::Reflection::MethodAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">Объект <see langword="MethodAttributes" />, представляющий атрибуты, применяемые к конструктору.</param>
        <summary>Определяет конструктор по умолчанию. Определенный здесь конструктор просто вызовет конструктор по умолчанию родительского элемента.</summary>
        <returns>Возвращает конструктор.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструктор по умолчанию определяется автоматически, его не нужно вызывать этот метод только в следующих ситуациях.  
  
-   Определен другой конструктор, а также конструктор по умолчанию, который просто вызывает конструктор базового класса.  
  
-   Чтобы задать атрибуты конструктора по умолчанию на что-то отличное от <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, и <xref:System.Reflection.MethodAttributes.RTSpecialName>.  
  
   
  
## Examples  
 В следующем образце кода показано использование `DefineConstructor` для установки определенной подписи и атрибутов конструктора на динамическом типе и возврата соответствующего <xref:System.Reflection.Emit.ConstructorBuilder> для заполнения MSIL.  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">У родительского типа (базового типа) нет конструктора по умолчанию.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - или -  
  
 Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EventBuilder DefineEvent(string name, valuetype System.Reflection.EventAttributes attributes, class System.Type eventtype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEvent (name As String, attributes As EventAttributes, eventtype As Type) As EventBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EventBuilder ^ DefineEvent(System::String ^ name, System::Reflection::EventAttributes attributes, Type ^ eventtype);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EventBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="eventtype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Имя события. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attributes">Атрибуты события.</param>
        <param name="eventtype">Тип события.</param>
        <summary>Добавляет новое событие в тип с заданным именем, атрибутами и типом события.</summary>
        <returns>Определенное событие.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="eventtype" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет новое поле к динамическому типу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">Имя поля. Параметр <c>fieldName</c> не может содержать внедренные значения NULL.</param>
        <param name="type">Тип поля.</param>
        <param name="attributes">Атрибуты поля.</param>
        <summary>Добавляет новое поле в тип с заданным именем, атрибутами и типом поля.</summary>
        <returns>Определенное поле.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="fieldName" /> равна нулю.  
  
 - или -  
  
 Параметр <paramref name="type" /> имеет значение System.Void.  
  
 - или -  
  
 Общий размер был указан для родительского класса этого поля.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="fieldName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, class System.Type[] requiredCustomModifiers, class System.Type[] optionalCustomModifiers, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, cli::array &lt;Type ^&gt; ^ requiredCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalCustomModifiers, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">Имя поля. Параметр <c>fieldName</c> не может содержать внедренные значения NULL.</param>
        <param name="type">Тип поля.</param>
        <param name="requiredCustomModifiers">Массив типов, представляющих обязательные настраиваемые модификаторы для поля, например <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
        <param name="optionalCustomModifiers">Массив типов, представляющих необязательные настраиваемые модификаторы для поля, например <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
        <param name="attributes">Атрибуты поля.</param>
        <summary>Добавляет новое поле в тип с заданным именем, атрибутами, типом поля и настраиваемыми модификаторами.</summary>
        <returns>Определенное поле.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка предназначен для разработки управляемых компиляторов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="fieldName" /> равна нулю.  
  
 - или -  
  
 Параметр <paramref name="type" /> имеет значение System.Void.  
  
 - или -  
  
 Общий размер был указан для родительского класса этого поля.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="fieldName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">Массив имен для параметров универсального типа.</param>
        <summary>Определяет параметры универсального типа для текущего типа, указывая их количество и имена, и возвращает массив объектов <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />, которые можно использовать для задания их ограничений.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />, которые можно использовать для определения ограничений параметров универсального типа для текущего типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода делает текущий тип является универсальным типом. Если метод вызывается снова на тот же тип, <xref:System.InvalidOperationException> возникает исключение.  
  
   
  
## Examples  
 В следующем примере кода создается универсальный тип с двумя параметрами типа и сохраняет их в сборке GenericEmitExample1.dll. Можно использовать [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) для просмотра в создаваемых типов. Более подробное описание действий, необходимых при определении динамического универсального типа см. в разделе [как: определение универсального типа с помощью порождаемого отражения](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).  
  
 [!code-cpp[EmitGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Для этого типа уже были определены параметры универсального типа.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="names" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Элемент <paramref name="names" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="names" /> является пустым массивом.</exception>
        <altmember cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Имя, используемое для ссылки на данные. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="data">Большой двоичный объект данных.</param>
        <param name="attributes">Атрибуты поля.</param>
        <summary>Определяет инициализированное поле данных в разделе .sdata переносимого исполняемого (PE) файла.</summary>
        <returns>Поле для ссылки на данные.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поле, созданная с помощью этого метода будет `static`, даже если не включать `FieldAttributes.Static` в `attributes` параметра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  
  
 - или -  
  
 Размер данных не больше нуля либо не меньше 0x3f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="name" /> или <paramref name="data" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> был вызван ранее.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет метод к типу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Имя метода. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attributes">Атрибуты метода.</param>
        <summary>Добавляет новый метод в тип с указанным именем и атрибутами метода.</summary>
        <returns>Объект <see cref="T:System.Reflection.Emit.MethodBuilder" />, представляющий вновь определенный метод.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не знаете подписи метода во время определения метода, используйте перегрузку этого метода. Например типы параметров и возвращаемого типа универсального метода может указываться с параметрами универсального типа метода, которые должны быть определены после добавления метода в тип. Параметры и тип возвращаемого значения метода можно установить позднее с помощью <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> метод.  
  
 Эта перегрузка метода определяет метод с <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>. Если вам необходимо определить метод без подписи, с другой соглашение о вызовах, используйте <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> перегрузки метода.  
  
   
  
## Examples  
 В следующем примере кода определяется универсальный метод с именем `DemoMethod` , тип параметра и тип возвращаемого значения задаются с помощью его параметров универсального типа. Метод определен без подписи, используя стандартное соглашение о вызовах. <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> Метод используется для создания `DemoMethod` универсального метода и вновь определенный тип параметров используются для подписи и тип возвращаемого значения.  
  
 Данный пример кода является частью большего примера, приведенного для <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> метод.  
  
 [!code-cpp[GenericMethodBuilder#4](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#4)]
 [!code-csharp[GenericMethodBuilder#4](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#4)]
 [!code-vb[GenericMethodBuilder#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#4)]  
[!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
[!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
[!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  
  
 - или -  
  
 Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<see langword="Overridable" /> в Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - или -  
  
 Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
      </Parameters>
      <Docs>
        <param name="name">Имя метода. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attributes">Атрибуты метода.</param>
        <param name="callingConvention">Соглашение о вызовах метода.</param>
        <summary>Добавляет новый метод в тип с указанным именем, атрибутами метода, соглашением о вызовах.</summary>
        <returns>Объект <see cref="T:System.Reflection.Emit.MethodBuilder" />, представляющий вновь определенный метод.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не знаете подписи метода во время определения метода, используйте перегрузку этого метода. Например типы параметров и возвращаемого типа универсального метода может указываться с параметрами универсального типа метода, которые должны быть определены после добавления метода в тип. Параметры и тип возвращаемого значения метода можно установить позднее с помощью <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  
  
 - или -  
  
 Тип родительского элемента данного метода является интерфейсом, и этот метод не является виртуальным (<see langword="Overridable" /> в Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - или -  
  
 Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Имя метода. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attributes">Атрибуты метода.</param>
        <param name="returnType">Возвращаемый тип метода.</param>
        <param name="parameterTypes">Типы параметров метода.</param>
        <summary>Добавляет новый метод в тип с указанным именем, атрибутами метода и сигнатурой метода.</summary>
        <returns>Определенный метод.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем образце кода показано использование `DefineMethod` можно задать определенной подписи и атрибутов конструктора на динамическом типе и возврата соответствующего <xref:System.Reflection.Emit.MethodBuilder> для заполнения MSIL.  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  
  
 - или -  
  
 Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<see langword="Overridable" /> в Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - или -  
  
 Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Имя метода. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attributes">Атрибуты метода.</param>
        <param name="callingConvention">Соглашение о вызовах метода.</param>
        <param name="returnType">Возвращаемый тип метода.</param>
        <param name="parameterTypes">Типы параметров метода.</param>
        <summary>Добавляет новый метод в тип с указанным именем, атрибутами метода, соглашением о вызовах и сигнатурой метода.</summary>
        <returns>Объект <see cref="T:System.Reflection.Emit.MethodBuilder" />, представляющий вновь определенный метод.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем образце кода показано использование `DefineMethod` можно задать определенной подписи и атрибутов конструктора на динамическом типе и возврата соответствующего <xref:System.Reflection.Emit.MethodBuilder> для заполнения MSIL.  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  
  
 - или -  
  
 Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<see langword="Overridable" /> в Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - или -  
  
 Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">Имя метода. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attributes">Атрибуты метода.</param>
        <param name="callingConvention">Соглашение о вызовах метода.</param>
        <param name="returnType">Возвращаемый тип метода.</param>
        <param name="returnTypeRequiredCustomModifiers">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа метода. Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа метода. Если возвращаемый тип не содержит необязательных настраиваемых модификаторов, укажите <see langword="null" />.</param>
        <param name="parameterTypes">Типы параметров метода.</param>
        <param name="parameterTypeRequiredCustomModifiers">Массив массивов типов. Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</param>
        <param name="parameterTypeOptionalCustomModifiers">Массив массивов типов. Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</param>
        <summary>Добавляет новый метод в тип с указанным именем, атрибутами метода, соглашением о вызовах, сигнатурой метода и настраиваемыми модификаторами.</summary>
        <returns>Объект <see cref="T:System.Reflection.Emit.MethodBuilder" />, представляющий добавленный метод.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, если требуется указать пользовательские модификаторы. Если требуется указать пользовательские модификаторы, после создания метода, как и, например, с универсальным методом, типы параметров задаются его параметры универсального типа можно использовать <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> или <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> перегруженных версий метода для определения метод, а затем с помощью <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> метод для определения параметра и возвращают типы с пользовательские модификаторы.  
  
> [!NOTE]
>  Дополнительные сведения о настраиваемых модификаторов см. в документации объектах. Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  
  
 - или -  
  
 Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<see langword="Overridable" /> в Visual Basic).  
  
 - или -  
  
 Размер <paramref name="parameterTypeRequiredCustomModifiers" /> или <paramref name="parameterTypeOptionalCustomModifiers" /> не равен размеру <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - или -  
  
 Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethodOverride">
      <MemberSignature Language="C#" Value="public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineMethodOverride(class System.Reflection.MethodInfo methodInfoBody, class System.Reflection.MethodInfo methodInfoDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineMethodOverride (methodInfoBody As MethodInfo, methodInfoDeclaration As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineMethodOverride(System::Reflection::MethodInfo ^ methodInfoBody, System::Reflection::MethodInfo ^ methodInfoDeclaration);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfoBody" Type="System.Reflection.MethodInfo" />
        <Parameter Name="methodInfoDeclaration" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="methodInfoBody">Тело метода, которое будет использоваться. Должно быть объектом <see langword="MethodBuilder" />.</param>
        <param name="methodInfoDeclaration">Метод, объявление которого будет использоваться.</param>
        <summary>Задает тело данного метода, реализующее объявление данного метода, возможно, с другим именем.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не используйте этот метод для создания перегрузки метода или реализации интерфейса. Переопределение метода базового класса или реализовать метод интерфейса, просто создайте метод с тем же именем и сигнатурой, что и метод должен быть переопределен или реализован, как показано в следующем примере кода.  
  
 <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> Метод используется, когда тела метода и в объявлении метода имеют разные имена. Например класс может переопределить метод базового класса и также предоставить отдельную реализацию элемента интерфейса с тем же именем, как показано в следующем примере кода.  
  
 `DefineMethodOverride` Определяет `methodimpl`, который состоит из пары токены метаданных. Один маркер указывает на реализацию, а также других маркеров точек с объявлением, реализующий текст. Текст должен быть определен в тип, определенный метод impl на и текст должен представлять виртуальный (`Overridable` в Visual Basic). Объявления можно сделать для метода, определенного на интерфейс, реализованный тип, метод для производного класса или метода, определенного в типе. Если объявление является только на интерфейсе, ячейка, заданная для интерфейса изменяется. При объявлении метода в базовом типе, ячейка для этого метода переопределяется, и любые дубликаты переопределенного метода также заменяются. Переопределенный метод не может быть фактический метод, который объявлен. Если метод находится на том же типе, ячейка заменяется, и любые дубликаты заменяемого метода переопределяются.  
  
> [!NOTE]
>  Дополнительные сведения о методе impls см. в разделе `MethodImpl` в объектах документации. Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.  
  
> [!IMPORTANT]
>  После <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> вызывается метод, некоторые функции `methodInfoBody` не может быть изменено. Например, нельзя применять атрибут к параметру универсального типа `methodInfoBody` с помощью <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> метод. Если необходимо использовать <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> метод, сделать это после все характеристики `methodInfoBody` определено.  
  
   
  
## Examples  
 В следующем примере кода содержит интерфейс `I` с методом `M()`, базовый класс `A` , реализующий интерфейс и производный класс `C` , переопределяет реализацию базового класса `M()` , а также Предоставляет отдельную явную реализацию `I.M()`.  
  
 `main()` Метод в примере кода показано, как выпустить производный класс `C`. Переопределение метода `A.M()` выполняется путем выпуска метода `M()` с такой же сигнатурой. Тем не менее для обеспечения отдельные реализации `I.M()`, необходимо определить тела метода и затем использовать <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> способ сопоставления, тело метода с <xref:System.Reflection.MethodInfo> представляющий `I.M()`. Имя тела метода не имеет значения.  
  
 В примере кода создается экземпляр выпущенного класса. Он получает <xref:System.Reflection.MethodInfo> для объекта `I.M()`, и использует его, чтобы вызвать класс, порожденный явную реализацию интерфейса. Затем происходит получение <xref:System.Reflection.MethodInfo> для объекта `A.M()`и использует его для вызова выпущенного класса переопределения этого метода.  
  
 [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cpp/source.cpp#1)]
 [!code-csharp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cs/source.cs#1)]
 [!code-vb[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Объект <paramref name="methodInfoBody" /> не принадлежит к этому классу.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="methodInfoBody" /> или <paramref name="methodInfoDeclaration" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - или -  
  
 Объявляющий тип <paramref name="methodInfoBody" /> не является типом, представленным этим <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineNestedType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет вложенный тип.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Краткое имя объекта. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <summary>Определяет вложенный тип с заданным именем.</summary>
        <returns>Определенный вложенный тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для создания вложенных типов даже после <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> метод вызван для включающего типа.  
  
 Вложенный тип должен быть завершен, прежде чем можно отразить с помощью метода <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, или <xref:System.Type.GetNestedTypes%2A>.  
  
 См. в описании <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для заказа, в котором следует выполнять вложенных и вложенных типов.  
  
 Повторяющееся имя не обязательно создается, если `name` совпадало с именем ранее определенного типа или вложенного типа. Будут повторяться, полных имен должен совпадать, включая пространство имен и все вложенные типы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина <paramref name="name" /> равна нулю или больше 1023.  
  
 - или -  
  
 Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Краткое имя объекта. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attr">Атрибуты типа.</param>
        <summary>Определяет вложенный тип с заданным именем и атрибутами.</summary>
        <returns>Определенный вложенный тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для создания вложенных типов даже после <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> метод вызван для включающего типа.  
  
 Вложенный тип должен быть завершен, прежде чем можно отразить с помощью метода <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, или <xref:System.Type.GetNestedTypes%2A>.  
  
 См. в описании <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для заказа, в котором следует выполнять вложенных и вложенных типов.  
  
 Повторяющееся имя не обязательно создается, если `name` совпадало с именем ранее определенного типа или вложенного типа. Будут повторяться, полных имен должен совпадать, включая пространство имен и все вложенные типы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не указан вложенный атрибут.  
  
 - или -  
  
 Этот тип запечатан.  
  
 - или -  
  
 Этот тип является массивом.  
  
 - или -  
  
 Этот тип является интерфейсом, а вложенный тип не является интерфейсом.  
  
 - или -  
  
 Длина <paramref name="name" /> равна нулю или больше 1023.  
  
 - или -  
  
 Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Краткое имя объекта. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attr">Атрибуты типа.</param>
        <param name="parent">Тип, который вложенный тип расширяет.</param>
        <summary>Определяет вложенный тип на основе его имени, атрибутов и типа, который он расширяет.</summary>
        <returns>Определенный вложенный тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для создания вложенных типов даже после <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> метод вызван для включающего типа.  
  
 Вложенный тип должен быть завершен, прежде чем можно отразить с помощью метода <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, или <xref:System.Type.GetNestedTypes%2A>.  
  
 См. в описании <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для заказа, в котором следует выполнять вложенных и вложенных типов.  
  
 Повторяющееся имя не обязательно создается, если `name` совпадало с именем ранее определенного типа или вложенного типа. Будут повторяться, полных имен должен совпадать, включая пространство имен и все вложенные типы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не указан вложенный атрибут.  
  
 - или -  
  
 Этот тип запечатан.  
  
 - или -  
  
 Этот тип является массивом.  
  
 - или -  
  
 Этот тип является интерфейсом, а вложенный тип не является интерфейсом.  
  
 - или -  
  
 Длина <paramref name="name" /> равна нулю или больше 1023.  
  
 - или -  
  
 Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Краткое имя объекта. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attr">Атрибуты типа.</param>
        <param name="parent">Тип, который вложенный тип расширяет.</param>
        <param name="typeSize">Общий размер типа.</param>
        <summary>Определяет вложенный тип по заданным имени, атрибутам, общему размеру типа и типу, который он расширяет.</summary>
        <returns>Определенный вложенный тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для создания вложенных типов даже после <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> метод вызван для включающего типа.  
  
 Вложенный тип должен быть завершен, прежде чем можно отразить с помощью метода <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, или <xref:System.Type.GetNestedTypes%2A>.  
  
 См. в описании <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для заказа, в котором следует выполнять вложенных и вложенных типов.  
  
 Повторяющееся имя не обязательно создается, если `name` совпадало с именем ранее определенного типа или вложенного типа. Будут повторяться, полных имен должен совпадать, включая пространство имен и все вложенные типы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не указан вложенный атрибут.  
  
 - или -  
  
 Этот тип запечатан.  
  
 - или -  
  
 Этот тип является массивом.  
  
 - или -  
  
 Этот тип является интерфейсом, а вложенный тип не является интерфейсом.  
  
 - или -  
  
 Длина <paramref name="name" /> равна нулю или больше 1023.  
  
 - или -  
  
 Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">Краткое имя объекта. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attr">Атрибуты типа.</param>
        <param name="parent">Тип, который вложенный тип расширяет.</param>
        <param name="packSize">Размер упаковки типа.</param>
        <summary>Определяет вложенный тип по заданным имени, атрибутам, типу, который он расширяет, и размеру упаковки.</summary>
        <returns>Определенный вложенный тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для создания вложенных типов даже после <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> метод вызван для включающего типа.  
  
 Вложенный тип должен быть завершен, прежде чем можно отразить с помощью метода <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, или <xref:System.Type.GetNestedTypes%2A>.  
  
 См. в описании <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для заказа, в котором следует выполнять вложенных и вложенных типов.  
  
 Повторяющееся имя не обязательно создается, если `name` совпадало с именем ранее определенного типа или вложенного типа. Будут повторяться, полных имен должен совпадать, включая пространство имен и все вложенные типы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не указан вложенный атрибут.  
  
 - или -  
  
 Этот тип запечатан.  
  
 - или -  
  
 Этот тип является массивом.  
  
 - или -  
  
 Этот тип является интерфейсом, а вложенный тип не является интерфейсом.  
  
 - или -  
  
 Длина <paramref name="name" /> равна нулю или больше 1023.  
  
 - или -  
  
 Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Краткое имя объекта. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attr">Атрибуты типа.</param>
        <param name="parent">Тип, расширяемый вложенным типом.</param>
        <param name="interfaces">Интерфейсы, реализуемые вложенным типом.</param>
        <summary>Определяет вложенный тип по заданным имени, атрибутам, типу, который он расширяет, и интерфейсам, которые он реализует.</summary>
        <returns>Определенный вложенный тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для создания вложенных типов даже после <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> метод вызван для включающего типа.  
  
 Вложенный тип должен быть завершен, прежде чем можно отразить с помощью метода <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, или <xref:System.Type.GetNestedTypes%2A>.  
  
 См. в описании <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для заказа, в котором следует выполнять вложенных и вложенных типов.  
  
 Повторяющееся имя не обязательно создается, если `name` совпадало с именем ранее определенного типа или вложенного типа. Будут повторяться, полных имен должен совпадать, включая пространство имен и все вложенные типы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не указан вложенный атрибут.  
  
 - или -  
  
 Этот тип запечатан.  
  
 - или -  
  
 Этот тип является массивом.  
  
 - или -  
  
 Этот тип является интерфейсом, а вложенный тип не является интерфейсом.  
  
 - или -  
  
 Длина <paramref name="name" /> равна нулю или больше 1023.  
  
 - или -  
  
 Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Элемент массива <paramref name="interfaces" /> является <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize, int typeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Краткое имя объекта. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attr">Атрибуты типа.</param>
        <param name="parent">Тип, который вложенный тип расширяет.</param>
        <param name="packSize">Размер упаковки типа.</param>
        <param name="typeSize">Общий размер типа.</param>
        <summary>Определяет вложенный тип на основе его имени, атрибутов, размера и типа, который он расширяет.</summary>
        <returns>Определенный вложенный тип.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет метод <see langword="PInvoke" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Имя метода <see langword="PInvoke" />. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="dllName">Имя библиотеки DLL, в которой определен метод <see langword="PInvoke" />.</param>
        <param name="attributes">Атрибуты метода.</param>
        <param name="callingConvention">Соглашение о вызове метода.</param>
        <param name="returnType">Возвращаемый тип метода.</param>
        <param name="parameterTypes">Типы параметров метода.</param>
        <param name="nativeCallConv">Собственное соглашение о вызове.</param>
        <param name="nativeCharSet">Собственная кодировка метода.</param>
        <summary>Определяет метод <see langword="PInvoke" /> с учетом его имени, имени библиотеки DLL, в которой определен метод, атрибутов метода, соглашения о вызове метода, возвращаемого типа метода, типов параметров метода и флагов <see langword="PInvoke" />.</summary>
        <returns>Определенный метод <see langword="PInvoke" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые DLL импорта атрибутов (см. в описании <xref:System.Runtime.InteropServices.DllImportAttribute>) не могут быть заданы как аргументы для этого метода. Например, атрибут импорта DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> должны быть добавлены после `PInvoke` создается метод, если метод возвращает значение. В примере, как это сделать.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> метод для создания `PInvoke` метод и как добавить <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> флаг флаги реализации метода после создания <xref:System.Reflection.Emit.MethodBuilder>, с помощью <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> и <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>методы.  
  
> [!IMPORTANT]
>  Чтобы получить возвращаемое значение ненулевое, необходимо добавить <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> флаг.  
  
 В примере создается динамическая сборка с одним динамическим модулем и одного типа, `MyType`, который содержит `PInvoke` метод. `PInvoke` Метод представляет Win32 `GetTickCount` функции.  
  
 При запуске данного примера выполняет `PInvoke` метод. Он также сохраняет динамическую сборку как PInvokeTest.dll. Можно использовать [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) для изучения `MyType` класса и `static` (`Shared` в Visual Basic) `PInvoke` метод, он содержит. Можно компилировать программы Visual Basic или C#, которая использует статический `MyType.GetTickCount` метода, включая ссылку на библиотеку DLL, при запуске csc.exe или vbc.exe; например, `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Метод не является статическим.  
  
 - или -  
  
 Родительский тип является интерфейсом.  
  
 - или -  
  
 Метод является абстрактным.  
  
 - или -  
  
 Метод был определен ранее.  
  
 - или -  
  
 Длина параметра <paramref name="name" /> или <paramref name="dllName" /> равна нулю.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="name" /> или <paramref name="dllName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Содержащий тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Имя метода <see langword="PInvoke" />. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="dllName">Имя библиотеки DLL, в которой определен метод <see langword="PInvoke" />.</param>
        <param name="entryName">Имя точки входа в библиотеке DLL.</param>
        <param name="attributes">Атрибуты метода.</param>
        <param name="callingConvention">Соглашение о вызове метода.</param>
        <param name="returnType">Возвращаемый тип метода.</param>
        <param name="parameterTypes">Типы параметров метода.</param>
        <param name="nativeCallConv">Собственное соглашение о вызове.</param>
        <param name="nativeCharSet">Собственная кодировка метода.</param>
        <summary>Определяет метод <see langword="PInvoke" /> с учетом его имени, имени библиотеки DLL, в которой определен метод, имени точки входа, атрибутов метода, соглашения о вызове метода, возвращаемого типа метода, типов параметров метода и флагов <see langword="PInvoke" />.</summary>
        <returns>Определенный метод <see langword="PInvoke" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые DLL импорта атрибутов (см. в описании <xref:System.Runtime.InteropServices.DllImportAttribute>) не могут быть заданы как аргументы для этого метода. Например, атрибут импорта DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> должны быть добавлены после `PInvoke` создается метод, если метод возвращает значение. В примере, как это сделать.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> метод для создания `PInvoke` метод и как добавить <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> флаг флаги реализации метода после создания <xref:System.Reflection.Emit.MethodBuilder>, с помощью <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> и <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> методы.  
  
> [!IMPORTANT]
>  Чтобы получить возвращаемое значение ненулевое, необходимо добавить <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> флаг.  
  
 В примере создается динамическая сборка с одним динамическим модулем и одного типа, `MyType`, который содержит `PInvoke` метод. `PInvoke` Метод представляет Win32 `GetTickCount` функции.  
  
 При запуске данного примера выполняет `PInvoke` метод. Он также сохраняет динамическую сборку как PInvokeTest.dll. Можно использовать [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) для изучения `MyType` класса и `static` (`Shared` в Visual Basic) `PInvoke` метод, он содержит. Можно компилировать программы Visual Basic или C#, которая использует статический `MyType.GetTickCount` метода, включая ссылку на библиотеку DLL, при запуске csc.exe или vbc.exe; например, `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Метод не является статическим.  
  
 - или -  
  
 Родительский тип является интерфейсом.  
  
 - или -  
  
 Метод является абстрактным.  
  
 - или -  
  
 Метод был определен ранее.  
  
 - или -  
  
 Длина параметра <paramref name="name" />, <paramref name="dllName" /> или <paramref name="entryName" /> равна нулю.</exception>
        <exception cref="T:System.ArgumentNullException">
          Значение параметра <paramref name="name" />, <paramref name="dllName" /> или <paramref name="entryName" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Содержащий тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Имя метода <see langword="PInvoke" />. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="dllName">Имя библиотеки DLL, в которой определен метод <see langword="PInvoke" />.</param>
        <param name="entryName">Имя точки входа в библиотеке DLL.</param>
        <param name="attributes">Атрибуты метода.</param>
        <param name="callingConvention">Соглашение о вызове метода.</param>
        <param name="returnType">Возвращаемый тип метода.</param>
        <param name="returnTypeRequiredCustomModifiers">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа метода. Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа метода. Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <see langword="null" />.</param>
        <param name="parameterTypes">Типы параметров метода.</param>
        <param name="parameterTypeRequiredCustomModifiers">Массив массивов типов. Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</param>
        <param name="parameterTypeOptionalCustomModifiers">Массив массивов типов. Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</param>
        <param name="nativeCallConv">Собственное соглашение о вызове.</param>
        <param name="nativeCharSet">Собственная кодировка метода.</param>
        <summary>Определяет метод <see langword="PInvoke" /> с учетом его имени, имени библиотеки DLL, в которой определен метод, имени точки входа, атрибутов метода, соглашения о вызове метода, возвращаемого типа метода, типов параметров метода, флагов <see langword="PInvoke" /> и настраиваемых модификаторов для параметров и возвращаемого типа.</summary>
        <returns>Объект <see cref="T:System.Reflection.Emit.MethodBuilder" />, представляющий определенный метод <see langword="PInvoke" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые DLL импорта атрибутов (см. в описании <xref:System.Runtime.InteropServices.DllImportAttribute>) не могут быть заданы как аргументы для этого метода. Например, атрибут импорта DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> должны быть добавлены после `PInvoke` создается метод, если метод возвращает значение. В примере, как это сделать.  
  
> [!NOTE]
>  Дополнительные сведения о настраиваемых модификаторов см. в документации объектах. Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование [\], тип\[\], тип\[\], тип\[\]\[\], тип\[ \] \<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A > для создания `PInvoke` метод и добавление <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> флаг флаги реализации метода после создания <xref:System.Reflection.Emit.MethodBuilder>, с помощью <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> и <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> методы.  
  
 В примере создается динамическая сборка с одним динамическим модулем и одного типа, `MyType`, который содержит `PInvoke` метод. `PInvoke` Метод представляет Win32 `GetTickCount` функции.  
  
> [!IMPORTANT]
>  Чтобы получить возвращаемое значение ненулевое, необходимо добавить <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> флаг.  
  
> [!NOTE]
>  В примере перегрузку, которая не задает пользовательские модификаторы. Чтобы указать пользовательские модификаторы, измените пример кода, вместо этого использовать перегрузку этого метода.  
  
 При запуске данного примера выполняет `PInvoke` метод. Он также сохраняет динамическую сборку как PInvokeTest.dll. Можно использовать [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) для изучения `MyType` класса и `static` (`Shared` в Visual Basic) `PInvoke` метод, он содержит. Можно компилировать программы Visual Basic или C#, которая использует статический `MyType.GetTickCount` метода, включая ссылку на библиотеку DLL, при запуске csc.exe или vbc.exe; например, `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Метод не является статическим.  
  
 - или -  
  
 Родительский тип является интерфейсом.  
  
 - или -  
  
 Метод является абстрактным.  
  
 - или -  
  
 Метод был определен ранее.  
  
 - или -  
  
 Длина параметра <paramref name="name" />, <paramref name="dllName" /> или <paramref name="entryName" /> равна нулю.  
  
 - или -  
  
 Размер <paramref name="parameterTypeRequiredCustomModifiers" /> или <paramref name="parameterTypeOptionalCustomModifiers" /> не равен размеру <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Значение параметра <paramref name="name" />, <paramref name="dllName" /> или <paramref name="entryName" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - или -  
  
 Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineProperty">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет новое свойство в тип.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Имя свойства. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attributes">Атрибуты свойства.</param>
        <param name="returnType">Тип возвращаемого значения свойства.</param>
        <param name="parameterTypes">Типы параметров свойства.</param>
        <summary>Добавляет новое свойство в тип с заданным именем и сигнатурой свойства.</summary>
        <returns>Заданное свойство.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем образце кода показано, как определить динамическое свойство и получить <xref:System.Reflection.Emit.PropertyBuilder> для спецификации. Обратите внимание, что `PropertyBuilder` должен существовать соответствующий <xref:System.Reflection.Emit.MethodBuilder>, который будет размещается IL-код для свойства.  
  
 [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один из элементов массива <paramref name="parameterTypes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Имя свойства. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attributes">Атрибуты свойства.</param>
        <param name="callingConvention">Соглашение о вызовах методов доступа свойства.</param>
        <param name="returnType">Тип возвращаемого значения свойства.</param>
        <param name="parameterTypes">Типы параметров свойства.</param>
        <summary>Добавляет новое свойство в тип с заданным именем, атрибутами, соглашением о вызове и сигнатурой свойства.</summary>
        <returns>Заданное свойство.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один из элементов массива <paramref name="parameterTypes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">Имя свойства. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attributes">Атрибуты свойства.</param>
        <param name="returnType">Тип возвращаемого значения свойства.</param>
        <param name="returnTypeRequiredCustomModifiers">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа свойства. Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа свойства. Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <see langword="null" />.</param>
        <param name="parameterTypes">Типы параметров свойства.</param>
        <param name="parameterTypeRequiredCustomModifiers">Массив массивов типов. Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</param>
        <param name="parameterTypeOptionalCustomModifiers">Массив массивов типов. Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</param>
        <summary>Добавляет новое свойство в тип с заданным именем, сигнатурой свойства и настраиваемыми модификаторами.</summary>
        <returns>Заданное свойство.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка предназначен для разработки управляемых компиляторов.  
  
> [!NOTE]
>  Дополнительные сведения о настраиваемых модификаторов см. в документации объектах. Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> равно <see langword="null" />  
  
 - или -  
  
 Один из элементов массива <paramref name="parameterTypes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">Имя свойства. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="attributes">Атрибуты свойства.</param>
        <param name="callingConvention">Соглашение о вызовах методов доступа свойства.</param>
        <param name="returnType">Тип возвращаемого значения свойства.</param>
        <param name="returnTypeRequiredCustomModifiers">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа свойства. Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа свойства. Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <see langword="null" />.</param>
        <param name="parameterTypes">Типы параметров свойства.</param>
        <param name="parameterTypeRequiredCustomModifiers">Массив массивов типов. Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</param>
        <param name="parameterTypeOptionalCustomModifiers">Массив массивов типов. Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />. Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов. Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</param>
        <summary>Добавляет новое свойство в тип с заданным именем, соглашением о вызове, сигнатурой свойства и настраиваемыми модификаторами.</summary>
        <returns>Заданное свойство.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка предназначен для разработки управляемых компиляторов.  
  
> [!NOTE]
>  Дополнительные сведения о настраиваемых модификаторов см. в документации объектах. Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.  
  
 Эта перегрузка метода впервые появился в [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздней версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один из элементов массива <paramref name="parameterTypes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineTypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineTypeInitializer () As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineTypeInitializer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Определяет инициализатор для этого типа.</summary>
        <returns>Возвращает инициализатор типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Созданный инициализатор всегда является открытым.  
  
   
  
## Examples  
 В следующем образце кода показано, как создать конструктор инициализации с помощью `DefineTypeInitializer`.  
  
 [!code-cpp[TypeBuilder_Properties1#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Properties1/CPP/typebuilder_properties.cpp#3)]
 [!code-csharp[TypeBuilder_Properties1#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Properties1/CS/typebuilder_properties.cs#3)]
 [!code-vb[TypeBuilder_Properties1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Properties1/VB/typebuilder_properties.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Содержащий тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Имя, используемое для ссылки на данные. Параметр <c>name</c> не может содержать внедренные значения NULL.</param>
        <param name="size">Размер поля данных.</param>
        <param name="attributes">Атрибуты поля.</param>
        <summary>Определяет неинициализированное поле данных в разделе <see langword=".sdata" /> переносимого исполняемого (PE) файла.</summary>
        <returns>Поле для ссылки на данные.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поле, созданная с помощью этого метода будет `static`, даже если не включать `FieldAttributes.Static` в `attributes` параметра.  
  
   
  
## Examples  
 В следующем образце кода показано использование `DefineUninitializedData` Создание неинициализированное поле данных в динамическом типе:  
  
 [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CPP/typebuilder_defineuninitializeddata.cpp#1)]
 [!code-csharp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CS/typebuilder_defineuninitializeddata.cs#1)]
 [!code-vb[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/VB/typebuilder_defineuninitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> равна нулю.  
  
 - или -  
  
 Значение <paramref name="size" /> меньше или равно нулю либо больше или равно 0x003f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает полный путь данного типа.</summary>
        <value>Только для чтения. Извлекает полный путь данного типа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемый формат — «полноеИмяВключающегоТипа + имяВложенногоТипа» для вложенных типов и «typeName» для типов, не являющегося вложенным.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее ковариацию и особые ограничения текущего параметра универсального типа.</summary>
        <value>Побитовое сочетание значений <see cref="T:System.Reflection.GenericParameterAttributes" />, которое описывает ковариацию и особые ограничения текущего параметра универсального типа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  При порождении кода, представленного параметром универсального типа <xref:System.Reflection.Emit.GenericTypeParameterBuilder> объекта, а не <xref:System.Reflection.Emit.TypeBuilder> объекта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public override int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает позицию параметра типа в списке параметров типа универсального типа, в котором объявлен этот параметр.</summary>
        <value>Если текущий объект <see cref="T:System.Reflection.Emit.TypeBuilder" /> представляет параметр универсального типа, позиция параметра типа в списке параметров типа универсального типа, который объявил параметр. В противном случае — не определено.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  При порождении кода, представленного параметром универсального типа <xref:System.Reflection.Emit.GenericTypeParameterBuilder> объекта, а не <xref:System.Reflection.Emit.TypeBuilder> объекта.  
  
 Если текущий <xref:System.Reflection.Emit.TypeBuilder> не представляет параметр универсального типа, значение этого свойства не определено. Используйте <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> свойство, чтобы определить, является ли текущий <xref:System.Reflection.Emit.TypeBuilder> представляет параметр универсального типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public override Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public override int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetArrayRank();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.ConstructorInfo GetConstructor(class System.Type type, class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::ConstructorInfo ^ GetConstructor(Type ^ type, System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="type">Сконструированный универсальный тип, конструктор которого возвращается.</param>
        <param name="constructor">Конструктор в определении универсального типа <c>type</c>, который указывает, какой конструктор <c>type</c> следует вернуть.</param>
        <summary>Возвращает конструктор указанного сконструированного универсального типа, соответствующего указанному конструктору определения универсального типа.</summary>
        <returns>Объект <see cref="T:System.Reflection.ConstructorInfo" />, представляющий конструктор <paramref name="type" />, соответствующий <paramref name="constructor" />, который указывает конструктор, принадлежащий определению универсального типа <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> Метод предоставляет способ получения <xref:System.Reflection.ConstructorInfo> , представляющий Конструктор сконструированный универсальный тип, определение универсального типа, представленного <xref:System.Reflection.Emit.TypeBuilder> объекта.  
  
 Например, предположим, что у вас есть <xref:System.Reflection.Emit.TypeBuilder> , представляющий тип `G<T>` в синтаксис C# (`G(Of T)` в Visual Basic `generic <T> ref class G` в C++) и <xref:System.Reflection.Emit.ConstructorBuilder> , представляющий конструктор `G<T>`. Предположим, что `G<T>` содержит универсальный метод с параметром типа `U` , создающий экземпляр сконструированного типа `G<U>`. Чтобы создать код для создания экземпляра сконструированного типа, необходимо <xref:System.Reflection.ConstructorInfo> , представляющий конструктор этого сконструированного типа — другими словами, который создает экземпляр `G<U>`. Чтобы сделать это, сначала нужно вызвать <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> метод <xref:System.Reflection.Emit.TypeBuilder> объекта, указав <xref:System.Reflection.Emit.GenericTypeParameterBuilder> , представляющий `U` в качестве аргумента типа. Затем вызовите <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> возвращаемое значение метода <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> метода в качестве параметра `type` и <xref:System.Reflection.Emit.ConstructorBuilder> , представляющий конструктор `G<U>` как параметр `constructor`. Возвращает значение <xref:System.Reflection.ConstructorInfo> объекта необходимо выпустить вызов функции. Пример кода демонстрирует этот сценарий.  
  
   
  
## Examples  
 В следующем примере кода содержит исходный код для универсального класса с именем `Sample` , содержит параметр типа с именем `T`. Класс имеет поле с именем `Field`, типа `T`, а также универсальный метод с именем `GM` со своим параметром типа с именем `U`. Метод `GM` создает экземпляр `Sample`, заменяя собственный параметр типа `U` для параметра типа `Sample`и сохраняет входной параметр в `Field`. Этот исходный код скомпилирован, но не используется. Вы можете просмотреть ее с [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) и сравнивают его код, созданный классом `Example`.  
  
 Код в классе `Example` демонстрирует использование <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> метод для создания универсального кода. `Main` Метод класса `Example` создает динамическую сборку, содержащую класс с именем `Sample` и использует <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> метод, чтобы сделать ее универсальной, добавив параметр типа с именем `T`. Конструктор по умолчанию и поле с именем `Field`, типа `T`, добавляются к классу `Sample`. Метод `GM` добавляется и преобразуются в универсальный метод, с помощью <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> метод. Параметр типа `GM` называется `U`. После определения параметра типа, сигнатуры `GM` добавляется с помощью <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> метод. Тип возвращаемого значения и нет необходимости или настраиваемые модификаторы, поэтому все параметры этого метода, `null` за исключением `parameterTypes`; `parameterTypes` задает тип параметра метода только `U`, параметр типа универсального метода. Тело метода создает экземпляр сконструированного типа `Sample<U>` (`Sample(Of U)` в Visual Basic), назначает параметр метода для `Field`, а затем выводит значение `Field`. <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> Метод используется для создания <xref:System.Reflection.ConstructorInfo> , представляющий конструктор по умолчанию сконструированного универсального типа `Sample<U>` в <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> инструкция, которая создает экземпляр.  
  
 Пустой тип определяется для хранения метода точки входа `Main`. В теле `Main`, статический `GM` сконструированный универсальный тип вызывается метод `Sample<int>` (`Sample(Of Integer)` в Visual Basic), с типом <xref:System.String> замещен `U`.  
  
 При запуске примера кода, она сохраняет порожденную сборку как TypeBuilderGetFieldExample.exe. Можно запустить TypeBuilderGetFieldExample.exe и использовании [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) для сравнения порожденного кода с кодом `Sample` класс, который компилируется в примере сам.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> не представляет универсальный тип.  
  
 - или -  
  
 Параметр <paramref name="type" /> не является параметром типа <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 - или -  
  
 Объявляющий тип <paramref name="constructor" /> не является определением универсального типа.  
  
 - или -  
  
 Объявляющий тип <paramref name="constructor" /> не является определением универсального типа <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Это должен быть одноразрядный флаг из объекта <see cref="T:System.Reflection.BindingFlags" />, как в методах <see langword="InvokeMethod" />, <see langword="NonPublic" /> и др.</param>
        <summary>Возвращает массив объектов <see cref="T:System.Reflection.ConstructorInfo" />, представляющий открытые или не открытые (в зависимости от того, что указано) конструкторы, которые определены для данного класса.</summary>
        <returns>Возвращает массив объектов <see cref="T:System.Reflection.ConstructorInfo" />, предоставляющий указанные конструкторы для данного класса. Если конструкторы не определены, возвращается пустой массив.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает настраиваемые атрибуты, определенные для данного типа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Указывает, следует ли выполнять поиск атрибутов в цепочке наследования этого члена.</param>
        <summary>Возвращает все настраиваемые атрибуты, определенные для данного типа.</summary>
        <returns>Возвращает массив объектов, представляющих все настраиваемые атрибуты этого типа.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается для неполных типов. Извлечение типа выполняется с помощью метода <see cref="M:System.Type.GetType" />, а затем вызывается<see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> на возвращенном типе <see cref="T:System.Type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Тип атрибута для поиска. Возвращаются только те атрибуты, которые можно назначить этому типу.</param>
        <param name="inherit">Указывает, следует ли выполнять поиск атрибутов в цепочке наследования этого члена.</param>
        <summary>Возвращает все настраиваемые атрибуты текущего типа, которые можно назначить указанному типу.</summary>
        <returns>Массив настраиваемых атрибутов, определенных для текущего типа.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается для неполных типов. Извлечение типа выполняется с помощью метода <see cref="M:System.Type.GetType" />, а затем вызывается<see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> на возвращенном типе <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="attributeType" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Тип должен быть типом, предоставленным базовой системой среды выполнения.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При вызове этого метода всегда возникает исключение <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Этот метод не поддерживается. Возвращаемое значение отсутствует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Имя искомого события.</param>
        <param name="bindingAttr">Побитовое сочетание значений <see cref="T:System.Reflection.BindingFlags" />, ограничивающее поиск.</param>
        <summary>Возвращает событие с указанным именем.</summary>
        <returns>Объект <see cref="T:System.Reflection.EventInfo" />, представляющий событие, объявленное или наследованное этим типом с указанным именем, или <see langword="null" />, если сопоставления отсутствуют.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает события, определенные текущим объектом <see cref="T:System.Reflection.Emit.TypeBuilder" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает открытые события, объявленные или наследованные данным типом.</summary>
        <returns>Возвращает массив объектов <see cref="T:System.Reflection.EventInfo" />, предоставляющий открытые события, объявленные или наследованные данным типом. Если открытые события отсутствуют, возвращается пустой массив.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A> или <xref:System.Reflection.Assembly.GetType%2A> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Побитовое сочетание значений <see cref="T:System.Reflection.BindingFlags" />, ограничивающее поиск.</param>
        <summary>Возвращает открытые и не являющиеся открытыми события, объявленные данным типом.</summary>
        <returns>Возвращает массив объектов <see cref="T:System.Reflection.EventInfo" />, представляющий события, объявленные или наследованные этим типом, которые соответствуют указанным флагам связывания. Если соответствующие события отсутствуют, возвращается пустой массив.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает поле, определенное текущим объектом <see cref="T:System.Reflection.Emit.TypeBuilder" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Имя получаемого поля.</param>
        <param name="bindingAttr">Это должен быть одноразрядный флаг из объекта <see cref="T:System.Reflection.BindingFlags" />, как в методах <see langword="InvokeMethod" />, <see langword="NonPublic" /> и др.</param>
        <summary>Возвращает поле, указанное данным именем.</summary>
        <returns>Возвращает объект <see cref="T:System.Reflection.FieldInfo" />, предоставляющий объявленное или наследованное данным типом поле с указанным именем и открытым или не являющимся открытым модификатором. Если совпадения отсутствуют, возвращается значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetField(class System.Type type, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetField(Type ^ type, System::Reflection::FieldInfo ^ field);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="type">Сконструированный универсальный тип, поле которого возвращается.</param>
        <param name="field">Поле в определении универсального типа <c>type</c>, которое указывает, какое поле <c>type</c> следует вернуть.</param>
        <summary>Возвращает поле указанного сконструированного универсального типа, соответствующее указанному полю определения универсального типа.</summary>
        <returns>Объект <see cref="T:System.Reflection.FieldInfo" />, представляющий поле <paramref name="type" />, соответствующее <paramref name="field" />, который указывает поле, принадлежащее определению универсального типа <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> Метод предоставляет способ получения <xref:System.Reflection.FieldInfo> объект, который представляет сконструированный универсальный тип, определение универсального типа, представленного поле <xref:System.Reflection.Emit.TypeBuilder> объекта.  
  
 Например, предположим, что у вас есть <xref:System.Reflection.Emit.TypeBuilder> , представляющий тип `G<T>` в синтаксис C# (`G(Of T)` в Visual Basic `generic <T> ref class G` в C++) и <xref:System.Reflection.Emit.FieldBuilder> , представляющий поле `public T F` в синтаксис C# (`Public F As T`в Visual Basic `public: T F` в C++), определяется `G<T>`. Предположим, что `G<T>` содержит универсальный метод с параметром типа `U` , создающий экземпляр сконструированного типа `G<U>` и вызывает поле `F` на этом экземпляре. Чтобы выпустить вызов функции, вы должны <xref:System.Reflection.FieldInfo> , представляющий `F` для сконструированного типа — другими словами, которое принадлежит типу `U` вместо типа `T`. Чтобы сделать это, сначала нужно вызвать <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> метод <xref:System.Reflection.Emit.TypeBuilder> объекта, указав <xref:System.Reflection.Emit.GenericTypeParameterBuilder> , представляющий `U` в качестве аргумента типа. Затем вызовите <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> возвращаемое значение метода <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> метода в качестве параметра `type` и <xref:System.Reflection.Emit.FieldBuilder> , представляющий `F` как параметр `field`. Возвращает значение <xref:System.Reflection.FieldInfo> объекта необходимо выпустить вызов функции. Пример кода демонстрирует этот сценарий.  
  
   
  
## Examples  
 В следующем примере кода содержит исходный код для универсального класса с именем Sample, который имеет параметр типа с именем `T`. Класс имеет поле с именем `Field`, типа `T`, а также универсальный метод с именем `GM` со своим параметром типа с именем `U`. Метод `GM` создает экземпляр `Sample`, заменяя собственный параметр типа `U` для параметра типа `Sample`и сохраняет входной параметр в `Field`. Этот исходный код скомпилирован, но не используется. Вы можете просмотреть ее с [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) и сравнивают его код, созданный классом `Example`.  
  
 Код в классе `Example` демонстрирует использование <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> метод для создания универсального кода. `Main` Метод класса `Example` создает динамическую сборку, содержащую класс с именем `Sample`и использует <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> метод, чтобы сделать ее универсальной, добавив параметр типа с именем `T`. Конструктор по умолчанию и поле с именем `Field`, типа `T`, добавляются к классу `Sample`. Метод `GM` добавляется и преобразуются в универсальный метод, с помощью <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> метод. Параметр типа `GM` называется `U`. После определения параметра типа, сигнатуры `GM` добавляется с помощью <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> метод. Тип возвращаемого значения и нет необходимости или настраиваемые модификаторы, поэтому все параметры этого метода, `null` за исключением `parameterTypes`; `parameterTypes` задает тип параметра метода только `U`, параметр типа универсального метода. Тело метода создает экземпляр сконструированного типа `Sample<U>` (`Sample(Of U)` в Visual Basic), назначает параметр метода для `Field`, а затем выводит значение `Field`. <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> Метод используется для создания <xref:System.Reflection.FieldInfo> , представляющий поле сконструированного универсального типа `Sample<U>` в <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> и <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> инструкции.  
  
 Пустой тип определяется для хранения метода точки входа `Main`. В теле `Main`, статический `GM` сконструированный универсальный тип вызывается метод `Sample<int>` (`Sample(Of Integer)` в Visual Basic), с типом <xref:System.String> замещен `U`.  
  
 При запуске примера кода, она сохраняет порожденную сборку как TypeBuilderGetFieldExample.exe. Можно запустить TypeBuilderGetFieldExample.exe и использовании [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) для сравнения порожденного кода с кодом `Sample` класс, который компилируется в примере сам.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> не представляет универсальный тип.  
  
 - или -  
  
 Параметр <paramref name="type" /> не является параметром типа <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 - или -  
  
 Объявляющий тип <paramref name="field" /> не является определением универсального типа.  
  
 - или -  
  
 Объявляющий тип <paramref name="field" /> не является определением универсального типа <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Этот параметр должен представлять собой битовый флаг объекта <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> и т. д.</param>
        <summary>Возвращает открытые и не являющиеся открытыми поля, объявленные данным типом.</summary>
        <returns>Возвращает массив объектов <see cref="T:System.Reflection.FieldInfo" />, предоставляющий открытые и не являющиеся открытыми поля, объявленные или наследованные данным типом. Если заданные поля отсутствуют, возвращается пустой массив.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> Метод не возвращает поля в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть порядка, в котором возвращаются поля, так как этот порядок может меняться.  
  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив объектов <see cref="T:System.Type" />, представляющий аргументы универсального типа, или параметры типа определения универсального типа.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />. Элементы массива, которые представляют аргументы универсального типа или параметры определения универсального типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы возвращаемого массива, в том порядке, в котором они отображаются в списке параметров типа для определения универсального типа.  
  
 Объект <xref:System.Reflection.Emit.TypeBuilder> объект представляет определение универсального типа, если <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> метод использовался для придания ей параметры универсального типа. Этот метод получает <xref:System.Reflection.Emit.GenericTypeParameterBuilder> объекты, представляющие параметры универсального типа.  
  
 Дополнительные сведения об универсальных типах в отражении и списке неизменяемых условий для терминов, используемых в универсальном отражении см. в разделе <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericArguments" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetGenericTypeDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, представляющий определение универсального типа, на основе которого можно получить текущий тип.</summary>
        <returns>Объект <see cref="T:System.Type" />, представляющий определение универсального типа, на основе которого можно получить текущий тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове метода <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> метод <xref:System.Reflection.Emit.TypeBuilder> объект, для которого <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> возвращает `true`, <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> свойство возвращает текущий экземпляр. Объект <xref:System.Reflection.Emit.TypeBuilder> , представляет универсальный тип всегда является определением универсального типа.  
  
 При использовании <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> метод для создания универсального типа из <xref:System.Reflection.Emit.TypeBuilder> , представляющий определение универсального типа, с помощью <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> возвращает метод для сконструированного типа <xref:System.Reflection.Emit.TypeBuilder> , представляющий универсальный тип Определение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий тип не является универсальным. То есть <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> возвращает <see langword="false" />.</exception>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Имя интерфейса.</param>
        <param name="ignoreCase">Если <see langword="true" />, то при поиске не учитывается регистр. Если <see langword="false" />, то при поиске учитывается регистр.</param>
        <summary>Возвращает интерфейс, реализованный (прямо или косвенно) данным классом с полным именем, совпадающим с именем данного интерфейса.</summary>
        <returns>Возвращает объект <see cref="T:System.Type" />, предоставляющий реализованный интерфейс. Возвращает значение null, если совпадающее имя интерфейса не найдено.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Тип <see cref="T:System.Type" /> интерфейса, для которого необходимо извлечь сопоставление.</param>
        <summary>Возвращает сопоставление для запрошенного интерфейса.</summary>
        <returns>Возвращает запрошенное сопоставление интерфейса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив всех интерфейсов, реализованных для данного типа и его базовых типов.</summary>
        <returns>Возвращает массив объектов <see cref="T:System.Type" />, предоставляющий реализованные интерфейсы. Если они не определены, возвращается пустой массив.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Имя элемента.</param>
        <param name="type">Тип возвращаемого элемента.</param>
        <param name="bindingAttr">Это должен быть одноразрядный флаг из объекта <see cref="T:System.Reflection.BindingFlags" />, как в методах <see langword="InvokeMethod" />, <see langword="NonPublic" /> и др.</param>
        <summary>Возвращает все открытые и закрытые члены, объявленные или наследуемые данным типом, как указано.</summary>
        <returns>Если задано <paramref name="nonPublic" />, метод возвращает массив объектов <see cref="T:System.Reflection.MemberInfo" />, предоставляющий открытые и не являющиеся открытыми элементы, определенные для данного типа; в противном случае возвращаются только открытые элементы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Это должен быть одноразрядный флаг из объекта <see cref="T:System.Reflection.BindingFlags" />, например <see langword="InvokeMethod" />, <see langword="NonPublic" /> и др.</param>
        <summary>Возвращает открытые и не являющиеся открытыми члены, объявленные или наследуемые данным типом.</summary>
        <returns>Возвращает массив объектов <see cref="T:System.Reflection.MemberInfo" />, предоставляющий открытые и не являющиеся открытыми элементы, объявленные или наследованные данным типом. Если соответствующие члены отсутствуют, возвращается пустой массив.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodInfo GetMethod(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodInfo ^ GetMethod(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">Сконструированный универсальный тип, метод которого возвращается.</param>
        <param name="method">Метод в определении универсального типа <c>type</c>, который указывает, какой метод <c>type</c> следует вернуть.</param>
        <summary>Возвращает метод указанного сконструированного универсального типа, соответствующего указанному методу определения универсального типа.</summary>
        <returns>Объект <see cref="T:System.Reflection.MethodInfo" />, представляющий метод <paramref name="type" />, соответствующий <paramref name="method" />, который указывает метод, принадлежащий определению универсального типа <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> Метод предоставляет способ получения <xref:System.Reflection.MethodInfo> объект, представляющий метод сконструированный универсальный тип, определение универсального типа, представленного <xref:System.Reflection.Emit.TypeBuilder> объекта.  
  
 Например, предположим, что у вас есть <xref:System.Reflection.Emit.TypeBuilder> , представляющий тип `G<T>` в синтаксис C# (`G(Of T)` в Visual Basic `generic <T> ref class G` в C++) и <xref:System.Reflection.Emit.MethodBuilder> объект, представляющий метод `T M()` в синтаксис C# (`Function M() As T`в Visual Basic `T M()` в C++), определяется `G<T>`. Предположим, что `G<T>` содержит универсальный метод с параметром типа `U` , создающий экземпляр сконструированного типа `G<U>` и вызывает метод `M` на этом экземпляре. Чтобы выпустить вызов функции, необходим <xref:System.Reflection.MethodInfo> , представляющий `M` для сконструированного типа — другими словами, которая возвращает тип `U` вместо типа `T`. Чтобы сделать это, сначала нужно вызвать <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> метод <xref:System.Reflection.Emit.TypeBuilder> объекта, указав <xref:System.Reflection.Emit.GenericTypeParameterBuilder> , представляющий `U` в качестве аргумента типа. Затем вызовите <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> возвращаемое значение метода <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> метода в качестве параметра `type` и <xref:System.Reflection.Emit.MethodBuilder> , представляющий `T M()` как параметр `method`. Возвращает значение <xref:System.Reflection.MethodInfo> объекта необходимо выпустить вызов функции. Пример кода демонстрирует сценарий аналогичным образом.  
  
   
  
## Examples  
 В следующем примере кода содержит исходный код для универсального класса с именем `Sample` , содержит параметр типа с именем `T`. Класс имеет поле с именем `Field`, типа `T`, а также универсальный метод с именем `GM` со своим параметром типа с именем `U`. Метод `GM` создает экземпляр `Sample`, заменяя собственный параметр типа `U` для параметра типа `Sample`и сохраняет входной параметр в `Field`. Этот исходный код скомпилирован, но не используется. Вы можете просмотреть ее с [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) и сравнивают его код, созданный классом `Example`.  
  
 Код в классе `Example` демонстрирует использование <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> метод для создания универсального кода. `Main` Метод класса `Example` создает динамическую сборку, содержащую класс с именем `Sample` и использует <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> метод, чтобы сделать ее универсальной, добавив параметр типа с именем `T`. Конструктор по умолчанию и поле с именем `Field`, типа `T`, добавляются к классу `Sample`. Метод `GM` добавляется и преобразуются в универсальный метод, с помощью <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> метод. Параметр типа `GM` называется `U`. После определения параметра типа, сигнатуры `GM` добавляется с помощью <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> метод. Тип возвращаемого значения и нет необходимости или настраиваемые модификаторы, поэтому все параметры этого метода, `null` за исключением `parameterTypes`; `parameterTypes` задает тип параметра метода только `U`, параметр типа универсального метода. Тело метода создает экземпляр сконструированного типа `Sample<U>` (`Sample(Of U)` в Visual Basic), назначает параметр метода для `Field`, а затем выводит значение `Field`. Пустой тип определяется для хранения метода точки входа `Main`. В теле `Main`, статический `GM` сконструированный универсальный тип вызывается метод `Sample<int>` (`Sample(Of Integer)` в Visual Basic), с типом <xref:System.String> замещен `U`. <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> Метод используется для создания <xref:System.Reflection.MethodInfo> для статического `GM` метод сконструированного универсального типа `Sample<U>`и <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> метод затем используется для создания <xref:System.Reflection.MethodInfo> , можно создать в вызове метода.  
  
 При запуске примера кода, она сохраняет порожденную сборку как TypeBuilderGetFieldExample.exe. Можно запустить TypeBuilderGetFieldExample.exe и использовании [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) для сравнения порожденного кода с кодом `Sample` класс, который компилируется в примере сам.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> представляет универсальный метод, который не является определением универсального метода.  
  
 - или -  
  
 <paramref name="type" /> не представляет универсальный тип.  
  
 - или -  
  
 Параметр <paramref name="type" /> не является параметром типа <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 - или -  
  
 Объявляющий тип <paramref name="method" /> не является определением универсального типа.  
  
 - или -  
  
 Объявляющий тип <paramref name="method" /> не является определением универсального типа <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Это должен быть одноразрядный флаг из объекта <see cref="T:System.Reflection.BindingFlags" />, как в методах <see langword="InvokeMethod" />, <see langword="NonPublic" /> и др.</param>
        <summary>Возвращает все открытые и закрытые методы, объявленные или наследуемые данным типом, как указано.</summary>
        <returns>Если задано <paramref name="nonPublic" />, метод возвращает массив объектов <see cref="T:System.Reflection.MethodInfo" />, предоставляющий открытые и не являющиеся открытыми методы, определенные для данного типа; в противном случае возвращаются только открытые методы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Объект <see cref="T:System.String" />, содержащий имя искомого вложенного типа.</param>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль для выполнения поиска открытых методов с учетом регистра.</param>
        <summary>Возвращает открытые и не являющиеся открытыми вложенные типы, объявленные этим типом.</summary>
        <returns>Если поиск выполнен удачно, возвращается объект <see cref="T:System.Type" />, предоставляющий вложенный тип, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 Если этот тип является завершения, например, если `CreateType` был вызван для этого типа, но имеются вложенные типы, которые не являются полными, затем `GetNestedTypes` возвращает только те вложенные типы, для которых `CreateType` был вызван.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Это должен быть одноразрядный флаг из объекта <see cref="T:System.Reflection.BindingFlags" />, как в методах <see langword="InvokeMethod" />, <see langword="NonPublic" /> и др.</param>
        <summary>Возвращает открытые и не являющиеся открытыми вложенные типы, объявленные или наследованные данным типом.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />, предоставляющий все типы, вложенные в текущий объект <see cref="T:System.Type" />, которые соответствуют указанным ограничениям на связывание.  
  
 Пустой массив типа <see cref="T:System.Type" />, если у текущего типа <see cref="T:System.Type" /> нет вложенных типов или если ни один из вложенных типов не соответствует ограничениям на связывание.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 Если этот тип является завершения, например, если `CreateType` был вызван для этого типа, но имеются вложенные типы, которые не являются полными, затем `GetNestedTypes` возвращает только те вложенные типы, для которых `CreateType` был вызван.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Это атрибут вызова. Этот параметр должен представлять собой битовый флаг объекта <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> и т. д.</param>
        <summary>Возвращает все открытые и закрытые свойства, объявленные или наследуемые данным типом, как указано.</summary>
        <returns>Возвращает массив объектов <see langword="PropertyInfo" />, предоставляющих открытые и неоткрытые свойства, определенные на данном типе, если используется параметр <paramref name="nonPublic" />; в противном случае возвращаются только открытые свойства.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не реализован для неполных типов.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает идентификатор GUID этого типа.</summary>
        <value>Только для чтения. Получает идентификатор GUID этого типа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается для неполных типов.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">Имя вызываемого члена. Это может быть конструктор, метод, свойство или поле. Необходимо указать подходящий атрибут вызова. Обратите внимание, что можно вызвать член класса, заданный по умолчанию, передав в качестве имени члена пустую строку.</param>
        <param name="invokeAttr">Атрибут вызова. Этот должен быть битовый флаг из <see langword="BindingFlags" />.</param>
        <param name="binder">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see langword="MemberInfo" /> с помощью отражения. Если связыватель имеет значение <see langword="null" />, используется связыватель по умолчанию. См. раздел <see cref="T:System.Reflection.Binder" />.</param>
        <param name="target">Объект, для которого следует вызвать указанный член. Если член является статическим, этот параметр игнорируется.</param>
        <param name="args">Список аргументов. Это массив объектов, содержащий число, порядок и тип параметров вызываемого члена. Если параметров нет, должно быть указано значение NULL.</param>
        <param name="modifiers">Массив, длина которого равна длине <c>args</c>, с элементами, представляющими атрибуты, связанные с аргументами вызываемого члена. Параметр имеет атрибуты, связанные с ним в метаданных. Они используются различными службами взаимодействия. Дополнительные сведения см. в спецификации метаданных.</param>
        <param name="culture">Экземпляр объекта <see langword="CultureInfo" />, используемого для управления приведением типов. Если его значением является null, для текущего потока используется <see langword="CultureInfo" />. (Обратите внимание, что необходимо, например, преобразовать строку, представляющую 1000, в число с двойной точностью, поскольку для разных языков и региональных параметров 1000 представляется по-разному.)</param>
        <param name="namedParameters">Каждый параметр в массиве <c>namedParameters</c> получает значение в соответствующем элементе в массиве <c>args</c>. Если длина <c>args</c> превышает длину <c>namedParameters</c>, оставшиеся значения аргументов передаются по порядку.</param>
        <summary>Вызывает указанный член. Вызываемый метод должен быть доступен и обеспечивать наиболее точное соответствие заданному списку аргументов с учетом ограничений заданного модуля привязки и атрибутов вызова.</summary>
        <returns>Возвращает возвращаемое значение вызываемого члена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод будет вызван, если число параметров в объявлении метода равно количеству аргументов в списке аргументов, а тип каждого аргумента может преобразовываться связывателем тип параметра.  
  
 Связыватель найдет все подходящие методы. Эти методы находятся в зависимости от типа привязки запрошенного (BindingFlags.InvokeMethod, BindingFlags.GetProperties и т. д.). Набор методов фильтруется по имени, количество аргументов и набор модификаторов поиска, определенных в модуле привязки. После выбора метод будет вызван. На этом этапе проверяется доступность. Средство поиска может управлять поиском определения набора методов на основе связанного с методом атрибута доступности. `IBinder.BindToMethod` Метод отвечает за выбор вызываемого метода. Связыватель по умолчанию выбирает наиболее точное соответствие.  
  
> [!NOTE]
>  Ограничения доступа игнорируются для полностью доверенный код. То есть закрытые конструкторы, методы, поля и свойства доступны и с использованием отражения, если полностью доверенный код.  
  
 В настоящее время этот метод не поддерживается. Можно извлечь при помощи типа <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается для неполных типов.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAssignableFrom">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, можно ли назначить указанный тип этому объекту.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">Объект для тестирования.</param>
        <summary>Получает значение, указывающее, может ли заданный объект <see cref="T:System.Reflection.TypeInfo" /> быть назначен этому объекту.</summary>
        <returns>
          Значение <see langword="true" />, если <paramref name="typeInfo" /> может быть назначен этому объекту. В противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Объект для тестирования.</param>
        <summary>Получает значение, указывающее, можно ли назначить указанный объект <see cref="T:System.Type" /> данному объекту.</summary>
        <returns>
          Значение <see langword="true" />, если параметр <paramref name="c" /> и текущий объект тип представляют один тип, или если текущий тип находится в иерархии наследования параметра <paramref name="c" />, или если текущий тип является интерфейсом, поддерживаемым параметром <paramref name="c" />. Значение <see langword="false" />, если не выполняется ни одно из этих условий, или значение параметра <paramref name="c" /> равно <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли этот данный объект сконструированный универсальный тип.</summary>
        <value>
          Значение <see langword="true" />, если этот объект представляет сконструированный универсальный тип; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCreated">
      <MemberSignature Language="C#" Value="public bool IsCreated ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsCreated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCreated" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCreated () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsCreated();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, которое показывает, был ли создан текущий динамический тип.</summary>
        <returns>
          Значение <see langword="true" />, если был вызван метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />. В противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> был вызван метод, к типу, представленному <xref:System.Reflection.Emit.TypeBuilder> объекта завершена. Исключения создаются на любые дальнейшие попытки добавления элементов или изменения других характеристик типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Тип атрибута для поиска. Возвращаются только те атрибуты, которые можно назначить этому типу.</param>
        <param name="inherit">Указывает, следует ли выполнять поиск атрибутов в цепочке наследования этого члена.</param>
        <summary>Определяет, применяется ли настраиваемый атрибут к текущему типу.</summary>
        <returns>
          Значение <see langword="true" />, если один или несколько экземпляров <paramref name="attributeType" /> или атрибут, производный от <paramref name="attributeType" />, определен для этого типа; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживается для неполных параметров универсального типа. Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">В настоящее время этот метод не поддерживается для неполных типов. Извлечение типа выполняется с помощью метода <see cref="M:System.Type.GetType" />, а затем вызывается<see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> на возвращенном типе <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> не определен.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="attributeType" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public override bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, является ли текущий тип параметром универсального типа.</summary>
        <value>
          Значение <see langword="true" />, если текущий объект <see cref="T:System.Reflection.Emit.TypeBuilder" /> представляет параметр универсального типа; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  При порождении кода, представленного параметром универсального типа <xref:System.Reflection.Emit.GenericTypeParameterBuilder> объекта, а не <xref:System.Reflection.Emit.TypeBuilder> объекта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public override bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, является ли текущий тип универсальным.</summary>
        <value>
          Значение <see langword="true" />, если тип, представленный текущим объектом <see cref="T:System.Reflection.Emit.TypeBuilder" />, является универсальным; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Reflection.Emit.TypeBuilder> объект представляет определение универсального типа, если <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> метод использовался для придания ей параметры универсального типа. Экземпляр <xref:System.Reflection.Emit.TypeBuilder> универсального класса всегда является определением универсального типа.  
  
 Дополнительные сведения об универсальных типах в отражении и списке неизменяемых условий для терминов, используемых в универсальном отражении см. в разделе <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, представляет ли текущий объект <see cref="T:System.Reflection.Emit.TypeBuilder" /> определение универсального типа, на основе которого можно конструировать другие универсальные типы.</summary>
        <value>
          Значение <see langword="true" />, если этот объект <see cref="T:System.Reflection.Emit.TypeBuilder" /> представляет определение универсального типа. В противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Reflection.Emit.TypeBuilder> объект представляет определение универсального типа, если <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> метод использовался для придания ей параметры универсального типа. Экземпляр <xref:System.Reflection.Emit.TypeBuilder> универсального класса всегда является определением универсального типа.  
  
 Объект <xref:System.Reflection.Emit.TypeBuilder> можно использовать для создания определений универсальных типов, но не сконструированные универсальные типы. Чтобы получить сконструированный универсальный тип, вызовите <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> метод <xref:System.Reflection.Emit.TypeBuilder> , представляющий определение универсального типа.  
  
 Дополнительные сведения об универсальных типах в отражении и списке неизменяемых условий для терминов, используемых в универсальном отражении см. в разделе <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, которое указывает, является ли текущий тип критическим с точки зрения безопасности или надежным с точки зрения безопасности и, следовательно, может ли он выполнять важные операции.</summary>
        <value>
          Значение <see langword="true" />, если текущий тип является критически важным для безопасности или защищенным критически важным для безопасности; значение <see langword="false" />, если он является прозрачным.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, И <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> свойства отчетов уровень прозрачности типа, что определяется общеязыковой среды выполнения (CLR). В следующей таблице показаны сочетания этих свойств.  
  
|Уровень безопасности|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|Критический в плане безопасности|`true`|`true`|`false`|  
|Прозрачный|`false`|`false`|`true`|  
  
 Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.  
  
 Среда выполнения начинает вычисление уровней прозрачности в сборке. Например если динамическая сборка является критическим с точки зрения безопасности, примечания для типов игнорируются и все типы являются прозрачными.  
  
 По умолчанию динамическая сборка наследует прозрачность породившая его сборка. Это значение по умолчанию можно переопределить с помощью <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, или <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> перегруженный метод и указывая атрибуты безопасности. Не может повысить уровень безопасности благодаря этому; то есть прозрачный код не может выдавать критически важным для безопасности или защищенным критически важным для безопасности кода. Необходимо указать атрибуты, при динамической сборки, или они не вступят в силу до сборка сохранена на диске и загружаются в память.  
  
> [!NOTE]
>  Наследование по умолчанию ограничено оценкой прозрачности среды выполнения. Атрибуты не применяются к динамической сборке. Если вы хотите добавить атрибуты безопасности, необходимо применить их самостоятельно.  
  
 Дополнительные сведения об отражении выпуска и прозрачности см [вопросы безопасности в порождение отражения](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Сведения о прозрачности см. в разделе [изменения системы безопасности](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Текущий динамический тип не был создан с помощью вызова метода <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, которое указывает, является ли текущий тип надежным с точки зрения безопасности и, следовательно, может ли он выполнять критически важные операции и предоставлять доступ прозрачному коду.</summary>
        <value>
          Значение <see langword="true" />, если текущий тип является защищенным критически важным для безопасности; значение <see langword="false" />, если он является критически важным для безопасности или прозрачным.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, И <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> свойства отчетов уровень прозрачности типа, что определяется общеязыковой среды выполнения (CLR). В следующей таблице показаны сочетания этих свойств.  
  
|Уровень безопасности|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|Критический в плане безопасности|`true`|`true`|`false`|  
|Прозрачный|`false`|`false`|`true`|  
  
 Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.  
  
 Среда выполнения начинает вычисление уровней прозрачности в сборке. Например если динамическая сборка является критическим с точки зрения безопасности, примечания для типов игнорируются и все типы являются прозрачными.  
  
 По умолчанию динамическая сборка наследует прозрачность породившая его сборка. Это значение по умолчанию можно переопределить с помощью <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, или <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> перегруженный метод и указывая атрибуты безопасности. Не может повысить уровень безопасности благодаря этому; то есть прозрачный код не может выдавать критически важным для безопасности или защищенным критически важным для безопасности кода. Необходимо указать атрибуты, при динамической сборки, или они не вступят в силу до сборка сохранена на диске и загружаются в память.  
  
> [!NOTE]
>  Наследование по умолчанию ограничено оценкой прозрачности среды выполнения. Атрибуты не применяются к динамической сборке. Если вы хотите добавить атрибуты безопасности, необходимо применить их самостоятельно.  
  
 Дополнительные сведения об отражении выпуска и прозрачности см [вопросы безопасности в порождение отражения](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Сведения о прозрачности см. в разделе [изменения системы безопасности](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Текущий динамический тип не был создан с помощью вызова метода <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, которое указывает, является ли текущий тип прозрачным и, следовательно, не может выполнять критические операции.</summary>
        <value>
          Значение <see langword="true" />, если тип прозрачный; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, И <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> свойства отчетов уровень прозрачности типа, что определяется общеязыковой среды выполнения (CLR). В следующей таблице показаны сочетания этих свойств.  
  
|Уровень безопасности|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|Критический в плане безопасности|`true`|`true`|`false`|  
|Прозрачный|`false`|`false`|`true`|  
  
 Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.  
  
 Среда выполнения начинает вычисление уровней прозрачности в сборке. Например если динамическая сборка является критическим с точки зрения безопасности, примечания для типов игнорируются и все типы являются прозрачными.  
  
 По умолчанию динамическая сборка наследует прозрачность породившая его сборка. Это значение по умолчанию можно переопределить с помощью <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, или <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> перегруженный метод и указывая атрибуты безопасности. Не может повысить уровень безопасности благодаря этому; то есть прозрачный код не может выдавать критически важным для безопасности или защищенным критически важным для безопасности кода. Необходимо указать атрибуты, при динамической сборки, или они не вступят в силу до сборка сохранена на диске и загружаются в память.  
  
> [!NOTE]
>  Наследование по умолчанию ограничено оценкой прозрачности среды выполнения. Атрибуты не применяются к динамической сборке. Если вы хотите добавить атрибуты безопасности, необходимо применить их самостоятельно.  
  
 Дополнительные сведения об отражении выпуска и прозрачности см [вопросы безопасности в порождение отражения](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Сведения о прозрачности см. в разделе [изменения системы безопасности](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Текущий динамический тип не был создан с помощью вызова метода <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public override bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public override bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubclassOf(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Проверяемый тип <see cref="T:System.Type" />.</param>
        <summary>Определяет, является ли этот тип производным от указанного типа.</summary>
        <returns>Только для чтения. Возвращает <see langword="true" />, если данный тип совпадает с типом параметра <paramref name="c" /> или является подтипом типа <paramref name="c" />, в противном случае возвращает <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, который представляет массив текущего типа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</summary>
        <returns>Объект <see cref="T:System.Type" />, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> Метод предоставляет способ создания тип массива с любым типом возможный элемент, включая универсальные типы.  
  
   
  
## Examples  
 В следующем примере кода создается динамический модуль, абстрактный тип с именем `Sample`и абстрактный метод с именем `TestMethod`. `TestMethod` принимает `ref` параметра (`ByRef` в Visual Basic) типа `Sample`, указатель на тип `Sample`, а также массив объектов типа `Sample`. Он возвращает двухмерный массив типа `Sample`. В примере кода сохраняет динамический модуль на диск, чтобы вы могли изучить его с [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType(int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">Размерность массива.</param>
        <summary>Возвращает объект <see cref="T:System.Type" />, представляющий массив текущего типа указанной размерности.</summary>
        <returns>Объект <see cref="T:System.Type" />, который представляет одномерный массив текущего типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> Метод предоставляет способ создания тип массива с любым типом возможный элемент, включая универсальные типы.  
  
   
  
## Examples  
 В следующем примере кода создается динамический модуль, абстрактный тип с именем `Sample`и абстрактный метод с именем `TestMethod`. `TestMethod` принимает `ref` параметра (`ByRef` в Visual Basic) типа `Sample`, указатель на тип `Sample`, а также массив объектов типа `Sample`. Он возвращает двухмерный массив типа `Sample`. В примере кода сохраняет динамический модуль на диск, чтобы вы могли изучить его с [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> не является допустимой размерностью массива.</exception>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public override Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeByRefType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, который представляет текущий тип при передаче в качестве параметра <see langword="ref" /> (параметра <see langword="ByRef" /> в Visual Basic).</summary>
        <returns>Объект <see cref="T:System.Type" />, который представляет текущий тип при передаче в качестве параметра <see langword="ref" /> (параметра <see langword="ByRef" /> в Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> Метод предоставляет способ создания `ref` типов (`ByRef` в Visual Basic) для параметра перечислены.  
  
> [!NOTE]
>  С помощью синтаксиса Microsoft промежуточного языка MSIL, если текущий <xref:System.Reflection.Emit.TypeBuilder> представляет `MyType`, то будет тип, возвращаемый этим методом `MyType&`.  
  
   
  
## Examples  
 В следующем примере кода создается динамический модуль, абстрактный тип с именем `Sample`и абстрактный метод с именем `TestMethod`. `TestMethod` принимает `ref` параметра (`ByRef` в Visual Basic) типа `Sample`, указатель на тип `Sample`, а также массив объектов типа `Sample`. Он возвращает двухмерный массив типа `Sample`. В примере кода сохраняет динамический модуль на диск, чтобы вы могли изучить его с [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public override Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Массив типов, который должен быть замещен параметрами типа определения текущего универсального типа.</param>
        <summary>Замещает элементы массива типов для параметров типа определения текущего универсального типа и возвращает результирующий сконструированный тип.</summary>
        <returns>
          <see cref="T:System.Type" /> представляет сконструированный тип, сформированный путем замещения элементов объекта <paramref name="typeArguments" /> параметрами текущего универсального типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если выпущенного кода требуется тип, построенный из текущего определения универсального типа. Нет необходимости вызывать <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> метод перед вызовом метода <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> метод <xref:System.Reflection.Emit.TypeBuilder> , представляющий определение универсального типа. Если текущий <xref:System.Reflection.Emit.TypeBuilder> не представляет определение универсального типа, <xref:System.InvalidOperationException> возникает исключение.  
  
 Объект, возвращаемый этим методом, функционирует как заполнитель для сконструированного универсального типа в выпуске кода. Он является экземпляром класса, производного от <xref:System.Type> с ограниченными возможностями. В частности:  
  
-   Чтобы получить эти сконструированные универсальные типы методы, поля и конструкторы, используйте <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, и <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> перегруженных версий метода.  
  
-   Два экземпляра, которые представляют один и тот же сконструированный тип, не рассматриваются как равные. Например, в следующем коде `t1.Equals(t2)` возвращает `false`:  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий тип не представляет определение универсального типа. То есть <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> возвращает <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="typeArguments" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Любой элемент <paramref name="typeArguments" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see cref="P:System.Type.Module" /> любого элемента <paramref name="typeArguments" /> — <see langword="null" />.  
  
 - или -  
  
 Свойство <see cref="P:System.Reflection.Module.Assembly" /> модуля любого элемента <paramref name="typeArguments" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public override Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakePointerType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, который представляет тип неуправляемого указателя на текущий тип.</summary>
        <returns>Объект <see cref="T:System.Type" />, который представляет тип неуправляемого указателя на текущий тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> Метод предоставляет способ создания типов указателей для списки параметров.  
  
> [!NOTE]
>  С помощью синтаксиса Microsoft промежуточного языка MSIL, если текущий <xref:System.Reflection.Emit.TypeBuilder> представляет `MyType`, то будет тип, возвращаемый этим методом `MyType*`.  
  
   
  
## Examples  
 В следующем примере кода создается динамический модуль, абстрактный тип с именем `Sample`и абстрактный метод с именем `TestMethod`. `TestMethod` принимает `ref` параметра (`ByRef` в Visual Basic) типа `Sample`, указатель на тип `Sample`, а также массив объектов типа `Sample`. Он возвращает двухмерный массив типа `Sample`. В примере кода сохраняет динамический модуль на диск, чтобы вы могли изучить его с [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает динамический модуль, который содержит определение данного типа.</summary>
        <value>Только для чтения. Извлекает динамический модуль, который содержит определение данного типа.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает имя данного типа.</summary>
        <value>Только для чтения. Извлекает имя <see cref="T:System.String" /> данного типа.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает пространство имен, в котором определен этот объект <see langword="TypeBuilder" />.</summary>
        <value>Только для чтения. Получает пространство имен, в котором определен этот объект <see langword="TypeBuilder" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PackingSize">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PackingSize PackingSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.PackingSize PackingSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackingSize As PackingSize" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::PackingSize PackingSize { System::Reflection::Emit::PackingSize get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PackingSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает размер упаковки данного типа.</summary>
        <value>Только для чтения. Получает размер упаковки данного типа.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает тип, который был использован для получения этого типа.</summary>
        <value>Только для чтения. Тип, который был использован для получения этого типа.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает пользовательский атрибут.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">Экземпляр вспомогательного класса для определения настраиваемого атрибута.</param>
        <summary>Задает настраиваемый атрибут с помощью построителя настраиваемых атрибутов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот элемент больше не требуется <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> флаг. (См. [вопросы безопасности в порождаемом отражении](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="customBuilder" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">Конструктор настраиваемого атрибута.</param>
        <param name="binaryAttribute">Большой двоичный объект байтов, представляющий атрибуты.</param>
        <summary>Задает настраиваемый атрибут с помощью большого двоичного объекта пользовательских атрибутов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о форматировании `binaryAttribute`, см. в документации Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика». Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот элемент больше не требуется <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> флаг. (См. [вопросы безопасности в порождаемом отражении](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="con" /> или <paramref name="binaryAttribute" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetParent">
      <MemberSignature Language="C#" Value="public void SetParent (Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParent(class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParent (parent As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParent(Type ^ parent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parent">Новый базовый тип.</param>
        <summary>Задает базовый тип конструируемого в настоящий момент типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `parent` — `null`, <xref:System.Object> используется как базовый тип.  
  
 В .NET Framework версий 1.0 и 1.1, исключение не возникает, если `parent` является типом интерфейса, но <xref:System.TypeLoadException> возникает, когда <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> вызывается метод.  
  
 <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> Метод не проверяет для большинства типов Недопустимый родительский элемент. Например, этот метод не отклоняет родительский тип, который имеет конструктор по умолчанию, если текущий тип имеет конструктор по умолчанию и не отклоняет запечатанные типы не отклоняет <xref:System.Delegate> типа. Во всех этих случаях исключений <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 - или -  
  
 <paramref name="parent" /> имеет значение <see langword="null" />, и текущий экземпляр представляет интерфейс, атрибуты которого не включают <see cref="F:System.Reflection.TypeAttributes.Abstract" />.  
  
 - или -  
  
 Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parent" /> является интерфейсом. Это условие исключения было впервые представлено в .NET Framework 2.0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Size { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает общий размер типа.</summary>
        <value>Только для чтения. Получает общий размер этого типа.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _TypeBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_TypeBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Зарезервировано для будущего использования. Должно быть равным IID_NULL.</param>
        <param name="rgszNames">Переданный массив имен, которые необходимо сопоставить.</param>
        <param name="cNames">Количество сопоставляемых имен.</param>
        <param name="lcid">Контекст языкового стандарта для интерпретации имен.</param>
        <param name="rgDispId">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</param>
        <summary>Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetIDsOfNames`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _TypeBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Возвращаемые сведения о типе.</param>
        <param name="lcid">Идентификатор языкового стандарта для сведений о типе.</param>
        <param name="ppTInfo">Получает указатель на объект с запрошенными сведениями о типе.</param>
        <summary>Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfo`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _TypeBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</param>
        <summary>Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfoCount`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _TypeBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_TypeBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Идентифицирует член.</param>
        <param name="riid">Зарезервировано для будущего использования. Должно быть равным IID_NULL.</param>
        <param name="lcid">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</param>
        <param name="wFlags">Флаги, описывающие контекст вызова.</param>
        <param name="pDispParams">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</param>
        <param name="pVarResult">Указатель, по которому будет сохранен результат.</param>
        <param name="pExcepInfo">Указатель на структуру, содержащую сведения об исключении.</param>
        <param name="puArgErr">Индекс первого аргумента, вызвавшего ошибку.</param>
        <summary>Предоставляет доступ к открытым свойствам и методам объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::Invoke`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает имя типа, исключая пространство имен.</summary>
        <returns>Только для чтения. Имя типа, исключая пространство имен.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Не поддерживается в динамических модулях.</summary>
        <value>Только для чтения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получить тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и для полученного типа использовать отражение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Не поддерживается в динамических модулях.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken TypeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.TypeToken TypeToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeToken As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::TypeToken TypeToken { System::Reflection::Emit::TypeToken get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает токен типа этого типа.</summary>
        <value>Только для чтения. Возвращает <see langword="TypeToken" /> для данного типа.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает тип основной системы для данного <see langword="TypeBuilder" />.</summary>
        <value>Только для чтения. Возвращает базовый системный тип.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Этот тип является перечислением, но базовый системный тип отсутствует.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnspecifiedTypeSize">
      <MemberSignature Language="C#" Value="public const int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 UnspecifiedTypeSize = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberSignature Language="VB.NET" Value="Public Const UnspecifiedTypeSize As Integer  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: int UnspecifiedTypeSize = 0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Представляет, что общий размер для типа не указан.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>