<Type Name="MethodBase" FullName="System.Reflection.MethodBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cc835ba89554a81318a5948b06c2447df89fe759" />
    <Meta Name="ms.sourcegitcommit" Value="254e16ae65e82f4aa59360cd8572b36b6b5b2f80" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/05/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodBase extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodBase&#xA;Inherits MemberInfo&#xA;Implements _MethodBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBase abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_MethodBase" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBase))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="3f675-101">Предоставляет сведения о методах и конструкторах.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3f675-101">Provides information about methods and constructors.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-102">`MethodBase` является базовым классом для <xref:System.Reflection.MethodInfo> и <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="3f675-102">`MethodBase` is the base class of <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="3f675-103">для полного доверия для разработчиков производных классов.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3f675-103">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="3f675-104">Этот класс не наследуется частично доверенным кодом.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3f675-104">This class cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <threadsafe>
      <span data-ttu-id="3f675-105">Данный тип потокобезопасен.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3f675-105">This type is thread safe.</span>
      </span>
    </threadsafe>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="3f675-106">При наследовании от <see langword="MethodBase" />, необходимо переопределить следующие члены: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> , <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, и <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span>
        <span class="sxs-lookup">
          <span data-stu-id="3f675-106">When you inherit from <see langword="MethodBase" />, you must override the following members: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, and <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span>
        </span>
      </para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3f675-107">Инициализирует новый экземпляр класса <see cref="T:System.Reflection.MethodBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-107">Initializes a new instance of the <see cref="T:System.Reflection.MethodBase" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="3f675-108">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-108">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="3f675-109">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-109">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-110">Возвращает атрибуты, сопоставленные этому методу.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-110">Gets the attributes associated with this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-111">Одно из значений перечисления <see cref="T:System.Reflection.MethodAttributes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-111">One of the <see cref="T:System.Reflection.MethodAttributes" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-112">Все члены имеют набор атрибутов, определенных относительно определенного типа члена.</span><span class="sxs-lookup"><span data-stu-id="3f675-112">All members have a set of attributes, which are defined in relation to the specific type of member.</span></span>  
  
 <span data-ttu-id="3f675-113">Для получения <xref:System.Reflection.MethodAttributes>, сначала нужно получить тип.</span><span class="sxs-lookup"><span data-stu-id="3f675-113">To get the <xref:System.Reflection.MethodAttributes>, first get the type.</span></span> <span data-ttu-id="3f675-114">Из типа которого вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="3f675-114">From the type, get the method.</span></span> <span data-ttu-id="3f675-115">С помощью метода get <xref:System.Reflection.MethodAttributes>.</span><span class="sxs-lookup"><span data-stu-id="3f675-115">From the method, get the <xref:System.Reflection.MethodAttributes>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f675-116">В следующем примере кода отображаются атрибуты определяемого пользователем метода Mymethod.</span><span class="sxs-lookup"><span data-stu-id="3f675-116">The following code example displays the attributes of the user-defined method Mymethod.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 <span data-ttu-id="3f675-117">Этот код выводит следующие результаты:</span><span class="sxs-lookup"><span data-stu-id="3f675-117">This code produces the following output:</span></span>  
  
 <span data-ttu-id="3f675-118">Образец Reflection.MethodBase.Attributes</span><span class="sxs-lookup"><span data-stu-id="3f675-118">Reflection.MethodBase.Attributes Sample</span></span>  
  
 <span data-ttu-id="3f675-119">Mymethodbase = Void Mymethod (Int32, System.String ByRef System.String ByRef)</span><span class="sxs-lookup"><span data-stu-id="3f675-119">Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)</span></span>  
  
 <span data-ttu-id="3f675-120">PrivateScope</span><span class="sxs-lookup"><span data-stu-id="3f675-120">PrivateScope</span></span>  
  
 <span data-ttu-id="3f675-121">FamANDAssem</span><span class="sxs-lookup"><span data-stu-id="3f675-121">FamANDAssem</span></span>  
  
 <span data-ttu-id="3f675-122">Семейство</span><span class="sxs-lookup"><span data-stu-id="3f675-122">Family</span></span>  
  
 <span data-ttu-id="3f675-123">Public</span><span class="sxs-lookup"><span data-stu-id="3f675-123">Public</span></span>  
  
 <span data-ttu-id="3f675-124">HideBySig</span><span class="sxs-lookup"><span data-stu-id="3f675-124">HideBySig</span></span>  
  
 <span data-ttu-id="3f675-125">ReuseSlot</span><span class="sxs-lookup"><span data-stu-id="3f675-125">ReuseSlot</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="3f675-126">Используйте <see cref="P:System.Reflection.MethodBase.Attributes" /> свойства, чтобы определить, является ли <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />, и т. д.</span>
            <span class="sxs-lookup">
              <span data-stu-id="3f675-126">Use the <see cref="P:System.Reflection.MethodBase.Attributes" /> property to determine whether a method is <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />, and so on.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.CallingConvention</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-127">Возвращает значение, показывающее соглашения о вызовах для этого метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-127">Gets a value indicating the calling conventions for this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-128">Атрибуты <see cref="T:System.Reflection.CallingConventions" /> для этого метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-128">The <see cref="T:System.Reflection.CallingConventions" /> for this method.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-129">Возвращает значение, указывающее, содержит ли универсальный метод не присвоенные параметры универсального типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-129">Gets a value indicating whether the generic method contains unassigned generic type parameters.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-130">Значение <see langword="true" />, если текущий объект <see cref="T:System.Reflection.MethodBase" /> представляет универсальный метод, который содержит не присвоенные параметры универсального типа; в обратном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-130">
              <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents a generic method that contains unassigned generic type parameters; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-131">Универсальный метод может вызываться только в том случае, если не существует определения универсального типа или открытые сконструированные типы в аргументах типа самого метода или в любой заключенных типов.</span><span class="sxs-lookup"><span data-stu-id="3f675-131">A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types.</span></span> <span data-ttu-id="3f675-132">Так как типы могут быть произвольной, выполнить такое рекурсивное определение сложно.</span><span class="sxs-lookup"><span data-stu-id="3f675-132">Because types can be arbitrarily complex, making this recursive determination is difficult.</span></span> <span data-ttu-id="3f675-133">Для удобства и уменьшить вероятность ошибок <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> свойство предоставляет стандартный способ различения закрытых сконструированных методов, которые могут быть вызваны, и откройте созданных методов, которые не.</span><span class="sxs-lookup"><span data-stu-id="3f675-133">For convenience, and to reduce the chance of error, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</span></span> <span data-ttu-id="3f675-134">Если <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> возвращает `true`, вызов метода невозможен.</span><span class="sxs-lookup"><span data-stu-id="3f675-134">If the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`, the method cannot be invoked.</span></span>  
  
 <span data-ttu-id="3f675-135"><xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> Свойство выполняет рекурсивно для параметров типа.</span><span class="sxs-lookup"><span data-stu-id="3f675-135">The <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="3f675-136">Например, он возвращает `true` для любого метода в открытом типе `A<T>` (`A(Of T)` в Visual Basic), даже если сам метод не является универсальным.</span><span class="sxs-lookup"><span data-stu-id="3f675-136">For example, it returns `true` for any method in an open type `A<T>` (`A(Of T)` in Visual Basic), even though the method itself is not generic.</span></span> <span data-ttu-id="3f675-137">Сравните это с поведением <xref:System.Reflection.MethodBase.IsGenericMethod%2A> свойство, которое возвращает `false` для такого метода.</span><span class="sxs-lookup"><span data-stu-id="3f675-137">Contrast this with the behavior of the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property, which returns `false` for such a method.</span></span>  
  
 <span data-ttu-id="3f675-138">Аналогичным образом <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> возвращает свойства параметра `true` для любого конструктора в виде открытого типа, даже если конструкторы не могут иметь свои собственные параметры типа.</span><span class="sxs-lookup"><span data-stu-id="3f675-138">Similarly, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property parameter returns `true` for any constructor in an open type, even though constructors cannot have type parameters of their own.</span></span>  
  
 <span data-ttu-id="3f675-139">Список неизменяемых условий для конкретных универсальных методов см. в разделе <xref:System.Reflection.MethodBase.IsGenericMethod%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="3f675-139">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="3f675-140">Список неизменяемых условий для других терминов, используемых в универсальном отражении см. в разделе <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> свойство.</span><span class="sxs-lookup"><span data-stu-id="3f675-140">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="3f675-141">Объект, сравниваемый с этим экземпляром, или значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-141">An object to compare with this instance, or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3f675-142">Возвращает значение, показывающее, равен ли экземпляр указанному объекту.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-142">Returns a value that indicates whether this instance is equal to a specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3f675-143">
            <see langword="true" />, если значение параметра <paramref name="obj" /> равно типу и значению данного экземпляра; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-143">
              <see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetCurrentMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetCurrentMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetCurrentMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentMethod () As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetCurrentMethod();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3f675-144">Возвращает объект <see langword="MethodBase" />, представляющий выполняющийся в текущий момент метод.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-144">Returns a <see langword="MethodBase" /> object representing the currently executing method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3f675-145">
            <see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> — это статический метод, который вызывается из выполняющегося метода и возвращает сведения об этом методе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-145">
              <see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> is a static method that is called from within an executing method and that returns information about that method.</span>
          </span>
          <span data-ttu-id="3f675-146">Объект <see langword="MethodBase" />, представляющий выполняющийся в текущий момент метод.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-146">A <see langword="MethodBase" /> object representing the currently executing method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-147">Если текущий выполняемый метод определен в универсальном типе, <xref:System.Reflection.MethodInfo> , возвращаемый <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> получается из определения универсального типа (то есть <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> возвращает `true`).</span><span class="sxs-lookup"><span data-stu-id="3f675-147">If the currently executing method is defined on a generic type, the <xref:System.Reflection.MethodInfo> that is returned by <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is obtained from the generic type definition (that is, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> returns `true`).</span></span> <span data-ttu-id="3f675-148">Таким образом он не отражает аргументы типа, которые использовались при вызове метода.</span><span class="sxs-lookup"><span data-stu-id="3f675-148">Therefore, it does not reflect the type arguments that were used when the method was called.</span></span> <span data-ttu-id="3f675-149">Например, если метод `M()` определено в универсальном типе `C<T>` (`C(Of T)` в Visual Basic), и <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> вызывается из `C<string>.M()`, затем <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> возвращает `C<T>.M()` (`C(Of T).M()` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3f675-149">For example, if a method `M()` is defined on a generic type `C<T>` (`C(Of T)` in Visual Basic), and <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is called from `C<string>.M()`, then <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns `C<T>.M()` (`C(Of T).M()` in Visual Basic).</span></span>  
  
 <span data-ttu-id="3f675-150">Если текущий выполняемый метод является универсальным методом, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> возвращает определение универсального метода.</span><span class="sxs-lookup"><span data-stu-id="3f675-150">If the currently executing method is a generic method, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns the generic method definition.</span></span> <span data-ttu-id="3f675-151">Если универсальный метод определен в универсальном типе <xref:System.Reflection.MethodInfo> получается из определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="3f675-151">If the generic method is defined on a generic type, the <xref:System.Reflection.MethodInfo> is obtained from the generic type definition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f675-152">В следующем примере определяется двумя типами.</span><span class="sxs-lookup"><span data-stu-id="3f675-152">The following example defines two types.</span></span> <span data-ttu-id="3f675-153">Первый — неуниверсальных классах, `TestClass`, включает конструктор, метод с именем `GetValue`и для чтения и записи свойство с именем `GetValue`.</span><span class="sxs-lookup"><span data-stu-id="3f675-153">The first is a non-generic class, `TestClass`, includes a constructor, a method named `GetValue`, and a read-write property named `GetValue`.</span></span> <span data-ttu-id="3f675-154">Второй — универсальный класс с именем `TestClass<T>` , включает конструктор, `GetValue` метод и универсального метода `ConvertValue<Y>`.</span><span class="sxs-lookup"><span data-stu-id="3f675-154">The second is a generic class named `TestClass<T>` that includes a constructor, a `GetValue` method, and a generic method, `ConvertValue<Y>`.</span></span> <span data-ttu-id="3f675-155">Каждый конструктор, метод и метод доступа к свойству включает вызов <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="3f675-155">Each constructor, method, and property accessor includes a call to the <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> method.</span></span>  
  
 [!code-csharp[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/cs/GetCurentMethod1.cs#1)]
 [!code-vb[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/vb/GetCurentMethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="3f675-156">Этот элемент был вызван при помощи механизма позднего связывания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-156">This member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="3f675-157">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-157">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="3f675-158">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-158">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3f675-159">Возвращает массив объектов <see cref="T:System.Type" />, которые представляют аргументы универсального метода, относящиеся к типу, или параметры типа определения универсального метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-159">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3f675-160">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа, относящиеся к универсальному методу, или параметры типа определения универсального метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-160">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span>
          </span>
          <span data-ttu-id="3f675-161">Возвращает пустой массив, если текущий метод не является универсальным методом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-161">Returns an empty array if the current method is not a generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-162">Элементы возвращаемого массива, в том порядке, в котором они отображаются в списке параметров типа для универсального метода.</span><span class="sxs-lookup"><span data-stu-id="3f675-162">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</span></span>  
  
-   <span data-ttu-id="3f675-163">Если текущий метод является закрытым сконструированным методом (то есть <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> возвращает `false`), массив, возвращаемый методом <xref:System.Reflection.MethodBase.GetGenericArguments%2A> метод содержит типы, которые были назначены для параметров универсального типа для универсального метода Определение.</span><span class="sxs-lookup"><span data-stu-id="3f675-163">If the current method is a closed constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic method definition.</span></span>  
  
-   <span data-ttu-id="3f675-164">Если текущий метод является определением универсального метода, массив содержит параметры типа.</span><span class="sxs-lookup"><span data-stu-id="3f675-164">If the current method is a generic method definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="3f675-165">Если текущий метод является открытым сконструированным методом (то есть <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> возвращает `true`) в определенные типы были назначены для некоторых параметров типа и типа параметров, включающих универсальные типы были назначены другого типа содержит массив параметров, типов и типов параметров.</span><span class="sxs-lookup"><span data-stu-id="3f675-165">If the current method is an open constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</span></span> <span data-ttu-id="3f675-166">Используйте <xref:System.Type.IsGenericParameter%2A> свойство, чтобы отличить друг от друга.</span><span class="sxs-lookup"><span data-stu-id="3f675-166">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="3f675-167">Для демонстрации этого сценария, см. пример кода, указанный для <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> свойства.</span><span class="sxs-lookup"><span data-stu-id="3f675-167">For a demonstration of this scenario, see the code example provided for the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="3f675-168">Универсальные конструкторы в платформе .NET Framework версии 2.0 не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="3f675-168">Generic constructors are not supported in the .NET Framework version 2.0.</span></span> <span data-ttu-id="3f675-169">Это свойство создает <xref:System.NotSupportedException> , если не переопределено в производном классе, поэтому создается исключение, если текущий экземпляр является типа <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="3f675-169">This property throws <xref:System.NotSupportedException> if not overridden in a derived class, so an exception is thrown if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="3f675-170">Список неизменяемых условий для конкретных универсальных методов см. в разделе <xref:System.Reflection.MethodBase.IsGenericMethod%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="3f675-170">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="3f675-171">Список неизменяемых условий для других терминов, используемых в универсальном отражении см. в разделе <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> свойство.</span><span class="sxs-lookup"><span data-stu-id="3f675-171">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3f675-172">Текущий объект является объектом <see cref="T:System.Reflection.ConstructorInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-172">The current object is a <see cref="T:System.Reflection.ConstructorInfo" />.</span>
          </span>
          <span data-ttu-id="3f675-173">Универсальные конструкторы в платформе .NET Framework версии 2.0 не поддерживаются.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-173">Generic constructors are not supported in the .NET Framework version 2.0.</span>
          </span>
          <span data-ttu-id="3f675-174">Это исключение является поведением по умолчанию, если этот метод не переопределен в производном классе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-174">This exception is the default behavior if this method is not overridden in a derived class.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericArguments" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3f675-175">Возвращает хэш-код данного экземпляра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-175">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3f675-176">Хэш-код в виде 32-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-176">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBody">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBody GetMethodBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBody GetMethodBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodBody" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMethodBody () As MethodBody" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBody ^ GetMethodBody();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBody</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3f675-177">При переопределении в производном классе возвращает объект <see cref="T:System.Reflection.MethodBody" />, который обеспечивает доступ к потоку MSIL, локальным переменным и исключениям для текущего метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-177">When overridden in a derived class, gets a <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3f675-178">Объект <see cref="T:System.Reflection.MethodBody" />, который обеспечивает доступ к потоку MSIL, локальным переменным и исключениям для текущего метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-178">A <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-179">Необходимо переопределить <xref:System.Reflection.MethodBase.GetMethodBody%2A> для использования.</span><span class="sxs-lookup"><span data-stu-id="3f675-179">You do not have to override the <xref:System.Reflection.MethodBase.GetMethodBody%2A> in order to use it.</span></span> <span data-ttu-id="3f675-180">Можно вызвать <xref:System.Reflection.MethodBase.GetMethodBody%2A> метод <xref:System.Reflection.MethodInfo> и <xref:System.Reflection.ConstructorInfo> объектов, так как метод переопределяется в версии среды выполнения из этих классов.</span><span class="sxs-lookup"><span data-stu-id="3f675-180">You can call the <xref:System.Reflection.MethodBase.GetMethodBody%2A> method on <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo> objects, because the method is overridden in the runtime versions of these classes.</span></span> <span data-ttu-id="3f675-181">Например, версия среды выполнения <xref:System.Reflection.MethodInfo> класс является производным от <xref:System.Reflection.MethodInfo> класс, который в свою очередь является производным от <xref:System.Reflection.MethodBase> класса.</span><span class="sxs-lookup"><span data-stu-id="3f675-181">For example, the runtime version of the <xref:System.Reflection.MethodInfo> class derives from the <xref:System.Reflection.MethodInfo> class, which in turn derives from the <xref:System.Reflection.MethodBase> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f675-182">В следующем примере кода определяется метод теста, с именем `MethodBodyExample` и отображает ее локальных переменных и предложений обработки исключений.</span><span class="sxs-lookup"><span data-stu-id="3f675-182">The following code example defines a test method named `MethodBodyExample` and displays its local variable information and exception-handling clauses.</span></span> <span data-ttu-id="3f675-183"><xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> Метод используется для получения <xref:System.Reflection.MethodBody> объекта для метода теста.</span><span class="sxs-lookup"><span data-stu-id="3f675-183">The <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> method is used to obtain a <xref:System.Reflection.MethodBody> object for the test method.</span></span>  
  
 <span data-ttu-id="3f675-184"><xref:System.Reflection.MethodBody.LocalVariables%2A> Свойство используется для получения списка <xref:System.Reflection.LocalVariableInfo> объектов и отображать их типы и порядок индекса.</span><span class="sxs-lookup"><span data-stu-id="3f675-184">The <xref:System.Reflection.MethodBody.LocalVariables%2A> property is used to obtain a list of <xref:System.Reflection.LocalVariableInfo> objects and display their types and index order.</span></span> <span data-ttu-id="3f675-185"><xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> Свойство используется, чтобы получить список предложений обработки исключений.</span><span class="sxs-lookup"><span data-stu-id="3f675-185">The <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> property is used to obtain a list of exception-handling clauses.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f675-186">Не все языки программирования можно создавать <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> предложения.</span><span class="sxs-lookup"><span data-stu-id="3f675-186">Not all computer languages can generate <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> clauses.</span></span> <span data-ttu-id="3f675-187">В примере Visual Basic показано предложение фильтра с помощью Visual Basic `When` выражения, отсутствующего в примерах для других языков.</span><span class="sxs-lookup"><span data-stu-id="3f675-187">The Visual Basic example shows a filter clause, using a Visual Basic `When` expression, which is omitted from the examples for other languages.</span></span>  
  
 [!code-cpp[MethodBody#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBody/cpp/source.cpp#1)]
 [!code-csharp[MethodBody#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBody/CS/source.cs#1)]
 [!code-vb[MethodBody#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBody/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3f675-188">Если этот метод не переопределен в производном классе, он является недопустимым.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-188">This method is invalid unless overridden in a derived class.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="3f675-189">для доступа к метаданным для элементов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-189">for the access to metadata for members.</span>
          </span>
          <span data-ttu-id="3f675-190">Значение разрешения: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-190">Permission value: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-191">Возвращает сведения о методе с с использованием заданного дескриптора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-191">Gets method information using the specified handle.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="3f675-192">Дескриптор метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-192">The method's handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3f675-193">Получает сведения о методе с помощью представления внутренних метаданных метода (дескриптора).</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-193">Gets method information by using the method's internal metadata representation (handle).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3f675-194">Строка <see langword="MethodBase" />, содержащая сведения о методе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-194">A <see langword="MethodBase" /> containing information about the method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-195">Дескрипторы доступны только в домене приложения, в котором они были получены.</span><span class="sxs-lookup"><span data-stu-id="3f675-195">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3f675-196">
            <paramref name="handle" /> недопустим.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-196">
              <paramref name="handle" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="3f675-197">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-197">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="3f675-198">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-198">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle, declaringType As RuntimeTypeHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="3f675-199">Дескриптор представления внутренних метаданных конструктора или метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-199">A handle to the internal metadata representation of a constructor or method.</span>
          </span>
        </param>
        <param name="declaringType">
          <span data-ttu-id="3f675-200">Дескриптор универсального типа, определяющего конструктор или метод.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-200">A handle to the generic type that defines the constructor or method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3f675-201">Возвращает объект <see cref="T:System.Reflection.MethodBase" /> для конструктора метода, представленного заданным дескриптором для заданного универсального типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-201">Gets a <see cref="T:System.Reflection.MethodBase" /> object for the constructor or method represented by the specified handle, for the specified generic type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3f675-202">Объект <see cref="T:System.Reflection.MethodBase" />, который представляет метод или конструктор, определенный дескриптором <paramref name="handle" />, в универсальном типе, заданном параметром <paramref name="declaringType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-202">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor specified by <paramref name="handle" />, in the generic type specified by <paramref name="declaringType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-203">Дескрипторы доступны только в домене приложения, в котором они были получены.</span><span class="sxs-lookup"><span data-stu-id="3f675-203">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 <span data-ttu-id="3f675-204">Объект <xref:System.RuntimeMethodHandle> структуру к конструктору или методу универсального типа может представлять различные <xref:System.Reflection.MethodBase> объектов, в зависимости от типов, заданных для параметров типа универсального типа.</span><span class="sxs-lookup"><span data-stu-id="3f675-204">A <xref:System.RuntimeMethodHandle> structure for a constructor or method of a generic type can represent different <xref:System.Reflection.MethodBase> objects, depending on the types specified for the type parameters of the generic type.</span></span> <span data-ttu-id="3f675-205">Например если `class G<T>` (`class G(Of T)` в Visual Basic `generic <T> ref class G` в C++) содержит метод, который возвращает тип `T`, <xref:System.Reflection.MethodBase> объект для этого метода в сформированного класса, такой как `G<int>` отличается от <xref:System.Reflection.MethodBase>объект для этого метода в определении универсального типа.</span><span class="sxs-lookup"><span data-stu-id="3f675-205">For example, if `class G<T>` (`class G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) has a method that returns type `T`, the <xref:System.Reflection.MethodBase> object for that method in a constructed class such as `G<int>` is different from the <xref:System.Reflection.MethodBase> object for that method in the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3f675-206">
            <paramref name="handle" /> недопустим.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-206">
              <paramref name="handle" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="3f675-207">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-207">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="3f675-208">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-208">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetMethodImplementationFlags</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3f675-209">При переопределении в производном классе возвращает новые флаги <see cref="T:System.Reflection.MethodImplAttributes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-209">When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodImplAttributes" /> flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3f675-210">Флаги <see langword="MethodImplAttributes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-210">The <see langword="MethodImplAttributes" /> flags.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3f675-211">В следующем примере определяется конструктор в динамической сборке и затем использует <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> метод для отображения, заданные по умолчанию флаги реализации метода.</span><span class="sxs-lookup"><span data-stu-id="3f675-211">The following example defines a constructor in a dynamic assembly and then uses the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method to display the method implementation flags that are set by default.</span></span>  
  
 [!code-cpp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#3)]
 [!code-csharp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#3)]
 [!code-vb[ConstructorBuilder_GetModule_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="3f675-212">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-212">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="3f675-213">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-213">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.MethodImplAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3f675-214">При переопределении в производном классе возвращает параметры заданного метода или конструктора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-214">When overridden in a derived class, gets the parameters of the specified method or constructor.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3f675-215">Массив типа <see langword="ParameterInfo" />, содержащий сведения, которые соответствуют подписи метода (или конструктора), представленного этим экземпляром <see langword="MethodBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-215">An array of type <see langword="ParameterInfo" /> containing information that matches the signature of the method (or constructor) reflected by this <see langword="MethodBase" /> instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3f675-216">В следующем примере используется <xref:System.Reflection.MethodBase.GetParameters%2A> метод для извлечения параметров `Invoke` метод делегата.</span><span class="sxs-lookup"><span data-stu-id="3f675-216">The following example uses the <xref:System.Reflection.MethodBase.GetParameters%2A> method to retrieve the parameters of the `Invoke` method of a delegate.</span></span>  
  
 <span data-ttu-id="3f675-217">В примере определяется делегат с именем `MyDelegate` и событие с именем `ev` типа `MyDelegate`.</span><span class="sxs-lookup"><span data-stu-id="3f675-217">The example defines a delegate named `MyDelegate` and an event named `ev` of type `MyDelegate`.</span></span> <span data-ttu-id="3f675-218">Код в `Main` метод обнаруживает сигнатуры события, обратившись в тип делегата события, получение `Invoke` метод тип делегата, а затем извлечение и отображение параметров.</span><span class="sxs-lookup"><span data-stu-id="3f675-218">The code in the `Main` method discovers the event signature by getting the delegate type of the event, getting the `Invoke` method of the delegate type, and then retrieving and displaying the parameters.</span></span>  
  
 [!code-cpp[eventarg#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventArg/CPP/eventarg.cpp#1)]
 [!code-csharp[eventarg#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventArg/CS/eventarg.cs#1)]
 [!code-vb[eventarg#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventArg/VB/eventarg.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="3f675-219">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-219">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="3f675-220">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-220">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.ParameterInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-221">Вызывает метод или конструктор, отражаемый этим экземпляром <see langword="MethodInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-221">Invokes the method or constructor reflected by this <see langword="MethodInfo" /> instance.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="3f675-222">Объект, для которого нужно вызвать метод или конструктор.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-222">The object on which to invoke the method or constructor.</span>
          </span>
          <span data-ttu-id="3f675-223">Если метод является статическим, этот аргумент игнорируется.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-223">If a method is static, this argument is ignored.</span>
          </span>
          <span data-ttu-id="3f675-224">Если конструктор является статическим, этот аргумент должен иметь значение <see langword="null" /> или представлять экземпляр класса, который определяет конструктор.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-224">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="3f675-225">Список аргументов для вызываемого метода или конструктора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-225">An argument list for the invoked method or constructor.</span>
          </span>
          <span data-ttu-id="3f675-226">Это массив объектов, количество, порядок и тип которых должны соответствовать списку параметров вызываемого метода или конструктора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-226">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span>
          </span>
          <span data-ttu-id="3f675-227">Если параметров нет, для <c>parameters</c> должно быть указано значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-227">If there are no parameters, <c>parameters</c> should be <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3f675-228">Если метод или конструктор, представленный этим экземпляром, принимает параметр <see langword="ref" /> (<see langword="ByRef" /> в Visual Basic), не требуются никакие специальные атрибуты для вызова этого метода или конструктора с использованием этой функции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-228">If the method or constructor represented by this instance takes a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function.</span>
          </span>
          <span data-ttu-id="3f675-229">Любой объект этого массива, которому не присвоено значение явным образом, будет содержать значение по умолчанию для своего типа объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-229">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span>
          </span>
          <span data-ttu-id="3f675-230">Для элементов ссылочного типа это значение равно <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-230">For reference-type elements, this value is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3f675-231">Для элементов, хранящих значения, это значение равно 0, 0,0 или <see langword="false" /> (в зависимости от типа конкретного элемента).</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-231">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3f675-232">Вызывает метод или конструктор, представленный текущим экземпляром, используя указанные параметры.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-232">Invokes the method or constructor represented by the current instance, using the specified parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3f675-233">Объект, который содержит возвращаемое значение вызываемого метода, или <see langword="null" /> при вызове конструктора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-233">An object containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-234">Это удобный метод, который вызывает <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> перегрузка метода, передав <xref:System.Reflection.BindingFlags.Default> для `invokeAttr` и `null` для `binder` и `culture`.</span><span class="sxs-lookup"><span data-stu-id="3f675-234">This is a convenience method that calls the <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> method overload, passing <xref:System.Reflection.BindingFlags.Default> for `invokeAttr` and `null` for `binder` and `culture`.</span></span>  
  
 <span data-ttu-id="3f675-235">Если вызванный метод создает исключение, <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> метод возвращает исключение.</span><span class="sxs-lookup"><span data-stu-id="3f675-235">If the invoked method throws an exception, the <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> method returns the exception.</span></span>  
  
 <span data-ttu-id="3f675-236">Для вызова статического метода с помощью его <xref:System.Reflection.MethodInfo> , передать `null` для `obj`.</span><span class="sxs-lookup"><span data-stu-id="3f675-236">To invoke a static method using its <xref:System.Reflection.MethodInfo> object, pass `null` for `obj`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f675-237">Эта перегрузка метода используется для вызова конструктора экземпляра, объект, предоставленный для `obj` инициализируется; то есть выполняются все инициализаторы экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f675-237">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="3f675-238">Возвращаемое значение — `null`.</span><span class="sxs-lookup"><span data-stu-id="3f675-238">The return value is `null`.</span></span> <span data-ttu-id="3f675-239">Если вызывается конструктор класса, инициализируется класс; то есть выполняются все инициализаторы класса.</span><span class="sxs-lookup"><span data-stu-id="3f675-239">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="3f675-240">Возвращаемое значение — `null`.</span><span class="sxs-lookup"><span data-stu-id="3f675-240">The return value is `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f675-241">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым членам, если вызывающему объекту предоставлены <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и отметки Если набор прав, не являющиеся открытыми члены ограничена вызывающего набором разрешений или подмножество его.</span><span class="sxs-lookup"><span data-stu-id="3f675-241">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="3f675-242">(См. [рекомендации по безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="3f675-242">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="3f675-243">Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="3f675-243">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 <span data-ttu-id="3f675-244">Если параметр текущего метода является тип значения и соответствующего аргумента в `parameters` — `null`, среда выполнения передает инициализированный нулем экземпляр типа значения.</span><span class="sxs-lookup"><span data-stu-id="3f675-244">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f675-245">В следующем примере кода демонстрируется поиск динамических методов, с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="3f675-245">The following code example demonstrates dynamic method lookup using reflection.</span></span> <span data-ttu-id="3f675-246">Обратите внимание, что нельзя использовать <xref:System.Reflection.MethodInfo> объект из базового класса, чтобы вызвать метод, переопределенный в производном классе, так как функция позднего связывания не удается разрешить переопределения.</span><span class="sxs-lookup"><span data-stu-id="3f675-246">Note that you cannot use the <xref:System.Reflection.MethodInfo> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.</span></span>  
  
 [!code-cpp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="3f675-247">Вместо этого в [.NET для приложений Магазина Windows](http://go.microsoft.com/fwlink/?LinkID=247912) или в [переносимой библиотеке классов](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) перехватите исключение <see cref="T:System.Exception" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="3f675-247">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception" /> instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="3f675-248">Параметр <paramref name="obj" /> имеет значение <see langword="null" /> и метод не является статическим.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-248">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span>
          </span>
          <span data-ttu-id="3f675-249">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-249">-or-</span>
          </span>
          <span data-ttu-id="3f675-250">Этот метод не объявлен и не унаследован в классе <paramref name="obj" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-250">The method is not declared or inherited by the class of <paramref name="obj" />.</span>
          </span>
          <span data-ttu-id="3f675-251">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-251">-or-</span>
          </span>
          <span data-ttu-id="3f675-252">Вызывается статический конструктор, а <paramref name="obj" /> не имеет значения <see langword="null" /> и не является экземпляром класса, в котором объявлен этот конструктор.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-252">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3f675-253">Элементы массива <paramref name="parameters" /> не соответствуют подписи метода или конструктора, отраженного этим экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-253">The elements of the <paramref name="parameters" /> array do not match the signature of the method or constructor reflected by this instance.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="3f675-254">Вызванный метод или конструктор создает исключение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-254">The invoked method or constructor throws an exception.</span>
          </span>
          <span data-ttu-id="3f675-255">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-255">-or-</span>
          </span>
          <span data-ttu-id="3f675-256">Текущий экземпляр представляет <see cref="T:System.Reflection.Emit.DynamicMethod" />, который содержит непроверяемый код.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-256">The current instance is a <see cref="T:System.Reflection.Emit.DynamicMethod" /> that contains unverifiable code.</span>
          </span>
          <span data-ttu-id="3f675-257">См. подраздел "Проверка" в разделе примечаний для <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-257">See the "Verification" section in Remarks for <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <span data-ttu-id="3f675-258">Массив <paramref name="parameters" /> содержит неправильное число аргументов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-258">The <paramref name="parameters" /> array does not have the correct number of arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="3f675-259">Вместо этого в [.NET для приложений Магазина Windows](http://go.microsoft.com/fwlink/?LinkID=247912) или в [переносимой библиотеке классов](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) перехватите исключение базового класса <see cref="T:System.MemberAccessException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="3f675-259">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="3f675-260">Вызывающий объект не имеет разрешение на выполнение метода или конструктора, представленного текущим экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-260">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3f675-261">Тип, объявляющий метод, является открытым универсальным типом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-261">The type that declares the method is an open generic type.</span>
          </span>
          <span data-ttu-id="3f675-262">То есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> для объявляющего типа возвращает значение <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-262">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3f675-263">Текущий экземпляр представляет <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-263">The current instance is a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="3f675-264">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-264">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="3f675-265">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-265">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Missing" />
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public abstract object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="3f675-266">Объект, для которого нужно вызвать метод или конструктор.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-266">The object on which to invoke the method or constructor.</span>
          </span>
          <span data-ttu-id="3f675-267">Если метод является статическим, этот аргумент игнорируется.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-267">If a method is static, this argument is ignored.</span>
          </span>
          <span data-ttu-id="3f675-268">Если конструктор является статическим, этот аргумент должен иметь значение <see langword="null" /> или представлять экземпляр класса, который определяет конструктор.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-268">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="3f675-269">Битовая маска, которая содержит от нуля и больше битовых флагов из атрибута <see cref="T:System.Reflection.BindingFlags" /> в разных сочетаниях.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-269">A bitmask that is a combination of 0 or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
          <span data-ttu-id="3f675-270">Если параметр <c>binder</c> имеет значение <see langword="null" />, ему присваивается значение <see cref="F:System.Reflection.BindingFlags.Default" />. В результате все передаваемые параметры игнорируются.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-270">If <c>binder</c> is <see langword="null" />, this parameter is assigned the value <see cref="F:System.Reflection.BindingFlags.Default" />; thus, whatever you pass in is ignored.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="3f675-271">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see langword="MemberInfo" /> с помощью отражения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-271">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span>
          </span>
          <span data-ttu-id="3f675-272">Если указан <c>модуль привязки</c><see langword="null" />, используется модуль привязки по умолчанию.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-272">If <c>binder</c> is <see langword="null" />, the default binder is used.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="3f675-273">Список аргументов для вызываемого метода или конструктора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-273">An argument list for the invoked method or constructor.</span>
          </span>
          <span data-ttu-id="3f675-274">Это массив объектов, количество, порядок и тип которых должны соответствовать списку параметров вызываемого метода или конструктора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-274">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span>
          </span>
          <span data-ttu-id="3f675-275">При отсутствии параметров — значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-275">If there are no parameters, this should be <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3f675-276">Если метод или конструктор, представленный этим экземпляром, принимает параметр ByRef, для вызова метода или конструктора с использованием этой функции специальные атрибуты не требуются.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-276">If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function.</span>
          </span>
          <span data-ttu-id="3f675-277">Любой объект этого массива, которому не присвоено значение явным образом, будет содержать значение по умолчанию для своего типа объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-277">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span>
          </span>
          <span data-ttu-id="3f675-278">Для элементов ссылочного типа это значение равно <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-278">For reference-type elements, this value is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3f675-279">Для элементов, хранящих значения, это значение равно 0, 0,0 или <see langword="false" /> (в зависимости от типа конкретного элемента).</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-279">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="3f675-280">Экземпляр объекта <see langword="CultureInfo" />, используемого для управления приведением типов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-280">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="3f675-281">Если значение этого объекта — <see langword="null" />, для текущего потока используется <see langword="CultureInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-281">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="3f675-282">(Например, необходимо преобразовывать объект <see langword="String" />, представляющий 1000, в значение <see langword="Double" />, поскольку при разных языках и региональных параметрах 1000 представляется по-разному.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-282">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3f675-283">При переопределении в производном классе вызывает отражаемый метод или конструктор с заданными параметрами.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-283">When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3f675-284">Объект <see langword="Object" />, содержащий возвращаемое значение вызванного метода, значение <see langword="null" /> для конструктора или значение <see langword="null" />, если метод возвращает значение типа <see langword="void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-284">An <see langword="Object" /> containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor, or <see langword="null" /> if the method's return type is <see langword="void" />.</span>
          </span>
          <span data-ttu-id="3f675-285">Перед вызовом метода или конструктора функция <see langword="Invoke" /> проверяет наличие у пользователя права доступа и допустимость параметров.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-285">Before calling the method or constructor, <see langword="Invoke" /> checks to see if the user has access permission and verifies that the parameters are valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-286">Динамически вызывает метод, отраженный этим экземпляром `obj`и передает указанные параметры.</span><span class="sxs-lookup"><span data-stu-id="3f675-286">Dynamically invokes the method reflected by this instance on `obj`, and passes along the specified parameters.</span></span> <span data-ttu-id="3f675-287">Если метод является статическим, `obj` параметр учитывается.</span><span class="sxs-lookup"><span data-stu-id="3f675-287">If the method is static, the `obj` parameter is ignored.</span></span> <span data-ttu-id="3f675-288">Для методов, не являющиеся статическими `obj` должен быть экземпляром класса, который наследует или объявляет метод, а также должен быть того же типа, что и этот класс.</span><span class="sxs-lookup"><span data-stu-id="3f675-288">For non-static methods, `obj` should be an instance of a class that inherits or declares the method and must be the same type as this class.</span></span> <span data-ttu-id="3f675-289">Если метод не имеет параметров, значение `parameters` должно быть `null`.</span><span class="sxs-lookup"><span data-stu-id="3f675-289">If the method has no parameters, the value of `parameters` should be `null`.</span></span> <span data-ttu-id="3f675-290">В противном случае число, тип и порядок элементов в `parameters` должен быть идентичен количество, тип и порядок параметров метода, отраженный этим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="3f675-290">Otherwise, the number, type, and order of elements in `parameters` should be identical to the number, type, and order of parameters for the method reflected by this instance.</span></span>  
  
 <span data-ttu-id="3f675-291">Не менее опускать необязательные параметры в вызовах `Invoke`.</span><span class="sxs-lookup"><span data-stu-id="3f675-291">You may not omit optional parameters in calls to `Invoke`.</span></span> <span data-ttu-id="3f675-292">Чтобы вызвать метод, опустив необязательные параметры, необходимо вызвать `Type.InvokeMember` вместо него.</span><span class="sxs-lookup"><span data-stu-id="3f675-292">To invoke a method omitting optional parameters, you should call `Type.InvokeMember` instead.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f675-293">Эта перегрузка метода используется для вызова конструктора экземпляра, объект, предоставленный для `obj` инициализируется; то есть выполняются все инициализаторы экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f675-293">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="3f675-294">Возвращаемое значение — `null`.</span><span class="sxs-lookup"><span data-stu-id="3f675-294">The return value is `null`.</span></span> <span data-ttu-id="3f675-295">Если вызывается конструктор класса, инициализируется класс; то есть выполняются все инициализаторы класса.</span><span class="sxs-lookup"><span data-stu-id="3f675-295">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="3f675-296">Возвращаемое значение — `null`.</span><span class="sxs-lookup"><span data-stu-id="3f675-296">The return value is `null`.</span></span>  
  
 <span data-ttu-id="3f675-297">Для примитивных параметров передачи по значению, выполняется нормальное расширение (Int16 -> Int32, например).</span><span class="sxs-lookup"><span data-stu-id="3f675-297">For pass-by-value primitive parameters, normal widening is performed (Int16 -> Int32, for example).</span></span> <span data-ttu-id="3f675-298">Для передачи по значению ссылочных параметров нормальное расширение ссылки допускается (производный класс для базового класса и базового класса к типу интерфейса).</span><span class="sxs-lookup"><span data-stu-id="3f675-298">For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type).</span></span> <span data-ttu-id="3f675-299">Однако для передачи по ссылке примитивных параметров, типы должны точно совпадать.</span><span class="sxs-lookup"><span data-stu-id="3f675-299">However, for pass-by-reference primitive parameters, the types must match exactly.</span></span> <span data-ttu-id="3f675-300">Для передачи по ссылке ссылочных параметров нормальное расширение по-прежнему применяется.</span><span class="sxs-lookup"><span data-stu-id="3f675-300">For pass-by-reference reference parameters, the normal widening still applies.</span></span>  
  
 <span data-ttu-id="3f675-301">Например, если метод отражаться на этот экземпляр объявляется как `public boolean Compare(String a, String b)`, затем `parameters` должен быть массивом `Objects` длиной 2 таким образом, что `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.</span><span class="sxs-lookup"><span data-stu-id="3f675-301">For example, if the method reflected by this instance is declared as `public boolean Compare(String a, String b)`, then `parameters` should be an array of `Objects` with length 2 such that `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.</span></span>  
  
 <span data-ttu-id="3f675-302">Если параметр текущего метода является тип значения и соответствующего аргумента в `parameters` — `null`, среда выполнения передает инициализированный нулем экземпляр типа значения.</span><span class="sxs-lookup"><span data-stu-id="3f675-302">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
 <span data-ttu-id="3f675-303">Отражение использует поиск динамического метода, при вызове виртуальных методов.</span><span class="sxs-lookup"><span data-stu-id="3f675-303">Reflection uses dynamic method lookup when invoking virtual methods.</span></span> <span data-ttu-id="3f675-304">Например предположим, что класс B наследует от класса A, и оба реализуют виртуальный метод с именем M. Теперь предположим, что есть `MethodInfo` объект, представляющий M для класса. Если вы используете `Invoke` метод, вызываемый M на объект типа б, то отражение использует реализацию, которую класс B. Даже если объект типа Б приводится к A, используется реализация, происходящая от класса B (см. пример кода ниже).</span><span class="sxs-lookup"><span data-stu-id="3f675-304">For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a `MethodInfo` object that represents M on class A. If you use the `Invoke` method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</span></span>  
  
 <span data-ttu-id="3f675-305">С другой стороны, если невиртуальный метод, отражение использует реализацию по типу, из которого `MethodInfo` был получен, независимо от типа объекта, переданного в качестве целевого объекта.</span><span class="sxs-lookup"><span data-stu-id="3f675-305">On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the `MethodInfo` was obtained, regardless of the type of the object passed as the target.</span></span>  
  
 <span data-ttu-id="3f675-306">Ограничения доступа игнорируются для полностью доверенный код.</span><span class="sxs-lookup"><span data-stu-id="3f675-306">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="3f675-307">То есть закрытые конструкторы, методы, поля и свойства можно получить доступ к и вызывается через отражение, если код имеет полное доверие.</span><span class="sxs-lookup"><span data-stu-id="3f675-307">That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="3f675-308">Если вызванный метод создает исключение, `TargetInvocationException.GetException` возвращает исключение.</span><span class="sxs-lookup"><span data-stu-id="3f675-308">If the invoked method throws an exception, `TargetInvocationException.GetException` returns the exception.</span></span> <span data-ttu-id="3f675-309">Эта реализация создает исключение `NotSupportedException`.</span><span class="sxs-lookup"><span data-stu-id="3f675-309">This implementation throws a `NotSupportedException`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f675-310">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым членам, если вызывающему объекту предоставлены <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и отметки Если набор прав, не являющиеся открытыми члены ограничена вызывающего набором разрешений или подмножество его.</span><span class="sxs-lookup"><span data-stu-id="3f675-310">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="3f675-311">(См. [рекомендации по безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="3f675-311">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="3f675-312">Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="3f675-312">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f675-313">В следующем примере показано все члены <xref:System.Reflection.Binder?displayProperty=nameWithType> класса с помощью перегруженной <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3f675-313">The following example demonstrates all members of the <xref:System.Reflection.Binder?displayProperty=nameWithType> class using an overload of <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3f675-314">Закрытый метод `CanConvertFrom` находит совместимые типы для данного типа.</span><span class="sxs-lookup"><span data-stu-id="3f675-314">The private method `CanConvertFrom` finds compatible types for a given type.</span></span> <span data-ttu-id="3f675-315">Другой пример вызова членов в пользовательском сценарии связывания см [динамическая загрузка и использование типов](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).</span><span class="sxs-lookup"><span data-stu-id="3f675-315">For another example of invoking members in a custom binding scenario, see [Dynamically Loading and Using Types](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).</span></span>  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="3f675-316">Параметр <paramref name="obj" /> имеет значение <see langword="null" /> и метод не является статическим.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-316">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span>
          </span>
          <span data-ttu-id="3f675-317">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-317">-or-</span>
          </span>
          <span data-ttu-id="3f675-318">Этот метод не объявлен и не унаследован в классе <paramref name="obj" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-318">The method is not declared or inherited by the class of <paramref name="obj" />.</span>
          </span>
          <span data-ttu-id="3f675-319">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-319">-or-</span>
          </span>
          <span data-ttu-id="3f675-320">Вызывается статический конструктор, а <paramref name="obj" /> не имеет значения <see langword="null" /> и не является экземпляром класса, в котором объявлен этот конструктор.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-320">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3f675-321">Тип параметра <paramref name="parameters" /> не соответствует подписи метода или конструктора, отраженного этим экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-321">The type of the <paramref name="parameters" /> parameter does not match the signature of the method or constructor reflected by this instance.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <span data-ttu-id="3f675-322">Массив <paramref name="parameters" /> содержит неправильное число аргументов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-322">The <paramref name="parameters" /> array does not have the correct number of arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="3f675-323">Вызванный метод или конструктор создает исключение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-323">The invoked method or constructor throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="3f675-324">Вызывающий объект не имеет разрешение на выполнение метода или конструктора, представленного текущим экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-324">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3f675-325">Тип, объявляющий метод, является открытым универсальным типом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-325">The type that declares the method is an open generic type.</span>
          </span>
          <span data-ttu-id="3f675-326">То есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> для объявляющего типа возвращает значение <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-326">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="3f675-327">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-327">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="3f675-328">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-328">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-329">Возвращает значение, указывающее, является ли метод абстрактным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-329">Gets a value indicating whether the method is abstract.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-330">Значение <see langword="true" />, если метод является абстрактным; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-330">
              <see langword="true" /> if the method is abstract; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-331">Абстрактный член объявлен в базовом классе и предоставил нет реализации.</span><span class="sxs-lookup"><span data-stu-id="3f675-331">An abstract member is declared on a base class and has no implementation supplied.</span></span>  
  
 <span data-ttu-id="3f675-332">Для получения <xref:System.Reflection.MethodBase>, сначала нужно получить тип.</span><span class="sxs-lookup"><span data-stu-id="3f675-332">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="3f675-333">Из типа которого вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="3f675-333">From the type, get the method.</span></span> <span data-ttu-id="3f675-334">С помощью метода get `MethodBase`.</span><span class="sxs-lookup"><span data-stu-id="3f675-334">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="3f675-335">Если `MethodBase` или конструктор не являются открытыми, они защищены и не может быть непосредственно доступны.</span><span class="sxs-lookup"><span data-stu-id="3f675-335">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="3f675-336">Для обращения к методу, не являющиеся открытыми, установите <xref:System.Reflection.BindingFlags> для маски `NonPublic` в `GetMethod`.</span><span class="sxs-lookup"><span data-stu-id="3f675-336">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f675-337">В следующем примере определяется, является ли указанный метод является абстрактным и отображается результат.</span><span class="sxs-lookup"><span data-stu-id="3f675-337">The following example determines whether specified the method is abstract and displays the result.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-338">Возвращает значение, которое указывает, описана ли доступность данного метода или конструктора в поле <see cref="F:System.Reflection.MethodAttributes.Assembly" />; другими словами, этот метод или конструктор полностью доступен для других полей той же сборки и недоступен для производных типов, не включенных в сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-338">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-339">Значение <see langword="true" />, если доступность этого метода или конструктора точно описана в поле <see cref="F:System.Reflection.MethodAttributes.Assembly" />; в обратном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-339">
              <see langword="true" /> if the visibility of this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-340">Фактически доступность метода ограничена доступностью его типа.</span><span class="sxs-lookup"><span data-stu-id="3f675-340">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="3f675-341"><xref:System.Reflection.MethodBase.IsAssembly%2A> Свойство может быть `true` для метода, но если он является метод закрытого вложенного типа метода не отображается за пределами содержащего типа.</span><span class="sxs-lookup"><span data-stu-id="3f675-341">The <xref:System.Reflection.MethodBase.IsAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="3f675-342">Видимость метод или конструктор точно описываемого <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> Если модификатор видимости только `internal` (`Friend` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3f675-342">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> if the only visibility modifier is `internal` (`Friend` in Visual Basic).</span></span> <span data-ttu-id="3f675-343">Это свойство является `false` для методов, которые являются `protected internal` в C# (`Protected Friend` в Visual Basic `protected public` в C++); используйте <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> свойство для определения таких методов.</span><span class="sxs-lookup"><span data-stu-id="3f675-343">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f675-344">В следующем примере кода определяет методы, с различными уровнями видимость и отображает значения их <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, и <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> свойства.</span><span class="sxs-lookup"><span data-stu-id="3f675-344">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f675-345">Языки Visual Basic и C# не может определить методы с <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> видимости, что уровень доступа отображается только в примере C++.</span><span class="sxs-lookup"><span data-stu-id="3f675-345">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructor">
      <MemberSignature Language="C#" Value="public bool IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructor" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructor { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-346">Возвращает значение, указывающее, является ли метод конструктором.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-346">Gets a value indicating whether the method is a constructor.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-347">Значение <see langword="true" />, если метод является конструктором, представленным объектом <see cref="T:System.Reflection.ConstructorInfo" /> (см. примечание, относящееся к объектам <see cref="T:System.Reflection.Emit.ConstructorBuilder" />, в разделе "Заметки"); в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-347">
              <see langword="true" /> if this method is a constructor represented by a <see cref="T:System.Reflection.ConstructorInfo" /> object (see note in Remarks about <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> objects); otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="3f675-348"><xref:System.Reflection.MethodBase.IsConstructor%2A> Возвращает `false` для <xref:System.Reflection.Emit.ConstructorBuilder> объекта в динамический тип, если не <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> флаг был включен в `attributes` параметр, если конструктор был определен.</span><span class="sxs-lookup"><span data-stu-id="3f675-348">The <xref:System.Reflection.MethodBase.IsConstructor%2A> property returns `false` for a <xref:System.Reflection.Emit.ConstructorBuilder> object in a dynamic type, unless the <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> flag was included in the `attributes` parameter when the constructor was defined.</span></span> <span data-ttu-id="3f675-349">Пропуск <xref:System.Reflection.MethodAttributes.RTSpecialName> флаг не влияет на правильность порожденную конструктора.</span><span class="sxs-lookup"><span data-stu-id="3f675-349">Omitting the <xref:System.Reflection.MethodAttributes.RTSpecialName> flag does not affect the correctness of the emitted constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-350">Возвращает значение, которое указывает, описана ли доступность этого метода или конструктора в поле <see cref="F:System.Reflection.MethodAttributes.Family" />; другими словами, этот метод или конструктор доступен только в своем классе и производных классах.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-350">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Family" />; that is, the method or constructor is visible only within its class and derived classes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-351">Значение <see langword="true" />, если доступность этого метода или конструктора точно описана в поле <see cref="F:System.Reflection.MethodAttributes.Family" />; в обратном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-351">
              <see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Family" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-352">Видимость метод или конструктор точно описываемого <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> Если модификатор видимости только `protected`.</span><span class="sxs-lookup"><span data-stu-id="3f675-352">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> if the only visibility modifier is `protected`.</span></span> <span data-ttu-id="3f675-353">Это свойство является `false` для методов, которые являются `protected internal` в C# (`Protected Friend` в Visual Basic `protected public` в C++); используйте <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> свойство для определения таких методов.</span><span class="sxs-lookup"><span data-stu-id="3f675-353">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f675-354">В следующем примере кода определяет методы, с различными уровнями видимость и отображает значения их <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, и <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> свойства.</span><span class="sxs-lookup"><span data-stu-id="3f675-354">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f675-355">Языки Visual Basic и C# не может определить методы с <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> видимости, что уровень доступа отображается только в примере C++.</span><span class="sxs-lookup"><span data-stu-id="3f675-355">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyAndAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyAndAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-356">Возвращает значение, которое указывает, описана ли доступность этого метода или конструктора в поле <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; другими словами, этот метод или конструктор может вызываться в производных классах, но только в том случае, если они находятся в той же сборке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-356">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-357">Значение <see langword="true" />, если доступность этого метода или конструктора точно описана в поле <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; в обратном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-357">
              <see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-358">Видимость метод или конструктор точно описываемого <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> Если модификатор видимости `protected private` в C++.</span><span class="sxs-lookup"><span data-stu-id="3f675-358">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> if the visibility modifier is `protected private` in C++.</span></span> <span data-ttu-id="3f675-359">Методы с этим уровнем доступности не может определяться в Visual Basic или C#.</span><span class="sxs-lookup"><span data-stu-id="3f675-359">Methods with this visibility cannot be defined in Visual Basic or C#.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f675-360">В следующем примере кода определяет методы, с различными уровнями видимость и отображает значения их <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, и <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> свойства.</span><span class="sxs-lookup"><span data-stu-id="3f675-360">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f675-361">Языки Visual Basic и C# не может определить методы с <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> видимости, что уровень доступа отображается только в примере C++.</span><span class="sxs-lookup"><span data-stu-id="3f675-361">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyOrAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyOrAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-362">Возвращает значение, которое указывает, описана ли потенциальная доступность этого метода или конструктора в поле <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; другими словами, этот метод или конструктор может вызываться в производных классах независимо от их расположения, а также в классах той же сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-362">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-363">Значение <see langword="true" />, если доступность этого метода или конструктора точно описана в поле <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; в обратном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-363">
              <see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-364">Если у элемента типа <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> видимости, он может вызываться из любого члена производного класса или любого члена в той же сборке, но не из любого другого типа.</span><span class="sxs-lookup"><span data-stu-id="3f675-364">If a type member has <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</span></span>  
  
 <span data-ttu-id="3f675-365">Фактически доступность метода ограничена доступностью его типа.</span><span class="sxs-lookup"><span data-stu-id="3f675-365">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="3f675-366"><xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> Свойство может быть `true` для метода, но если он является метод закрытого вложенного типа метода не отображается за пределами содержащего типа.</span><span class="sxs-lookup"><span data-stu-id="3f675-366">The <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="3f675-367">Видимость метод или конструктор точно описываемого <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> Если модификатор видимости `protected internal` в C# (`Protected Friend` в Visual Basic `protected public` в C++).</span><span class="sxs-lookup"><span data-stu-id="3f675-367">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> if the visibility modifier is `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f675-368">В следующем примере кода определяет методы, с различными уровнями видимость и отображает значения их <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, и <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> свойства.</span><span class="sxs-lookup"><span data-stu-id="3f675-368">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f675-369">Языки Visual Basic и C# не может определить методы с <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> видимости, что уровень доступа отображается только в примере C++.</span><span class="sxs-lookup"><span data-stu-id="3f675-369">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFinal">
      <MemberSignature Language="C#" Value="public bool IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFinal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinal { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-370">Возвращает значение, указывающее, является ли метод <see langword="final" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-370">Gets a value indicating whether this method is <see langword="final" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-371">
            <see langword="true" />, если этот метод имеет значение <see langword="final" />. В противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-371">
              <see langword="true" /> if this method is <see langword="final" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-372">Чтобы определить, если метод является переопределяемым, не достаточно, чтобы убедиться, что <xref:System.Reflection.MethodBase.IsVirtual%2A> — `true`.</span><span class="sxs-lookup"><span data-stu-id="3f675-372">To determine if a method is overridable, it is not sufficient to check that <xref:System.Reflection.MethodBase.IsVirtual%2A> is `true`.</span></span> <span data-ttu-id="3f675-373">Для метода для переопределения `IsVirtual` должно быть `true` и `IsFinal` должен быть `false`.</span><span class="sxs-lookup"><span data-stu-id="3f675-373">For a method to be overridable, `IsVirtual` must be `true` and `IsFinal` must be `false`.</span></span> <span data-ttu-id="3f675-374">Например может быть невиртуальный метод, но он реализует метод интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-374">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="3f675-375">Общеязыковая среда выполнения требует, чтобы все методы, которые реализуют члены интерфейса должен быть помечен как `virtual`; таким образом, компилятор отмечает метод `virtual final`.</span><span class="sxs-lookup"><span data-stu-id="3f675-375">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="3f675-376">Возможны случаи, когда метод, помеченный как `virtual` по-прежнему не является переопределяемым.</span><span class="sxs-lookup"><span data-stu-id="3f675-376">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="3f675-377">Чтобы однозначно установить, является ли метод переопределяемым, воспользуйтесь следующим кодом:</span><span class="sxs-lookup"><span data-stu-id="3f675-377">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
 `if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)`  
  
 <span data-ttu-id="3f675-378">Если `IsVirtual` — `false` или `IsFinal` — `true`, а затем метод не может быть переопределен.</span><span class="sxs-lookup"><span data-stu-id="3f675-378">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f675-379">В следующем примере отображается `false` для `IsFinal`, что могло что MyMethod является переопределяемым.</span><span class="sxs-lookup"><span data-stu-id="3f675-379">The following example displays `false` for `IsFinal`, which might lead you to think that MyMethod is overridable.</span></span> <span data-ttu-id="3f675-380">Код печатает `false` несмотря на то, что не помечен как MyMethod `virtual` и поэтому не может быть переопределен.</span><span class="sxs-lookup"><span data-stu-id="3f675-380">The code prints `false` even though MyMethod is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-381">Возвращает значение, указывающее, является ли этот метод универсальным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-381">Gets a value indicating whether the method is generic.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-382">Значение <see langword="true" />, если текущий объект <see cref="T:System.Reflection.MethodBase" /> представляет универсальный метод; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-382">
              <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> represents a generic method; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-383">Используйте <xref:System.Reflection.MethodBase.IsGenericMethod%2A> свойства, чтобы определить ли текущий <xref:System.Reflection.MethodBase> объект представляет универсальный метод.</span><span class="sxs-lookup"><span data-stu-id="3f675-383">Use the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents a generic method.</span></span> <span data-ttu-id="3f675-384">Используйте <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> свойства, чтобы определить ли текущий <xref:System.Reflection.MethodBase> представляет открытым сконструированным методом или закрытым сконструированным методом.</span><span class="sxs-lookup"><span data-stu-id="3f675-384">Use the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents an open constructed method or a closed constructed method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f675-385">Универсальные шаблоны не поддерживаются по умолчанию. Это свойство возвращает `false` Если не переопределен в производном классе.</span><span class="sxs-lookup"><span data-stu-id="3f675-385">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="3f675-386">Универсальные конструкторы не поддерживаются в платформе .NET Framework версии 2.0, поэтому это свойство возвращает `false` текущего экземпляра имеет тип <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="3f675-386">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
<span data-ttu-id="3f675-387">В следующей таблице перечислены неизменяемых условий для конкретных универсальных методов.</span><span class="sxs-lookup"><span data-stu-id="3f675-387">The following table summarizes the invariant conditions for terms specific to generic methods.</span></span> <span data-ttu-id="3f675-388">Другие условия, используемые в отражении универсальных объектов, такие как *параметр универсального типа* и *универсального типа*, в разделе <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> свойство.</span><span class="sxs-lookup"><span data-stu-id="3f675-388">For other terms used in generic reflection, such as *generic type parameter* and *generic type*, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>   

|<span data-ttu-id="3f675-389">Термин</span><span class="sxs-lookup"><span data-stu-id="3f675-389">Term</span></span>|<span data-ttu-id="3f675-390">Инвариантное условие</span><span class="sxs-lookup"><span data-stu-id="3f675-390">Invariant condition</span></span>| 
|---|---| 
|<span data-ttu-id="3f675-391">Определение универсального метода.</span><span class="sxs-lookup"><span data-stu-id="3f675-391">generic method definition</span></span>| <span data-ttu-id="3f675-392">Значение свойства <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> — `true`.</span><span class="sxs-lookup"><span data-stu-id="3f675-392">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> property is `true`.</span></span> <br /><span data-ttu-id="3f675-393">Определяет универсальный метод.</span><span class="sxs-lookup"><span data-stu-id="3f675-393">Defines a generic method.</span></span> <span data-ttu-id="3f675-394">Сконструированный метод создается путем вызова <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> метод <xref:System.Reflection.MethodInfo> объект, представляющий определение универсального метода и указав массив аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="3f675-394">A constructed method is created by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method on a <xref:System.Reflection.MethodInfo> object that represents a generic method definition, and specifying an array of type arguments.</span></span> <br /><span data-ttu-id="3f675-395"><xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> Метод может вызываться только для определения универсального метода.</span><span class="sxs-lookup"><span data-stu-id="3f675-395">The <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method can be called only on generic method definitions.</span></span> <br/><span data-ttu-id="3f675-396">Любое определение универсального метода является универсальным методом, но обратное неверно.</span><span class="sxs-lookup"><span data-stu-id="3f675-396">Any generic method definition is a generic method, but the converse is not true.</span></span>|    
|<span data-ttu-id="3f675-397">универсальный метод</span><span class="sxs-lookup"><span data-stu-id="3f675-397">generic method</span></span>|<span data-ttu-id="3f675-398">Значение свойства `IsGenericMethod` — `true`.</span><span class="sxs-lookup"><span data-stu-id="3f675-398">The `IsGenericMethod` property is `true`.</span></span> <br/> <span data-ttu-id="3f675-399">Может быть определением универсального метода, открытым сконструированным методом или закрытым сконструированным методом.</span><span class="sxs-lookup"><span data-stu-id="3f675-399">Can be a generic method definition, an open constructed method, or a closed constructed method.</span></span>| 
|<span data-ttu-id="3f675-400">сконструированный метод Open</span><span class="sxs-lookup"><span data-stu-id="3f675-400">open constructed method</span></span>|<span data-ttu-id="3f675-401">Значение свойства <xref:System.Reflection.MethodBase.ContainsGenericParameters> — `true`.</span><span class="sxs-lookup"><span data-stu-id="3f675-401">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `true`.</span></span> <br/><span data-ttu-id="3f675-402">Не поддерживается для вызова открытым сконструированным методом.</span><span class="sxs-lookup"><span data-stu-id="3f675-402">It is not possible to invoke an open constructed method.</span></span>|  
|<span data-ttu-id="3f675-403">закрытый сконструированный метод</span><span class="sxs-lookup"><span data-stu-id="3f675-403">closed constructed method</span></span>|<span data-ttu-id="3f675-404">Значение свойства <xref:System.Reflection.MethodBase.ContainsGenericParameters> — `false`.</span><span class="sxs-lookup"><span data-stu-id="3f675-404">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `false`.</span></span> <br/><span data-ttu-id="3f675-405">При рекурсивном метод не имеет неназначенные универсальных параметров.</span><span class="sxs-lookup"><span data-stu-id="3f675-405">When examined recursively, the method has no unassigned generic parameters.</span></span> <span data-ttu-id="3f675-406">Содержащий тип не имеет универсальных параметров типа, и ни один из аргументов типа не имеет параметров универсального типа.</span><span class="sxs-lookup"><span data-stu-id="3f675-406">The containing type has no generic type parameters, and none of the type arguments have generic type parameters.</span></span> <br/><span data-ttu-id="3f675-407">Метод может быть вызван.</span><span class="sxs-lookup"><span data-stu-id="3f675-407">The method can be invoked.</span></span>|   

 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-408">Возвращает значение, указывающее, является ли этот метод определением универсального метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-408">Gets a value indicating whether the method is a generic method definition.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-409">Значение <see langword="true" />, если текущий объект <see cref="T:System.Reflection.MethodBase" /> представляет определение универсального метода; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-409">
              <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-410">Если текущий <xref:System.Reflection.MethodBase> представляет определение универсального метода, затем:</span><span class="sxs-lookup"><span data-stu-id="3f675-410">If the current <xref:System.Reflection.MethodBase> represents a generic method definition, then:</span></span>  
  
-   <span data-ttu-id="3f675-411">Значение свойства <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> — `true`.</span><span class="sxs-lookup"><span data-stu-id="3f675-411">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property is `true`.</span></span>  
  
-   <span data-ttu-id="3f675-412">Для каждого <xref:System.Type> объект в массиве, возвращенном <xref:System.Reflection.MethodBase.GetGenericArguments%2A> метод:</span><span class="sxs-lookup"><span data-stu-id="3f675-412">For each <xref:System.Type> object in the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method:</span></span>  
  
    -   <span data-ttu-id="3f675-413">Значение свойства <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> — `true`.</span><span class="sxs-lookup"><span data-stu-id="3f675-413">The <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> property is `true`.</span></span>  
  
    -   <span data-ttu-id="3f675-414"><xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> Свойство возвращает текущий экземпляр.</span><span class="sxs-lookup"><span data-stu-id="3f675-414">The <xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> property returns the current instance.</span></span>  
  
    -   <span data-ttu-id="3f675-415"><xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> Имеет то же, как позицию <xref:System.Type> объект в массиве.</span><span class="sxs-lookup"><span data-stu-id="3f675-415">The <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> property is the same as the position of the <xref:System.Type> object in the array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f675-416">Универсальные шаблоны не поддерживаются по умолчанию. Это свойство возвращает `false` Если не переопределен в производном классе.</span><span class="sxs-lookup"><span data-stu-id="3f675-416">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="3f675-417">Универсальные конструкторы не поддерживаются в платформе .NET Framework версии 2.0, поэтому это свойство возвращает `false` текущего экземпляра имеет тип <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="3f675-417">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="3f675-418">Список неизменяемых условий для конкретных универсальных методов см. в разделе <xref:System.Reflection.MethodBase.IsGenericMethod%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="3f675-418">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="3f675-419">Список неизменяемых условий для других терминов, используемых в универсальном отражении см. в разделе <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> свойство.</span><span class="sxs-lookup"><span data-stu-id="3f675-419">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsHideBySig">
      <MemberSignature Language="C#" Value="public bool IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsHideBySig" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHideBySig As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHideBySig { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-420">Возвращает значение, указывающее, скрывается ли в производном классе только член такого же вида с точно такой же сигнатурой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-420">Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-421">Значение <see langword="true" />, если член скрыт на основе сигнатуры; в обратном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-421">
              <see langword="true" /> if the member is hidden by signature; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-422">Если член в производном классе объявлена с помощью C# `new` модификатор или Visual Basic `Shadows` модификатор, его можно скрыть член с тем же именем в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="3f675-422">When a member in a derived class is declared with the C# `new` modifier or the Visual Basic `Shadows` modifier, it can hide a member of the same name in the base class.</span></span> <span data-ttu-id="3f675-423">C# скрывает члены базового класса на основе подписи.</span><span class="sxs-lookup"><span data-stu-id="3f675-423">C# hides base class members by signature.</span></span> <span data-ttu-id="3f675-424">Если член базового класса существует несколько перегруженных версий, единственный, который является скрытым является один с идентичную сигнатуру.</span><span class="sxs-lookup"><span data-stu-id="3f675-424">That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature.</span></span> <span data-ttu-id="3f675-425">В отличие от этого Visual Basic скрывает все перегруженные версии базового класса.</span><span class="sxs-lookup"><span data-stu-id="3f675-425">By contrast, Visual Basic hides all the base class overloads.</span></span> <span data-ttu-id="3f675-426">Таким образом <xref:System.Reflection.MethodBase.IsHideBySig%2A> возвращает `false` на элемент, объявленный с помощью Visual Basic `Shadows` модификатор, и `true` на элемент, объявленный с помощью C# `new` модификатор.</span><span class="sxs-lookup"><span data-stu-id="3f675-426">Thus, <xref:System.Reflection.MethodBase.IsHideBySig%2A> returns `false` on a member declared with the Visual Basic `Shadows` modifier, and `true` on a member declared with the C# `new` modifier.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="3f675-427">Это свойство определяет, есть ли метод <xref:System.Reflection.MethodAttributes.NewSlot> атрибута.</span><span class="sxs-lookup"><span data-stu-id="3f675-427">This property does not determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute.</span></span> <span data-ttu-id="3f675-428">Метод, объявленный с помощью `new` или `Shadows` будет иметь модификатор <xref:System.Reflection.MethodAttributes.NewSlot> атрибут, но только методы, объявленные с `new` (то есть только методы C#) будет иметь <xref:System.Reflection.MethodBase.IsHideBySig%2A> свойства `true`.</span><span class="sxs-lookup"><span data-stu-id="3f675-428">A method that is declared with either the `new` or the `Shadows` modifier will have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, but only methods declared with `new` (that is, only C# methods) will have the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property set to `true`.</span></span>  <span data-ttu-id="3f675-429">Чтобы определить, является ли метод <xref:System.Reflection.MethodAttributes.NewSlot> атрибут, используйте код, аналогичный следующему: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` в C# или `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="3f675-429">To determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, use code similar to the following: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` in C# or `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` in Visual Basic.</span></span> <span data-ttu-id="3f675-430">Тем не менее, несмотря на то, что все методы объявлены с `new` или `Shadows` имеют <xref:System.Reflection.MethodAttributes.NewSlot> атрибут, не все методы, которые имеют <xref:System.Reflection.MethodAttributes.NewSlot> атрибута должны быть объявлены с `new` или `Shadows`.</span><span class="sxs-lookup"><span data-stu-id="3f675-430">Note, however, that although all methods declared with `new` or `Shadows` have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, not all methods that have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute are declared with `new` or `Shadows`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f675-431">В следующем примере кода содержит базовый класс с перегруженным методом и производный класс, который скрывает одну из перегрузок.</span><span class="sxs-lookup"><span data-stu-id="3f675-431">The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads.</span></span> <span data-ttu-id="3f675-432">В версии Visual Basic в примере кода <xref:System.Reflection.MethodBase.IsHideBySig%2A> возвращает `false` для члена в производном классе.</span><span class="sxs-lookup"><span data-stu-id="3f675-432">In the Visual Basic version of the code example, the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property returns `false` for the member in the derived class.</span></span> <span data-ttu-id="3f675-433">В C# версии образца кода, это свойство возвращает `true` для члена в производном классе.</span><span class="sxs-lookup"><span data-stu-id="3f675-433">In the C# version of the code sample, the property returns `true` for the member in the derived class.</span></span>  
  
 [!code-cpp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/cpp/hide.cpp#1)]
 [!code-csharp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/CS/hide.cs#1)]
 [!code-vb[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/VB/hide.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-434">Возвращает значение, указывающее, является ли этот член закрытым.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-434">Gets a value indicating whether this member is private.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-435">Значение <see langword="true" />, если доступ к этому методу разрешен только элементам данного класса, в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-435">
              <see langword="true" /> if access to this method is restricted to other members of the class itself; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-436">Если у элемента типа `Private` видимость на уровне, может вызываться из любого члена класса, но не других.</span><span class="sxs-lookup"><span data-stu-id="3f675-436">If a type member has `Private` level visibility, it can be called from any member in the same class and no others.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-437">Возвращает значение, указывающее, является ли метод открытым.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-437">Gets a value indicating whether this is a public method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-438">Значение <see langword="true" />, если метод является открытым; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-438">
              <see langword="true" /> if this method is public; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-439">Для получения <xref:System.Reflection.MethodBase>, сначала нужно получить тип.</span><span class="sxs-lookup"><span data-stu-id="3f675-439">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="3f675-440">Из типа которого вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="3f675-440">From the type, get the method.</span></span> <span data-ttu-id="3f675-441">С помощью метода get `MethodBase`.</span><span class="sxs-lookup"><span data-stu-id="3f675-441">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="3f675-442">Если `MethodBase` или конструктор не являются открытыми, они защищены и не может быть непосредственно доступны.</span><span class="sxs-lookup"><span data-stu-id="3f675-442">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="3f675-443">Для обращения к методу, не являющиеся открытыми, установите <xref:System.Reflection.BindingFlags> для маски `NonPublic` в `GetMethod`.</span><span class="sxs-lookup"><span data-stu-id="3f675-443">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f675-444">В следующем примере используется <xref:System.Reflection.MethodBase.IsPublic%2A> свойство для отображения сообщение, указывающее, является ли указанный метод открытым.</span><span class="sxs-lookup"><span data-stu-id="3f675-444">The following example uses the <xref:System.Reflection.MethodBase.IsPublic%2A> property to display a message that indicates whether the specified method is public.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-445">Получает значение, которое указывает, является ли текущий метод или конструктор критически важным для безопасности или защищенным критически важным для безопасности на данном уровне доверия и, следовательно, может ли он выполнять критические операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-445">Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-446">Значение <see langword="true" />, если текущий метод или конструктор является критически важным для безопасности или защищенным критически важным для безопасности на текущем уровне доверия; значение <see langword="false" />, если он является прозрачным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-446">
              <see langword="true" /> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-447"><xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, И <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> свойства отчетов уровень прозрачности метод или конструктор в его текущем уровне доверия, что определяется общеязыковой среды выполнения (CLR).</span><span class="sxs-lookup"><span data-stu-id="3f675-447">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="3f675-448">В следующей таблице показаны сочетания этих свойств.</span><span class="sxs-lookup"><span data-stu-id="3f675-448">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="3f675-449">Уровень безопасности</span><span class="sxs-lookup"><span data-stu-id="3f675-449">Security level</span></span>|<span data-ttu-id="3f675-450">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="3f675-450">IsSecurityCritical</span></span>|<span data-ttu-id="3f675-451">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="3f675-451">IsSecuritySafeCritical</span></span>|<span data-ttu-id="3f675-452">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="3f675-452">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="3f675-453">Critical</span><span class="sxs-lookup"><span data-stu-id="3f675-453">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="3f675-454">Надежным с точки зрения</span><span class="sxs-lookup"><span data-stu-id="3f675-454">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="3f675-455">Прозрачный</span><span class="sxs-lookup"><span data-stu-id="3f675-455">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="3f675-456">Использовать эти свойства гораздо проще, чем просматривать заметки безопасности сборки и ее типов и членов, проверять текущий уровень доверия и пытаться Дублировать правила среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="3f675-456">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3f675-457">Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки.</span><span class="sxs-lookup"><span data-stu-id="3f675-457">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="3f675-458">Если сборка загружается в домен приложения с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки.</span><span class="sxs-lookup"><span data-stu-id="3f675-458">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="3f675-459">Сборка и все типы считаются прозрачными.</span><span class="sxs-lookup"><span data-stu-id="3f675-459">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="3f675-460">Среда выполнения уделяет внимание заметки безопасности сборки с частичным доверием, только в том случае, если эта сборка загружается в домен приложения с полным доверием (например, в домене приложения по умолчанию для настольного приложения).</span><span class="sxs-lookup"><span data-stu-id="3f675-460">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="3f675-461">В отличие от этого доверенной сборке (то есть сборки строгим именем, установленной в глобальном кэше сборок) всегда является загружена с полным доверием независимо от уровня доверия домена приложения, поэтому ее текущий уровень доверия всегда является полностью доверенным.</span><span class="sxs-lookup"><span data-stu-id="3f675-461">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="3f675-462">Можно определить текущие уровни доверия сборок и доменов приложений с помощью <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> и <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> свойства.</span><span class="sxs-lookup"><span data-stu-id="3f675-462">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="3f675-463">Дополнительные сведения о отражение и прозрачность см. в разделе [рекомендации по безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="3f675-463">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="3f675-464">Сведения о прозрачности см. в разделе [изменения системы безопасности](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="3f675-464">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-465">Получает значение, которое указывает, является ли текущий динамический метод или конструктор защищенным критически важным для безопасности и, следовательно, может ли он выполнять критические операции и предоставлять доступ прозрачному коду.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-465">Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-466">Значение <see langword="true" />, если текущий метод или конструктор является защищенным критически важным для безопасности на текущем уровне доверия; значение <see langword="false" />, если он является критически важным для безопасности или прозрачным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-466">
              <see langword="true" /> if the method or constructor is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-467"><xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, И <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> свойства отчетов уровень прозрачности метод или конструктор в его текущем уровне доверия, что определяется общеязыковой среды выполнения (CLR).</span><span class="sxs-lookup"><span data-stu-id="3f675-467">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="3f675-468">В следующей таблице показаны сочетания этих свойств.</span><span class="sxs-lookup"><span data-stu-id="3f675-468">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="3f675-469">Уровень безопасности</span><span class="sxs-lookup"><span data-stu-id="3f675-469">Security level</span></span>|<span data-ttu-id="3f675-470">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="3f675-470">IsSecurityCritical</span></span>|<span data-ttu-id="3f675-471">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="3f675-471">IsSecuritySafeCritical</span></span>|<span data-ttu-id="3f675-472">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="3f675-472">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="3f675-473">Critical</span><span class="sxs-lookup"><span data-stu-id="3f675-473">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="3f675-474">Надежным с точки зрения</span><span class="sxs-lookup"><span data-stu-id="3f675-474">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="3f675-475">Прозрачный</span><span class="sxs-lookup"><span data-stu-id="3f675-475">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="3f675-476">Использовать эти свойства гораздо проще, чем просматривать заметки безопасности сборки и ее типов и членов, проверять текущий уровень доверия и пытаться Дублировать правила среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="3f675-476">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3f675-477">Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки.</span><span class="sxs-lookup"><span data-stu-id="3f675-477">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="3f675-478">Если сборка загружается в домен приложения с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки.</span><span class="sxs-lookup"><span data-stu-id="3f675-478">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="3f675-479">Сборка и все типы считаются прозрачными.</span><span class="sxs-lookup"><span data-stu-id="3f675-479">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="3f675-480">Среда выполнения уделяет внимание заметки безопасности сборки с частичным доверием, только в том случае, если эта сборка загружается в домен приложения с полным доверием (например, в домене приложения по умолчанию для настольного приложения).</span><span class="sxs-lookup"><span data-stu-id="3f675-480">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="3f675-481">В отличие от этого доверенной сборке (то есть сборки строгим именем, установленной в глобальном кэше сборок) всегда является загружена с полным доверием независимо от уровня доверия домена приложения, поэтому ее текущий уровень доверия всегда является полностью доверенным.</span><span class="sxs-lookup"><span data-stu-id="3f675-481">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="3f675-482">Можно определить текущие уровни доверия сборок и доменов приложений с помощью <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> и <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> свойства.</span><span class="sxs-lookup"><span data-stu-id="3f675-482">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="3f675-483">Дополнительные сведения о отражение и прозрачность см. в разделе [рекомендации по безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="3f675-483">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="3f675-484">Сведения о прозрачности см. в разделе [изменения системы безопасности](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="3f675-484">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-485">Получает значение, которое указывает, является ли текущий метод или конструктор прозрачным на текущем уровне доверия и, следовательно, не может выполнять критические операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-485">Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-486">Значение <see langword="true" />, если метод или конструктор является прозрачным на текущем уровне доверия; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-486">
              <see langword="true" /> if the method or constructor is security-transparent at the current trust level; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-487">Если это свойство возвращает `true`, <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> и <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> возвращаемого свойства `false`.</span><span class="sxs-lookup"><span data-stu-id="3f675-487">If this property returns `true`, the <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> and <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="3f675-488"><xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, И <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> свойства отчетов уровень прозрачности метод или конструктор в его текущем уровне доверия, что определяется общеязыковой среды выполнения (CLR).</span><span class="sxs-lookup"><span data-stu-id="3f675-488">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="3f675-489">Использовать эти свойства гораздо проще, чем просматривать заметки безопасности сборки и ее типов и членов, проверять текущий уровень доверия и пытаться Дублировать правила среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="3f675-489">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3f675-490">Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки.</span><span class="sxs-lookup"><span data-stu-id="3f675-490">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="3f675-491">Если сборка загружается в домен приложения с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки.</span><span class="sxs-lookup"><span data-stu-id="3f675-491">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="3f675-492">Сборка и все типы считаются прозрачными.</span><span class="sxs-lookup"><span data-stu-id="3f675-492">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="3f675-493">Среда выполнения уделяет внимание заметки безопасности сборки с частичным доверием, только в том случае, если эта сборка загружается в домен приложения с полным доверием (например, в домене приложения по умолчанию для настольного приложения).</span><span class="sxs-lookup"><span data-stu-id="3f675-493">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="3f675-494">В отличие от этого доверенной сборке (то есть сборки строгим именем, установленной в глобальном кэше сборок) всегда является загружена с полным доверием независимо от уровня доверия домена приложения, поэтому ее текущий уровень доверия всегда является полностью доверенным.</span><span class="sxs-lookup"><span data-stu-id="3f675-494">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="3f675-495">Можно определить текущие уровни доверия сборок и доменов приложений с помощью <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> и <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> свойства.</span><span class="sxs-lookup"><span data-stu-id="3f675-495">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="3f675-496">Дополнительные сведения о отражение и прозрачность см. в разделе [рекомендации по безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="3f675-496">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="3f675-497">Сведения о прозрачности см. в разделе [изменения системы безопасности](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="3f675-497">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-498">Возвращает значение, указывающее, имеет ли этот метод специальное имя.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-498">Gets a value indicating whether this method has a special name.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-499">Значение <see langword="true" />, если у этого метода имеется специальное имя; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-499">
              <see langword="true" /> if this method has a special name; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-500"><xref:System.Reflection.MethodAttributes.SpecialName> Бит равен отметить члены, которые обрабатываются особым образом, в некоторых компиляторах (например, к свойствам и методы перегрузки операторов).</span><span class="sxs-lookup"><span data-stu-id="3f675-500">The <xref:System.Reflection.MethodAttributes.SpecialName> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f675-501">В этом примере показано использование <xref:System.Reflection.MethodBase.IsSpecialName%2A> исключить внутренние и закрытые члены из списка.</span><span class="sxs-lookup"><span data-stu-id="3f675-501">This example shows a use of <xref:System.Reflection.MethodBase.IsSpecialName%2A> to filter internal or private members out of a list.</span></span>  
  
 [!code-cpp[Classic Type.IsSpecialName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsSpecialName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsSpecialName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-502">Получает значение, указывающее, имеет ли метод значение <see langword="static" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-502">Gets a value indicating whether the method is <see langword="static" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-503">
            <see langword="true" />, если этот метод имеет значение <see langword="static" />. В противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-503">
              <see langword="true" /> if this method is <see langword="static" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-504">Статический член не может неявно обращаться к данным экземпляра в классе.</span><span class="sxs-lookup"><span data-stu-id="3f675-504">A static member cannot implicitly reference instance data in a class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsVirtual">
      <MemberSignature Language="C#" Value="public bool IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsVirtual" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVirtual As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVirtual { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-505">Получает значение, указывающее, имеет ли метод значение <see langword="virtual" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-505">Gets a value indicating whether the method is <see langword="virtual" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-506">
            <see langword="true" />, если этот метод имеет значение <see langword="virtual" />. В противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-506">
              <see langword="true" /> if this method is <see langword="virtual" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-507">Виртуальный член может обращаться к данным экземпляра в классе и должна быть ссылка через экземпляр класса.</span><span class="sxs-lookup"><span data-stu-id="3f675-507">A virtual member may reference instance data in a class and must be referenced through an instance of the class.</span></span>  
  
 <span data-ttu-id="3f675-508">Чтобы определить, если метод является переопределяемым, не достаточно, чтобы убедиться, что `IsVirtual` — `true`.</span><span class="sxs-lookup"><span data-stu-id="3f675-508">To determine if a method is overridable, it is not sufficient to check that `IsVirtual` is `true`.</span></span> <span data-ttu-id="3f675-509">Для метода для переопределения `IsVirtual` должно быть `true` и <xref:System.Reflection.MethodBase.IsFinal%2A> должен быть `false`.</span><span class="sxs-lookup"><span data-stu-id="3f675-509">For a method to be overridable, `IsVirtual` must be `true` and <xref:System.Reflection.MethodBase.IsFinal%2A> must be `false`.</span></span> <span data-ttu-id="3f675-510">Например может быть невиртуальный метод, но он реализует метод интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-510">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="3f675-511">Общеязыковая среда выполнения требует, чтобы все методы, которые реализуют члены интерфейса должен быть помечен как `virtual`; таким образом, компилятор отмечает метод `virtual final`.</span><span class="sxs-lookup"><span data-stu-id="3f675-511">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="3f675-512">Возможны случаи, когда метод, помеченный как `virtual` по-прежнему не является переопределяемым.</span><span class="sxs-lookup"><span data-stu-id="3f675-512">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="3f675-513">Чтобы однозначно установить, является ли метод переопределяемым, воспользуйтесь следующим кодом:</span><span class="sxs-lookup"><span data-stu-id="3f675-513">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
```csharp  
if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)  
```  
  
```vb  
If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then  
```  
  
 <span data-ttu-id="3f675-514">Если `IsVirtual` — `false` или `IsFinal` — `true`, а затем метод не может быть переопределен.</span><span class="sxs-lookup"><span data-stu-id="3f675-514">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
 <span data-ttu-id="3f675-515">Можно определить, является ли текущий метод переопределяет метод в базовом классе путем вызова <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="3f675-515">You can determine whether the current method overrides a method in a base class by calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3f675-516">В следующем примере реализуется `IsOverride` метод, который делает это.</span><span class="sxs-lookup"><span data-stu-id="3f675-516">The following example implements an `IsOverride` method that does this.</span></span>  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="3f675-517">В следующем примере отображается `false` для `IsFinal`, что могло показаться, что `MyMethod` является переопределяемым.</span><span class="sxs-lookup"><span data-stu-id="3f675-517">The following example displays `false` for `IsFinal`, which might lead you to think that `MyMethod` is overridable.</span></span> <span data-ttu-id="3f675-518">Код печатает `false` несмотря на то что `MyMethod` не помечен как `virtual` и поэтому не может быть переопределен.</span><span class="sxs-lookup"><span data-stu-id="3f675-518">The code prints `false` even though `MyMethod` is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.MethodHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-519">Возвращает дескриптор представления внутренних метаданных метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-519">Gets a handle to the internal metadata representation of a method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-520">Объект <see cref="T:System.RuntimeMethodHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-520">A <see cref="T:System.RuntimeMethodHandle" /> object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-521">Дескрипторы доступны только в домене приложения, в котором они были получены.</span><span class="sxs-lookup"><span data-stu-id="3f675-521">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-522">Получает флаги <see cref="T:System.Reflection.MethodImplAttributes" />, указывающие атрибуты реализации методы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-522">Gets the <see cref="T:System.Reflection.MethodImplAttributes" /> flags that specify the attributes of a method implementation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-523">Флаги реализации метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-523">The method implementation flags.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-524">Дополнительные сведения см. в описании метода <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A>.</span><span class="sxs-lookup"><span data-stu-id="3f675-524">See the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method for more information.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3f675-525">Первый из сравниваемых объектов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-525">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3f675-526">Второй из сравниваемых объектов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-526">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3f675-527">Определение равенства двух объектов <see cref="T:System.Reflection.MethodBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-527">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3f675-528">
            <see langword="true" />, если значения параметров <paramref name="left" /> и <paramref name="right" /> равны; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-528">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3f675-529">Первый из сравниваемых объектов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-529">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3f675-530">Второй из сравниваемых объектов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-530">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3f675-531">Определяет неравенство двух объектов <see cref="T:System.Reflection.MethodBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-531">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3f675-532">
            <see langword="true" />, если значения <paramref name="left" /> и <paramref name="right" /> не равны; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-532">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBase.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBase.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBase::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="3f675-533">Зарезервировано для будущего использования.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-533">Reserved for future use.</span>
          </span>
          <span data-ttu-id="3f675-534">Должно быть равным IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-534">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="3f675-535">Переданный массив имен, которые необходимо сопоставить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-535">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="3f675-536">Количество сопоставляемых имен.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-536">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="3f675-537">Контекст языкового стандарта для интерпретации имен.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-537">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="3f675-538">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-538">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3f675-539">Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-539">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-540">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="3f675-540">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3f675-541">Дополнительные сведения о `IDispatch::GetIDsOfNames`, см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="3f675-541">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="3f675-542">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-542">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetType">
      <MemberSignature Language="C#" Value="Type _MethodBase.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodBase.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodBase.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodBase.GetType() = System::Runtime::InteropServices::_MethodBase::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3f675-543">Описание этого члена см. в разделе <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-543">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3f675-544">Описание этого члена см. в разделе <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-544">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-545">Этот член представляет собой явную реализацию члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-545">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3f675-546">Он может использоваться, только если экземпляр <xref:System.Reflection.MethodBase> приведен к типу интерфейса <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="3f675-546">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBase.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="3f675-547">Возвращаемые сведения о типе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-547">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="3f675-548">Идентификатор языкового стандарта для сведений о типе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-548">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="3f675-549">Получает указатель на объект с запрошенными сведениями о типе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-549">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3f675-550">Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-550">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-551">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="3f675-551">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3f675-552">Дополнительные сведения о `IDispatch::GetTypeInfo`, см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="3f675-552">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="3f675-553">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-553">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBase.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="3f675-554">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-554">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3f675-555">Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-555">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-556">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="3f675-556">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3f675-557">Дополнительные сведения о `IDispatch::GetTypeInfoCount`, см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="3f675-557">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="3f675-558">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-558">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBase.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBase.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBase::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="3f675-559">Идентифицирует член.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-559">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="3f675-560">Зарезервировано для будущего использования.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-560">Reserved for future use.</span>
          </span>
          <span data-ttu-id="3f675-561">Должно быть равным IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-561">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="3f675-562">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-562">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="3f675-563">Флаги, описывающие контекст вызова.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-563">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="3f675-564">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-564">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="3f675-565">Указатель, по которому будет сохранен результат.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-565">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="3f675-566">Указатель на структуру, содержащую сведения об исключении.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-566">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="3f675-567">Индекс первого аргумента, вызвавшего ошибку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-567">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3f675-568">Предоставляет доступ к открытым свойствам и методам объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-568">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-569">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="3f675-569">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3f675-570">Дополнительные сведения о `IDispatch::Invoke`, см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="3f675-570">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="3f675-571">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-571">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAbstract">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAbstract As Boolean Implements _MethodBase.IsAbstract" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-572">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-572">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-573">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-573">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-574">Этот член представляет собой явную реализацию члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-574">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3f675-575">Он может использоваться, только если экземпляр <xref:System.Reflection.MethodBase> приведен к типу интерфейса <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="3f675-575">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAssembly As Boolean Implements _MethodBase.IsAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-576">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-576">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-577">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-577">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-578">Этот член представляет собой явную реализацию члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-578">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3f675-579">Он может использоваться, только если экземпляр <xref:System.Reflection.MethodBase> приведен к типу интерфейса <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="3f675-579">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsConstructor">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsConstructor As Boolean Implements _MethodBase.IsConstructor" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsConstructor { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-580">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-580">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-581">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-581">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-582">Этот член представляет собой явную реализацию члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-582">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3f675-583">Он может использоваться, только если экземпляр <xref:System.Reflection.MethodBase> приведен к типу интерфейса <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="3f675-583">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamily">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamily As Boolean Implements _MethodBase.IsFamily" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-584">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-584">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-585">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-585">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-586">Этот член представляет собой явную реализацию члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-586">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3f675-587">Он может использоваться, только если экземпляр <xref:System.Reflection.MethodBase> приведен к типу интерфейса <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="3f675-587">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyAndAssembly As Boolean Implements _MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-588">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-588">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-589">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-589">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-590">Этот член представляет собой явную реализацию члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-590">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3f675-591">Он может использоваться, только если экземпляр <xref:System.Reflection.MethodBase> приведен к типу интерфейса <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="3f675-591">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyOrAssembly As Boolean Implements _MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-592">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-592">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-593">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-593">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-594">Этот член представляет собой явную реализацию члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-594">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3f675-595">Он может использоваться, только если экземпляр <xref:System.Reflection.MethodBase> приведен к типу интерфейса <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="3f675-595">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFinal">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFinal As Boolean Implements _MethodBase.IsFinal" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFinal { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-596">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-596">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-597">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-597">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-598">Этот член представляет собой явную реализацию члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-598">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3f675-599">Он может использоваться, только если экземпляр <xref:System.Reflection.MethodBase> приведен к типу интерфейса <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="3f675-599">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsHideBySig">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsHideBySig As Boolean Implements _MethodBase.IsHideBySig" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsHideBySig { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-600">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-600">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-601">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-601">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-602">Этот член представляет собой явную реализацию члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-602">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3f675-603">Он может использоваться, только если экземпляр <xref:System.Reflection.MethodBase> приведен к типу интерфейса <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="3f675-603">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPrivate">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPrivate As Boolean Implements _MethodBase.IsPrivate" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-604">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-604">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-605">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-605">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-606">Этот член представляет собой явную реализацию члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-606">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3f675-607">Он может использоваться, только если экземпляр <xref:System.Reflection.MethodBase> приведен к типу интерфейса <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="3f675-607">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPublic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPublic As Boolean Implements _MethodBase.IsPublic" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-608">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-608">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-609">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-609">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-610">Этот член представляет собой явную реализацию члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-610">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3f675-611">Он может использоваться, только если экземпляр <xref:System.Reflection.MethodBase> приведен к типу интерфейса <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="3f675-611">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsSpecialName">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSpecialName As Boolean Implements _MethodBase.IsSpecialName" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-612">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-612">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-613">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-613">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-614">Этот член представляет собой явную реализацию члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-614">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3f675-615">Он может использоваться, только если экземпляр <xref:System.Reflection.MethodBase> приведен к типу интерфейса <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="3f675-615">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsStatic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsStatic As Boolean Implements _MethodBase.IsStatic" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-616">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-616">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-617">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-617">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-618">Этот член представляет собой явную реализацию члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-618">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3f675-619">Он может использоваться, только если экземпляр <xref:System.Reflection.MethodBase> приведен к типу интерфейса <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="3f675-619">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsVirtual">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsVirtual As Boolean Implements _MethodBase.IsVirtual" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsVirtual { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f675-620">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-620">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f675-621">Описание этого члена см. в разделе <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f675-621">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f675-622">Этот член представляет собой явную реализацию члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="3f675-622">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3f675-623">Он может использоваться, только если экземпляр <xref:System.Reflection.MethodBase> приведен к типу интерфейса <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="3f675-623">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>