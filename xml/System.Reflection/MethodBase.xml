<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MethodBase.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac55a27c711459e7ed675df80d23d28b658e1d7b113.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5a27c711459e7ed675df80d23d28b658e1d7b113</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodBase">
          <source>Provides information about methods and constructors.</source>
          <target state="translated">Предоставляет сведения о методах и конструкторах.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source><ph id="ph1">`MethodBase`</ph> is the base class of <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`MethodBase`</ph> является базовым классом для <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> и <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>for full trust for inheritors.</source>
          <target state="translated">для полного доверия для разработчиков производных классов.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">Этот класс не наследуется частично доверенным кодом.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>This type is thread safe.</source>
          <target state="translated">Данный тип потокобезопасен.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>When you inherit from <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>, you must override the following members: <ph id="ph2">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph5">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph6">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph9">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph11">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph>, <ph id="ph12">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, and <ph id="ph13">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</source>
          <target state="translated">При наследовании от <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>, необходимо переопределить следующие члены: <ph id="ph2">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph5">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph6">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph9">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph11">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> , <ph id="ph12">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, и <ph id="ph13">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.#ctor">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">При вызове поздней привязкой, такие как <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.#ctor">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Gets the attributes associated with this method.</source>
          <target state="translated">Возвращает атрибуты, сопоставленные этому методу.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> values.</source>
          <target state="translated">Одно из значений перечисления <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>All members have a set of attributes, which are defined in relation to the specific type of member.</source>
          <target state="translated">Все члены имеют набор атрибутов, определенных относительно определенного типа члена.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, first get the type.</source>
          <target state="translated">Для получения <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, сначала нужно получить тип.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>From the type, get the method.</source>
          <target state="translated">Из типа которого вызывается метод.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>From the method, get the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>.</source>
          <target state="translated">С помощью метода get <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>The following code example displays the attributes of the user-defined method Mymethod.</source>
          <target state="translated">В следующем примере кода отображаются атрибуты определяемого пользователем метода Mymethod.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>This code produces the following output:</source>
          <target state="translated">Этот код выводит следующие результаты:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Reflection.MethodBase.Attributes Sample</source>
          <target state="translated">Образец Reflection.MethodBase.Attributes</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)</source>
          <target state="translated">Mymethodbase = Void Mymethod (Int32, System.String ByRef System.String ByRef)</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>PrivateScope</source>
          <target state="translated">PrivateScope</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>FamANDAssem</source>
          <target state="translated">FamANDAssem</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Family</source>
          <target state="translated">Семейство</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Public</source>
          <target state="translated">Public</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>HideBySig</source>
          <target state="translated">HideBySig</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>ReuseSlot</source>
          <target state="translated">ReuseSlot</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Use the <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph> property to determine whether a method is <ph id="ph2">&lt;see langword="public" /&gt;</ph>, <ph id="ph3">&lt;see langword="private" /&gt;</ph>, <ph id="ph4">&lt;see langword="final" /&gt;</ph>, <ph id="ph5">&lt;see langword="virtual" /&gt;</ph>, and so on.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph> свойства, чтобы определить, является ли <ph id="ph2">&lt;see langword="public" /&gt;</ph>, <ph id="ph3">&lt;see langword="private" /&gt;</ph>, <ph id="ph4">&lt;see langword="final" /&gt;</ph>, <ph id="ph5">&lt;see langword="virtual" /&gt;</ph>, и т. д.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.CallingConvention">
          <source>Gets a value indicating the calling conventions for this method.</source>
          <target state="translated">Возвращает значение, показывающее соглашения о вызовах для этого метода.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.CallingConvention">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> for this method.</source>
          <target state="translated">Атрибуты <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> для этого метода.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Gets a value indicating whether the generic method contains unassigned generic type parameters.</source>
          <target state="translated">Возвращает значение, указывающее, содержит ли универсальный метод не присвоенные параметры универсального типа.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object represents a generic method that contains unassigned generic type parameters; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий объект <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> представляет универсальный метод, который содержит не присвоенные параметры универсального типа; в обратном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types.</source>
          <target state="translated">Универсальный метод может вызываться только в том случае, если не существует определения универсального типа или открытые сконструированные типы в аргументах типа самого метода или в любой заключенных типов.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Because types can be arbitrarily complex, making this recursive determination is difficult.</source>
          <target state="translated">Так как типы могут быть произвольной, выполнить такое рекурсивное определение сложно.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For convenience, and to reduce the chance of error, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</source>
          <target state="translated">Для удобства и уменьшить вероятность ошибок <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> свойство предоставляет стандартный способ различения закрытых сконструированных методов, которые могут быть вызваны, и откройте созданных методов, которые не.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, the method cannot be invoked.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> возвращает <ph id="ph2">`true`</ph>, вызов метода невозможен.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property searches recursively for type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> Свойство выполняет рекурсивно для параметров типа.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For example, it returns <ph id="ph1">`true`</ph> for any method in an open type <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> in Visual Basic), even though the method itself is not generic.</source>
          <target state="translated">Например, он возвращает <ph id="ph1">`true`</ph> для любого метода в открытом типе <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> в Visual Basic), даже если сам метод не является универсальным.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Contrast this with the behavior of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property, which returns <ph id="ph2">`false`</ph> for such a method.</source>
          <target state="translated">Сравните это с поведением <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> свойство, которое возвращает <ph id="ph2">`false`</ph> для такого метода.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Similarly, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property parameter returns <ph id="ph2">`true`</ph> for any constructor in an open type, even though constructors cannot have type parameters of their own.</source>
          <target state="translated">Аналогичным образом <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> возвращает свойства параметра <ph id="ph2">`true`</ph> для любого конструктора в виде открытого типа, даже если конструкторы не могут иметь свои собственные параметры типа.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Список неизменяемых условий для конкретных универсальных методов см. в разделе <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Список неизменяемых условий для других терминов, используемых в универсальном отражении см. в разделе <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Equals(System.Object)">
          <source>An object to compare with this instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, сравниваемый с этим экземпляром, или значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Equals(System.Object)">
          <source>Returns a value that indicates whether this instance is equal to a specified object.</source>
          <target state="translated">Возвращает значение, показывающее, равен ли экземпляр указанному объекту.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> equals the type and value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение параметра <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> равно типу и значению данного экземпляра; в противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Returns a <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> object representing the currently executing method.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>, представляющий выполняющийся в текущий момент метод.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /&gt;</ph> is a static method that is called from within an executing method and that returns information about that method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /&gt;</ph> — это статический метод, который вызывается из выполняющегося метода и возвращает сведения об этом методе.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>A <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> object representing the currently executing method.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>, представляющий выполняющийся в текущий момент метод.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>If the currently executing method is defined on a generic type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that is returned by <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> is obtained from the generic type definition (that is, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph> returns <ph id="ph4">`true`</ph>).</source>
          <target state="translated">Если текущий выполняемый метод определен в универсальном типе, <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , возвращаемый <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> получается из определения универсального типа (то есть <ph id="ph3">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph> возвращает <ph id="ph4">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Therefore, it does not reflect the type arguments that were used when the method was called.</source>
          <target state="translated">Таким образом он не отражает аргументы типа, которые использовались при вызове метода.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>For example, if a method <ph id="ph1">`M()`</ph> is defined on a generic type <ph id="ph2">`C&lt;T&gt;`</ph> (<ph id="ph3">`C(Of T)`</ph> in Visual Basic), and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> is called from <ph id="ph5">`C&lt;string&gt;.M()`</ph>, then <ph id="ph6">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> returns <ph id="ph7">`C&lt;T&gt;.M()`</ph> (<ph id="ph8">`C(Of T).M()`</ph> in Visual Basic).</source>
          <target state="translated">Например, если метод <ph id="ph1">`M()`</ph> определено в универсальном типе <ph id="ph2">`C&lt;T&gt;`</ph> (<ph id="ph3">`C(Of T)`</ph> в Visual Basic), и <ph id="ph4">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> вызывается из <ph id="ph5">`C&lt;string&gt;.M()`</ph>, затем <ph id="ph6">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> возвращает <ph id="ph7">`C&lt;T&gt;.M()`</ph> (<ph id="ph8">`C(Of T).M()`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>If the currently executing method is a generic method, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> returns the generic method definition.</source>
          <target state="translated">Если текущий выполняемый метод является универсальным методом, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> возвращает определение универсального метода.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>If the generic method is defined on a generic type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is obtained from the generic type definition.</source>
          <target state="translated">Если универсальный метод определен в универсальном типе <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> получается из определения универсального типа.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>The following example defines two types.</source>
          <target state="translated">В следующем примере определяется двумя типами.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>The first is a non-generic class, <ph id="ph1">`TestClass`</ph>, includes a constructor, a method named <ph id="ph2">`GetValue`</ph>, and a read-write property named <ph id="ph3">`GetValue`</ph>.</source>
          <target state="translated">Первый — неуниверсальных классах, <ph id="ph1">`TestClass`</ph>, включает конструктор, метод с именем <ph id="ph2">`GetValue`</ph>и для чтения и записи свойство с именем <ph id="ph3">`GetValue`</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>The second is a generic class named <ph id="ph1">`TestClass&lt;T&gt;`</ph> that includes a constructor, a <ph id="ph2">`GetValue`</ph> method, and a generic method, <ph id="ph3">`ConvertValue&lt;Y&gt;`</ph>.</source>
          <target state="translated">Второй — универсальный класс с именем <ph id="ph1">`TestClass&lt;T&gt;`</ph> , включает конструктор, <ph id="ph2">`GetValue`</ph> метод и универсального метода <ph id="ph3">`ConvertValue&lt;Y&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Each constructor, method, and property accessor includes a call to the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> method.</source>
          <target state="translated">Каждый конструктор, метод и метод доступа к свойству включает вызов <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>This member was invoked with a late-binding mechanism.</source>
          <target state="translated">Этот элемент был вызван при помощи механизма позднего связывания.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">При вызове поздней привязкой, такие как <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, которые представляют аргументы универсального метода, относящиеся к типу, или параметры типа определения универсального метода.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющих аргументы типа, относящиеся к универсальному методу, или параметры типа определения универсального метода.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Returns an empty array if the current method is not a generic method.</source>
          <target state="translated">Возвращает пустой массив, если текущий метод не является универсальным методом.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</source>
          <target state="translated">Элементы возвращаемого массива, в том порядке, в котором они отображаются в списке параметров типа для универсального метода.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>If the current method is a closed constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic method definition.</source>
          <target state="translated">Если текущий метод является закрытым сконструированным методом (то есть <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> возвращает <ph id="ph2">`false`</ph>), массив, возвращаемый методом <ph id="ph3">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> метод содержит типы, которые были назначены для параметров универсального типа для универсального метода Определение.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>If the current method is a generic method definition, the array contains the type parameters.</source>
          <target state="translated">Если текущий метод является определением универсального метода, массив содержит параметры типа.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>If the current method is an open constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</source>
          <target state="translated">Если текущий метод является открытым сконструированным методом (то есть <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> возвращает <ph id="ph2">`true`</ph>) в определенные типы были назначены для некоторых параметров типа и типа параметров, включающих универсальные типы были назначены другого типа содержит массив параметров, типов и типов параметров.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> свойство, чтобы отличить друг от друга.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>For a demonstration of this scenario, see the code example provided for the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">Для демонстрации этого сценария, см. пример кода, указанный для <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Generic constructors are not supported in the .NET Framework version 2.0.</source>
          <target state="translated">Универсальные конструкторы в платформе .NET Framework версии 2.0 не поддерживаются.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>This property throws <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> if not overridden in a derived class, so an exception is thrown if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">Это свойство создает <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> , если не переопределено в производном классе, поэтому создается исключение, если текущий экземпляр является типа <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Список неизменяемых условий для конкретных универсальных методов см. в разделе <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Список неизменяемых условий для других терминов, используемых в универсальном отражении см. в разделе <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>The current object is a <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>.</source>
          <target state="translated">Текущий объект является объектом <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Generic constructors are not supported in the .NET Framework version 2.0.</source>
          <target state="translated">Универсальные конструкторы в платформе .NET Framework версии 2.0 не поддерживаются.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>This exception is the default behavior if this method is not overridden in a derived class.</source>
          <target state="translated">Это исключение является поведением по умолчанию, если этот метод не переопределен в производном классе.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Возвращает хэш-код данного экземпляра.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Хэш-код в виде 32-разрядного целого числа со знаком.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>When overridden in a derived class, gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</source>
          <target state="translated">При переопределении в производном классе возвращает объект <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph>, который обеспечивает доступ к потоку MSIL, локальным переменным и исключениям для текущего метода.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph>, который обеспечивает доступ к потоку MSIL, локальным переменным и исключениям для текущего метода.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>You do not have to override the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> in order to use it.</source>
          <target state="translated">Необходимо переопределить <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> для использования.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>You can call the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> method on <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects, because the method is overridden in the runtime versions of these classes.</source>
          <target state="translated">Можно вызвать <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> метод <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> и <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> объектов, так как метод переопределяется в версии среды выполнения из этих классов.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>For example, the runtime version of the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class derives from the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class, which in turn derives from the <ph id="ph3">&lt;xref:System.Reflection.MethodBase&gt;</ph> class.</source>
          <target state="translated">Например, версия среды выполнения <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> класс является производным от <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> класс, который в свою очередь является производным от <ph id="ph3">&lt;xref:System.Reflection.MethodBase&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The following code example defines a test method named <ph id="ph1">`MethodBodyExample`</ph> and displays its local variable information and exception-handling clauses.</source>
          <target state="translated">В следующем примере кода определяется метод теста, с именем <ph id="ph1">`MethodBodyExample`</ph> и отображает ее локальных переменных и предложений обработки исключений.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType&gt;</ph> method is used to obtain a <ph id="ph2">&lt;xref:System.Reflection.MethodBody&gt;</ph> object for the test method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType&gt;</ph> Метод используется для получения <ph id="ph2">&lt;xref:System.Reflection.MethodBody&gt;</ph> объекта для метода теста.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBody.LocalVariables%2A&gt;</ph> property is used to obtain a list of <ph id="ph2">&lt;xref:System.Reflection.LocalVariableInfo&gt;</ph> objects and display their types and index order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBody.LocalVariables%2A&gt;</ph> Свойство используется для получения списка <ph id="ph2">&lt;xref:System.Reflection.LocalVariableInfo&gt;</ph> объектов и отображать их типы и порядок индекса.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A&gt;</ph> property is used to obtain a list of exception-handling clauses.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A&gt;</ph> Свойство используется, чтобы получить список предложений обработки исключений.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>Not all computer languages can generate <ph id="ph1">&lt;xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType&gt;</ph> clauses.</source>
          <target state="translated">Не все языки программирования можно создавать <ph id="ph1">&lt;xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType&gt;</ph> предложения.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The Visual Basic example shows a filter clause, using a Visual Basic <ph id="ph1">`When`</ph> expression, which is omitted from the examples for other languages.</source>
          <target state="translated">В примере Visual Basic показано предложение фильтра с помощью Visual Basic <ph id="ph1">`When`</ph> выражения, отсутствующего в примерах для других языков.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>This method is invalid unless overridden in a derived class.</source>
          <target state="translated">Если этот метод не переопределен в производном классе, он является недопустимым.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>for the access to metadata for members.</source>
          <target state="translated">для доступа к метаданным для элементов.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>Permission value: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Значение разрешения: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodBase">
          <source>Gets method information using the specified handle.</source>
          <target state="translated">Возвращает сведения о методе с с использованием заданного дескриптора.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>The method's handle.</source>
          <target state="translated">Дескриптор метода.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>Gets method information by using the method's internal metadata representation (handle).</source>
          <target state="translated">Получает сведения о методе с помощью представления внутренних метаданных метода (дескриптора).</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>A <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> containing information about the method.</source>
          <target state="translated">Строка <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>, содержащая сведения о методе.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>Handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Дескрипторы доступны только в домене приложения, в котором они были получены.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> недопустим.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">При вызове поздней привязкой, такие как <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A handle to the internal metadata representation of a constructor or method.</source>
          <target state="translated">Дескриптор представления внутренних метаданных конструктора или метода.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A handle to the generic type that defines the constructor or method.</source>
          <target state="translated">Дескриптор универсального типа, определяющего конструктор или метод.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object for the constructor or method represented by the specified handle, for the specified generic type.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> для конструктора метода, представленного заданным дескриптором для заданного универсального типа.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method or constructor specified by <ph id="ph2">&lt;paramref name="handle" /&gt;</ph>, in the generic type specified by <ph id="ph3">&lt;paramref name="declaringType" /&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>, который представляет метод или конструктор, определенный дескриптором <ph id="ph2">&lt;paramref name="handle" /&gt;</ph>, в универсальном типе, заданном параметром <ph id="ph3">&lt;paramref name="declaringType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>Handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Дескрипторы доступны только в домене приложения, в котором они были получены.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A <ph id="ph1">&lt;xref:System.RuntimeMethodHandle&gt;</ph> structure for a constructor or method of a generic type can represent different <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> objects, depending on the types specified for the type parameters of the generic type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.RuntimeMethodHandle&gt;</ph> структуру к конструктору или методу универсального типа может представлять различные <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> объектов, в зависимости от типов, заданных для параметров типа универсального типа.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>For example, if <ph id="ph1">`class G&lt;T&gt;`</ph> (<ph id="ph2">`class G(Of T)`</ph> in Visual Basic, <ph id="ph3">`generic &lt;T&gt; ref class G`</ph> in C++) has a method that returns type <ph id="ph4">`T`</ph>, the <ph id="ph5">&lt;xref:System.Reflection.MethodBase&gt;</ph> object for that method in a constructed class such as <ph id="ph6">`G&lt;int&gt;`</ph> is different from the <ph id="ph7">&lt;xref:System.Reflection.MethodBase&gt;</ph> object for that method in the generic type definition.</source>
          <target state="translated">Например если <ph id="ph1">`class G&lt;T&gt;`</ph> (<ph id="ph2">`class G(Of T)`</ph> в Visual Basic <ph id="ph3">`generic &lt;T&gt; ref class G`</ph> в C++) содержит метод, который возвращает тип <ph id="ph4">`T`</ph>, <ph id="ph5">&lt;xref:System.Reflection.MethodBase&gt;</ph> объект для этого метода в сформированного класса, такой как <ph id="ph6">`G&lt;int&gt;`</ph> отличается от <ph id="ph7">&lt;xref:System.Reflection.MethodBase&gt;</ph>объект для этого метода в определении универсального типа.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> недопустим.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">При вызове поздней привязкой, такие как <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags.</source>
          <target state="translated">При переопределении в производном классе возвращает новые флаги <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>The <ph id="ph1">&lt;see langword="MethodImplAttributes" /&gt;</ph> flags.</source>
          <target state="translated">Флаги <ph id="ph1">&lt;see langword="MethodImplAttributes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>The following example defines a constructor in a dynamic assembly and then uses the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> method to display the method implementation flags that are set by default.</source>
          <target state="translated">В следующем примере определяется конструктор в динамической сборке и затем использует <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> метод для отображения, заданные по умолчанию флаги реализации метода.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">При вызове поздней привязкой, такие как <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>When overridden in a derived class, gets the parameters of the specified method or constructor.</source>
          <target state="translated">При переопределении в производном классе возвращает параметры заданного метода или конструктора.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>An array of type <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> containing information that matches the signature of the method (or constructor) reflected by this <ph id="ph2">&lt;see langword="MethodBase" /&gt;</ph> instance.</source>
          <target state="translated">Массив типа <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph>, содержащий сведения, которые соответствуют подписи метода (или конструктора), представленного этим экземпляром <ph id="ph2">&lt;see langword="MethodBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> method to retrieve the parameters of the <ph id="ph2">`Invoke`</ph> method of a delegate.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> метод для извлечения параметров <ph id="ph2">`Invoke`</ph> метод делегата.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>The example defines a delegate named <ph id="ph1">`MyDelegate`</ph> and an event named <ph id="ph2">`ev`</ph> of type <ph id="ph3">`MyDelegate`</ph>.</source>
          <target state="translated">В примере определяется делегат с именем <ph id="ph1">`MyDelegate`</ph> и событие с именем <ph id="ph2">`ev`</ph> типа <ph id="ph3">`MyDelegate`</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>The code in the <ph id="ph1">`Main`</ph> method discovers the event signature by getting the delegate type of the event, getting the <ph id="ph2">`Invoke`</ph> method of the delegate type, and then retrieving and displaying the parameters.</source>
          <target state="translated">Код в <ph id="ph1">`Main`</ph> метод обнаруживает сигнатуры события, обратившись в тип делегата события, получение <ph id="ph2">`Invoke`</ph> метод тип делегата, а затем извлечение и отображение параметров.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">При вызове поздней привязкой, такие как <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodBase">
          <source>Invokes the method or constructor reflected by this <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> instance.</source>
          <target state="translated">Вызывает метод или конструктор, отражаемый этим экземпляром <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The object on which to invoke the method or constructor.</source>
          <target state="translated">Объект, для которого нужно вызвать метод или конструктор.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a method is static, this argument is ignored.</source>
          <target state="translated">Если метод является статическим, этот аргумент игнорируется.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a constructor is static, this argument must be <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an instance of the class that defines the constructor.</source>
          <target state="translated">Если конструктор является статическим, этот аргумент должен иметь значение <ph id="ph1">&lt;see langword="null" /&gt;</ph> или представлять экземпляр класса, который определяет конструктор.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>An argument list for the invoked method or constructor.</source>
          <target state="translated">Список аргументов для вызываемого метода или конструктора.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</source>
          <target state="translated">Это массив объектов, количество, порядок и тип которых должны соответствовать списку параметров вызываемого метода или конструктора.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If there are no parameters, <bpt id="p1">&lt;c&gt;</bpt>parameters<ept id="p1">&lt;/c&gt;</ept> should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если параметров нет, для <bpt id="p1">&lt;c&gt;</bpt>parameters<ept id="p1">&lt;/c&gt;</ept> должно быть указано значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If the method or constructor represented by this instance takes a <ph id="ph1">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function.</source>
          <target state="translated">Если метод или конструктор, представленный этим экземпляром, принимает параметр <ph id="ph1">&lt;see langword="ref" /&gt;</ph> (<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> в Visual Basic), не требуются никакие специальные атрибуты для вызова этого метода или конструктора с использованием этой функции.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</source>
          <target state="translated">Любой объект этого массива, которому не присвоено значение явным образом, будет содержать значение по умолчанию для своего типа объекта.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>For reference-type elements, this value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Для элементов ссылочного типа это значение равно <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>For value-type elements, this value is 0, 0.0, or <ph id="ph1">&lt;see langword="false" /&gt;</ph>, depending on the specific element type.</source>
          <target state="translated">Для элементов, хранящих значения, это значение равно 0, 0,0 или <ph id="ph1">&lt;see langword="false" /&gt;</ph> (в зависимости от типа конкретного элемента).</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Invokes the method or constructor represented by the current instance, using the specified parameters.</source>
          <target state="translated">Вызывает метод или конструктор, представленный текущим экземпляром, используя указанные параметры.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>An object containing the return value of the invoked method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> in the case of a constructor.</source>
          <target state="translated">Объект, который содержит возвращаемое значение вызываемого метода, или <ph id="ph1">&lt;see langword="null" /&gt;</ph> при вызове конструктора.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>This is a convenience method that calls the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> method overload, passing <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Default&gt;</ph> for <ph id="ph3">`invokeAttr`</ph> and <ph id="ph4">`null`</ph> for <ph id="ph5">`binder`</ph> and <ph id="ph6">`culture`</ph>.</source>
          <target state="translated">Это удобный метод, который вызывает <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> перегрузка метода, передав <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Default&gt;</ph> для <ph id="ph3">`invokeAttr`</ph> и <ph id="ph4">`null`</ph> для <ph id="ph5">`binder`</ph> и <ph id="ph6">`culture`</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If the invoked method throws an exception, the <ph id="ph1">&lt;xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType&gt;</ph> method returns the exception.</source>
          <target state="translated">Если вызванный метод создает исключение, <ph id="ph1">&lt;xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType&gt;</ph> метод возвращает исключение.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>To invoke a static method using its <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object, pass <ph id="ph2">`null`</ph> for <ph id="ph3">`obj`</ph>.</source>
          <target state="translated">Для вызова статического метода с помощью его <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , передать <ph id="ph2">`null`</ph> для <ph id="ph3">`obj`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If this method overload is used to invoke an instance constructor, the object supplied for <ph id="ph1">`obj`</ph> is reinitialized; that is, all instance initializers are executed.</source>
          <target state="translated">Эта перегрузка метода используется для вызова конструктора экземпляра, объект, предоставленный для <ph id="ph1">`obj`</ph> инициализируется; то есть выполняются все инициализаторы экземпляра.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Возвращаемое значение — <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</source>
          <target state="translated">Если вызывается конструктор класса, инициализируется класс; то есть выполняются все инициализаторы класса.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Возвращаемое значение — <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, этот метод можно использовать для доступа к закрытым членам, если вызывающему объекту предоставлены <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> и отметки Если набор прав, не являющиеся открытыми члены ограничена вызывающего набором разрешений или подмножество его.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>рекомендации по безопасности для отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Для применения этих функциональных возможностей приложение должно использовать <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздние версии.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a parameter of the current method is a value type, and the corresponding argument in <ph id="ph1">`parameters`</ph> is <ph id="ph2">`null`</ph>, the runtime passes a zero-initialized instance of the value type.</source>
          <target state="translated">Если параметр текущего метода является тип значения и соответствующего аргумента в <ph id="ph1">`parameters`</ph> — <ph id="ph2">`null`</ph>, среда выполнения передает инициализированный нулем экземпляр типа значения.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The following code example demonstrates dynamic method lookup using reflection.</source>
          <target state="translated">В следующем примере кода демонстрируется поиск динамических методов, с помощью отражения.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Note that you cannot use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.</source>
          <target state="translated">Обратите внимание, что нельзя использовать <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объект из базового класса, чтобы вызвать метод, переопределенный в производном классе, так как функция позднего связывания не удается разрешить переопределения.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> instead.</source>
          <target state="translated">Вместо этого в <bpt id="p1">[</bpt>.NET для приложений Магазина Windows<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> или в <bpt id="p2">[</bpt>переносимой библиотеке классов<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept> перехватите исключение <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and the method is not static.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph> и метод не является статическим.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The method is not declared or inherited by the class of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated">Этот метод не объявлен и не унаследован в классе <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>A static constructor is invoked, and <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is neither <ph id="ph2">&lt;see langword="null" /&gt;</ph> nor an instance of the class that declared the constructor.</source>
          <target state="translated">Вызывается статический конструктор, а <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> не имеет значения <ph id="ph2">&lt;see langword="null" /&gt;</ph> и не является экземпляром класса, в котором объявлен этот конструктор.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The elements of the <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> array do not match the signature of the method or constructor reflected by this instance.</source>
          <target state="translated">Элементы массива <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> не соответствуют подписи метода или конструктора, отраженного этим экземпляром.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The invoked method or constructor throws an exception.</source>
          <target state="translated">Вызванный метод или конструктор создает исключение.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The current instance is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph> that contains unverifiable code.</source>
          <target state="translated">Текущий экземпляр представляет <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>, который содержит непроверяемый код.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>See the "Verification" section in Remarks for <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>.</source>
          <target state="translated">См. подраздел "Проверка" в разделе примечаний для <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> array does not have the correct number of arguments.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> содержит неправильное число аргументов.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.MemberAccessException" /&gt;</ph>, instead.</source>
          <target state="translated">Вместо этого в <bpt id="p1">[</bpt>.NET для приложений Магазина Windows<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> или в <bpt id="p2">[</bpt>переносимой библиотеке классов<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept> перехватите исключение базового класса <ph id="ph1">&lt;see cref="T:System.MemberAccessException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The caller does not have permission to execute the method or constructor that is represented by the current instance.</source>
          <target state="translated">Вызывающий объект не имеет разрешение на выполнение метода или конструктора, представленного текущим экземпляром.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The type that declares the method is an open generic type.</source>
          <target state="translated">Тип, объявляющий метод, является открытым универсальным типом.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph> for the declaring type.</source>
          <target state="translated">То есть свойство <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> для объявляющего типа возвращает значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The current instance is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</source>
          <target state="translated">Текущий экземпляр представляет <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">При вызове поздней привязкой, такие как <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The object on which to invoke the method or constructor.</source>
          <target state="translated">Объект, для которого нужно вызвать метод или конструктор.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a method is static, this argument is ignored.</source>
          <target state="translated">Если метод является статическим, этот аргумент игнорируется.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a constructor is static, this argument must be <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an instance of the class that defines the constructor.</source>
          <target state="translated">Если конструктор является статическим, этот аргумент должен иметь значение <ph id="ph1">&lt;see langword="null" /&gt;</ph> или представлять экземпляр класса, который определяет конструктор.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A bitmask that is a combination of 0 or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Битовая маска, которая содержит от нуля и больше битовых флагов из атрибута <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> в разных сочетаниях.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this parameter is assigned the value <ph id="ph2">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>; thus, whatever you pass in is ignored.</source>
          <target state="translated">Если параметр <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> имеет значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, ему присваивается значение <ph id="ph2">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>. В результате все передаваемые параметры игнорируются.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects via reflection.</source>
          <target state="translated">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> с помощью отражения.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Если указан <bpt id="p1">&lt;c&gt;</bpt>модуль привязки<ept id="p1">&lt;/c&gt;</ept> <ph id="ph1">&lt;see langword="null" /&gt;</ph>, используется модуль привязки по умолчанию.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An argument list for the invoked method or constructor.</source>
          <target state="translated">Список аргументов для вызываемого метода или конструктора.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</source>
          <target state="translated">Это массив объектов, количество, порядок и тип которых должны соответствовать списку параметров вызываемого метода или конструктора.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If there are no parameters, this should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">При отсутствии параметров — значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function.</source>
          <target state="translated">Если метод или конструктор, представленный этим экземпляром, принимает параметр ByRef, для вызова метода или конструктора с использованием этой функции специальные атрибуты не требуются.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</source>
          <target state="translated">Любой объект этого массива, которому не присвоено значение явным образом, будет содержать значение по умолчанию для своего типа объекта.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For reference-type elements, this value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Для элементов ссылочного типа это значение равно <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For value-type elements, this value is 0, 0.0, or <ph id="ph1">&lt;see langword="false" /&gt;</ph>, depending on the specific element type.</source>
          <target state="translated">Для элементов, хранящих значения, это значение равно 0, 0,0 или <ph id="ph1">&lt;see langword="false" /&gt;</ph> (в зависимости от типа конкретного элемента).</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Экземпляр объекта <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph>, используемого для управления приведением типов.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Если значение этого объекта — <ph id="ph1">&lt;see langword="null" /&gt;</ph>, для текущего потока используется <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>(This is necessary to convert a <ph id="ph1">&lt;see langword="String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see langword="Double" /&gt;</ph> value, for example, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">(Например, необходимо преобразовывать объект <ph id="ph1">&lt;see langword="String" /&gt;</ph>, представляющий 1000, в значение <ph id="ph2">&lt;see langword="Double" /&gt;</ph>, поскольку при разных языках и региональных параметрах 1000 представляется по-разному.)</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</source>
          <target state="translated">При переопределении в производном классе вызывает отражаемый метод или конструктор с заданными параметрами.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An <ph id="ph1">&lt;see langword="Object" /&gt;</ph> containing the return value of the invoked method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> in the case of a constructor, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the method's return type is <ph id="ph4">&lt;see langword="void" /&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="Object" /&gt;</ph>, содержащий возвращаемое значение вызванного метода, значение <ph id="ph2">&lt;see langword="null" /&gt;</ph> для конструктора или значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>, если метод возвращает значение типа <ph id="ph4">&lt;see langword="void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Before calling the method or constructor, <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> checks to see if the user has access permission and verifies that the parameters are valid.</source>
          <target state="translated">Перед вызовом метода или конструктора функция <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> проверяет наличие у пользователя права доступа и допустимость параметров.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Dynamically invokes the method reflected by this instance on <ph id="ph1">`obj`</ph>, and passes along the specified parameters.</source>
          <target state="translated">Динамически вызывает метод, отраженный этим экземпляром <ph id="ph1">`obj`</ph>и передает указанные параметры.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method is static, the <ph id="ph1">`obj`</ph> parameter is ignored.</source>
          <target state="translated">Если метод является статическим, <ph id="ph1">`obj`</ph> параметр учитывается.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For non-static methods, <ph id="ph1">`obj`</ph> should be an instance of a class that inherits or declares the method and must be the same type as this class.</source>
          <target state="translated">Для методов, не являющиеся статическими <ph id="ph1">`obj`</ph> должен быть экземпляром класса, который наследует или объявляет метод, а также должен быть того же типа, что и этот класс.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method has no parameters, the value of <ph id="ph1">`parameters`</ph> should be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Если метод не имеет параметров, значение <ph id="ph1">`parameters`</ph> должно быть <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Otherwise, the number, type, and order of elements in <ph id="ph1">`parameters`</ph> should be identical to the number, type, and order of parameters for the method reflected by this instance.</source>
          <target state="translated">В противном случае число, тип и порядок элементов в <ph id="ph1">`parameters`</ph> должен быть идентичен количество, тип и порядок параметров метода, отраженный этим экземпляром.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>You may not omit optional parameters in calls to <ph id="ph1">`Invoke`</ph>.</source>
          <target state="translated">Не менее опускать необязательные параметры в вызовах <ph id="ph1">`Invoke`</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>To invoke a method omitting optional parameters, you should call <ph id="ph1">`Type.InvokeMember`</ph> instead.</source>
          <target state="translated">Чтобы вызвать метод, опустив необязательные параметры, необходимо вызвать <ph id="ph1">`Type.InvokeMember`</ph> вместо него.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this method overload is used to invoke an instance constructor, the object supplied for <ph id="ph1">`obj`</ph> is reinitialized; that is, all instance initializers are executed.</source>
          <target state="translated">Эта перегрузка метода используется для вызова конструктора экземпляра, объект, предоставленный для <ph id="ph1">`obj`</ph> инициализируется; то есть выполняются все инициализаторы экземпляра.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Возвращаемое значение — <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</source>
          <target state="translated">Если вызывается конструктор класса, инициализируется класс; то есть выполняются все инициализаторы класса.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Возвращаемое значение — <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For pass-by-value primitive parameters, normal widening is performed (Int16 -&gt; Int32, for example).</source>
          <target state="translated">Для примитивных параметров передачи по значению, выполняется нормальное расширение (Int16 -&gt; Int32, например).</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type).</source>
          <target state="translated">Для передачи по значению ссылочных параметров нормальное расширение ссылки допускается (производный класс для базового класса и базового класса к типу интерфейса).</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>However, for pass-by-reference primitive parameters, the types must match exactly.</source>
          <target state="translated">Однако для передачи по ссылке примитивных параметров, типы должны точно совпадать.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For pass-by-reference reference parameters, the normal widening still applies.</source>
          <target state="translated">Для передачи по ссылке ссылочных параметров нормальное расширение по-прежнему применяется.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if the method reflected by this instance is declared as <ph id="ph1">`public boolean Compare(String a, String b)`</ph>, then <ph id="ph2">`parameters`</ph> should be an array of <ph id="ph3">`Objects`</ph> with length 2 such that <ph id="ph4">`parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`</ph>.</source>
          <target state="translated">Например, если метод отражаться на этот экземпляр объявляется как <ph id="ph1">`public boolean Compare(String a, String b)`</ph>, затем <ph id="ph2">`parameters`</ph> должен быть массивом <ph id="ph3">`Objects`</ph> длиной 2 таким образом, что <ph id="ph4">`parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a parameter of the current method is a value type, and the corresponding argument in <ph id="ph1">`parameters`</ph> is <ph id="ph2">`null`</ph>, the runtime passes a zero-initialized instance of the value type.</source>
          <target state="translated">Если параметр текущего метода является тип значения и соответствующего аргумента в <ph id="ph1">`parameters`</ph> — <ph id="ph2">`null`</ph>, среда выполнения передает инициализированный нулем экземпляр типа значения.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Reflection uses dynamic method lookup when invoking virtual methods.</source>
          <target state="translated">Отражение использует поиск динамического метода, при вызове виртуальных методов.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a <ph id="ph1">`MethodInfo`</ph> object that represents M on class A. If you use the <ph id="ph2">`Invoke`</ph> method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</source>
          <target state="translated">Например предположим, что класс B наследует от класса A, и оба реализуют виртуальный метод с именем M. Теперь предположим, что есть <ph id="ph1">`MethodInfo`</ph> объект, представляющий M для класса. Если вы используете <ph id="ph2">`Invoke`</ph> метод, вызываемый M на объект типа б, то отражение использует реализацию, которую класс B. Даже если объект типа Б приводится к A, используется реализация, происходящая от класса B (см. пример кода ниже).</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the <ph id="ph1">`MethodInfo`</ph> was obtained, regardless of the type of the object passed as the target.</source>
          <target state="translated">С другой стороны, если невиртуальный метод, отражение использует реализацию по типу, из которого <ph id="ph1">`MethodInfo`</ph> был получен, независимо от типа объекта, переданного в качестве целевого объекта.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully trusted code.</source>
          <target state="translated">Ограничения доступа игнорируются для полностью доверенный код.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</source>
          <target state="translated">То есть закрытые конструкторы, методы, поля и свойства можно получить доступ к и вызывается через отражение, если код имеет полное доверие.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the invoked method throws an exception, <ph id="ph1">`TargetInvocationException.GetException`</ph> returns the exception.</source>
          <target state="translated">Если вызванный метод создает исключение, <ph id="ph1">`TargetInvocationException.GetException`</ph> возвращает исключение.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This implementation throws a <ph id="ph1">`NotSupportedException`</ph>.</source>
          <target state="translated">Эта реализация создает исключение <ph id="ph1">`NotSupportedException`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, этот метод можно использовать для доступа к закрытым членам, если вызывающему объекту предоставлены <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> и отметки Если набор прав, не являющиеся открытыми члены ограничена вызывающего набором разрешений или подмножество его.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>рекомендации по безопасности для отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Для применения этих функциональных возможностей приложение должно использовать <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздние версии.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The following example demonstrates all members of the <ph id="ph1">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class using an overload of <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">В следующем примере показано все члены <ph id="ph1">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> класса с помощью перегруженной <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The private method <ph id="ph1">`CanConvertFrom`</ph> finds compatible types for a given type.</source>
          <target state="translated">Закрытый метод <ph id="ph1">`CanConvertFrom`</ph> находит совместимые типы для данного типа.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For another example of invoking members in a custom binding scenario, see <bpt id="p1">[</bpt>Dynamically Loading and Using Types<ept id="p1">](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md)</ept>.</source>
          <target state="translated">Другой пример вызова членов в пользовательском сценарии связывания см <bpt id="p1">[</bpt>динамическая загрузка и использование типов<ept id="p1">](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and the method is not static.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph> и метод не является статическим.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The method is not declared or inherited by the class of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated">Этот метод не объявлен и не унаследован в классе <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A static constructor is invoked, and <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is neither <ph id="ph2">&lt;see langword="null" /&gt;</ph> nor an instance of the class that declared the constructor.</source>
          <target state="translated">Вызывается статический конструктор, а <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> не имеет значения <ph id="ph2">&lt;see langword="null" /&gt;</ph> и не является экземпляром класса, в котором объявлен этот конструктор.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of the <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> parameter does not match the signature of the method or constructor reflected by this instance.</source>
          <target state="translated">Тип параметра <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> не соответствует подписи метода или конструктора, отраженного этим экземпляром.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> array does not have the correct number of arguments.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> содержит неправильное число аргументов.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The invoked method or constructor throws an exception.</source>
          <target state="translated">Вызванный метод или конструктор создает исключение.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The caller does not have permission to execute the method or constructor that is represented by the current instance.</source>
          <target state="translated">Вызывающий объект не имеет разрешение на выполнение метода или конструктора, представленного текущим экземпляром.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The type that declares the method is an open generic type.</source>
          <target state="translated">Тип, объявляющий метод, является открытым универсальным типом.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph> for the declaring type.</source>
          <target state="translated">То есть свойство <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> для объявляющего типа возвращает значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">При вызове поздней привязкой, такие как <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>Gets a value indicating whether the method is abstract.</source>
          <target state="translated">Возвращает значение, указывающее, является ли метод абстрактным.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method is abstract; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если метод является абстрактным; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>An abstract member is declared on a base class and has no implementation supplied.</source>
          <target state="translated">Абстрактный член объявлен в базовом классе и предоставил нет реализации.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, first get the type.</source>
          <target state="translated">Для получения <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, сначала нужно получить тип.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>From the type, get the method.</source>
          <target state="translated">Из типа которого вызывается метод.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>From the method, get the <ph id="ph1">`MethodBase`</ph>.</source>
          <target state="translated">С помощью метода get <ph id="ph1">`MethodBase`</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>If the <ph id="ph1">`MethodBase`</ph> or constructor is other than public, it is protected and cannot be readily accessed.</source>
          <target state="translated">Если <ph id="ph1">`MethodBase`</ph> или конструктор не являются открытыми, они защищены и не может быть непосредственно доступны.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>To access a non-public method, set the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> mask to <ph id="ph2">`NonPublic`</ph> in <ph id="ph3">`GetMethod`</ph>.</source>
          <target state="translated">Для обращения к методу, не являющиеся открытыми, установите <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> для маски <ph id="ph2">`NonPublic`</ph> в <ph id="ph3">`GetMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>The following example determines whether specified the method is abstract and displays the result.</source>
          <target state="translated">В следующем примере определяется, является ли указанный метод является абстрактным и отображается результат.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>Gets a value indicating whether the potential visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</source>
          <target state="translated">Возвращает значение, которое указывает, описана ли доступность данного метода или конструктора в поле <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>; другими словами, этот метод или конструктор полностью доступен для других полей той же сборки и недоступен для производных типов, не включенных в сборку.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the visibility of this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если доступность этого метода или конструктора точно описана в поле <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>; в обратном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The actual visibility of a method is limited by the visibility of its type.</source>
          <target state="translated">Фактически доступность метода ограничена доступностью его типа.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph> property might be <ph id="ph2">`true`</ph> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph> Свойство может быть <ph id="ph2">`true`</ph> для метода, но если он является метод закрытого вложенного типа метода не отображается за пределами содержащего типа.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType&gt;</ph> if the only visibility modifier is <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic).</source>
          <target state="translated">Видимость метод или конструктор точно описываемого <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType&gt;</ph> Если модификатор видимости только <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>This property is <ph id="ph1">`false`</ph> for methods that are <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++); use the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property to identify such methods.</source>
          <target state="translated">Это свойство является <ph id="ph1">`false`</ph> для методов, которые являются <ph id="ph2">`protected internal`</ph> в C# (<ph id="ph3">`Protected Friend`</ph> в Visual Basic <ph id="ph4">`protected public`</ph> в C++); используйте <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> свойство для определения таких методов.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">В следующем примере кода определяет методы, с различными уровнями видимость и отображает значения их <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, и <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Языки Visual Basic и C# не может определить методы с <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> видимости, что уровень доступа отображается только в примере C++.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source>Gets a value indicating whether the method is a constructor.</source>
          <target state="translated">Возвращает значение, указывающее, является ли метод конструктором.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is a constructor represented by a <ph id="ph2">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object (see note in Remarks about <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph> objects); otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если метод является конструктором, представленным объектом <ph id="ph2">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> (см. примечание, относящееся к объектам <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph>, в разделе "Заметки"); в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsConstructor%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for a <ph id="ph3">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object in a dynamic type, unless the <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType&gt;</ph> flag was included in the <ph id="ph5">`attributes`</ph> parameter when the constructor was defined.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsConstructor%2A&gt;</ph> Возвращает <ph id="ph2">`false`</ph> для <ph id="ph3">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> объекта в динамический тип, если не <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType&gt;</ph> флаг был включен в <ph id="ph5">`attributes`</ph> параметр, если конструктор был определен.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source>Omitting the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph> flag does not affect the correctness of the emitted constructor.</source>
          <target state="translated">Пропуск <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph> флаг не влияет на правильность порожденную конструктора.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>Gets a value indicating whether the visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>; that is, the method or constructor is visible only within its class and derived classes.</source>
          <target state="translated">Возвращает значение, которое указывает, описана ли доступность этого метода или конструктора в поле <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>; другими словами, этот метод или конструктор доступен только в своем классе и производных классах.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если доступность этого метода или конструктора точно описана в поле <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>; в обратном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType&gt;</ph> if the only visibility modifier is <ph id="ph2">`protected`</ph>.</source>
          <target state="translated">Видимость метод или конструктор точно описываемого <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType&gt;</ph> Если модификатор видимости только <ph id="ph2">`protected`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>This property is <ph id="ph1">`false`</ph> for methods that are <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++); use the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property to identify such methods.</source>
          <target state="translated">Это свойство является <ph id="ph1">`false`</ph> для методов, которые являются <ph id="ph2">`protected internal`</ph> в C# (<ph id="ph3">`Protected Friend`</ph> в Visual Basic <ph id="ph4">`protected public`</ph> в C++); используйте <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> свойство для определения таких методов.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">В следующем примере кода определяет методы, с различными уровнями видимость и отображает значения их <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, и <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Языки Visual Basic и C# не может определить методы с <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> видимости, что уровень доступа отображается только в примере C++.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>Gets a value indicating whether the visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</source>
          <target state="translated">Возвращает значение, которое указывает, описана ли доступность этого метода или конструктора в поле <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>; другими словами, этот метод или конструктор может вызываться в производных классах, но только в том случае, если они находятся в той же сборке.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если доступность этого метода или конструктора точно описана в поле <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>; в обратном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> if the visibility modifier is <ph id="ph2">`protected private`</ph> in C++.</source>
          <target state="translated">Видимость метод или конструктор точно описываемого <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> Если модификатор видимости <ph id="ph2">`protected private`</ph> в C++.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>Methods with this visibility cannot be defined in Visual Basic or C#.</source>
          <target state="translated">Методы с этим уровнем доступности не может определяться в Visual Basic или C#.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">В следующем примере кода определяет методы, с различными уровнями видимость и отображает значения их <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, и <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Языки Visual Basic и C# не может определить методы с <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> видимости, что уровень доступа отображается только в примере C++.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>Gets a value indicating whether the potential visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</source>
          <target state="translated">Возвращает значение, которое указывает, описана ли потенциальная доступность этого метода или конструктора в поле <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>; другими словами, этот метод или конструктор может вызываться в производных классах независимо от их расположения, а также в классах той же сборки.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если доступность этого метода или конструктора точно описана в поле <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>; в обратном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>If a type member has <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</source>
          <target state="translated">Если у элемента типа <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> видимости, он может вызываться из любого члена производного класса или любого члена в той же сборке, но не из любого другого типа.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The actual visibility of a method is limited by the visibility of its type.</source>
          <target state="translated">Фактически доступность метода ограничена доступностью его типа.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property might be <ph id="ph2">`true`</ph> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> Свойство может быть <ph id="ph2">`true`</ph> для метода, но если он является метод закрытого вложенного типа метода не отображается за пределами содержащего типа.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> if the visibility modifier is <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++).</source>
          <target state="translated">Видимость метод или конструктор точно описываемого <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> Если модификатор видимости <ph id="ph2">`protected internal`</ph> в C# (<ph id="ph3">`Protected Friend`</ph> в Visual Basic <ph id="ph4">`protected public`</ph> в C++).</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">В следующем примере кода определяет методы, с различными уровнями видимость и отображает значения их <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, и <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Языки Visual Basic и C# не может определить методы с <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> видимости, что уровень доступа отображается только в примере C++.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>Gets a value indicating whether this method is <ph id="ph1">&lt;see langword="final" /&gt;</ph>.</source>
          <target state="translated">Возвращает значение, указывающее, является ли метод <ph id="ph1">&lt;see langword="final" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is <ph id="ph2">&lt;see langword="final" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если этот метод имеет значение <ph id="ph2">&lt;see langword="final" /&gt;</ph>. В противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>To determine if a method is overridable, it is not sufficient to check that <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsVirtual%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Чтобы определить, если метод является переопределяемым, не достаточно, чтобы убедиться, что <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsVirtual%2A&gt;</ph> — <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>For a method to be overridable, <ph id="ph1">`IsVirtual`</ph> must be <ph id="ph2">`true`</ph> and <ph id="ph3">`IsFinal`</ph> must be <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Для метода для переопределения <ph id="ph1">`IsVirtual`</ph> должно быть <ph id="ph2">`true`</ph> и <ph id="ph3">`IsFinal`</ph> должен быть <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>For example, a method might be non-virtual, but it implements an interface method.</source>
          <target state="translated">Например может быть невиртуальный метод, но он реализует метод интерфейса.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>The common language runtime requires that all methods that implement interface members must be marked as <ph id="ph1">`virtual`</ph>; therefore, the compiler marks the method <ph id="ph2">`virtual final`</ph>.</source>
          <target state="translated">Общеязыковая среда выполнения требует, чтобы все методы, которые реализуют члены интерфейса должен быть помечен как <ph id="ph1">`virtual`</ph>; таким образом, компилятор отмечает метод <ph id="ph2">`virtual final`</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>So there are cases where a method is marked as <ph id="ph1">`virtual`</ph> but is still not overridable.</source>
          <target state="translated">Возможны случаи, когда метод, помеченный как <ph id="ph1">`virtual`</ph> по-прежнему не является переопределяемым.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>To establish with certainty whether a method is overridable, use code such as this:</source>
          <target state="translated">Чтобы однозначно установить, является ли метод переопределяемым, воспользуйтесь следующим кодом:</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>If <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`false`</ph> or <ph id="ph3">`IsFinal`</ph> is <ph id="ph4">`true`</ph>, then the method cannot be overridden.</source>
          <target state="translated">Если <ph id="ph1">`IsVirtual`</ph> — <ph id="ph2">`false`</ph> или <ph id="ph3">`IsFinal`</ph> — <ph id="ph4">`true`</ph>, а затем метод не может быть переопределен.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>The following example displays <ph id="ph1">`false`</ph> for <ph id="ph2">`IsFinal`</ph>, which might lead you to think that MyMethod is overridable.</source>
          <target state="translated">В следующем примере отображается <ph id="ph1">`false`</ph> для <ph id="ph2">`IsFinal`</ph>, что могло что MyMethod является переопределяемым.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>The code prints <ph id="ph1">`false`</ph> even though MyMethod is not marked <ph id="ph2">`virtual`</ph> and thus cannot be overridden.</source>
          <target state="translated">Код печатает <ph id="ph1">`false`</ph> несмотря на то, что не помечен как MyMethod <ph id="ph2">`virtual`</ph> и поэтому не может быть переопределен.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Gets a value indicating whether the method is generic.</source>
          <target state="translated">Возвращает значение, указывающее, является ли этот метод универсальным.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> represents a generic method; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий объект <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> представляет универсальный метод; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> object represents a generic method.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> свойства, чтобы определить ли текущий <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> объект представляет универсальный метод.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> object represents an open constructed method or a closed constructed method.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> свойства, чтобы определить ли текущий <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> представляет открытым сконструированным методом или закрытым сконструированным методом.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Generics are not supported by default; this property returns <ph id="ph1">`false`</ph> if not overridden in a derived class.</source>
          <target state="translated">Универсальные шаблоны не поддерживаются по умолчанию. Это свойство возвращает <ph id="ph1">`false`</ph> Если не переопределен в производном классе.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <ph id="ph1">`false`</ph> if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">Универсальные конструкторы не поддерживаются в платформе .NET Framework версии 2.0, поэтому это свойство возвращает <ph id="ph1">`false`</ph> текущего экземпляра имеет тип <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The following table summarizes the invariant conditions for terms specific to generic methods.</source>
          <target state="translated">В следующей таблице перечислены неизменяемых условий для конкретных универсальных методов.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>For other terms used in generic reflection, such as <bpt id="p1">*</bpt>generic type parameter<ept id="p1">*</ept> and <bpt id="p2">*</bpt>generic type<ept id="p2">*</ept>, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Другие условия, используемые в отражении универсальных объектов, такие как <bpt id="p1">*</bpt>параметр универсального типа<ept id="p1">*</ept> и <bpt id="p2">*</bpt>универсального типа<ept id="p2">*</ept>, в разделе <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Term</source>
          <target state="translated">Термин</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Invariant condition</source>
          <target state="translated">Инвариантное условие</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>generic method definition</source>
          <target state="translated">Определение универсального метода.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Значение свойства <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition&gt;</ph> — <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Defines a generic method.</source>
          <target state="translated">Определяет универсальный метод.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>A constructed method is created by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition, and specifying an array of type arguments.</source>
          <target state="translated">Сконструированный метод создается путем вызова <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> метод <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объект, представляющий определение универсального метода и указав массив аргументов типа.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method can be called only on generic method definitions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> Метод может вызываться только для определения универсального метода.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Any generic method definition is a generic method, but the converse is not true.</source>
          <target state="translated">Любое определение универсального метода является универсальным методом, но обратное неверно.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>generic method</source>
          <target state="translated">универсальный метод</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">`IsGenericMethod`</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Значение свойства <ph id="ph1">`IsGenericMethod`</ph> — <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Can be a generic method definition, an open constructed method, or a closed constructed method.</source>
          <target state="translated">Может быть определением универсального метода, открытым сконструированным методом или закрытым сконструированным методом.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>open constructed method</source>
          <target state="translated">сконструированный метод Open</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Значение свойства <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> — <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>It is not possible to invoke an open constructed method.</source>
          <target state="translated">Не поддерживается для вызова открытым сконструированным методом.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>closed constructed method</source>
          <target state="translated">закрытый сконструированный метод</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> property is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Значение свойства <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> — <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>When examined recursively, the method has no unassigned generic parameters.</source>
          <target state="translated">При рекурсивном метод не имеет неназначенные универсальных параметров.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The containing type has no generic type parameters, and none of the type arguments have generic type parameters.</source>
          <target state="translated">Содержащий тип не имеет универсальных параметров типа, и ни один из аргументов типа не имеет параметров универсального типа.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The method can be invoked.</source>
          <target state="translated">Метод может быть вызван.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>Gets a value indicating whether the method is a generic method definition.</source>
          <target state="translated">Возвращает значение, указывающее, является ли этот метод определением универсального метода.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object represents the definition of a generic method; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий объект <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> представляет определение универсального метода; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> represents a generic method definition, then:</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> представляет определение универсального метода, затем:</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Значение свойства <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> — <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>For each <ph id="ph1">&lt;xref:System.Type&gt;</ph> object in the array returned by the <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> method:</source>
          <target state="translated">Для каждого <ph id="ph1">&lt;xref:System.Type&gt;</ph> объект в массиве, возвращенном <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> метод:</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Значение свойства <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType&gt;</ph> — <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType&gt;</ph> property returns the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType&gt;</ph> Свойство возвращает текущий экземпляр.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType&gt;</ph> property is the same as the position of the <ph id="ph2">&lt;xref:System.Type&gt;</ph> object in the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType&gt;</ph> Имеет то же, как позицию <ph id="ph2">&lt;xref:System.Type&gt;</ph> объект в массиве.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>Generics are not supported by default; this property returns <ph id="ph1">`false`</ph> if not overridden in a derived class.</source>
          <target state="translated">Универсальные шаблоны не поддерживаются по умолчанию. Это свойство возвращает <ph id="ph1">`false`</ph> Если не переопределен в производном классе.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <ph id="ph1">`false`</ph> if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">Универсальные конструкторы не поддерживаются в платформе .NET Framework версии 2.0, поэтому это свойство возвращает <ph id="ph1">`false`</ph> текущего экземпляра имеет тип <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Список неизменяемых условий для конкретных универсальных методов см. в разделе <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Список неизменяемых условий для других терминов, используемых в универсальном отражении см. в разделе <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</source>
          <target state="translated">Возвращает значение, указывающее, скрывается ли в производном классе только член такого же вида с точно такой же сигнатурой.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the member is hidden by signature; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если член скрыт на основе сигнатуры; в обратном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>When a member in a derived class is declared with the C# <ph id="ph1">`new`</ph> modifier or the Visual Basic <ph id="ph2">`Shadows`</ph> modifier, it can hide a member of the same name in the base class.</source>
          <target state="translated">Если член в производном классе объявлена с помощью C# <ph id="ph1">`new`</ph> модификатор или Visual Basic <ph id="ph2">`Shadows`</ph> модификатор, его можно скрыть член с тем же именем в базовом классе.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>C# hides base class members by signature.</source>
          <target state="translated">C# скрывает члены базового класса на основе подписи.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature.</source>
          <target state="translated">Если член базового класса существует несколько перегруженных версий, единственный, который является скрытым является один с идентичную сигнатуру.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>By contrast, Visual Basic hides all the base class overloads.</source>
          <target state="translated">В отличие от этого Visual Basic скрывает все перегруженные версии базового класса.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>Thus, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> returns <ph id="ph2">`false`</ph> on a member declared with the Visual Basic <ph id="ph3">`Shadows`</ph> modifier, and <ph id="ph4">`true`</ph> on a member declared with the C# <ph id="ph5">`new`</ph> modifier.</source>
          <target state="translated">Таким образом <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> возвращает <ph id="ph2">`false`</ph> на элемент, объявленный с помощью Visual Basic <ph id="ph3">`Shadows`</ph> модификатор, и <ph id="ph4">`true`</ph> на элемент, объявленный с помощью C# <ph id="ph5">`new`</ph> модификатор.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>This property does not determine whether a method has the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute.</source>
          <target state="translated">Это свойство определяет, есть ли метод <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>A method that is declared with either the <ph id="ph1">`new`</ph> or the <ph id="ph2">`Shadows`</ph> modifier will have the <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, but only methods declared with <ph id="ph4">`new`</ph> (that is, only C# methods) will have the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> property set to <ph id="ph6">`true`</ph>.</source>
          <target state="translated">Метод, объявленный с помощью <ph id="ph1">`new`</ph> или <ph id="ph2">`Shadows`</ph> будет иметь модификатор <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> атрибут, но только методы, объявленные с <ph id="ph4">`new`</ph> (то есть только методы C#) будет иметь <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> свойства <ph id="ph6">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>To determine whether a method has the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, use code similar to the following: <ph id="ph2">`if ((myMethodInfo.Attributes &amp; MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)`</ph> in C# or <ph id="ph3">`If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot`</ph> in Visual Basic.</source>
          <target state="translated">Чтобы определить, является ли метод <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> атрибут, используйте код, аналогичный следующему: <ph id="ph2">`if ((myMethodInfo.Attributes &amp; MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)`</ph> в C# или <ph id="ph3">`If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot`</ph> в Visual Basic.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>Note, however, that although all methods declared with <ph id="ph1">`new`</ph> or <ph id="ph2">`Shadows`</ph> have the <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, not all methods that have the <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute are declared with <ph id="ph5">`new`</ph> or <ph id="ph6">`Shadows`</ph>.</source>
          <target state="translated">Тем не менее, несмотря на то, что все методы объявлены с <ph id="ph1">`new`</ph> или <ph id="ph2">`Shadows`</ph> имеют <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> атрибут, не все методы, которые имеют <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> атрибута должны быть объявлены с <ph id="ph5">`new`</ph> или <ph id="ph6">`Shadows`</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads.</source>
          <target state="translated">В следующем примере кода содержит базовый класс с перегруженным методом и производный класс, который скрывает одну из перегрузок.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>In the Visual Basic version of the code example, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for the member in the derived class.</source>
          <target state="translated">В версии Visual Basic в примере кода <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> возвращает <ph id="ph2">`false`</ph> для члена в производном классе.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>In the C# version of the code sample, the property returns <ph id="ph1">`true`</ph> for the member in the derived class.</source>
          <target state="translated">В C# версии образца кода, это свойство возвращает <ph id="ph1">`true`</ph> для члена в производном классе.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsPrivate">
          <source>Gets a value indicating whether this member is private.</source>
          <target state="translated">Возвращает значение, указывающее, является ли этот член закрытым.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPrivate">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method is restricted to other members of the class itself; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если доступ к этому методу разрешен только элементам данного класса, в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPrivate">
          <source>If a type member has <ph id="ph1">`Private`</ph> level visibility, it can be called from any member in the same class and no others.</source>
          <target state="translated">Если у элемента типа <ph id="ph1">`Private`</ph> видимость на уровне, может вызываться из любого члена класса, но не других.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>Gets a value indicating whether this is a public method.</source>
          <target state="translated">Возвращает значение, указывающее, является ли метод открытым.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is public; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если метод является открытым; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, first get the type.</source>
          <target state="translated">Для получения <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, сначала нужно получить тип.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>From the type, get the method.</source>
          <target state="translated">Из типа которого вызывается метод.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>From the method, get the <ph id="ph1">`MethodBase`</ph>.</source>
          <target state="translated">С помощью метода get <ph id="ph1">`MethodBase`</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>If the <ph id="ph1">`MethodBase`</ph> or constructor is other than public, it is protected and cannot be readily accessed.</source>
          <target state="translated">Если <ph id="ph1">`MethodBase`</ph> или конструктор не являются открытыми, они защищены и не может быть непосредственно доступны.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>To access a non-public method, set the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> mask to <ph id="ph2">`NonPublic`</ph> in <ph id="ph3">`GetMethod`</ph>.</source>
          <target state="translated">Для обращения к методу, не являющиеся открытыми, установите <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> для маски <ph id="ph2">`NonPublic`</ph> в <ph id="ph3">`GetMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> property to display a message that indicates whether the specified method is public.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> свойство для отображения сообщение, указывающее, является ли указанный метод открытым.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</source>
          <target state="translated">Получает значение, которое указывает, является ли текущий метод или конструктор критически важным для безопасности или защищенным критически важным для безопасности на данном уровне доверия и, следовательно, может ли он выполнять критические операции.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий метод или конструктор является критически важным для безопасности или защищенным критически важным для безопасности на текущем уровне доверия; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, если он является прозрачным.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, И <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> свойства отчетов уровень прозрачности метод или конструктор в его текущем уровне доверия, что определяется общеязыковой среды выполнения (CLR).</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">В следующей таблице показаны сочетания этих свойств.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">Уровень безопасности</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Safe critical</source>
          <target state="translated">Надежным с точки зрения</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Использовать эти свойства гораздо проще, чем просматривать заметки безопасности сборки и ее типов и членов, проверять текущий уровень доверия и пытаться Дублировать правила среды выполнения.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Если сборка загружается в домен приложения с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">Сборка и все типы считаются прозрачными.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Среда выполнения уделяет внимание заметки безопасности сборки с частичным доверием, только в том случае, если эта сборка загружается в домен приложения с полным доверием (например, в домене приложения по умолчанию для настольного приложения).</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">В отличие от этого доверенной сборке (то есть сборки строгим именем, установленной в глобальном кэше сборок) всегда является загружена с полным доверием независимо от уровня доверия домена приложения, поэтому ее текущий уровень доверия всегда является полностью доверенным.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Можно определить текущие уровни доверия сборок и доменов приложений с помощью <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о отражение и прозрачность см. в разделе <bpt id="p1">[</bpt>рекомендации по безопасности для отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Сведения о прозрачности см. в разделе <bpt id="p1">[</bpt>изменения системы безопасности<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">Получает значение, которое указывает, является ли текущий динамический метод или конструктор защищенным критически важным для безопасности и, следовательно, может ли он выполнять критические операции и предоставлять доступ прозрачному коду.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method or constructor is security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий метод или конструктор является защищенным критически важным для безопасности на текущем уровне доверия; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, если он является критически важным для безопасности или прозрачным.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, И <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> свойства отчетов уровень прозрачности метод или конструктор в его текущем уровне доверия, что определяется общеязыковой среды выполнения (CLR).</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">В следующей таблице показаны сочетания этих свойств.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">Уровень безопасности</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Safe critical</source>
          <target state="translated">Надежным с точки зрения</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Использовать эти свойства гораздо проще, чем просматривать заметки безопасности сборки и ее типов и членов, проверять текущий уровень доверия и пытаться Дублировать правила среды выполнения.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Если сборка загружается в домен приложения с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">Сборка и все типы считаются прозрачными.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Среда выполнения уделяет внимание заметки безопасности сборки с частичным доверием, только в том случае, если эта сборка загружается в домен приложения с полным доверием (например, в домене приложения по умолчанию для настольного приложения).</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">В отличие от этого доверенной сборке (то есть сборки строгим именем, установленной в глобальном кэше сборок) всегда является загружена с полным доверием независимо от уровня доверия домена приложения, поэтому ее текущий уровень доверия всегда является полностью доверенным.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Можно определить текущие уровни доверия сборок и доменов приложений с помощью <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о отражение и прозрачность см. в разделе <bpt id="p1">[</bpt>рекомендации по безопасности для отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Сведения о прозрачности см. в разделе <bpt id="p1">[</bpt>изменения системы безопасности<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</source>
          <target state="translated">Получает значение, которое указывает, является ли текущий метод или конструктор прозрачным на текущем уровне доверия и, следовательно, не может выполнять критические операции.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method or constructor is security-transparent at the current trust level; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если метод или конструктор является прозрачным на текущем уровне доверия; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>If this property returns <ph id="ph1">`true`</ph>, the <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> properties return <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Если это свойство возвращает <ph id="ph1">`true`</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> и <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> возвращаемого свойства <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, И <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> свойства отчетов уровень прозрачности метод или конструктор в его текущем уровне доверия, что определяется общеязыковой среды выполнения (CLR).</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Использовать эти свойства гораздо проще, чем просматривать заметки безопасности сборки и ее типов и членов, проверять текущий уровень доверия и пытаться Дублировать правила среды выполнения.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Если сборка загружается в домен приложения с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">Сборка и все типы считаются прозрачными.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Среда выполнения уделяет внимание заметки безопасности сборки с частичным доверием, только в том случае, если эта сборка загружается в домен приложения с полным доверием (например, в домене приложения по умолчанию для настольного приложения).</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">В отличие от этого доверенной сборке (то есть сборки строгим именем, установленной в глобальном кэше сборок) всегда является загружена с полным доверием независимо от уровня доверия домена приложения, поэтому ее текущий уровень доверия всегда является полностью доверенным.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Можно определить текущие уровни доверия сборок и доменов приложений с помощью <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о отражение и прозрачность см. в разделе <bpt id="p1">[</bpt>рекомендации по безопасности для отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Сведения о прозрачности см. в разделе <bpt id="p1">[</bpt>изменения системы безопасности<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source>Gets a value indicating whether this method has a special name.</source>
          <target state="translated">Возвращает значение, указывающее, имеет ли этот метод специальное имя.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method has a special name; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если у этого метода имеется специальное имя; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph> Бит равен отметить члены, которые обрабатываются особым образом, в некоторых компиляторах (например, к свойствам и методы перегрузки операторов).</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source>This example shows a use of <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSpecialName%2A&gt;</ph> to filter internal or private members out of a list.</source>
          <target state="translated">В этом примере показано использование <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSpecialName%2A&gt;</ph> исключить внутренние и закрытые члены из списка.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsStatic">
          <source>Gets a value indicating whether the method is <ph id="ph1">&lt;see langword="static" /&gt;</ph>.</source>
          <target state="translated">Получает значение, указывающее, имеет ли метод значение <ph id="ph1">&lt;see langword="static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsStatic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is <ph id="ph2">&lt;see langword="static" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если этот метод имеет значение <ph id="ph2">&lt;see langword="static" /&gt;</ph>. В противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsStatic">
          <source>A static member cannot implicitly reference instance data in a class.</source>
          <target state="translated">Статический член не может неявно обращаться к данным экземпляра в классе.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>Gets a value indicating whether the method is <ph id="ph1">&lt;see langword="virtual" /&gt;</ph>.</source>
          <target state="translated">Получает значение, указывающее, имеет ли метод значение <ph id="ph1">&lt;see langword="virtual" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is <ph id="ph2">&lt;see langword="virtual" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если этот метод имеет значение <ph id="ph2">&lt;see langword="virtual" /&gt;</ph>. В противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>A virtual member may reference instance data in a class and must be referenced through an instance of the class.</source>
          <target state="translated">Виртуальный член может обращаться к данным экземпляра в классе и должна быть ссылка через экземпляр класса.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>To determine if a method is overridable, it is not sufficient to check that <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Чтобы определить, если метод является переопределяемым, не достаточно, чтобы убедиться, что <ph id="ph1">`IsVirtual`</ph> — <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>For a method to be overridable, <ph id="ph1">`IsVirtual`</ph> must be <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFinal%2A&gt;</ph> must be <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Для метода для переопределения <ph id="ph1">`IsVirtual`</ph> должно быть <ph id="ph2">`true`</ph> и <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFinal%2A&gt;</ph> должен быть <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>For example, a method might be non-virtual, but it implements an interface method.</source>
          <target state="translated">Например может быть невиртуальный метод, но он реализует метод интерфейса.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The common language runtime requires that all methods that implement interface members must be marked as <ph id="ph1">`virtual`</ph>; therefore, the compiler marks the method <ph id="ph2">`virtual final`</ph>.</source>
          <target state="translated">Общеязыковая среда выполнения требует, чтобы все методы, которые реализуют члены интерфейса должен быть помечен как <ph id="ph1">`virtual`</ph>; таким образом, компилятор отмечает метод <ph id="ph2">`virtual final`</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>So there are cases where a method is marked as <ph id="ph1">`virtual`</ph> but is still not overridable.</source>
          <target state="translated">Возможны случаи, когда метод, помеченный как <ph id="ph1">`virtual`</ph> по-прежнему не является переопределяемым.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>To establish with certainty whether a method is overridable, use code such as this:</source>
          <target state="translated">Чтобы однозначно установить, является ли метод переопределяемым, воспользуйтесь следующим кодом:</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>If <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`false`</ph> or <ph id="ph3">`IsFinal`</ph> is <ph id="ph4">`true`</ph>, then the method cannot be overridden.</source>
          <target state="translated">Если <ph id="ph1">`IsVirtual`</ph> — <ph id="ph2">`false`</ph> или <ph id="ph3">`IsFinal`</ph> — <ph id="ph4">`true`</ph>, а затем метод не может быть переопределен.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>You can determine whether the current method overrides a method in a base class by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Можно определить, является ли текущий метод переопределяет метод в базовом классе путем вызова <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The following example implements an <ph id="ph1">`IsOverride`</ph> method that does this.</source>
          <target state="translated">В следующем примере реализуется <ph id="ph1">`IsOverride`</ph> метод, который делает это.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The following example displays <ph id="ph1">`false`</ph> for <ph id="ph2">`IsFinal`</ph>, which might lead you to think that <ph id="ph3">`MyMethod`</ph> is overridable.</source>
          <target state="translated">В следующем примере отображается <ph id="ph1">`false`</ph> для <ph id="ph2">`IsFinal`</ph>, что могло показаться, что <ph id="ph3">`MyMethod`</ph> является переопределяемым.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The code prints <ph id="ph1">`false`</ph> even though <ph id="ph2">`MyMethod`</ph> is not marked <ph id="ph3">`virtual`</ph> and thus cannot be overridden.</source>
          <target state="translated">Код печатает <ph id="ph1">`false`</ph> несмотря на то что <ph id="ph2">`MyMethod`</ph> не помечен как <ph id="ph3">`virtual`</ph> и поэтому не может быть переопределен.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.MethodHandle">
          <source>Gets a handle to the internal metadata representation of a method.</source>
          <target state="translated">Возвращает дескриптор представления внутренних метаданных метода.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodHandle">
          <source>A <ph id="ph1">&lt;see cref="T:System.RuntimeMethodHandle" /&gt;</ph> object.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.RuntimeMethodHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodHandle">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Дескрипторы доступны только в домене приложения, в котором они были получены.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.MethodImplementationFlags">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags that specify the attributes of a method implementation.</source>
          <target state="translated">Получает флаги <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph>, указывающие атрибуты реализации методы.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodImplementationFlags">
          <source>The method implementation flags.</source>
          <target state="translated">Флаги реализации метода.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodImplementationFlags">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> method for more information.</source>
          <target state="translated">Дополнительные сведения см. в описании метода <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The first object to compare.</source>
          <target state="translated">Первый из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The second object to compare.</source>
          <target state="translated">Второй из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> objects are equal.</source>
          <target state="translated">Определение равенства двух объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значения параметров <ph id="ph2">&lt;paramref name="left" /&gt;</ph> и <ph id="ph3">&lt;paramref name="right" /&gt;</ph> равны; в противном случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The first object to compare.</source>
          <target state="translated">Первый из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The second object to compare.</source>
          <target state="translated">Второй из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Определяет неравенство двух объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значения <ph id="ph2">&lt;paramref name="left" /&gt;</ph> и <ph id="ph3">&lt;paramref name="right" /&gt;</ph> не равны; в противном случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Зарезервировано для будущего использования.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Должно быть равным IID_NULL.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Переданный массив имен, которые необходимо сопоставить.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Количество сопоставляемых имен.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Контекст языкового стандарта для интерпретации имен.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Возвращаемые сведения о типе.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Идентификатор языкового стандарта для сведений о типе.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Получает указатель на объект с запрошенными сведениями о типе.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Идентифицирует член.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Зарезервировано для будущего использования.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Должно быть равным IID_NULL.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Флаги, описывающие контекст вызова.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Указатель, по которому будет сохранен результат.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Указатель на структуру, содержащую сведения об исключении.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Индекс первого аргумента, вызвавшего ошибку.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Предоставляет доступ к открытым свойствам и методам объекта.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::Invoke`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>