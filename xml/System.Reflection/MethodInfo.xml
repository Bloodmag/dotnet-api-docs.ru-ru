<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MethodInfo.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-567ae5a" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3cf4df88-236b-4f49-aebe-6184303eadc31db341516e40895b598e4179337fa6c67cfc445c.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1db341516e40895b598e4179337fa6c67cfc445c</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1465f1a9bce3970cd9e95769eaa641b92a0a22d5</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/18/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodInfo">
          <source>Discovers the attributes of a method and provides access to method metadata.</source>
          <target state="translated">Выявляет атрибуты метода и обеспечивает доступ к его метаданным.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class represents a method of a type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> Класс представляет метод типа.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can use a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object to obtain information about the method that the object represents and to invoke the method.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объекта, чтобы получить сведения о методе, который представляет объект и вызова метода.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>For example:</source>
          <target state="translated">Пример:</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can determine the method's visibility by retrieving the values of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsPrivate%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> properties.</source>
          <target state="translated">Можно определить видимость метода путем извлечения значений из <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsPrivate%2A&gt;</ph>, и <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can discover what attributes are applied to the method by retrieving the value of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Attributes%2A&gt;</ph> property or calling the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A&gt;</ph> method.</source>
          <target state="translated">Вы можете узнать, какие атрибуты применяются к методу, получая значение <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Attributes%2A&gt;</ph> свойства или метода <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can determine whether the method is a generic method, an open constructed generic method, or a closed constructed generic method, by retrieving the values of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> properties.</source>
          <target state="translated">Можно определить, является ли универсальный метод открытого сконструированного универсального типа или закрытый сконструированного универсального типа, получая значения из <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can get information about the method's parameters and return type from the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.ReturnParameter%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> properties.</source>
          <target state="translated">Можно получить сведения о параметрах метода и возвращаемый тип из <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> метод и <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.ReturnParameter%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A&gt;</ph>, и <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can execute a method on a class instance by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">Можно выполнить метод в экземпляре класса путем вызова <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a constructed generic method from one that represents a generic method definition by calling the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method.</source>
          <target state="translated">Можно создать экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объект, который представляет сконструированный универсальный метод из одного, представляющий определение универсального метода, вызвав <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> instances by calling the <ph id="ph2">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Type.GetMethod%2A?displayProperty=nameWithType&gt;</ph> method, or by calling the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method of a <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition.</source>
          <target state="translated">Можно создать экземпляр <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> экземпляры путем вызова <ph id="ph2">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph3">&lt;xref:System.Type.GetMethod%2A?displayProperty=nameWithType&gt;</ph> метод, или путем вызова <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> метод <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , представляющий определение универсального метода.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Список неизменяемых условий для конкретных универсальных методов см. в разделе <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">Список неизменяемых условий для других терминов, используемых в универсальном отражении см. в разделе <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>for full trust for inheritors.</source>
          <target state="translated">для полного доверия для разработчиков производных классов.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">Этот класс не наследуется частично доверенным кодом.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>This type is thread safe.</source>
          <target state="translated">Данный тип потокобезопасен.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>When you inherit from <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, you must override <ph id="ph2">&lt;see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" /&gt;</ph>, <ph id="ph3">&lt;see cref="P:System.Reflection.MethodInfo.ReturnType" /&gt;</ph>, <ph id="ph4">&lt;see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" /&gt;</ph>, <ph id="ph5">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph6">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph9">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph11">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph12">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph13">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph14">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph>, <ph id="ph15">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, and <ph id="ph16">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</source>
          <target state="translated">При наследовании от <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, необходимо переопределить <ph id="ph2">&lt;see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" /&gt;</ph>, <ph id="ph3">&lt;see cref="P:System.Reflection.MethodInfo.ReturnType" /&gt;</ph>, <ph id="ph4">&lt;see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" /&gt;</ph>, <ph id="ph5">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph6">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph9">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph11">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph12">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph13">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph14">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph>, <ph id="ph15">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, и <ph id="ph16">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodInfo">
          <source>Creates a delegate from this method.</source>
          <target state="translated">Создает делегат из этого метода.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)">
          <source>The type of the delegate to create.</source>
          <target state="translated">Тип создаваемого делегата.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)">
          <source>Creates a delegate of the specified type from this method.</source>
          <target state="translated">Создает делегат заданного типа из этого метода.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)">
          <source>The delegate for this method.</source>
          <target state="translated">Делегат для этого метода.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>The type of the delegate to create.</source>
          <target state="translated">Тип создаваемого делегата.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>The object targeted by the delegate.</source>
          <target state="translated">Целевой объект для делегата.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>Creates a delegate of the specified type with the specified target from this method.</source>
          <target state="translated">Создает делегат заданного типа с заданным целевым объектом из этого метода.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>The delegate for this method.</source>
          <target state="translated">Делегат для этого метода.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.Equals(System.Object)">
          <source>An object to compare with this instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, сравниваемый с этим экземпляром, или значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.Equals(System.Object)">
          <source>Returns a value that indicates whether this instance is equal to a specified object.</source>
          <target state="translated">Возвращает значение, показывающее, равен ли экземпляр указанному объекту.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> equals the type and value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение параметра <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> равно типу и значению данного экземпляра; в противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object for the method on the direct or indirect base class in which the method represented by this instance was first declared.</source>
          <target state="translated">Если переопределено в производном классе, возвращает объект <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> для метода в прямом или косвенном базовом классе, в котором был первоначально объявлен метод, предоставляемый этим экземпляром.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object for the first implementation of this method.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> для первой реализации этого метода.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the first definition of the specified method in the class hierarchy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> Метод возвращает первое определение заданного метода в иерархии классов.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>You can determine the type on which the first definition of the method is found by retrieving the value of the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">Можно определить тип, на котором находится первое определение метода, получая значение <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> свойство в возвращенном <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method behaves as follows:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> Метод ведет себя следующим образом:</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents an interface implementation, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the current <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объект представляет собой реализацию интерфейса <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> метод возвращает текущий <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents a method that overrides a virtual definition in a base class, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the virtual definition.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объект представляет метод, который переопределяет виртуальное определение в базовом классе, <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> возвращает <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , представляющий виртуальный definition.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents a method that is specified with the <ph id="ph2">`new`</ph> keyword in C# or the <ph id="ph3">`Shadows`</ph> keyword in Visual Basic (as in <ph id="ph4">`newslot`</ph>, as described in <bpt id="p1">[</bpt>Common Type System<ept id="p1">](~/docs/standard/base-types/common-type-system.md)</ept>), the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the current <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объект представляет метод, который указан с <ph id="ph2">`new`</ph> ключевого слова C# или <ph id="ph3">`Shadows`</ph> ключевого слова в Visual Basic (как в <ph id="ph4">`newslot`</ph>, как описано в <bpt id="p1">[</bpt>система общих типов CTS<ept id="p1">](~/docs/standard/base-types/common-type-system.md)</ept>), <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> метод возвращает текущий <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents an inherited method (that is, the current method does not provide its own implementation), the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the lowest method in the class hierarchy.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> унаследованный метод представляет объект (то есть, текущий метод не предоставляет собственной реализации), <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> возвращает <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , представляющий наименьшее метода в иерархии классов.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>For example, if <ph id="ph1">`Base.ToString`</ph> overrides <ph id="ph2">`Object.ToString`</ph>, and <ph id="ph3">`Derived.ToString`</ph> overrides <ph id="ph4">`Base.ToString`</ph>, calling the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method on a <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph7">`Derived.ToString`</ph> returns a <ph id="ph8">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph9">`Object.ToString`</ph>.</source>
          <target state="translated">Например если <ph id="ph1">`Base.ToString`</ph> переопределяет <ph id="ph2">`Object.ToString`</ph>, и <ph id="ph3">`Derived.ToString`</ph> переопределяет <ph id="ph4">`Base.ToString`</ph>, вызов <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> метод <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , представляющий <ph id="ph7">`Derived.ToString`</ph> возвращает <ph id="ph8">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , представляющий <ph id="ph9">`Object.ToString`</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents a method that is not present in any base class, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the current <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объект представляет метод, который отсутствует в любой базовый класс <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> метод возвращает текущий <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>You can determine whether the current method overrides a method in a base class by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method.</source>
          <target state="translated">Можно определить, является ли текущий метод переопределяет метод в базовом классе путем вызова <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The following example implements an <ph id="ph1">`IsOverride`</ph> method that does this.</source>
          <target state="translated">В следующем примере реализуется <ph id="ph1">`IsOverride`</ph> метод, который делает это.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>To call the <ph id="ph1">`GetBaseDefinition`</ph> method:</source>
          <target state="translated">Для вызова <ph id="ph1">`GetBaseDefinition`</ph> метод:</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the type (the class or structure) that contains the property.</source>
          <target state="translated">Получить <ph id="ph1">&lt;xref:System.Type&gt;</ph> , представляющий тип (класс или структура), содержащий свойство.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If you are working with an object (an instance of a type), you can call its <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method.</source>
          <target state="translated">Если вы работаете с объектом (экземпляр типа), можно вызвать его <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Otherwise, you can use the C#  operator or the Visual Basic  operator, as the example illustrates.</source>
          <target state="translated">В противном случае можно использовать оператор C# или Visual Basic оператор, как показано в примере.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Get a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the method in which you're interested.</source>
          <target state="translated">Получить <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , представляющий метод, в котором вы заинтересованы.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>You can do this by getting an array of all methods from the <ph id="ph1">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph> method and then iterating the elements in the array, or you can retrieve the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the method directly by calling the <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType&gt;</ph> method and specifying the method name.</source>
          <target state="translated">Это можно сделать путем получения массив все методы из <ph id="ph1">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph> метода и затем итерация элементов в массиве, или можно извлечь <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , представляющий непосредственно, путем вызова метода <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType&gt;</ph> и задав Имя метода.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Call the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method to get the value of the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the base method definition.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> метод, чтобы получить значение <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , представляющий определение базового метода.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The following example demonstrates the behavior of the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере показано поведение <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, которые представляют аргументы универсального метода, относящиеся к типу, или параметры типа определения универсального метода.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющих аргументы типа, относящиеся к универсальному методу, или параметры типа определения универсального метода.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>Returns an empty array if the current method is not a generic method.</source>
          <target state="translated">Возвращает пустой массив, если текущий метод не является универсальным методом.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</source>
          <target state="translated">Элементы возвращаемого массива, в том порядке, в котором они отображаются в списке параметров типа для универсального метода.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>If the current method is a closed constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic method definition.</source>
          <target state="translated">Если текущий метод является закрытым сконструированным методом (то есть <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> возвращает <ph id="ph2">`false`</ph>), массив, возвращаемый методом <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> метод содержит типы, которые были назначены для параметров универсального типа для универсального метода Определение.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>If the current method is a generic method definition, the array contains the type parameters.</source>
          <target state="translated">Если текущий метод является определением универсального метода, массив содержит параметры типа.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>If the current method is an open constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</source>
          <target state="translated">Если текущий метод является открытым сконструированным методом (то есть <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> возвращает <ph id="ph2">`true`</ph>) в определенные типы были назначены для некоторых параметров типа и типа параметров, включающих универсальные типы были назначены другого типа содержит массив параметров, типов и типов параметров.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> свойство, чтобы отличить друг от друга.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>For a demonstration of this scenario, see the code example for the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">Для демонстрации этого сценария, см. пример кода для <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Список неизменяемых условий для конкретных универсальных методов см. в разделе <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Список неизменяемых условий для других терминов, используемых в универсальном отражении см. в разделе <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>The following code example shows how to get the type arguments of a generic method and display them.</source>
          <target state="translated">В следующем примере кода показано, как получить аргументы типа для универсального метода и отобразить их.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>This example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method.</source>
          <target state="translated">Данный пример является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>This method is not supported.</source>
          <target state="translated">Этот метод не поддерживается.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object that represents a generic method definition from which the current method can be constructed.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, представляющий определение универсального метода, на основе которого можно сконструировать текущий метод.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object representing a generic method definition from which the current method can be constructed.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, представляющий определение универсального метода, на основе которого может быть сконструирован текущий метод.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>A generic method definition is a template from which methods can be constructed.</source>
          <target state="translated">Определение универсального метода — это шаблон, на основе которого можно сконструировать методы.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For example, from the generic method definition <ph id="ph1">`T M&lt;T&gt;(T t)`</ph> (expressed in C# syntax; <ph id="ph2">`Function M(Of T)(ByVal tVal As T) As T`</ph> in Visual Basic) you can construct and invoke the method <ph id="ph3">`int M&lt;int&gt;(int t)`</ph> (<ph id="ph4">`Function M(Of Integer)(ByVal tVal As Integer) As Integer`</ph> in Visual Basic).</source>
          <target state="translated">Например, из определения универсального метода <ph id="ph1">`T M&lt;T&gt;(T t)`</ph> (выраженная в синтаксис C#; <ph id="ph2">`Function M(Of T)(ByVal tVal As T) As T`</ph> в Visual Basic) можно создать и вызвать метод <ph id="ph3">`int M&lt;int&gt;(int t)`</ph> (<ph id="ph4">`Function M(Of Integer)(ByVal tVal As Integer) As Integer`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>Given a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object representing this constructed method, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> method returns the generic method definition.</source>
          <target state="translated">Получает <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объект, представляющий это сконструированный метод, <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> метод возвращает определение универсального метода.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>If two constructed methods are created from the same generic method definition, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> method returns the same <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object for both methods.</source>
          <target state="translated">Если два метода сконструированный создаются из одного определения универсального метода <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> метод возвращает тот же <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объекта для обоих методов.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>If you call <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> on a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that already represents a generic method definition, it returns the current <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">При вызове метода <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> на <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> уже, представляющий определение универсального метода, то возвращается текущий <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type.</source>
          <target state="translated">Если определение универсального метода содержит универсальные параметры объявляющего типа, будет существовать определение универсального метода для каждого сконструированного типа.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For example, consider the following C#, Visual Basic, and C++ code:</source>
          <target state="translated">Например рассмотрим следующий код C#, Visual Basic и C++.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the constructed type <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> in Visual Basic), the generic method <ph id="ph3">`M`</ph> returns <ph id="ph4">`B&lt;int, S&gt;`</ph>.</source>
          <target state="translated">В сконструированном типе <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> в Visual Basic), этот универсальный метод <ph id="ph3">`M`</ph> возвращает <ph id="ph4">`B&lt;int, S&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the open type <ph id="ph1">`C&lt;T&gt;`</ph>, <ph id="ph2">`M`</ph> returns <ph id="ph3">`B&lt;T, S&gt;`</ph>.</source>
          <target state="translated">В поле Открыть введите <ph id="ph1">`C&lt;T&gt;`</ph>, <ph id="ph2">`M`</ph> возвращает <ph id="ph3">`B&lt;T, S&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In both cases, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents <ph id="ph4">`M`</ph>, so <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> can be called on both <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects.</source>
          <target state="translated">В обоих случаях <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> возвращает <ph id="ph2">`true`</ph> для <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , представляющий <ph id="ph4">`M`</ph>, поэтому <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> может быть вызван на обоих <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объектов.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the case of the constructed type, the result of calling <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> is a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that can be invoked.</source>
          <target state="translated">В случае сконструированного типа, результатом вызова метода <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> — <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> может быть вызвана.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the case of the open type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> returned by <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> cannot be invoked.</source>
          <target state="translated">В случае открытого типа <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> возвращенных <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> не могут быть вызваны.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Список неизменяемых условий для конкретных универсальных методов см. в разделе <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">Список неизменяемых условий для других терминов, используемых в универсальном отражении см. в разделе <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>The following code example shows a class with a generic method and the code required to obtain a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for the method, bind the method to type arguments, and get the original generic type definition back from the bound method.</source>
          <target state="translated">В следующем примере кода показан класс с универсальным методом и код, необходимый для получения <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> привязку метода к аргументам типа для метода и получить исходного определения универсального типа из связанный метод.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>This example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method.</source>
          <target state="translated">Данный пример является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>The current method is not a generic method.</source>
          <target state="translated">Текущий метод не является универсальным.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.IsGenericMethod" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">То есть <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.IsGenericMethod" /&gt;</ph> возвращает <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>This method is not supported.</source>
          <target state="translated">Этот метод не поддерживается.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Возвращает хэш-код данного экземпляра.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Хэш-код в виде 32-разрядного целого числа со знаком.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>An array of types to be substituted for the type parameters of the current generic method definition.</source>
          <target state="translated">Массив типов, который должен быть замещен параметрами типов текущего определения универсального метода.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic method definition, and returns a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object representing the resulting constructed method.</source>
          <target state="translated">Заменяет параметры типа элементами массива типов для определения текущего универсального метода и возвращает объект <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, представляющий итоговый сконструированный метод.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object that represents the constructed method formed by substituting the elements of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> for the type parameters of the current generic method definition.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> который представляет сконструированный метод, сформированный путем замены элементами <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> параметров типов текущего определения универсального метода.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method allows you to write code that assigns specific types to the type parameters of a generic method definition, thus creating a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a particular constructed method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> Метод позволяет написать код, который назначает определенные типы параметров типа определения универсального метода, тем самым создавая <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , представляющий определенный сконструированный метод.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property of this <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object returns <ph id="ph3">`true`</ph>, you can use it to invoke the method or to create a delegate to invoke the method.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> этого <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> возвращает <ph id="ph3">`true`</ph>, ее можно использовать для вызова метода или для создания делегата для вызова метода.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Methods constructed with the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method can be open, that is, some of their type arguments can be type parameters of enclosing generic types.</source>
          <target state="translated">Методы создаются с <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> метод может быть открыт, то есть некоторые их аргументы могут быть параметры типа включающего универсального типа.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>You might use such open constructed methods when you generate dynamic assemblies.</source>
          <target state="translated">Такие открытые сконструированные методы можно использовать при создании динамических сборок.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>For example, consider the following C#, Visual Basic, and C++ code.</source>
          <target state="translated">Например рассмотрим следующий код C#, Visual Basic и C++.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The method body of <ph id="ph1">`M`</ph> contains a call to method <ph id="ph2">`N`</ph>, specifying the type parameter of <ph id="ph3">`M`</ph> and the type <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">Тело метода <ph id="ph1">`M`</ph> содержит вызов метода <ph id="ph2">`N`</ph>, указав параметр типа <ph id="ph3">`M`</ph> и тип <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for method <ph id="ph3">`N&lt;V,int&gt;`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> Возвращает <ph id="ph2">`false`</ph> для метода <ph id="ph3">`N&lt;V,int&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, so method <ph id="ph3">`N&lt;V,int&gt;`</ph> cannot be invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> Возвращает <ph id="ph2">`true`</ph>, поэтому метод <ph id="ph3">`N&lt;V,int&gt;`</ph> не может быть вызвана.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Список неизменяемых условий для конкретных универсальных методов см. в разделе <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">Список неизменяемых условий для других терминов, используемых в универсальном отражении см. в разделе <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The following code example demonstrates the properties and methods of <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that support the examination of generic methods.</source>
          <target state="translated">В следующем примере кода показано, свойствам и методам <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , которые поддерживают анализ универсальных методов.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The example does the following:</source>
          <target state="translated">В примере выполняет следующие задачи.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Defines a class that has a generic method.</source>
          <target state="translated">Определяет класс, который содержит универсальный метод.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Creates a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents the generic method.</source>
          <target state="translated">Создает <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , представляющий универсальный метод.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Displays properties of the generic method definition.</source>
          <target state="translated">Отображаются свойства определения универсального метода.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Assigns type arguments to the type parameters of the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, and invokes the resulting constructed generic method.</source>
          <target state="translated">Задает аргументы типа для параметров типа <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>и вызывается итоговый сконструированный универсальный метод.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Displays properties of the constructed generic method.</source>
          <target state="translated">Отображаются свойства сконструированного универсального метода.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Retrieves the generic method definition from the constructed method and compares it to the original definition.</source>
          <target state="translated">Извлекает из сконструированный метод определения универсального метода и сравнивает его с исходным определением.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> does not represent a generic method definition.</source>
          <target state="translated">Текущий объект <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> не представляет определение универсального метода.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">То есть <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /&gt;</ph> возвращает <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Любой элемент <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The number of elements in <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is not the same as the number of type parameters of the current generic method definition.</source>
          <target state="translated">Число элементов <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> не равно числу параметров типа в текущем определении универсального метода.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> does not satisfy the constraints specified for the corresponding type parameter of the current generic method definition.</source>
          <target state="translated">Элемент <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> не соответствует ограничениям, указанным для соответствующего параметра типа текущего определения универсального метода.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>This method is not supported.</source>
          <target state="translated">Этот метод не поддерживается.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a method.</source>
          <target state="translated">Возвращает значение <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph>, указывающее, что этот элемент является методом.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a method.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph>, указывающее, что этот элемент является методом.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>This property overrides <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Это свойство переопределяет <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>Therefore, when you examine a set of <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects — for example, the array returned by <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph> — the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> property returns <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType&gt;</ph> only when a given member is a method.</source>
          <target state="translated">Таким образом, при рассмотрении набор <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> объектов — например, массив, возвращаемый методом <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph> — <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> возвращает <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType&gt;</ph> только в том случае, когда данный элемент является методом.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>To get the <ph id="ph1">`MemberType`</ph> property, first get the class <ph id="ph2">`Type`</ph>.</source>
          <target state="translated">Для получения <ph id="ph1">`MemberType`</ph> свойство, сначала нужно получить класс <ph id="ph2">`Type`</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`MethodInfo`</ph>.</source>
          <target state="translated">Из <ph id="ph1">`Type`</ph>, получить <ph id="ph2">`MethodInfo`</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>From the <ph id="ph1">`MethodInfo`</ph>, get the <ph id="ph2">`MemberType`</ph>.</source>
          <target state="translated">Из <ph id="ph1">`MethodInfo`</ph>, получить <ph id="ph2">`MemberType`</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>The following example displays the type of the specified member.</source>
          <target state="translated">Следующий пример отображает тип указанного элемента.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The first object to compare.</source>
          <target state="translated">Первый из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The second object to compare.</source>
          <target state="translated">Второй из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects are equal.</source>
          <target state="translated">Определение равенства двух объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значения параметров <ph id="ph2">&lt;paramref name="left" /&gt;</ph> и <ph id="ph3">&lt;paramref name="right" /&gt;</ph> равны; в противном случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The first object to compare.</source>
          <target state="translated">Первый из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The second object to compare.</source>
          <target state="translated">Второй из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Определяет неравенство двух объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значения <ph id="ph2">&lt;paramref name="left" /&gt;</ph> и <ph id="ph3">&lt;paramref name="right" /&gt;</ph> не равны; в противном случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph>, который содержит сведения о типе возвращаемого значения этого метода, например, имеет ли возвращаемый тип пользовательские модификаторы.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph>, содержащий сведения о типе возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>Compiler designers can use the <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> object returned by this property to discover whether custom modifiers, such as <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, have been applied to the return type.</source>
          <target state="translated">Конструкторы компилятора могут использовать <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> объект, возвращаемый этим свойством, для обнаружения ли пользовательские модификаторы, такие как <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, были применены к возвращаемому типу.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>This method is not implemented.</source>
          <target state="translated">Этот метод не реализован.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>Gets the return type of this method.</source>
          <target state="translated">Возвращает тип значения, возвращаемый этим методом.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>The return type of this method.</source>
          <target state="translated">Тип возвращаемого значения этого метода.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>To get the return type property, first get the class <ph id="ph1">`Type`</ph>.</source>
          <target state="translated">Чтобы получить тип возвращаемого значения свойства, сначала нужно получить класс <ph id="ph1">`Type`</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`MethodInfo`</ph>.</source>
          <target state="translated">Из <ph id="ph1">`Type`</ph>, получить <ph id="ph2">`MethodInfo`</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>From the <ph id="ph1">`MethodInfo`</ph>, get the <ph id="ph2">`ReturnType`</ph>.</source>
          <target state="translated">Из <ph id="ph1">`MethodInfo`</ph>, получить <ph id="ph2">`ReturnType`</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>The following example displays the return type of the specified method.</source>
          <target state="translated">Следующий пример отображает тип возвращаемого значения указанного метода.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes">
          <source>Gets the custom attributes for the return type.</source>
          <target state="translated">Возвращает пользовательские атрибуты типа возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes">
          <source>An <ph id="ph1">&lt;see langword="ICustomAttributeProvider" /&gt;</ph> object representing the custom attributes for the return type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="ICustomAttributeProvider" /&gt;</ph>, представляющий пользовательские атрибуты для возвращаемого типа.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Зарезервировано для будущего использования.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Должно быть равным IID_NULL.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Переданный массив имен, которые необходимо сопоставить.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Количество сопоставляемых имен.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Контекст языкового стандарта для интерпретации имен.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array that receives the IDs corresponding to the names.</source>
          <target state="translated">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetType">
          <source>Provides access to the <ph id="ph1">&lt;see cref="M:System.Object.GetType" /&gt;</ph> method from COM.</source>
          <target state="translated">Предоставляет доступ к методу <ph id="ph1">&lt;see cref="M:System.Object.GetType" /&gt;</ph> из COM-объекта.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий тип <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Возвращаемые сведения о типе.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Идентификатор языкового стандарта для сведений о типе.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Получает указатель на объект с запрошенными сведениями о типе.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can be used to get the type information for an interface.</source>
          <target state="translated">Возвращает сведения о типе объекта, которые можно использовать для получения сведений о типе интерфейса.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Идентифицирует член.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Зарезервировано для будущего использования.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Должно быть равным IID_NULL.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Флаги, описывающие контекст вызова.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Указатель, по которому будет сохранен результат.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Указатель на структуру, содержащую сведения об исключении.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Индекс первого аргумента, вызвавшего ошибку.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Предоставляет доступ к открытым свойствам и методам объекта.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::Invoke`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>