<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Module.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac599434ae0ca2ae257e847cbb424c20883be128c2c.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">99434ae0ca2ae257e847cbb424c20883be128c2c</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Performs reflection on a module.</source>
          <target state="translated">Выполняет отражение для модуля.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>A module is a portable executable file, such as type.dll or application.exe, consisting of one or more classes and interfaces.</source>
          <target state="translated">Модуль — переносимый исполняемый файл, например DLL или application.exe, состоящий из одного или нескольких классов и интерфейсов.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>There may be multiple namespaces contained in a single module, and a namespace may span multiple modules.</source>
          <target state="translated">В отдельном модуле может быть несколько пространств имен, а одно пространство имен может охватывать несколько модулей.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>One or more modules deployed as a unit compose an assembly.</source>
          <target state="translated">Один или несколько модулей, развертываемые как единое целое, образуют сборку.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>For information about creating an assembly with more than one module, see <bpt id="p1">[</bpt>Multifile Assemblies<ept id="p1">](~/docs/framework/app-domains/multifile-assemblies.md)</ept>.</source>
          <target state="translated">Сведения о создании сборки с несколькими модулями см. в разделе <bpt id="p1">[</bpt>многофайловых сборок<ept id="p1">](~/docs/framework/app-domains/multifile-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>Note that a .NET Framework module is not the same as a module in Visual Basic, which is used by a programmers to organize functions and subroutines in an application.</source>
          <target state="translated">Обратите внимание, что модуль .NET Framework не совпадает с модулем в Visual Basic, который используется программистами для организации функций и подпрограмм в приложении.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>The following code examples show how to use reflection to get information about modules:</source>
          <target state="translated">В следующем примере кода показано, как использовать отражение для получения сведений о модулях.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>for full trust for inheritors.</source>
          <target state="translated">для полного доверия для разработчиков производных классов.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">Этот класс не наследуется частично доверенным кодом.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.#ctor">
          <source>This constructor is invoked by derived classes during the construction of <ph id="ph1">&lt;xref:System.Reflection.Module&gt;</ph> objects.</source>
          <target state="translated">Этот конструктор вызывается производными классами во время создания <ph id="ph1">&lt;xref:System.Reflection.Module&gt;</ph> объектов.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.Assembly">
          <source>Gets the appropriate <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> for this instance of <ph id="ph2">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>.</source>
          <target state="translated">Возвращает соответствующую сборку <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> для данного экземпляра <ph id="ph2">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Assembly">
          <source>An <ph id="ph1">&lt;see langword="Assembly" /&gt;</ph> object.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="Assembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Assembly">
          <source>The following example displays the full name of the specified assembly in the specified module.</source>
          <target state="translated">Следующий пример отображает полное имя сборки, указанной в указанном модуле.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.CustomAttributes">
          <source>Gets a collection that contains this module's custom attributes.</source>
          <target state="translated">Получает коллекцию, содержащая пользовательские атрибуты этого модуля.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.CustomAttributes">
          <source>A collection that contains this module's custom attributes.</source>
          <target state="translated">Коллекция, содержащая пользовательские атрибуты этого модуля.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.Equals(System.Object)">
          <source>The object to compare with this instance.</source>
          <target state="translated">Объект, сравниваемый с данным экземпляром.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.Equals(System.Object)">
          <source>Determines whether this module and the specified object are equal.</source>
          <target state="translated">Определяет, равны ли этот модуль и заданный объект.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is equal to this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение параметра <ph id="ph2">&lt;paramref name="o" /&gt;</ph> равно данному экземпляру; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeName">
          <source>A <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph> object that filters the list of types defined in this module based upon the name.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph>, который фильтрует список типов, определенных в этом модуле на основе имени.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeName">
          <source>This field is case-sensitive and read-only.</source>
          <target state="translated">Это поле учитывает регистр и доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeName">
          <source>The filter supports a trailing "*" wildcard.</source>
          <target state="translated">Фильтр поддерживает символ «*» подстановочный знак.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeName">
          <source>The following example displays the module names that match the specified search criteria.</source>
          <target state="translated">Следующий пример отображает имена модулей, которые соответствуют заданным критериям поиска.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>A <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph> object that filters the list of types defined in this module based upon the name.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph>, который фильтрует список типов, определенных в этом модуле на основе имени.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>This field is case-insensitive and read-only.</source>
          <target state="translated">Это поле доступно только для чтения. В нем не учитывается регистр.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>The filter supports a trailing "*" wildcard.</source>
          <target state="translated">Фильтр поддерживает символ «*» подстановочный знак.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>The following example displays the module names that match the specified search criteria, ignoring the case.</source>
          <target state="translated">Следующий пример отображает имена модулей, которые соответствуют заданным критериям поиска, без учета регистра.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The delegate used to filter the classes.</source>
          <target state="translated">Делегат, который используется для фильтрования классов.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>An Object used to filter the classes.</source>
          <target state="translated">Объект, который используется для фильтрования классов.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>Returns an array of classes accepted by the given filter and filter criteria.</source>
          <target state="translated">Возвращает массив классов, удовлетворяющих указанному фильтру и критериям фильтра.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing classes that were accepted by the filter.</source>
          <target state="translated">Массив типа <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, который содержит классы, удовлетворяющие критериям фильтра.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Reflection.ReflectionTypeLoadException&gt;</ph> is a special class load exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.ReflectionTypeLoadException&gt;</ph> — Это специальный класс нагрузки исключение.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> property contains the array of classes that were defined in the module and were loaded.</source>
          <target state="translated"><ph id="ph1">`ReflectionTypeLoadException.Types`</ph> Свойство содержит массив классов, которые были определены в модуле и загружены.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>This array may contain some null values.</source>
          <target state="translated">Этот массив может содержать значения null.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> property is an array of exceptions that represent the exceptions that were thrown by the class loader.</source>
          <target state="translated"><ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> Свойство представляет собой массив исключений, которые представляют исключения, которые были созданы загрузчиком классов.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The holes in the class array line up with the exceptions.</source>
          <target state="translated">Уязвимости в массиве классов соответствуют исключения.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The delegate given by <ph id="ph1">`filter`</ph> is called for each class in the module, passing along the <ph id="ph2">`Type`</ph> object representing the class as well as the given <ph id="ph3">`filterCriteria`</ph>.</source>
          <target state="translated">Делегат, определенный параметром <ph id="ph1">`filter`</ph> вызывается для каждого класса в модуле, передавая <ph id="ph2">`Type`</ph> объект, представляющий класс, а также данного <ph id="ph3">`filterCriteria`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>If <ph id="ph1">`filter`</ph> returns a particular class, that class will be included in the returned array.</source>
          <target state="translated">Если <ph id="ph1">`filter`</ph> возвращает определенного класса, что класс будут включены в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>If <ph id="ph1">`filter`</ph> returns <ph id="ph2">`null`</ph>, all classes are returned and <ph id="ph3">`filterCriteria`</ph> is ignored.</source>
          <target state="translated">Если <ph id="ph1">`filter`</ph> возвращает <ph id="ph2">`null`</ph>, возвращаются все классы, и <ph id="ph3">`filterCriteria`</ph> учитывается.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">`FindTypes`</ph> cannot be used to look up parameterized types such as arrays.</source>
          <target state="translated"><ph id="ph1">`FindTypes`</ph> не может использоваться для просмотра параметризованных типов, таких как массивы.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The following example demonstrates the <ph id="ph1">`FindTypes`</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">`FindTypes`</ph> метод.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>One or more classes in a module could not be loaded.</source>
          <target state="translated">Невозможно загрузить один или несколько классов в модуле.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>Gets a string representing the fully qualified name and path to this module.</source>
          <target state="translated">Возвращает строку, содержащую полное имя и путь к этому модулю.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The fully qualified module name.</source>
          <target state="translated">Полное имя модуля.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>To get the name without the path, use <ph id="ph1">&lt;xref:System.Reflection.Module.Name%2A&gt;</ph>.</source>
          <target state="translated">Чтобы получить имя без пути, используйте <ph id="ph1">&lt;xref:System.Reflection.Module.Name%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>If the assembly for this module was loaded from a byte array then the <ph id="ph1">`FullyQualifiedName`</ph> for the module will be: <ph id="ph2">\&lt;</ph>Unknown&gt;.</source>
          <target state="translated">Если сборка для этого модуля была загружена из массива байтов то <ph id="ph1">`FullyQualifiedName`</ph> для модуля будут: <ph id="ph2">\&lt;</ph>Неизвестный &gt;.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The case of module name is platform-dependent.</source>
          <target state="translated">Регистр имени модуля зависит от платформы.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The following example displays the fully qualified name of the specified module.</source>
          <target state="translated">Следующий пример отображает полное имя заданного модуля.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The caller does not have the required permissions.</source>
          <target state="translated">У вызывающего объекта отсутствуют необходимые разрешения.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>for access to information in the path.</source>
          <target state="translated">для доступа к сведениям о пути.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns custom attributes.</source>
          <target state="translated">Возвращает настраиваемые атрибуты.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Данный аргумент не учитывается для объектов этого типа.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>Returns all custom attributes.</source>
          <target state="translated">Возвращает все настраиваемые атрибуты.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>An array of type <ph id="ph1">&lt;see langword="Object" /&gt;</ph> containing all custom attributes.</source>
          <target state="translated">Массив типа <ph id="ph1">&lt;see langword="Object" /&gt;</ph>, содержащий все настраиваемые атрибуты.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>The following example displays the module names that match the specified search criteria.</source>
          <target state="translated">Следующий пример отображает имена модулей, которые соответствуют заданным критериям поиска.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type of attribute to get.</source>
          <target state="translated">Тип возвращаемого атрибута.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Данный аргумент не учитывается для объектов этого типа.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Gets custom attributes of the specified type.</source>
          <target state="translated">Возвращает настраиваемые атрибуты заданного типа.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of type <ph id="ph1">&lt;see langword="Object" /&gt;</ph> containing all custom attributes of the specified type.</source>
          <target state="translated">Массив объектов типа <ph id="ph1">&lt;see langword="Object" /&gt;</ph>, содержащий все пользовательские атрибуты заданного типа.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The following example displays the module names of the specified type that match the specified search criteria.</source>
          <target state="translated">Следующий пример отображает имена модулей заданного типа, соответствующих указанным условиям поиска.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object supplied by the runtime.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> не является объектом <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, предоставленным во время разработки.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>For example, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Например, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> является объектом <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Returns a list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects for the current module, which can be used in the reflection-only context.</source>
          <target state="translated">Возвращает список объектов <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> для текущего модуля, который можно использовать в контексте, предназначенном только для отражения.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>A generic list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects representing data about the attributes that have been applied to the current module.</source>
          <target state="translated">Универсальный список объектов <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph>, представляющих данные об атрибутах, которые были применены к текущему модулю.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</source>
          <target state="translated">Этот метод можно используйте для исследования настраиваемых атрибутов кода в контексте только для отражения в случаях, где сами настраиваемые атрибуты определены в коде, который загружается в контекст только для отражения.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Methods such as <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> cannot be used in such cases, because they create instances of the attributes.</source>
          <target state="translated">Такие методы, как <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> не может использоваться в таких случаях, поскольку они создают экземпляры атрибутов.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Code in the reflection-only context cannot be executed.</source>
          <target state="translated">Не удается выполнить код в контексте только для отражения.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>For more information and example code, see the <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> class.</source>
          <target state="translated">Дополнительные сведения и пример кода см. в разделе <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns a specified field.</source>
          <target state="translated">Возвращает заданное поле.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>The field name.</source>
          <target state="translated">Имя поля.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>Returns a field having the specified name.</source>
          <target state="translated">Возвращает поле с указанным именем.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>A <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> object having the specified name, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the field does not exist.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> с указанным именем или <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если поле не существует.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The field name.</source>
          <target state="translated">Имя поля.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>One of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Один из битовых флагов <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>, используемых для управления поиском.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns a field having the specified name and binding attributes.</source>
          <target state="translated">Возвращает поле с указанным именем и атрибутами привязки.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> object having the specified name and binding attributes, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the field does not exist.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> с указанным именем и атрибутами привязки или <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если поле не существует.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the global fields defined on the module.</source>
          <target state="translated">Возвращает глобальные поля, определенные в модуле.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields">
          <source>Returns the global fields defined on the module.</source>
          <target state="translated">Возвращает глобальные поля, определенные в модуле.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing the global fields defined on the module; if there are no global fields, an empty array is returned.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, представляющих глобальные поля, определенные в модуле. Если глобальные поля отсутствуют, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> Метод не возвращает поля в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">Код не должен зависеть порядка, в котором возвращаются поля, так как этот порядок может меняться.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limit the search.</source>
          <target state="translated">Битовая комбинация значений <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, которая определяет границы поиска.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>Returns the global fields defined on the module that match the specified binding flags.</source>
          <target state="translated">Возвращает глобальные поля, определенные в модуле, которые соответствуют заданным флагам привязки.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> representing the global fields defined on the module that match the specified binding flags; if no global fields match the binding flags, an empty array is returned.</source>
          <target state="translated">Массив типа <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, представляющий глобальные поля, определенные в модуле, который соответствует указанным флагам привязки. Если глобальные поля не соответствуют флагам привязки, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> Метод не возвращает поля в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">Код не должен зависеть порядка, в котором возвращаются поля, так как этот порядок может меняться.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Возвращает хэш-код данного экземпляра.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Хэш-код в виде 32-разрядного целого числа со знаком.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns a method having the specified criteria.</source>
          <target state="translated">Возвращает метод, отвечающий заданным критериям.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source>The method name.</source>
          <target state="translated">Имя метода.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source>Returns a method having the specified name.</source>
          <target state="translated">Возвращает метод с указанным именем.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object having the specified name, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> с указанным именем или <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не существует.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>The method name.</source>
          <target state="translated">Имя метода.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>The parameter types to search for.</source>
          <target state="translated">Искомые типы параметров.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>Returns a method having the specified name and parameter types.</source>
          <target state="translated">Возвращает метод, имеющий указанные имя и типы параметров.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object in accordance with the specified criteria, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> в соответствии с указанными условиями или <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не существует.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) is <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="null" /&gt;</ph> или <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) имеет значение <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The method name.</source>
          <target state="translated">Имя метода.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Один из битовых флагов <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>, используемых для управления поиском.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that implements <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, containing properties related to this method.</source>
          <target state="translated">Объект, реализующий <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, содержащий свойства, связанные с этим методом.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling convention for the method.</source>
          <target state="translated">Соглашение о вызовах для метода.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The parameter types to search for.</source>
          <target state="translated">Искомые типы параметров.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</source>
          <target state="translated">Массив модификаторов параметров, используемый для работы привязки с подписями параметров, в которых были изменены типы.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Returns a method having the specified name, binding information, calling convention, and parameter types and modifiers.</source>
          <target state="translated">Возвращает метод, имеющий заданное имя, сведения о привязке, соглашение о вызовах и типы и модификаторы параметров.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object in accordance with the specified criteria, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> в соответствии с указанными условиями или <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не существует.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) is <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="null" /&gt;</ph> или <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) имеет значение <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The method name.</source>
          <target state="translated">Имя метода.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Один из битовых флагов <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>, используемых для управления поиском.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that implements <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, containing properties related to this method.</source>
          <target state="translated">Объект, реализующий <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, содержащий свойства, связанные с этим методом.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling convention for the method.</source>
          <target state="translated">Соглашение о вызовах для метода.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The parameter types to search for.</source>
          <target state="translated">Искомые типы параметров.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</source>
          <target state="translated">Массив модификаторов параметров, используемый для работы привязки с подписями параметров, в которых были изменены типы.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Returns the method implementation in accordance with the specified criteria.</source>
          <target state="translated">Возвращает реализацию метода в соответствии с заданными критериями.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object containing implementation information as specified, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph>, содержащий заданные сведения о реализации, или <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не существует.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the global methods defined on the module</source>
          <target state="translated">Возвращает глобальные методы, определенные в этом модуле.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods">
          <source>Returns the global methods defined on the module.</source>
          <target state="translated">Возвращает глобальные методы, определенные в модуле.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing all the global methods defined on the module; if there are no global methods, an empty array is returned.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, представляющих все глобальные методы, определенные в модуле. Если глобальные методы отсутствуют, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limit the search.</source>
          <target state="translated">Битовая комбинация значений <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, которая определяет границы поиска.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns the global methods defined on the module that match the specified binding flags.</source>
          <target state="translated">Возвращает глобальные методы, определенные в модуле, которые соответствуют заданным флагам привязки.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> representing the global methods defined on the module that match the specified binding flags; if no global methods match the binding flags, an empty array is returned.</source>
          <target state="translated">Массив типа <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> — представляет глобальные методы, определенные в модуле, который соответствует указанным флагам связывания. Если глобальные методы не соответствуют флагам привязки, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The information and data needed to serialize or deserialize an object.</source>
          <target state="translated">Сведения и данные, необходимые для выполнения сериализации и десериализации объекта.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The context for the serialization.</source>
          <target state="translated">Контекст для сериализации.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Provides an <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> implementation for serialized objects.</source>
          <target state="translated">Обеспечивает реализацию класса <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> для сериализованных объектов.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="info" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>When this method returns, a combination of the <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph> values indicating the nature of the code in the module.</source>
          <target state="translated">Этот метод возвращает сочетание значений <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph>, определяющее характер кода в модуле.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>When this method returns, one of the <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph> values indicating the platform targeted by the module.</source>
          <target state="translated">Этот метод возвращает одно из значений <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph>, определяющее платформу, на которой применяется модуль.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</source>
          <target state="translated">Возвращает пару значений, определяющих природу кода в модуле и платформе, на которой применяется этот модуль.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetSignerCertificate">
          <source>Returns an <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph>, соответствующий сертификату, включаемому в подпись Authenticode сборки, которой принадлежит этот модуль.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetSignerCertificate">
          <source>If the assembly has not been Authenticode signed, <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Если сборка не имеет подписи Authenticode, возвращается значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetSignerCertificate">
          <source>An <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph> object, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the assembly to which this module belongs has not been Authenticode signed.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph> или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если сборка, содержащая этот модуль, не имеет подписи Authenticode.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the specified type.</source>
          <target state="translated">Возвращает указанный тип.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The name of the type to locate.</source>
          <target state="translated">Имя искомого типа.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The name must be fully qualified with the namespace.</source>
          <target state="translated">Имя должно содержать пространство имен.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>Returns the specified type, performing a case-sensitive search.</source>
          <target state="translated">Возвращает заданный тип (выполняет поиск с учетом регистра).</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>A <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object representing the given type, if the type is in this module; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, представляющий указанный тип, если тип находится в этом модуле. В противном случае возвращается значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Если тип был перенаправлен в другую сборку, по-прежнему возвращается этим методом.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Сведения о перенаправлении типов см. в разделе <bpt id="p1">[</bpt>переадресации типов в общеязыковой<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>A type can be retrieved from a specific module using <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Тип может быть извлечен из конкретного модуля с помощью <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>Calling <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> on the module that contains the manifest will not search the entire assembly.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> модуля, содержащего манифест не будут выполнять поиск всей сборке.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>To retrieve a type from an assembly, regardless of which module it is in, you must call <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Чтобы получить тип из сборки, независимо от того, какой модуль он находится, необходимо вызвать <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The following example displays the name of a type in the specified module.</source>
          <target state="translated">Следующий пример отображает имя типа в указанном модуле.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="className" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The class initializers are invoked and an exception is thrown.</source>
          <target state="translated">Вызываются инициализаторы класса и создается исключение.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> представляет собой строку нулевой длины.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated">Для <ph id="ph1">&lt;paramref name="className" /&gt;</ph> требуется зависимая сборка, которую не удается найти.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated">Для <ph id="ph1">&lt;paramref name="className" /&gt;</ph> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">Текущая сборка была загружена в контекст только для отражения, а для <ph id="ph1">&lt;paramref name="className" /&gt;</ph> требуется зависимая сборка, которая не была предварительно загружена.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated">Для <ph id="ph1">&lt;paramref name="className" /&gt;</ph> требуется зависимая сборка, однако файл не является допустимой сборкой.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated">Для <ph id="ph1">&lt;paramref name="className" /&gt;</ph> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The name of the type to locate.</source>
          <target state="translated">Имя искомого типа.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The name must be fully qualified with the namespace.</source>
          <target state="translated">Имя должно содержать пространство имен.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> for case-insensitive search; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> для поиска без учета регистра. В противном случае используется значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>Returns the specified type, searching the module with the specified case sensitivity.</source>
          <target state="translated">Возвращает указанный тип, выполняя поиск в модуле с заданным требованием к учету регистра.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object representing the given type, if the type is in this module; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, представляющий указанный тип, если тип находится в этом модуле. В противном случае возвращается значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Если тип был перенаправлен в другую сборку, по-прежнему возвращается этим методом.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Сведения о перенаправлении типов см. в разделе <bpt id="p1">[</bpt>переадресации типов в общеязыковой<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>A type can be retrieved from a specific module using <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Тип может быть извлечен из конкретного модуля с помощью <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>Calling <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> on the module that contains the manifest will not search the entire assembly.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> модуля, содержащего манифест не будут выполнять поиск всей сборке.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>To retrieve a type from an assembly, regardless of which module it is in, you must call <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Чтобы получить тип из сборки, независимо от того, какой модуль он находится, необходимо вызвать <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The following example displays the name of a type in the specified module, specifying <ph id="ph1">`false`</ph> for the <ph id="ph2">`ignoreCase`</ph> parameter so that case will not be ignored.</source>
          <target state="translated">Следующий пример отображает имя типа в указанном модуле, указав <ph id="ph1">`false`</ph> для <ph id="ph2">`ignoreCase`</ph> параметр, в этом случае не будут пропущены.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="className" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The class initializers are invoked and an exception is thrown.</source>
          <target state="translated">Вызываются инициализаторы класса и создается исключение.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> представляет собой строку нулевой длины.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated">Для <ph id="ph1">&lt;paramref name="className" /&gt;</ph> требуется зависимая сборка, которую не удается найти.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated">Для <ph id="ph1">&lt;paramref name="className" /&gt;</ph> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">Текущая сборка была загружена в контекст только для отражения, а для <ph id="ph1">&lt;paramref name="className" /&gt;</ph> требуется зависимая сборка, которая не была предварительно загружена.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated">Для <ph id="ph1">&lt;paramref name="className" /&gt;</ph> требуется зависимая сборка, однако файл не является допустимой сборкой.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated">Для <ph id="ph1">&lt;paramref name="className" /&gt;</ph> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name of the type to locate.</source>
          <target state="translated">Имя искомого типа.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name must be fully qualified with the namespace.</source>
          <target state="translated">Имя должно содержать пространство имен.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы создать исключение, если тип не удается найти; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, чтобы вернуть значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> for case-insensitive search; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> для поиска без учета регистра. В противном случае используется значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Returns the specified type, specifying whether to make a case-sensitive search of the module and whether to throw an exception if the type cannot be found.</source>
          <target state="translated">Возвращает указанный тип, определяя, следует ли учитывать регистр при поиске модуля и должно ли создаваться исключение, если не удалось обнаружить этот тип.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the specified type, if the type is declared in this module; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий указанный тип, если тип был объявлен в этом модуле; в противном случае — <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter affects only what happens when the type is not found.</source>
          <target state="translated"><ph id="ph1">`throwOnError`</ph> Параметр влияет на только что произойдет, если тип не найден.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>It does not affect any other exceptions that might be thrown.</source>
          <target state="translated">Он не влияет на другие исключения, которые могут быть созданы.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In particular, if the type is found but cannot be loaded, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> can be thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">В частности, если тип присутствует, но не может быть загружена <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> может быть создано даже в том случае, если <ph id="ph2">`throwOnError`</ph> — <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Если тип был перенаправлен в другую сборку, по-прежнему возвращается этим методом.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Сведения о перенаправлении типов см. в разделе <bpt id="p1">[</bpt>переадресации типов в общеязыковой<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A type can be retrieved from a specific module using <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Тип может быть извлечен из конкретного модуля с помощью <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Calling <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> on the module that contains the manifest will not search the entire assembly.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> модуля, содержащего манифест не будут выполнять поиск всей сборке.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To retrieve a type from an assembly, regardless of which module it is in, you must call <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Чтобы получить тип из сборки, независимо от того, какой модуль он находится, необходимо вызвать <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The following example displays the name of a type in the specified module.</source>
          <target state="translated">Следующий пример отображает имя типа в указанном модуле.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> and <ph id="ph2">`ignoreCase`</ph> parameters are specified as <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`throwOnError`</ph> И <ph id="ph2">`ignoreCase`</ph> параметры задаются в виде <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="className" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The class initializers are invoked and an exception is thrown.</source>
          <target state="translated">Вызываются инициализаторы класса и создается исключение.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> представляет собой строку нулевой длины.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, and the type cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> является <ph id="ph2">&lt;see langword="true" /&gt;</ph>, не удается найти тип.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated">Для <ph id="ph1">&lt;paramref name="className" /&gt;</ph> требуется зависимая сборка, которую не удается найти.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated">Для <ph id="ph1">&lt;paramref name="className" /&gt;</ph> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">Текущая сборка была загружена в контекст только для отражения, а для <ph id="ph1">&lt;paramref name="className" /&gt;</ph> требуется зависимая сборка, которая не была предварительно загружена.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated">Для <ph id="ph1">&lt;paramref name="className" /&gt;</ph> требуется зависимая сборка, однако файл не является допустимой сборкой.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated">Для <ph id="ph1">&lt;paramref name="className" /&gt;</ph> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>Returns all the types defined within this module.</source>
          <target state="translated">Возвращает все типы, определенные в этом модуле.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing types defined within the module that is reflected by this instance.</source>
          <target state="translated">Массив типа <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, содержащий типы, определенные в модуле, отраженном этим экземпляром.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source><ph id="ph1">`ReflectionTypeLoadException`</ph> is a special load exception.</source>
          <target state="translated"><ph id="ph1">`ReflectionTypeLoadException`</ph> — это специальные нагрузки исключение.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> property contains the array of types that were defined in the module and were loaded.</source>
          <target state="translated"><ph id="ph1">`ReflectionTypeLoadException.Types`</ph> Свойство содержит массив типов, которые были определены в модуле и загружены.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>This array may contain some null values.</source>
          <target state="translated">Этот массив может содержать значения null.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> property is an array of exceptions that represent the exceptions that were thrown by the loader.</source>
          <target state="translated"><ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> Свойство представляет собой массив исключений, которые представляют исключения, которые были созданы загрузчиком.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>The holes in the class array line up with the exceptions.</source>
          <target state="translated">Уязвимости в массиве классов соответствуют исключения.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>For example, if the class initializers of one of the classes throws an exception while it is being loaded, a <ph id="ph1">`TargetInvocationException`</ph> is stored in the corresponding element of the <ph id="ph2">`LoaderExceptions`</ph> array.</source>
          <target state="translated">Например, если инициализаторы одного из классов вызывает исключение во время они загружаются, <ph id="ph1">`TargetInvocationException`</ph> хранятся в соответствующем элементе <ph id="ph2">`LoaderExceptions`</ph> массива.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>If a type has been forwarded to another assembly, it is not included in the returned array.</source>
          <target state="translated">Если тип был перенаправлен в другую сборку, он не включается в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Сведения о перенаправлении типов см. в разделе <bpt id="p1">[</bpt>переадресации типов в общеязыковой<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>One or more classes in a module could not be loaded.</source>
          <target state="translated">Невозможно загрузить один или несколько классов в модуле.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>The caller does not have the required permission.</source>
          <target state="translated">У вызывающего объекта отсутствует необходимое разрешение.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>Reflection permission for the current module.</source>
          <target state="translated">Разрешение отражения для текущего модуля.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>The type of custom attribute to test for.</source>
          <target state="translated">Тип настраиваемого атрибута для проверки.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Данный аргумент не учитывается для объектов этого типа.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>Returns a value that indicates whether the specified attribute type has been applied to this module.</source>
          <target state="translated">Возвращает значение, обозначающее, применен ли к этому модулю указанный тип атрибутов.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if one or more instances of <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> have been applied to this module; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если к этому модулю применен один или несколько экземпляров <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph>, в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsDefined`</ph> method.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">`IsDefined`</ph> метода.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object supplied by the runtime.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> не является объектом <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, предоставленным во время разработки.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>For example, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Например, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> является объектом <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsResource">
          <source>Gets a value indicating whether the object is a resource.</source>
          <target state="translated">Возвращает значение, указывающее, является ли объект ресурсом.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsResource">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the object is a resource; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект является ресурсом; в обратном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.IsResource">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsResource`</ph> method.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">`IsResource`</ph> метода.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>Gets the metadata stream version.</source>
          <target state="translated">Возвращает версию потока метаданных.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>A 32-bit integer representing the metadata stream version.</source>
          <target state="translated">32-разрядное целое число, представляющее версию потока метаданных.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.</source>
          <target state="translated">Два байта старшего разряда представляют основной номер версии, а два байта младшего разряда — дополнительный.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>For more information on the metadata header, see "Partition II: Metadata Definition and Semantics" in the Common Language Infrastructure (CLI) documentation.</source>
          <target state="translated">Дополнительные сведения о заголовке метаданных см. в разделе «Раздел II: определение метаданных и семантика» в документации по Common Language Infrastructure (CLI).</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Документация доступна через Интернет; в разделе <bpt id="p1">[</bpt>ECMA C# и общий стандарты инфраструктуры языка<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>стандарту ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на сайте ECMA.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.MetadataToken">
          <source>Gets a token that identifies the module in metadata.</source>
          <target state="translated">Возвращает токен, который определяет модуль в метаданных.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>An integer token that identifies the current module in metadata.</source>
          <target state="translated">Целочисленный токен, который идентифицирует текущий модуль в метаданных.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>The tokens obtained using this property can be passed to the unmanaged Reflection API.</source>
          <target state="translated">Маркеры, полученные с помощью этого свойства может быть передан на неуправляемый интерфейс API отражения.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>For more information, see <bpt id="p1">[</bpt>Unmanaged Reflection API<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>неуправляемый интерфейс API отражения<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Документация доступна через Интернет; в разделе <bpt id="p1">[</bpt>ECMA C# и общий стандарты инфраструктуры языка<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>стандарту ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на сайте ECMA.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.ModuleHandle">
          <source>Gets a handle for the module.</source>
          <target state="translated">Возвращает дескриптор модуля.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleHandle">
          <source>A <ph id="ph1">&lt;see cref="T:System.ModuleHandle" /&gt;</ph> structure for the current module.</source>
          <target state="translated">Структура <ph id="ph1">&lt;see cref="T:System.ModuleHandle" /&gt;</ph> для текущего модуля.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</source>
          <target state="translated">Возвращает универсальный уникальный идентификатор (UUID), по которому можно различить две версии модуля.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>A <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> that can be used to distinguish between two versions of a module.</source>
          <target state="translated">Значение свойства <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph>, по которому можно различить две версии модуля.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>In unmanaged metadata, the GUID returned by the <ph id="ph1">&lt;xref:System.Reflection.Module.ModuleVersionId%2A&gt;</ph> property is referred to as the <ph id="ph2">`mvid`</ph>, and is stored in the GUID heap.</source>
          <target state="translated">В неуправляемых метаданных, возвращенный идентификатор GUID <ph id="ph1">&lt;xref:System.Reflection.Module.ModuleVersionId%2A&gt;</ph> свойство называется <ph id="ph2">`mvid`</ph>и хранятся в куче GUID.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>More information about metadata can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Дополнительные сведения о метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Документация доступна через Интернет; в разделе <bpt id="p1">[</bpt>ECMA C# и общий стандарты инфраструктуры языка<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>стандарту ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на сайте ECMA.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.Name">
          <source>Gets a <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the name of the module with the path removed.</source>
          <target state="translated">Возвращает строку <ph id="ph1">&lt;see langword="String" /&gt;</ph>, представляющую имя модуля без пути.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>The module name with no path.</source>
          <target state="translated">Имя модуля без пути.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source><ph id="ph1">`Name`</ph> is a platform-dependent string.</source>
          <target state="translated"><ph id="ph1">`Name`</ph> является строкой, зависящей от платформы.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>If the assembly for this module was loaded from a byte array then the <ph id="ph1">`FullyQualifiedName`</ph> for the module will be: <ph id="ph2">\&lt;</ph>Unknown&gt;.</source>
          <target state="translated">Если сборка для этого модуля была загружена из массива байтов то <ph id="ph1">`FullyQualifiedName`</ph> для модуля будут: <ph id="ph2">\&lt;</ph>Неизвестный &gt;.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>To get the name and the path, use <ph id="ph1">&lt;xref:System.Reflection.Module.FullyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">Чтобы получить имя и путь, используйте <ph id="ph1">&lt;xref:System.Reflection.Module.FullyQualifiedName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>This example shows the effect of the <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, and <ph id="ph3">`Name`</ph> properties.</source>
          <target state="translated">В этом примере показано влияние <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, и <ph id="ph3">`Name`</ph> свойства.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source>The first object to compare.</source>
          <target state="translated">Первый из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source>The second object to compare.</source>
          <target state="translated">Второй из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> objects are equal.</source>
          <target state="translated">Определение равенства двух объектов <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значения параметров <ph id="ph2">&lt;paramref name="left" /&gt;</ph> и <ph id="ph3">&lt;paramref name="right" /&gt;</ph> равны; в противном случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source>The first object to compare.</source>
          <target state="translated">Первый из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source>The second object to compare.</source>
          <target state="translated">Второй из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Определяет неравенство двух объектов <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значения <ph id="ph2">&lt;paramref name="left" /&gt;</ph> и <ph id="ph3">&lt;paramref name="right" /&gt;</ph> не равны; в противном случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the field identified by a metadata token.</source>
          <target state="translated">Возвращает поле, определенное заданным токеном метаданных.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>A metadata token that identifies a field in the module.</source>
          <target state="translated">токен метаданных, определяющий поле в модуле.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>Returns the field identified by the specified metadata token.</source>
          <target state="translated">Возвращает поле, определенное заданным токеном метаданных.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field that is identified by the specified metadata token.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, представляющий поле, которое определяется заданным токеном метаданных.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>To resolve a metadata token that identifies a field whose parent <ph id="ph1">`TypeSpec`</ph> has a signature containing element type <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Для решения, родительский токен метаданных, определяющий поле <ph id="ph1">`TypeSpec`</ph> имеет сигнатуру, содержащую тип элемента <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> или <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, используйте <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> перегрузку, которая позволяет предоставить необходимый контекст.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>That is, when you are resolving a metadata token for a field that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">То есть при разрешении токен метаданных для поля, которое зависит от параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер, необходимо использовать перегруженный метод, который делает возможным предоставление таких параметров типа.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Документация доступна через Интернет; в разделе <bpt id="p1">[</bpt>ECMA C# и общий стандарты инфраструктуры языка<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>стандарту ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на сайте ECMA.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Код, который демонстрирует разрешение маркера с использованием универсального контекста (то есть параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер). в разделе <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a field in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является маркером для поля в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a field whose parent <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> has a signature containing element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> определяет поле, родительская спецификация <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> которого имеет подпись, содержащую сведения о типе элемента <ph id="ph3">&lt;see langword="var" /&gt;</ph> (параметр типа для универсального типа) или <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (параметр типа для универсального метода).</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является допустимым маркером для поля в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a field in the module.</source>
          <target state="translated">токен метаданных, определяющий поле в модуле.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющих аргументы типа для данного типа, если токен находится в области, либо значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если этот тип не является универсальным.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющих аргументы типа для метода, если токен находится в области, либо значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если этот метод не является универсальным.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Возвращает поле, определенное заданным токеном метаданных, в контексте, определенном заданными параметрами универсального типа.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field that is identified by the specified metadata token.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, представляющий поле, которое определяется заданным токеном метаданных.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> метода типа где <ph id="ph2">`metadataToken`</ph> находится в области, чтобы получить массив аргументов универсального типа для <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> метода на метод где <ph id="ph2">`metadataToken`</ph> находится в области, чтобы получить массив аргументов универсального типа для <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Всегда можно безопасно предоставить эти аргументы, даже в том случае, если они не нужны.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Документация доступна через Интернет; в разделе <bpt id="p1">[</bpt>ECMA C# и общий стандарты инфраструктуры языка<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>стандарту ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на сайте ECMA.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Код, который демонстрирует разрешение маркера с использованием универсального контекста (то есть параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер). в разделе <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a field in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является маркером для поля в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a field whose parent <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> has a signature containing element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> определяет поле, родительская спецификация <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> которого имеет подпись, содержащую сведения о типе элемента <ph id="ph3">&lt;see langword="var" /&gt;</ph> (параметр типа для универсального типа) или <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (параметр типа для универсального метода), а для метода <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> или <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph> не предоставлены необходимые аргументы типа.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является допустимым маркером для поля в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the type or member identified by a metadata token.</source>
          <target state="translated">Возвращает тип члена, определенный токеном метаданных.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>A metadata token that identifies a type or member in the module.</source>
          <target state="translated">токен метаданных, определяющий тип или член в модуле.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>Returns the type or member identified by the specified metadata token.</source>
          <target state="translated">Возвращает тип члена, определенный заданным токеном метаданных.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object representing the type or member that is identified by the specified metadata token.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, представляющий тип члена, который определяется заданным токеном метаданных.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>To resolve a metadata token for a <ph id="ph1">`MethodSpec`</ph> or <ph id="ph2">`TypeSpec`</ph> whose signature contains element type <ph id="ph3">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph4">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph5">&lt;xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Чтобы разрешить токен метаданных для <ph id="ph1">`MethodSpec`</ph> или <ph id="ph2">`TypeSpec`</ph> , сигнатура которого содержит тип элемента <ph id="ph3">`ELEMENT_TYPE_VAR`</ph> или <ph id="ph4">`ELEMENT_TYPE_MVAR`</ph>, используйте <ph id="ph5">&lt;xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> перегрузку, которая позволяет предоставить необходимый контекст.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>That is, when you are resolving a metadata token for a member that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">То есть при разрешении токен метаданных для элемента, который зависит от параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер, необходимо использовать перегруженный метод, который делает возможным предоставление таких параметров типа.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Документация доступна через Интернет; в разделе <bpt id="p1">[</bpt>ECMA C# и общий стандарты инфраструктуры языка<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>стандарту ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на сайте ECMA.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Код, который демонстрирует разрешение маркера с использованием универсального контекста (то есть параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер). в разделе <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type or member in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является маркером для типа или члена в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> or <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph4">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> содержит объект <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> или <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph>, чья подпись содержит тип элемента <ph id="ph4">&lt;see langword="var" /&gt;</ph> (параметр типа для универсального типа) или <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (параметр типа для универсального метода).</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a property or event.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> определяет свойство или событие.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является допустимым маркером для поля в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a type or member in the module.</source>
          <target state="translated">токен метаданных, определяющий тип или член в модуле.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющих аргументы типа для данного типа, если токен находится в области, либо значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если этот тип не является универсальным.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющих аргументы типа для метода, если токен находится в области, либо значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если этот метод не является универсальным.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Возвращает тип или член, которые определены заданным токеном метаданных, в контексте, определенном заданными параметрами универсального типа.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object representing the type or member that is identified by the specified metadata token.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, представляющий тип члена, который определяется заданным токеном метаданных.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> метода типа где <ph id="ph2">`metadataToken`</ph> находится в области, чтобы получить массив аргументов универсального типа для <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> метода на метод где <ph id="ph2">`metadataToken`</ph> находится в области, чтобы получить массив аргументов универсального типа для <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Всегда можно безопасно предоставить эти аргументы, даже в том случае, если они не нужны.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Документация доступна через Интернет; в разделе <bpt id="p1">[</bpt>ECMA C# и общий стандарты инфраструктуры языка<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>стандарту ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на сайте ECMA.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Код, который демонстрирует разрешение маркера с использованием универсального контекста (то есть параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер). в разделе <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type or member in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является маркером для типа или члена в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> or <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph4">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph6">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph7">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> является объектом <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> или <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph>, подпись которого содержит сведения о типе элемента <ph id="ph4">&lt;see langword="var" /&gt;</ph> (параметр типа для универсального типа) или <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (параметр типа для универсального метода), а для метода <ph id="ph6">&lt;paramref name="genericTypeArguments" /&gt;</ph> или <ph id="ph7">&lt;paramref name="genericMethodArguments" /&gt;</ph> не предоставлены необходимые аргументы типа.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a property or event.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> определяет свойство или событие.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является допустимым маркером для поля в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the method identified by a metadata token.</source>
          <target state="translated">Возвращает метод, определенный токеном метаданных.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>A metadata token that identifies a method or constructor in the module.</source>
          <target state="translated">маркер метаданных, определяющий метод или конструктор в модуле.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Returns the method or constructor identified by the specified metadata token.</source>
          <target state="translated">Возвращает метод или конструктор, определенный заданным токеном метаданных.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method or constructor that is identified by the specified metadata token.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>, представляющий метод или конструктор, который определяется заданным токеном метаданных.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>To resolve a metadata token for a <ph id="ph1">`MethodSpec`</ph> whose signature contains element type <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Чтобы разрешить токен метаданных для <ph id="ph1">`MethodSpec`</ph> , сигнатура которого содержит тип элемента <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> или <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, используйте <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> перегрузку, которая позволяет предоставить необходимый контекст.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>That is, when you are resolving a metadata token for a method that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">То есть при разрешении токен метаданных для метода, который зависит от параметров универсального типа для универсального типа или универсального метода, в котором внедрен этот маркер, необходимо использовать перегруженный метод, который делает возможным предоставление таких параметров типа.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Документация доступна через Интернет; в разделе <bpt id="p1">[</bpt>ECMA C# и общий стандарты инфраструктуры языка<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>стандарту ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на сайте ECMA.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The following example shows how to use the two overloads of the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> method to resolve metadata tokens from call sites in generic and non-generic contexts.</source>
          <target state="translated">Приведенный ниже показано, как использовать две перегрузки <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> метода для разрешения маркеров метаданных из вызова сайты в универсальных и неуниверсальных контекстов.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The code example defines two generic types, <ph id="ph1">`G1&lt;Tg1&gt;`</ph> and <ph id="ph2">`G2&lt;Tg2&gt;`</ph> (<ph id="ph3">`G1(Of Tg1)`</ph> and <ph id="ph4">`G2(Of Tg2)`</ph> in Visual Basic), each of which has a generic method.</source>
          <target state="translated">В примере кода определяется два универсальных типов, <ph id="ph1">`G1&lt;Tg1&gt;`</ph> и <ph id="ph2">`G2&lt;Tg2&gt;`</ph> (<ph id="ph3">`G1(Of Tg1)`</ph> и <ph id="ph4">`G2(Of Tg2)`</ph> в Visual Basic), каждый из которых содержит универсальный метод.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">`G1&lt;Tg1&gt;`</ph> also has a non-generic method that uses the type parameter <ph id="ph2">`Tg1`</ph> for its parameter.</source>
          <target state="translated"><ph id="ph1">`G1&lt;Tg1&gt;`</ph> также имеет неуниверсальный метод, который использует параметр типа <ph id="ph2">`Tg1`</ph> для его параметра.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The generic method <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> in type <ph id="ph2">`G2&lt;Tg2&gt;`</ph> contains several method calls:</source>
          <target state="translated">Универсальный метод <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> в типе <ph id="ph2">`G2&lt;Tg2&gt;`</ph> содержит несколько вызовов методов:</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 1: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, using the type parameters of <ph id="ph2">`G2&lt;Tg2&gt;`</ph> and <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> as the type arguments.</source>
          <target state="translated">Вариант 1: Универсальный метод <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> с использованием параметров типа <ph id="ph2">`G2&lt;Tg2&gt;`</ph> и <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> в качестве аргументов типа.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">Другими словами, типы параметров вызываемого метода будет зависеть от типов, которые используются для создания закрытого универсального типа из определения типа для <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 2: The non-generic method <ph id="ph1">`M1`</ph> is called.</source>
          <target state="translated">Вариант 2: Неуниверсальный метод <ph id="ph1">`M1`</ph> вызывается.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The parameter of this method uses the type parameter of the defining type, <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, which is replaced in this case by the type parameter of the enclosing type, <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">Параметр этого метода использует параметр типа, определяющего типа, <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, который заменяется в этом случае параметр типа включающего типа <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 3: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Вариант 3: Универсальный метод <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> вызывается, указав <ph id="ph2">&lt;xref:System.Int32&gt;</ph> и <ph id="ph3">&lt;xref:System.Object&gt;</ph> для аргументы типа для универсального типа и универсального метода соответственно.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Вызов этого метода не зависит от параметров типа включающего типа или метода.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 4: The non-generic method <ph id="ph1">`M1`</ph> of the <ph id="ph2">`Example`</ph> class is called.</source>
          <target state="translated">Случай 4: Неуниверсальный метод <ph id="ph1">`M1`</ph> из <ph id="ph2">`Example`</ph> класс называется.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Вызов этого метода не зависит от параметров типа включающего типа или метода.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>In addition, the example defines the non-generic <ph id="ph1">`Example`</ph> class.</source>
          <target state="translated">Кроме того, в примере определяется неуниверсальные <ph id="ph1">`Example`</ph> класса.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This class has a method <ph id="ph1">`M`</ph> that makes a call to a generic method:</source>
          <target state="translated">Этот класс содержит метод <ph id="ph1">`M`</ph> , выполняется вызов универсального метода:</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 5: The generic method <ph id="ph1">`GM1`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Случай 5: Универсальный метод <ph id="ph1">`GM1`</ph> вызывается, указав <ph id="ph2">&lt;xref:System.Int32&gt;</ph> и <ph id="ph3">&lt;xref:System.Object&gt;</ph> для аргументы типа для универсального типа и универсального метода соответственно.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The context for this method has no enclosing generic type or generic method.</source>
          <target state="translated">Контекст для этого метода не имеет включающего универсального типа или универсального метода.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>For each case, the example first constructs a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents the called method, and then resolves the token using the <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, using the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> methods to get the values for the <ph id="ph5">`genericTypeArguments`</ph> and <ph id="ph6">`genericMethodArguments`</ph> parameters.</source>
          <target state="translated">Для каждого варианта, в примере сначала создается <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , представляющий вызываемый метод и затем разрешает маркер с помощью <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> перегрузку метода, с помощью <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> методы для получения значения для <ph id="ph5">`genericTypeArguments`</ph> и <ph id="ph6">`genericMethodArguments`</ph> параметры.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This technique works in all cases, because the methods return <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> for non-generic contexts.</source>
          <target state="translated">Эта техника работает во всех случаях, так как они возвращают <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> для контекстов, не являющимися универсальными.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The example compares the resolved <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the constructed <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">В примере сравнивается Разрешить <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> с сконструированный <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The example then attempts to use the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> method overload to resolve the token.</source>
          <target state="translated">В примере затем предпринимается попытка использовать <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> перегрузка метода для разрешения маркера.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</source>
          <target state="translated">Это работает в случаях, 3, 4 и 5, так как вызовы методов не зависит от универсального контекста.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</source>
          <target state="translated">В случаях, 1 и 2 исключение из-за недостатка информации для разрешения маркера.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The metadata token values are hard-coded as an enumeration.</source>
          <target state="translated">Значения маркера метаданных жестко запрограммированы в виде перечисления.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>If you change this code example, the token values are likely to change.</source>
          <target state="translated">Если изменить этот пример кода, значения маркера, скорее всего, изменится.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>To determine the new token values, compile the code and use Ildasm.exe with the <bpt id="p1">**</bpt>/TOKENS<ept id="p1">**</ept> option to examine the assembly.</source>
          <target state="translated">Чтобы определить новые значения маркера, скомпилировать код и используйте Ildasm.exe с <bpt id="p1">**</bpt>/TOKENS<ept id="p1">**</ept> для просмотра сборки.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The tokens can be found at the points of call.</source>
          <target state="translated">Токены можно найти в местах вызова.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Insert the new values into the enumeration, and recompile the example.</source>
          <target state="translated">Вставьте новые значения в перечислении и перекомпилировать пример.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a method or constructor in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является маркером для метода или конструктора в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> является объектом <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph>, сигнатура которого содержит тип элемента <ph id="ph3">&lt;see langword="var" /&gt;</ph> (параметр типа для универсального типа) или <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (параметр типа для универсального метода).</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является допустимым маркером для поля в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a method or constructor in the module.</source>
          <target state="translated">маркер метаданных, определяющий метод или конструктор в модуле.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющих аргументы типа для данного типа, если токен находится в области, либо значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если этот тип не является универсальным.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющих аргументы типа для метода, если токен находится в области, либо значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если этот метод не является универсальным.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Возвращает метод или конструктор, определенный заданным маркером метаданных, в контексте, определенном заданными параметрами универсального типа.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method that is identified by the specified metadata token.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>, представляющий метод, определенный заданным токеном метаданных.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> метода типа где <ph id="ph2">`metadataToken`</ph> находится в области, чтобы получить массив аргументов универсального типа для <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericMethodArguments`</ph>.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> метода на метод где <ph id="ph2">`metadataToken`</ph> находится в области, чтобы получить массив аргументов универсального типа для <ph id="ph3">`genericMethodArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Всегда можно безопасно предоставить эти аргументы, даже в том случае, если они не нужны.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Документация доступна через Интернет; в разделе <bpt id="p1">[</bpt>ECMA C# и общий стандарты инфраструктуры языка<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>стандарту ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на сайте ECMA.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The following example shows how to use the two overloads of the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> method to resolve metadata tokens from call sites in generic and non-generic contexts.</source>
          <target state="translated">Приведенный ниже показано, как использовать две перегрузки <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> метода для разрешения маркеров метаданных из вызова сайты в универсальных и неуниверсальных контекстов.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The code example defines two generic types, <ph id="ph1">`G1&lt;Tg1&gt;`</ph> and <ph id="ph2">`G2&lt;Tg2&gt;`</ph>, each of which has a generic method.</source>
          <target state="translated">В примере кода определяется два универсальных типов, <ph id="ph1">`G1&lt;Tg1&gt;`</ph> и <ph id="ph2">`G2&lt;Tg2&gt;`</ph>, каждый из которых содержит универсальный метод.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">`G1&lt;Tg1&gt;`</ph> also has a non-generic method that uses the type parameter <ph id="ph2">`Tg1`</ph> for its parameter.</source>
          <target state="translated"><ph id="ph1">`G1&lt;Tg1&gt;`</ph> также имеет неуниверсальный метод, который использует параметр типа <ph id="ph2">`Tg1`</ph> для его параметра.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The generic method <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> in type <ph id="ph2">`G2&lt;Tg2&gt;`</ph> contains several method calls:</source>
          <target state="translated">Универсальный метод <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> в типе <ph id="ph2">`G2&lt;Tg2&gt;`</ph> содержит несколько вызовов методов:</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 1: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, using the type parameters of <ph id="ph2">`G2&lt;Tg2&gt;`</ph> and <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> as the type arguments.</source>
          <target state="translated">Вариант 1: Универсальный метод <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> с использованием параметров типа <ph id="ph2">`G2&lt;Tg2&gt;`</ph> и <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> в качестве аргументов типа.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">Другими словами, типы параметров вызываемого метода будет зависеть от типов, которые используются для создания закрытого универсального типа из определения типа для <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 2: The non-generic method <ph id="ph1">`M1`</ph> is called.</source>
          <target state="translated">Вариант 2: Неуниверсальный метод <ph id="ph1">`M1`</ph> вызывается.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The parameter of this method uses the type parameter of the defining type, <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, which is replaced in this case by the type parameter of the enclosing type, <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">Параметр этого метода использует параметр типа, определяющего типа, <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, который заменяется в этом случае параметр типа включающего типа <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 3: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Вариант 3: Универсальный метод <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> вызывается, указав <ph id="ph2">&lt;xref:System.Int32&gt;</ph> и <ph id="ph3">&lt;xref:System.Object&gt;</ph> для аргументы типа для универсального типа и универсального метода соответственно.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Вызов этого метода не зависит от параметров типа включающего типа или метода.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 4: The non-generic method <ph id="ph1">`M1`</ph> of the <ph id="ph2">`Example`</ph> class is called.</source>
          <target state="translated">Случай 4: Неуниверсальный метод <ph id="ph1">`M1`</ph> из <ph id="ph2">`Example`</ph> класс называется.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Вызов этого метода не зависит от параметров типа включающего типа или метода.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>In addition, the example defines the non-generic <ph id="ph1">`Example`</ph> class.</source>
          <target state="translated">Кроме того, в примере определяется неуниверсальные <ph id="ph1">`Example`</ph> класса.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This class has a method <ph id="ph1">`M`</ph> that makes a call to a generic method.</source>
          <target state="translated">Этот класс содержит метод <ph id="ph1">`M`</ph> , выполняется вызов универсального метода.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 5: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Случай 5: Универсальный метод <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> вызывается, указав <ph id="ph2">&lt;xref:System.Int32&gt;</ph> и <ph id="ph3">&lt;xref:System.Object&gt;</ph> для аргументы типа для универсального типа и универсального метода соответственно.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The context for this method has no enclosing generic type or generic method.</source>
          <target state="translated">Контекст для этого метода не имеет включающего универсального типа или универсального метода.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>For each case, the example first constructs a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents the called method, and then resolves the token using the <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, using the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> methods to get the values for the <ph id="ph5">`genericTypeArguments`</ph> and <ph id="ph6">`genericMethodArguments`</ph> parameters.</source>
          <target state="translated">Для каждого варианта, в примере сначала создается <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , представляющий вызываемый метод и затем разрешает маркер с помощью <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> перегрузку метода, с помощью <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> методы для получения значения для <ph id="ph5">`genericTypeArguments`</ph> и <ph id="ph6">`genericMethodArguments`</ph> параметры.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This technique works in all cases, because the methods return <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> for non-generic contexts.</source>
          <target state="translated">Эта техника работает во всех случаях, так как они возвращают <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> для контекстов, не являющимися универсальными.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The example compares the resolved <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the constructed <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">В примере сравнивается Разрешить <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> с сконструированный <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The example then attempts to use the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> method overload to resolve the token.</source>
          <target state="translated">В примере затем предпринимается попытка использовать <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> перегрузка метода для разрешения маркера.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</source>
          <target state="translated">Это работает в случаях, 3, 4 и 5, так как вызовы методов не зависит от универсального контекста.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</source>
          <target state="translated">В случаях, 1 и 2 исключение из-за недостатка информации для разрешения маркера.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The metadata token values are hard-coded as an enumeration.</source>
          <target state="translated">Значения маркера метаданных жестко запрограммированы в виде перечисления.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>If you change this code example, the token values are likely to change.</source>
          <target state="translated">Если изменить этот пример кода, значения маркера, скорее всего, изменится.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>To determine the new token values, compile the code and use Ildasm.exe with the <bpt id="p1">**</bpt>/TOKENS<ept id="p1">**</ept> option to examine the assembly.</source>
          <target state="translated">Чтобы определить новые значения маркера, скомпилировать код и используйте Ildasm.exe с <bpt id="p1">**</bpt>/TOKENS<ept id="p1">**</ept> для просмотра сборки.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The tokens can be found at the points of call.</source>
          <target state="translated">Токены можно найти в местах вызова.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Insert the new values into the enumeration, and recompile the example.</source>
          <target state="translated">Вставьте новые значения в перечислении и перекомпилировать пример.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a method or constructor in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является маркером для метода или конструктора в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> является объектом <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph>, сигнатура которого содержит сведения о типе элемента <ph id="ph3">&lt;see langword="var" /&gt;</ph> (параметр типа для универсального типа) или <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (параметр типа для универсального метода), а для <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph>, <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph> или обоих параметров не предоставлены необходимые аргументы типа.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является допустимым маркером для поля в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>A metadata token that identifies a signature in the module.</source>
          <target state="translated">токен метаданных, определяющий подпись в модуле.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>Returns the signature blob identified by a metadata token.</source>
          <target state="translated">Возвращает большой двоичный объект подписи, определенный токеном метаданных.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>An array of bytes representing the signature blob.</source>
          <target state="translated">Массив байтов, представляющий большой двоичный объект подписи.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>Information about metadata tokens and signatures can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Сведения о сигнатуры и токены метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Документация доступна через Интернет; в разделе <bpt id="p1">[</bpt>ECMA C# и общий стандарты инфраструктуры языка<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>стандарту ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на сайте ECMA.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid <ph id="ph2">&lt;see langword="MemberRef" /&gt;</ph>, <ph id="ph3">&lt;see langword="MethodDef" /&gt;</ph>, <ph id="ph4">&lt;see langword="TypeSpec" /&gt;</ph>, signature, or <ph id="ph5">&lt;see langword="FieldDef" /&gt;</ph> token in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является допустимым объектом <ph id="ph2">&lt;see langword="MemberRef" /&gt;</ph>, <ph id="ph3">&lt;see langword="MethodDef" /&gt;</ph>, <ph id="ph4">&lt;see langword="TypeSpec" /&gt;</ph>, сигнатурой или маркером <ph id="ph5">&lt;see langword="FieldDef" /&gt;</ph> в области видимости текущего модуля.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является допустимым маркером для поля в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>A metadata token that identifies a string in the string heap of the module.</source>
          <target state="translated">маркер метаданных, определяющий строку в куче строк модуля.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>Returns the string identified by the specified metadata token.</source>
          <target state="translated">Возвращает строку, определенную заданным маркером метаданных.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing a string value from the metadata string heap.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, содержащий строковое значение из кучи строк метаданных.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Документация доступна через Интернет; в разделе <bpt id="p1">[</bpt>ECMA C# и общий стандарты инфраструктуры языка<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>стандарту ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на сайте ECMA.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a string in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является маркером для строки в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является допустимым маркером для поля в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the type identified by a metadata token.</source>
          <target state="translated">Возвращает тип, определенный токеном метаданных.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>A metadata token that identifies a type in the module.</source>
          <target state="translated">Маркер метаданных, который определяет тип в модуле.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>Returns the type identified by the specified metadata token.</source>
          <target state="translated">Возвращает тип, определенный заданным токеном метаданных.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the type that is identified by the specified metadata token.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий тип, который определяется заданным токеном метаданных.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>To resolve a metadata token for a <ph id="ph1">`TypeSpec`</ph> whose signature contains <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Чтобы разрешить токен метаданных для <ph id="ph1">`TypeSpec`</ph> , сигнатура которого содержит <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> или <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, используйте <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> перегрузку, которая позволяет предоставить необходимый контекст.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>That is, when you are resolving a metadata token for a type that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">То есть при разрешении токен метаданных для типа, который зависит от параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер, необходимо использовать перегруженный метод, который делает возможным предоставление таких параметров типа.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Документация доступна через Интернет; в разделе <bpt id="p1">[</bpt>ECMA C# и общий стандарты инфраструктуры языка<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>стандарту ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на сайте ECMA.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является маркером для типа в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> является объектом <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph>, сигнатура которого содержит тип элемента <ph id="ph3">&lt;see langword="var" /&gt;</ph> (параметр типа для универсального типа) или <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (параметр типа для универсального метода).</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является допустимым маркером для поля в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a type in the module.</source>
          <target state="translated">Маркер метаданных, который определяет тип в модуле.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющих аргументы типа для данного типа, если токен находится в области, либо значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если этот тип не является универсальным.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющих аргументы типа для метода, если токен находится в области, либо значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если этот метод не является универсальным.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Возвращает тип, определенный заданным токеном метаданных, в контексте, определенном заданными параметрами универсального типа.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the type that is identified by the specified metadata token.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий тип, который определяется заданным токеном метаданных.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> метода типа где <ph id="ph2">`metadataToken`</ph> находится в области, чтобы получить массив аргументов универсального типа для <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> метода на метод где <ph id="ph2">`metadataToken`</ph> находится в области, чтобы получить массив аргументов универсального типа для <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Всегда можно безопасно предоставить эти аргументы, даже в том случае, если они не нужны.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Документация доступна через Интернет; в разделе <bpt id="p1">[</bpt>ECMA C# и общий стандарты инфраструктуры языка<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>стандарту ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на сайте ECMA.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Код, который демонстрирует разрешение маркера с использованием универсального контекста (то есть параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер). в разделе <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является маркером для типа в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> является объектом <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph>, сигнатура которого содержит сведения о типе элемента <ph id="ph3">&lt;see langword="var" /&gt;</ph> (параметр типа для универсального типа) или <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (параметр типа для универсального метода), а для <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph>, <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph> или обоих параметров не предоставлены необходимые аргументы типа.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> не является допустимым маркером для поля в области текущего модуля.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.ScopeName">
          <source>Gets a string representing the name of the module.</source>
          <target state="translated">Возвращает строку, представляющую имя модуля.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>The module name.</source>
          <target state="translated">Имя модуля.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>The <ph id="ph1">`ScopeName`</ph> property is not used by the common language runtime, but you can use it to store any string you want in the property when you emit a module using the metadata APIs.</source>
          <target state="translated"><ph id="ph1">`ScopeName`</ph> Свойство не используется средой CLR, но его можно использовать для хранения любой строки в свойстве при создании модуля с помощью интерфейсов API метаданных.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>Reflection itself does not allow you to set the <ph id="ph1">`ScopeName`</ph> property.</source>
          <target state="translated">Средствами отражения не позволяют задать <ph id="ph1">`ScopeName`</ph> свойства.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>This example shows the effect of the <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, and <ph id="ph3">`Name`</ph> properties.</source>
          <target state="translated">В этом примере показано влияние <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, и <ph id="ph3">`Name`</ph> свойства.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Зарезервировано для будущего использования.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Должно быть равным IID_NULL.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Переданный массив имен, которые необходимо сопоставить.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Количество сопоставляемых имен.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Контекст языкового стандарта для интерпретации имен.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array that receives the IDs corresponding to the names.</source>
          <target state="translated">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Возвращаемые сведения о типе.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Идентификатор языкового стандарта для сведений о типе.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Получает указатель на объект с запрошенными сведениями о типе.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Идентифицирует член.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Зарезервировано для будущего использования.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Должно быть равным IID_NULL.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Флаги, описывающие контекст вызова.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Указатель, по которому будет сохранен результат.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Указатель на структуру, содержащую сведения об исключении.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Индекс первого аргумента, вызвавшего ошибку.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Предоставляет доступ к открытым свойствам и методам объекта.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::Invoke`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ToString">
          <source>Returns the name of the module.</source>
          <target state="translated">Возвращает имя модуля.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ToString">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the name of this module.</source>
          <target state="translated">Строка <ph id="ph1">&lt;see langword="String" /&gt;</ph>, представляющая имя этого модуля.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ToString">
          <source>The following example demonstrates a use of the <ph id="ph1">`ToString`</ph> method.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">`ToString`</ph> метода.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>