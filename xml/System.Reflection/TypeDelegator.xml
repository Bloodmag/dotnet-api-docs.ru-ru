<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TypeDelegator.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b857fe3" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2eccf4de-4b1c-4706-8cb3-f46682ccfb72a4f7885feb36b422d1bc1a67c2ca21bdc27b7a81.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a4f7885feb36b422d1bc1a67c2ca21bdc27b7a81</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b15b8cf0f6dbc1504057c88969d9ef4b790891fe</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/11/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.TypeDelegator">
          <source>Wraps a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object and delegates methods to that <ph id="ph2">&lt;see langword="Type" /&gt;</ph>.</source>
          <target state="translated">Инкапсулирует объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> и делегирует методы этому типу <ph id="ph2">&lt;see langword="Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>Derive from this type and override only those members you have to provide customization in, plus any members that are required by your program and not already implemented by <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>.</source>
          <target state="translated">Являются производными от этого типа и переопределить только те элементы, которые необходимо производить настройку, а также все члены, которые необходимы программе и еще не реализован <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> derives from <ph id="ph2">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> and implements most of the properties and methods of <ph id="ph3">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> является производным от <ph id="ph2">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> и реализует большинство свойств и методов <ph id="ph3">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>For each member it implements, <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> automatically delegates to the corresponding member of an internal <ph id="ph2">&lt;xref:System.Type&gt;</ph> object, which is supplied as an argument to the constructor.</source>
          <target state="translated">Для каждого элемента, он реализует <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> автоматически делегирует соответствующий член внутренним <ph id="ph2">&lt;xref:System.Type&gt;</ph> объект, который предоставляется в качестве аргумента конструктору.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>This internal <ph id="ph1">&lt;xref:System.Type&gt;</ph> object is exposed to deriving classes by the <ph id="ph2">`protected`</ph><ph id="ph3">&lt;xref:System.Reflection.TypeDelegator.typeImpl&gt;</ph> field.</source>
          <target state="translated">Это внутреннее <ph id="ph1">&lt;xref:System.Type&gt;</ph> объект предоставляется производными классами, <ph id="ph2">`protected`</ph> <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator.typeImpl&gt;</ph> поля.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>Some members of <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> have implementations even though the members themselves are simply inherited from <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Некоторые члены <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> имеют реализации, несмотря на то, что самих элементов просто наследуются от <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>In these cases, the implementation is provided by an overridden <ph id="ph1">`protected`</ph> method that has a name that ends in "Impl".</source>
          <target state="translated">В этих случаях реализация предоставляется по переопределенный <ph id="ph1">`protected`</ph> метод, который имеет имя, которое заканчивается суффиксом «Impl».</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>For example, the implementation for all overloads of the <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.GetMethods%2A&gt;</ph> method is supplied by the overridden <ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.GetMethodImpl%2A&gt;</ph> method.</source>
          <target state="translated">Например, реализация для всех перегруженных версий <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.GetMethods%2A&gt;</ph> указанный метод, переопределенный <ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.GetMethodImpl%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>The implementation for inherited properties such as <ph id="ph1">&lt;xref:System.Type.IsPublic%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph> is provided by the overridden <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A&gt;</ph> method.</source>
          <target state="translated">Реализацию для унаследованные свойства, такие как <ph id="ph1">&lt;xref:System.Type.IsPublic%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph> предоставляется переопределенным <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>Deriving classes can provide a public constructor that takes a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object as its parameter and simply passes that object to the <ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29&gt;</ph> constructor, or can set the internal <ph id="ph3">&lt;xref:System.Type&gt;</ph> object in some other way.</source>
          <target state="translated">Наследование классов может предоставить открытый конструктор, принимающий <ph id="ph1">&lt;xref:System.Type&gt;</ph> объекта в качестве параметра и просто передает объект, чтобы <ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29&gt;</ph> конструктор, или можно установить внутренний <ph id="ph3">&lt;xref:System.Type&gt;</ph> объект другим способом.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>If a deriving class uses a member that is not implemented by <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>, it must override that member and provide an implementation.</source>
          <target state="translated">Если производный класс использует член, который не реализован <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>, его необходимо переопределить этот элемент и предоставить реализацию.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>The simplest implementation is to call the corresponding member on the internal <ph id="ph1">&lt;xref:System.Type&gt;</ph> object exposed by the <ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.typeImpl&gt;</ph> field, but you can provide any implementation your application requires.</source>
          <target state="translated">Простой реализации является вызов соответствующего члена на внутренний <ph id="ph1">&lt;xref:System.Type&gt;</ph> объекту, предоставленному <ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.typeImpl&gt;</ph> поле, но может обеспечить реализацию вашему приложению.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>It is not necessary to override these members if they are not used by your application or by library functions your application calls (for example, by the <ph id="ph1">&lt;xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=nameWithType&gt;</ph> constructor).</source>
          <target state="translated">Это не требуется переопределять эти элементы, если они не используются приложением или библиотекой функции приложение вызывает (например, с <ph id="ph1">&lt;xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=nameWithType&gt;</ph> конструктора).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>The following virtual methods (<ph id="ph1">`Overridable`</ph> methods in Visual Basic) of <ph id="ph2">&lt;xref:System.Type&gt;</ph> are not implemented by <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>: <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>, <ph id="ph9">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph>, <ph id="ph10">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>, <ph id="ph11">&lt;xref:System.Type.GetEnumNames%2A&gt;</ph>, <ph id="ph12">&lt;xref:System.Type.GetEnumValues%2A&gt;</ph>, <ph id="ph13">&lt;xref:System.Type.GetEnumUnderlyingType%2A&gt;</ph>, <ph id="ph14">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph>, <ph id="ph15">&lt;xref:System.Type.IsEnumDefined%2A&gt;</ph>, <ph id="ph16">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph>.</source>
          <target state="translated">Следующие виртуальные методы (<ph id="ph1">`Overridable`</ph> методы в Visual Basic) для <ph id="ph2">&lt;xref:System.Type&gt;</ph> не реализован <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>: <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>, <ph id="ph9">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph>, <ph id="ph10">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> , <ph id="ph11">&lt;xref:System.Type.GetEnumNames%2A&gt;</ph>, <ph id="ph12">&lt;xref:System.Type.GetEnumValues%2A&gt;</ph>, <ph id="ph13">&lt;xref:System.Type.GetEnumUnderlyingType%2A&gt;</ph>, <ph id="ph14">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph>, <ph id="ph15">&lt;xref:System.Type.IsEnumDefined%2A&gt;</ph>, <ph id="ph16">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>The following virtual properties (<ph id="ph1">`Overridable`</ph> properties in Visual Basic) of <ph id="ph2">&lt;xref:System.Type&gt;</ph> are not implemented by <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>: <ph id="ph4">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>, <ph id="ph9">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph>, <ph id="ph10">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>, <ph id="ph11">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph12">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, <ph id="ph13">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph>.</source>
          <target state="translated">Следующие свойства виртуального (<ph id="ph1">`Overridable`</ph> свойств в Visual Basic) для <ph id="ph2">&lt;xref:System.Type&gt;</ph> не реализован <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>: <ph id="ph4">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>, <ph id="ph9">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph>, <ph id="ph10">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> , <ph id="ph11">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph12">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, <ph id="ph13">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="T:System.Reflection.TypeDelegator">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> class with default properties.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> стандартными свойствами.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.#ctor(System.Type)">
          <source>The instance of the class <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> that encapsulates the call to the method of an object.</source>
          <target state="translated">Экземпляр класса <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который инкапсулирует вызов метода объекта.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.#ctor(System.Type)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> class specifying the encapsulating instance.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>, задавая инкапсулирующий экземпляр.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.#ctor(System.Type)">
          <source>This constructor is called from a class to generate a delegate based upon the <ph id="ph1">`Type`</ph> object for the class defining the method.</source>
          <target state="translated">Данный конструктор вызывается из класса для создания делегата на основе <ph id="ph1">`Type`</ph> объект для класса, определяющего метод.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.#ctor(System.Type)">
          <source><ph id="ph1">&lt;paramref name="delegatingType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="delegatingType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.Assembly">
          <source>Gets the assembly of the implemented type.</source>
          <target state="translated">Возвращает сборку реализуемого типа.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Assembly">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> object representing the assembly of the implemented type.</source>
          <target state="translated">Объект типа <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>, представляющий сборку реализуемого типа.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Assembly">
          <source>Assemblies are the deployment units in the common language runtime.</source>
          <target state="translated">Сборки представляют собой единицы развертывания в среде CLR.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Assembly">
          <source>Assemblies establish the namespace for resolving requests and determine which resources are exposed externally and which are accessible from within the assembly.</source>
          <target state="translated">Сборки образуют пространство имен для разрешения запросов и определить, какие ресурсы доступны извне и доступные в пределах сборки.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Assembly">
          <source>The common language runtime can determine and locate the assembly for any running object.</source>
          <target state="translated">Общеязыковая среда выполнения определяет и найти сборку для любого выполняющегося объекта.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.AssemblyQualifiedName">
          <source>Gets the assembly's fully qualified name.</source>
          <target state="translated">Возвращает полное имя сборки.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.AssemblyQualifiedName">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing the assembly's fully qualified name.</source>
          <target state="translated">Строка <ph id="ph1">&lt;see langword="String" /&gt;</ph>, содержащая полное имя сборки.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.BaseType">
          <source>Gets the base type for the current type.</source>
          <target state="translated">Возвращает базовый тип текущего типа.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.BaseType">
          <source>The base type for a type.</source>
          <target state="translated">Базовый тип данного типа.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.BaseType">
          <source>The base type is the type from which this type directly inherits.</source>
          <target state="translated">Базовый тип является типом, от которого непосредственно наследуется этот тип.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.BaseType">
          <source>Since the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class type is the ultimate base class of all the other types, it is the only type that does not have a base type.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.Object&gt;</ph> тип класса является исходным базовым классом для всех других типов, он является единственным типом, у которого нет базового типа.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.BaseType">
          <source>In this case, <ph id="ph1">`null`</ph> is returned as the base type of the <ph id="ph2">`Object`</ph> type.</source>
          <target state="translated">В этом случае <ph id="ph1">`null`</ph> возвращается как базовый тип <ph id="ph2">`Object`</ph> типа.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.FullName">
          <source>Gets the fully qualified name of the implemented type.</source>
          <target state="translated">Возвращает полное имя реализуемого типа.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.FullName">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing the type's fully qualified name.</source>
          <target state="translated">Строка <ph id="ph1">&lt;see langword="String" /&gt;</ph>, содержащая полное имя типа.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.FullName">
          <source>A string containing the fully qualified name of the current <ph id="ph1">`TypeDelegator`</ph>.</source>
          <target state="translated">Строка, содержащая полное имя текущего <ph id="ph1">`TypeDelegator`</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetAttributeFlagsImpl">
          <source>Gets the attributes assigned to the <ph id="ph1">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Получает атрибуты, присвоенные объекту <ph id="ph1">&lt;see langword="TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetAttributeFlagsImpl">
          <source>A <ph id="ph1">&lt;see langword="TypeAttributes" /&gt;</ph> object representing the implementation attribute flags.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="TypeAttributes" /&gt;</ph>, представляющий флаги атрибутов реализации.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetAttributeFlagsImpl">
          <source>This method can be used to determine if the <ph id="ph1">`TypeDelegator`</ph> is abstract, public, and so on.</source>
          <target state="translated">Этот метод можно использовать для определения <ph id="ph1">`TypeDelegator`</ph> является абстрактным, открытым и т. д.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Битовая маска, влияющая на способ выполнения поиска.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Значение является сочетанием битовых флагов из перечисления <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> с помощью отражения.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Если указан <bpt id="p1">&lt;c&gt;</bpt>модуль привязки<ept id="p1">&lt;/c&gt;</ept> <ph id="ph1">&lt;see langword="null" /&gt;</ph>, используется модуль привязки по умолчанию.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling conventions.</source>
          <target state="translated">Соглашения о вызовах.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing a list of the parameter number, order, and types.</source>
          <target state="translated">Массив объектов типа <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, содержащий число, порядок и типы параметров.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Types cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>; use an appropriate <ph id="ph2">&lt;see langword="GetMethod" /&gt;</ph> method or an empty array to search for a method without parameters.</source>
          <target state="translated">Типы не могут иметь значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>; для поиска метода без параметров следует использовать соответствующий метод <ph id="ph2">&lt;see langword="GetMethod" /&gt;</ph> или пустой массив.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of type <ph id="ph1">&lt;see langword="ParameterModifier" /&gt;</ph> having the same length as the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array, whose elements represent the attributes associated with the parameters of the method to get.</source>
          <target state="translated">Массив типа <ph id="ph1">&lt;see langword="ParameterModifier" /&gt;</ph>, имеющий такую же длину, как и массив <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>, элементы которого представляют атрибуты, связанные с параметрами получаемого метода.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Gets the constructor that implemented the <ph id="ph1">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Возвращает конструктор, при помощи которого был реализован объект <ph id="ph1">&lt;see langword="TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see langword="ConstructorInfo" /&gt;</ph> object for the method that matches the specified criteria, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if a match cannot be found.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="ConstructorInfo" /&gt;</ph> для метода, который соответствует заданным критериям, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если совпадение не найдено.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">`callConvention`</ph> parameter indicates the calling convention for the entry point.</source>
          <target state="translated"><ph id="ph1">`callConvention`</ph> Указывает соглашение о вызовах для точки входа.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If no calling convention is specified, a default <ph id="ph1">&lt;xref:System.Reflection.CallingConventions&gt;</ph> value of <ph id="ph2">`Standard`</ph> is used.</source>
          <target state="translated">Если соглашение о вызовах не указан, значение по умолчанию <ph id="ph1">&lt;xref:System.Reflection.CallingConventions&gt;</ph> значение <ph id="ph2">`Standard`</ph> используется.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Битовая маска, влияющая на способ выполнения поиска.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Значение является сочетанием битовых флагов из перечисления <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing constructors defined for the type wrapped by the current <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>, представляющих конструкторы, определенные для типа, который инкапсулируется в текущем типе <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="ConstructorInfo" /&gt;</ph> containing the specified constructors defined for this class.</source>
          <target state="translated">Массив объектов типа <ph id="ph1">&lt;see langword="ConstructorInfo" /&gt;</ph>, содержащий заданные конструкторы, определенные для этого класса.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>If no constructors are defined, an empty array is returned.</source>
          <target state="translated">Если конструкторы не определены, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>Depending on the value of a specified parameter, only public constructors or both public and non-public constructors will be returned.</source>
          <target state="translated">В зависимости от значения заданного параметра возвращаются только открытые конструкторы либо как открытые, так и закрытые конструкторы.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>Class initializers are available only through <ph id="ph1">`GetMember`</ph>, <ph id="ph2">`GetMembers`</ph>, <ph id="ph3">`FindMembers`</ph>, and <ph id="ph4">`GetConstructors`</ph>.</source>
          <target state="translated">Инициализаторы класса доступны только через <ph id="ph1">`GetMember`</ph>, <ph id="ph2">`GetMembers`</ph>, <ph id="ph3">`FindMembers`</ph>, и <ph id="ph4">`GetConstructors`</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="T:System.Reflection.TypeDelegator">
          <source>Returns all the custom attributes defined for this type.</source>
          <target state="translated">Возвращает все настраиваемые атрибуты, определенные для данного типа.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)">
          <source>Specifies whether to search this type's inheritance chain to find the attributes.</source>
          <target state="translated">Указывает, что необходимо просмотреть цепочку наследования этого типа для поиска данных атрибутов.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for this type, specifying whether to search the type's inheritance chain.</source>
          <target state="translated">Возвращает все пользовательские атрибуты, определенные для этого типа, а также определяет, должна ли быть просмотрена цепочка наследования данного типа.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)">
          <source>An array of objects containing all the custom attributes defined for this type.</source>
          <target state="translated">Массив объектов, содержащих все пользовательские атрибуты, определенные для этого типа.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)">
          <source>A custom attribute type cannot be loaded.</source>
          <target state="translated">Не удалось загрузить тип настраиваемого атрибута.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of custom attributes identified by type.</source>
          <target state="translated">Массив пользовательских атрибутов, идентифицируемых типом.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Specifies whether to search this type's inheritance chain to find the attributes.</source>
          <target state="translated">Указывает, что необходимо просмотреть цепочку наследования этого типа для поиска данных атрибутов.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns an array of custom attributes identified by type.</source>
          <target state="translated">Возвращает массив пользовательских атрибутов, отбираемых по типу.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of objects containing the custom attributes defined in this type that match the <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> parameter, specifying whether to search the type's inheritance chain, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no custom attributes are defined on this type.</source>
          <target state="translated">Массив объектов, содержащих пользовательские атрибуты, определенные в этом типе, которые соответствуют параметру <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>, задающему необходимость просмотра иерархии наследования типа, либо значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если пользовательские атрибуты для этого типа не определены.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source>A custom attribute type cannot be loaded.</source>
          <target state="translated">Не удалось загрузить тип настраиваемого атрибута.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetElementType">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer or ByRef.</source>
          <target state="translated">Возвращает тип <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> объекта, используемого или упоминаемого в текущем массиве, указателе или параметре ByRef.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetElementType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer or <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the current <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> is not an array, a pointer or a <ph id="ph5">&lt;see langword="ByRef" /&gt;</ph>.</source>
          <target state="translated">Тип <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> объекта, используемого или упоминаемого в текущем массиве, указателе или параметре <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> или значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>, если текущий тип <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> не является массивом, указателем или параметром <ph id="ph5">&lt;see langword="ByRef" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The name of the event to get.</source>
          <target state="translated">Имя возвращаемого события.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Битовая маска, влияющая на способ выполнения поиска.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Значение является сочетанием битовых флагов из перечисления <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Returns the specified event.</source>
          <target state="translated">Возвращает заданное событие.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the event declared or inherited by this type with the specified name.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, представляющий событие, объявленное или унаследованное этим типом с заданным именем.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>This method returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no such event is found.</source>
          <target state="translated">Если такое событие не найдено, метод возвращает значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>If <ph id="ph1">`bindingAttr`</ph> is <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.<ph id="ph3">`IgnoreCase`</ph>, the case of the <ph id="ph4">`name`</ph> parameter is ignored.</source>
          <target state="translated">Если <ph id="ph1">`bindingAttr`</ph> — <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.<ph id="ph3">`IgnoreCase`</ph>, вариант <ph id="ph4">`name`</ph> параметр учитывается.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="T:System.Reflection.TypeDelegator">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all the public events declared or inherited by the current <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Возвращает массив объектов типа <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, представляющих все открытые события, объявленные или унаследованные текущим объектом <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all the public events declared or inherited by the current <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Возвращает массив объектов типа <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, представляющих все открытые события, объявленные или унаследованные текущим объектом <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents">
          <source>Returns an array of type <ph id="ph1">&lt;see langword="EventInfo" /&gt;</ph> containing all the events declared or inherited by the current type.</source>
          <target state="translated">Возвращает массив объектов типа <ph id="ph1">&lt;see langword="EventInfo" /&gt;</ph>, представляющих все события, объявленные или унаследованные текущим типом.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents">
          <source>If there are no events, an empty array is returned.</source>
          <target state="translated">Если события отсутствуют, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Битовая маска, влияющая на способ выполнения поиска.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Значение является сочетанием битовых флагов из перечисления <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)">
          <source>Returns the events specified in <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph> that are declared or inherited by the current <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Возвращает события, заданные параметром <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph> и объявленные или унаследованные текущим объектом <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="EventInfo" /&gt;</ph> containing the events specified in <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph>.</source>
          <target state="translated">Массив объектов типа <ph id="ph1">&lt;see langword="EventInfo" /&gt;</ph>, содержащий события, заданные параметром <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)">
          <source>If there are no events, an empty array is returned.</source>
          <target state="translated">Если события отсутствуют, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The name of the field to find.</source>
          <target state="translated">Имя искомого поля.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Битовая маска, влияющая на способ выполнения поиска.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Значение является сочетанием битовых флагов из перечисления <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field with the specified name.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, представляющий поле с заданным именем.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> object representing the field declared or inherited by this <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> with the specified name.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph>, представляющий поле, объявленное или унаследованное этим объектом <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> с заданным именем.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no such field is found.</source>
          <target state="translated">Если такое поле не найдено, возвращается значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Use a <ph id="ph1">`bindingAttr`</ph> of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.NonPublic to return all public and nonpublic fields.</source>
          <target state="translated">Используйте <ph id="ph1">`bindingAttr`</ph> из <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>. NonPublic, чтобы вернуть все открытые и закрытые поля.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Use <ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of the fields, as the search is case-sensitive by default.</source>
          <target state="translated">Используйте <ph id="ph1">`BindingFlags.IgnoreCase`</ph> учитывать регистр полей, как поиск с учетом регистра по умолчанию.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Битовая маска, влияющая на способ выполнения поиска.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Значение является сочетанием битовых флагов из перечисления <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing the data fields defined for the type wrapped by the current <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, представляющих поля данных, определенные для типа, который инкапсулируется в текущем типе <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> containing the fields declared or inherited by the current <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Массив объектов типа <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph>, представляющих поля, объявленные или унаследованные текущим объектом <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no matched fields.</source>
          <target state="translated">Если совпадающие поля отсутствуют, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.GetFields%2A&gt;</ph> Метод не возвращает поля в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">Код не должен зависеть порядка, в котором возвращаются поля, так как этот порядок может меняться.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>Use a <ph id="ph1">`bindingAttr`</ph> of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.NonPublic to return all public and nonpublic fields.</source>
          <target state="translated">Используйте <ph id="ph1">`bindingAttr`</ph> из <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>. NonPublic, чтобы вернуть все открытые и закрытые поля.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source>The fully qualified name of the interface implemented by the current class.</source>
          <target state="translated">Полное имя интерфейса, реализованного в текущем классе.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the case is to be ignored; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если регистр не должен учитываться; в обратном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source>Returns the specified interface implemented by the type wrapped by the current <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Возвращает заданный интерфейс, реализованный типом, инкапсулированным в текущем классе <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object representing the interface implemented (directly or indirectly) by the current class with the fully qualified name matching the specified name.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, представляющий интерфейс, явно или косвенно реализованный в текущем классе, с полным именем, соответствующим заданному имени.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source>If no interface that matches name is found, null is returned.</source>
          <target state="translated">Если интерфейс с совпадающим именем не найден, возвращается пустое значение.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the interface to retrieve a mapping of.</source>
          <target state="translated">Тип <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> интерфейса предназначен для извлечения сопоставления.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)">
          <source>Returns an interface mapping for the specified interface type.</source>
          <target state="translated">Возвращает сопоставление для интерфейса заданного типа.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.InterfaceMapping" /&gt;</ph> object representing the interface mapping for <ph id="ph2">&lt;paramref name="interfaceType" /&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.InterfaceMapping" /&gt;</ph>, который представляет сопоставление интерфейса для параметра <ph id="ph2">&lt;paramref name="interfaceType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)">
          <source>The interface map denotes how an interface is mapped into the actual methods on a class that implements that interface.</source>
          <target state="translated">В сопоставлении интерфейса указывается способ отображения интерфейса в фактических методах для класса, реализующего этот интерфейс.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaces">
          <source>Returns all the interfaces implemented on the current class and its base classes.</source>
          <target state="translated">Возвращает все интерфейсы, реализованные в текущем классе и его базовых классах.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaces">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing all the interfaces implemented on the current class and its base classes.</source>
          <target state="translated">Массив объектов типа <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, содержащий все интерфейсы, реализованные в текущем классе и его базовых классах.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaces">
          <source>If none are defined, an empty array is returned.</source>
          <target state="translated">Если они не определены, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The name of the member to get.</source>
          <target state="translated">Имя возвращаемого члена.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Битовая маска, влияющая на способ выполнения поиска.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Значение является сочетанием битовых флагов из перечисления <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The type of members to get.</source>
          <target state="translated">Тип возвращаемого члена.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Returns members (properties, methods, constructors, fields, events, and nested types) specified by the given <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="type" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="bindingAttr" /&gt;</ph>.</source>
          <target state="translated">Возвращает члены (свойства, методы, конструкторы, поля, события и вложенные типы), задаваемые параметрами <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="type" /&gt;</ph> и <ph id="ph3">&lt;paramref name="bindingAttr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> containing all the members of the current class and its base class meeting the specified criteria.</source>
          <target state="translated">Массив объектов типа <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph>, содержащий все члены текущего и его базовых классов, удовлетворяющие заданным критериям.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If <ph id="ph1">`bindingAttr`</ph> is <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.NonPublic, all the members will be considered.</source>
          <target state="translated">Если <ph id="ph1">`bindingAttr`</ph> — <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>. NonPublic, все члены будут учитываться.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If there are no matches, an empty array is returned.</source>
          <target state="translated">Если совпадений не найдено, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Битовая маска, влияющая на способ выполнения поиска.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Значение является сочетанием битовых флагов из перечисления <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>Returns members specified by <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph>.</source>
          <target state="translated">Возвращает члены, заданные параметром <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> containing all the members of the current class and its base classes that meet the <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph> filter.</source>
          <target state="translated">Массив объектов типа <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph>, содержащий все члены текущего класса и его базовых классов, удовлетворяющие условиям фильтра <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>If <ph id="ph1">`bindingAttr`</ph> is <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.NonPublic, all the members will be considered.</source>
          <target state="translated">Если <ph id="ph1">`bindingAttr`</ph> — <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>. NonPublic, все члены будут учитываться.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>If there are no matches, an empty array is returned.</source>
          <target state="translated">Если совпадений не найдено, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The method name.</source>
          <target state="translated">Имя метода.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Битовая маска, влияющая на способ выполнения поиска.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Значение является сочетанием битовых флагов из перечисления <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> с помощью отражения.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Если указан <bpt id="p1">&lt;c&gt;</bpt>модуль привязки<ept id="p1">&lt;/c&gt;</ept> <ph id="ph1">&lt;see langword="null" /&gt;</ph>, используется модуль привязки по умолчанию.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling conventions.</source>
          <target state="translated">Соглашения о вызовах.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing a list of the parameter number, order, and types.</source>
          <target state="translated">Массив объектов типа <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, содержащий число, порядок и типы параметров.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Types cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>; use an appropriate <ph id="ph2">&lt;see langword="GetMethod" /&gt;</ph> method or an empty array to search for a method without parameters.</source>
          <target state="translated">Типы не могут иметь значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>; для поиска метода без параметров следует использовать соответствующий метод <ph id="ph2">&lt;see langword="GetMethod" /&gt;</ph> или пустой массив.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of type <ph id="ph1">&lt;see langword="ParameterModifier" /&gt;</ph> having the same length as the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array, whose elements represent the attributes associated with the parameters of the method to get.</source>
          <target state="translated">Массив типа <ph id="ph1">&lt;see langword="ParameterModifier" /&gt;</ph>, имеющий такую же длину, как и массив <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>, элементы которого представляют атрибуты, связанные с параметрами получаемого метода.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">Ищет метод с параметрами, соответствующими указанным модификаторам и типам аргументов, с учетом заданных ограничений привязки и соглашений о вызовах.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see langword="MethodInfoInfo" /&gt;</ph> object for the implementation method that matches the specified criteria, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if a match cannot be found.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="MethodInfoInfo" /&gt;</ph> для реализации метода, который соответствует заданным критериям, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если совпадение не найдено.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">`callConvention`</ph> parameter indicates the calling convention for the entry point.</source>
          <target state="translated"><ph id="ph1">`callConvention`</ph> Указывает соглашение о вызовах для точки входа.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If no <ph id="ph1">&lt;xref:System.Reflection.CallingConventions&gt;</ph> is specified, a default <ph id="ph2">`CallingConventions`</ph> value of <ph id="ph3">`Standard`</ph> is used.</source>
          <target state="translated">Если не <ph id="ph1">&lt;xref:System.Reflection.CallingConventions&gt;</ph> указан, значение по умолчанию <ph id="ph2">`CallingConventions`</ph> значение <ph id="ph3">`Standard`</ph> используется.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Битовая маска, влияющая на способ выполнения поиска.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Значение является сочетанием битовых флагов из перечисления <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing specified methods of the type wrapped by the current <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, представляющих заданные методы типа, который инкапсулируется в текущем типе <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> objects representing the methods defined on this <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph>, представляющих методы, определенные для данного объекта <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The nested type's name.</source>
          <target state="translated">Имя вложенного типа.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Битовая маска, влияющая на способ выполнения поиска.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Значение является сочетанием битовых флагов из перечисления <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Returns a nested type specified by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> and in <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph> that are declared or inherited by the type represented by the current <ph id="ph3">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Возвращает вложенный тип, заданный параметрами <ph id="ph1">&lt;paramref name="name" /&gt;</ph> и <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph>, которые объявлены или унаследованы типом, представленным текущим объектом <ph id="ph3">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object representing the nested type.</source>
          <target state="translated">Объект типа <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, представляющий вложенный тип.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Битовая маска, влияющая на способ выполнения поиска.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Значение является сочетанием битовых флагов из перечисления <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Returns the nested types specified in <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph> that are declared or inherited by the type wrapped by the current <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Возвращает вложенные типы, заданные параметром <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph>, которые объявлены или унаследованы типом, инкапсулированным в текущем объекте <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing the nested types.</source>
          <target state="translated">Массив объектов типа <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, содержащих вложенные типы.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Битовая маска, влияющая на способ выполнения поиска.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Значение является сочетанием битовых флагов из перечисления <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> objects representing properties of the type wrapped by the current <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>, представляющих заданные свойства типа, который инкапсулируется в текущем типе <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph> objects representing properties defined on this <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph>, представляющих свойства, определенные для данного объекта <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The property to get.</source>
          <target state="translated">Возвращаемое свойство.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Битовая маска, влияющая на способ выполнения поиска.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Значение является сочетанием битовых флагов из перечисления <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects via reflection.</source>
          <target state="translated">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> с помощью отражения.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Если указан <bpt id="p1">&lt;c&gt;</bpt>модуль привязки<ept id="p1">&lt;/c&gt;</ept> <ph id="ph1">&lt;see langword="null" /&gt;</ph>, используется модуль привязки по умолчанию.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">См. раздел <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">Тип возвращаемого значения свойства.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A list of parameter types.</source>
          <target state="translated">Список типов параметров.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The list represents the number, order, and types of the parameters.</source>
          <target state="translated">В списке представлено количество, порядок и типы параметров.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Types cannot be null; use an appropriate <ph id="ph1">&lt;see langword="GetMethod" /&gt;</ph> method or an empty array to search for a method without parameters.</source>
          <target state="translated">Типы не могут иметь значение "null"; для поиска метода без параметров следует использовать соответствующий метод <ph id="ph1">&lt;see langword="GetMethod" /&gt;</ph> или пустой массив.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of the same length as types with elements that represent the attributes associated with the parameters of the method to get.</source>
          <target state="translated">Массив такой же длины, что и типы, элементы которых представляют атрибуты, сопоставленные параметрам получаемого метода.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">При переопределении в производном классе выполняет поиск заданного свойства, параметры которого соответствуют типам и модификаторам заданных аргументов, с использованием заданных ограничений привязки.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> object for the property that matches the specified criteria, or null if a match cannot be found.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> для свойства, которое соответствует заданным критериям, или пустое значение, если совпадение не найдено.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.GUID">
          <source>Gets the GUID (globally unique identifier) of the implemented type.</source>
          <target state="translated">Возвращает GUID (глобальный идентификатор) реализуемого типа.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.GUID">
          <source>A GUID.</source>
          <target state="translated">Идентификатор GUID.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.GUID">
          <source>The GUID (globally unique identifier) is a 128-bit unique identification string used to identify a class or an interface.</source>
          <target state="translated">Глобально уникальный идентификатор (GUID) — 128-разрядный уникальный идентификационный строка, используемая для определения класса или интерфейса.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.GUID">
          <source>It is primarily useful for interoperability between the Microsoft .NET Framework and COM.</source>
          <target state="translated">В основном полезно для обеспечения взаимодействия между Microsoft .NET Framework и COM.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.HasElementTypeImpl">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer or a ByRef.</source>
          <target state="translated">Возвращает значение, указывающее, использует или обращается ли текущий тип <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> к другому типу; другими словами, является ли текущий тип <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> массивом, указателем или параметром ByRef.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.HasElementTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer or a ByRef; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если тип <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является массивом, указателем или параметром ByRef; в обратном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The name of the member to invoke.</source>
          <target state="translated">Имя вызываемого члена.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This may be a constructor, method, property, or field.</source>
          <target state="translated">Это может быть конструктор, метод, свойство или поле.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If an empty string ("") is passed, the default member is invoked.</source>
          <target state="translated">Если передается пустая строка (""), вызывается стандартный член.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The invocation attribute.</source>
          <target state="translated">Атрибут вызова.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This must be one of the following <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="Static" /&gt;</ph>, <ph id="ph5">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph7">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph8">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated">Атрибут должен быть одним из следующих флагов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="Static" /&gt;</ph>, <ph id="ph5">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph7">&lt;see langword="GetProperty" /&gt;</ph> или <ph id="ph8">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A suitable invocation attribute must be specified.</source>
          <target state="translated">Необходимо указать подходящий атрибут вызова.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If a static member is to be invoked, the <ph id="ph1">&lt;see langword="Static" /&gt;</ph> flag must be set.</source>
          <target state="translated">Для вызова статического члена должен быть установлен флаг <ph id="ph1">&lt;see langword="Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects via reflection.</source>
          <target state="translated">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> с помощью отражения.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Если указан <bpt id="p1">&lt;c&gt;</bpt>модуль привязки<ept id="p1">&lt;/c&gt;</ept> <ph id="ph1">&lt;see langword="null" /&gt;</ph>, используется модуль привязки по умолчанию.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">См. раздел <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">Объект, для которого следует вызвать указанный член.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of type <ph id="ph1">&lt;see langword="Object" /&gt;</ph> that contains the number, order, and type of the parameters of the member to be invoked.</source>
          <target state="translated">Массив объектов типа <ph id="ph1">&lt;see langword="Object" /&gt;</ph>, содержащий число, последовательность и тип параметров, получаемых вызываемым методом.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> contains an uninitialized <ph id="ph1">&lt;see langword="Object" /&gt;</ph>, it is treated as empty, which, with the default binder, can be widened to 0, 0.0 or a string.</source>
          <target state="translated">Если параметр <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> содержит не инициализированный объект <ph id="ph1">&lt;see langword="Object" /&gt;</ph>, он обрабатывается как пустой и может быть преобразован стандартным связывателем в 0, 0,0 или строку.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of type <ph id="ph1">&lt;see langword="ParameterModifer" /&gt;</ph> that is the same length as <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>, with elements that represent the attributes associated with the arguments of the member to be invoked.</source>
          <target state="translated">Массив типа <ph id="ph1">&lt;see langword="ParameterModifer" /&gt;</ph> такой же длины, как и массив <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>, элементы которого представляют атрибуты, связанные с аргументами вызываемого члена.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A parameter has attributes associated with it in the member's signature.</source>
          <target state="translated">С параметром связаны атрибуты в сигнатуре члена.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For ByRef, use <ph id="ph1">&lt;see langword="ParameterModifer.ByRef" /&gt;</ph>, and for none, use <ph id="ph2">&lt;see langword="ParameterModifer.None" /&gt;</ph>.</source>
          <target state="translated">Для параметра ByRef следует использовать параметр <ph id="ph1">&lt;see langword="ParameterModifer.ByRef" /&gt;</ph>, а при отсутствии параметра — параметр <ph id="ph2">&lt;see langword="ParameterModifer.None" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder does exact matching on these.</source>
          <target state="translated">Связыватель по умолчанию выбирает точное совпадение.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Attributes such as <ph id="ph1">&lt;see langword="In" /&gt;</ph> and <ph id="ph2">&lt;see langword="InOut" /&gt;</ph> are not used in binding, and can be viewed using <ph id="ph3">&lt;see langword="ParameterInfo" /&gt;</ph>.</source>
          <target state="translated">Такие атрибуты, как <ph id="ph1">&lt;see langword="In" /&gt;</ph> и <ph id="ph2">&lt;see langword="InOut" /&gt;</ph>, не используются в привязке и могут быть просмотрены с помощью свойства <ph id="ph3">&lt;see langword="ParameterInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Экземпляр объекта <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph>, используемого для управления приведением типов.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This is necessary, for example, to convert a string that represents 1000 to a <ph id="ph1">&lt;see langword="Double" /&gt;</ph> value, since 1000 is represented differently by different cultures.</source>
          <target state="translated">Он необходим, например, для преобразования строки, которая представляет число 1000, в значение типа <ph id="ph1">&lt;see langword="Double" /&gt;</ph>, поскольку в разных культурах 1000 может быть представлено по-разному.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread's <ph id="ph3">&lt;see langword="CultureInfo" /&gt;</ph> is used.</source>
          <target state="translated">Если параметр <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> имеет значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, используется <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> для <ph id="ph3">&lt;see langword="CultureInfo" /&gt;</ph> текущего потока.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of type <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing parameter names that match up, starting at element zero, with the <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Массив типа <ph id="ph1">&lt;see langword="String" /&gt;</ph>, содержащий имена параметров, совпадающие, начиная с нулевого элемента, с массивом <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>There must be no holes in the array.</source>
          <target state="translated">В массиве не должно быть пустых элементов.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Если <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;see langword="Length" /&gt;</ph> is greater than <bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Length" /&gt;</ph> больше <bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;see langword="Length" /&gt;</ph>, the remaining parameters are filled in order.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Length" /&gt;</ph>, остальные параметры заполняются по порядку.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Invokes the specified member.</source>
          <target state="translated">Вызывает указанный член.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</source>
          <target state="translated">Вызываемый метод должен быть доступен и обеспечивать наиболее точное соответствие заданному списку аргументов с учетом ограничений заданного модуля привязки и атрибутов вызова.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An <ph id="ph1">&lt;see langword="Object" /&gt;</ph> representing the return value of the invoked member.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="Object" /&gt;</ph>, представляющий значение, возвращаемое указанным членом.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A method will be invoked if both the following conditions are true:</source>
          <target state="translated">Метод будет вызван, если выполняются следующие условия:</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The number of parameters in the method declaration equals the number of arguments in the specified argument list (unless default arguments are defined on the member).</source>
          <target state="translated">Число параметров в объявлении метода равно количеству аргументов в списке аргументов (если аргументы по умолчанию не определены в элементе).</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The type of each arguments can be converted by the binder to the type of the parameter.</source>
          <target state="translated">Тип каждого аргумента может преобразовываться связывателем тип параметра.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The binder will find all the matching methods.</source>
          <target state="translated">Связыватель найдет все подходящие методы.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">`BindingFlags.MethodInvoke`</ph>, <ph id="ph2">`BindingFlags.GetProperties`</ph>, and so on).</source>
          <target state="translated">Эти методы находятся в зависимости от типа связывания (<ph id="ph1">`BindingFlags.MethodInvoke`</ph>, <ph id="ph2">`BindingFlags.GetProperties`</ph>и так далее).</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">Набор методов фильтруется по имени, количество аргументов и набор модификаторов поиска, определенных в модуле привязки.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>After the method is selected, it will be invoked.</source>
          <target state="translated">После выбора метод будет вызван.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">На этом этапе проверяется доступность.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">Средство поиска может управлять поиском определения набора методов на основе связанного с методом атрибута доступности.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method is responsible for selecting the method to be invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> Метод отвечает за выбор вызываемого метода.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">Связыватель по умолчанию выбирает наиболее точное соответствие.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Access restrictions are ignored for fully trusted code.</source>
          <target state="translated">Ограничения доступа игнорируются для полностью доверенный код.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked using reflection whenever the code is fully trusted.</source>
          <target state="translated">То есть закрытые конструкторы, методы, поля и свойства доступны и с использованием отражения, если полностью доверенный код.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Currently, <ph id="ph1">`InvokeMember`</ph> performs the Microsoft .NET Framework reflection semantics for every type of object.</source>
          <target state="translated">В настоящее время <ph id="ph1">`InvokeMember`</ph> выполняет семантику отражения Microsoft .NET Framework для каждого типа объекта.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the member specified by name is an array and the <ph id="ph1">`BindingFlags.GetField`</ph> flag is set on <ph id="ph2">`invokeAttr`</ph>, the <ph id="ph3">`args`</ph> array specifies the elements whose values are to be returned.</source>
          <target state="translated">Если элемент, заданный по имени является массивом и <ph id="ph1">`BindingFlags.GetField`</ph> установлен флаг <ph id="ph2">`invokeAttr`</ph>, <ph id="ph3">`args`</ph> массив задает элементы, значения которых должны быть возвращены.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, the following call through <ph id="ph1">`Type`</ph> object <ph id="ph2">`t`</ph> returns the value of the first element of the string array MyArray, which is a member of the calling object:</source>
          <target state="translated">Например, следующий вызов с помощью <ph id="ph1">`Type`</ph> объекта <ph id="ph2">`t`</ph> возвращает значение первого элемента строкового массива MyArray, который является членом вызывающего объекта:</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can use <ph id="ph1">`InvokeMember`</ph> to set one or more elements of a member array.</source>
          <target state="translated">Можно использовать <ph id="ph1">`InvokeMember`</ph> для задания одного или нескольких элементов массива членов.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>All elements are set to the same value.</source>
          <target state="translated">Все элементы, присваивается то же значение.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">`args`</ph> array must be formatted as follows:</source>
          <target state="translated"><ph id="ph1">`args`</ph> Массив должен иметь следующий формат:</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, to set the first member of MyArray from the previous example, the syntax is as follows:</source>
          <target state="translated">Например чтобы установить первый член MyArray из предыдущего примера, используется следующий синтаксис:</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsArrayImpl">
          <source>Returns a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is an array.</source>
          <target state="translated">Возвращает значение, указывающее, является ли <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> массивом.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsArrayImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является массивом; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>The type to check.</source>
          <target state="translated">Проверяемый тип.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>Returns a value that indicates whether the specified type can be assigned to this type.</source>
          <target state="translated">Возвращает значение, указывающее, можно ли назначить указанный тип данному типу.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified type can be assigned to this type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если указанный тип может быть присвоен этому типу; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsByRefImpl">
          <source>Returns a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference.</source>
          <target state="translated">Возвращает значение, показывающее, передан ли <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> по ссылке.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsByRefImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> передан по ссылке; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsCOMObjectImpl">
          <source>Returns a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object.</source>
          <target state="translated">Возвращает значение, указывающее, является ли <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> объектом COM.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsCOMObjectImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является COM-объектом, в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.IsConstructedGenericType">
          <source>Gets a value that indicates whether this object represents a constructed generic type.</source>
          <target state="translated">Возвращает значение, указывающее, представляет ли этот данный объект сконструированный универсальный тип.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.IsConstructedGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this object represents a constructed generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если этот объект представляет сконструированный универсальный тип; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source>Specifies whether to search this type's inheritance chain to find the attributes.</source>
          <target state="translated">Указывает, что необходимо просмотреть цепочку наследования этого типа для поиска данных атрибутов.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source>An array of custom attributes identified by type.</source>
          <target state="translated">Массив пользовательских атрибутов, идентифицируемых типом.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source>Indicates whether a custom attribute identified by <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is defined.</source>
          <target state="translated">Указывает, определен ли пользовательский атрибут, заданный параметром <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if a custom attribute identified by <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> is defined; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если пользовательский атрибут, заданный параметром <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph>, определен; в обратном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source>The custom attribute type cannot be loaded.</source>
          <target state="translated">Невозможно загрузить тип настраиваемого атрибута.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsPointerImpl">
          <source>Returns a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer.</source>
          <target state="translated">Возвращает значение, указывающее, является ли <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> указателем.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsPointerImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является указателем; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsPrimitiveImpl">
          <source>Returns a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types.</source>
          <target state="translated">Возвращает значение, указывающее, является ли <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> одним из типов-примитивов.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsPrimitiveImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является одним из типов-примитивов; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsValueTypeImpl">
          <source>Returns a value that indicates whether the type is a value type; that is, not a class or an interface.</source>
          <target state="translated">Возвращает значение, указывающее, является ли данный тип типом значения, то есть, не классом и не интерфейсом.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsValueTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type is a value type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если тип является типом значения; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.MetadataToken">
          <source>Gets a value that identifies this entity in metadata.</source>
          <target state="translated">Возвращает значение, определяющее этот объект в метаданных.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.MetadataToken">
          <source>A value which, in combination with the module, uniquely identifies this entity in metadata.</source>
          <target state="translated">Свойство, которое в сочетании с модулем уникальным образом идентифицирует этот объект в метаданных.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.MetadataToken">
          <source>The tokens obtained using this property can be passed to the unmanaged reflection API.</source>
          <target state="translated">Маркеры, полученные с помощью этого свойства может быть передан неуправляемого API-интерфейса отражения.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.MetadataToken">
          <source>For more information, see <bpt id="p1">[</bpt>Unmanaged Reflection API<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>неуправляемый интерфейс API отражения<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.Module">
          <source>Gets the module that contains the implemented type.</source>
          <target state="translated">Возвращает модуль, содержащий реализованный тип.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Module">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> object representing the module of the implemented type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>, представляющий модуль реализованного типа.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Module">
          <source>A module is a loadable unit that can contain type declarations and implementations.</source>
          <target state="translated">Модуль — загружаемая единица, которая может содержать объявления и реализации типов.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Module">
          <source>Modules contain enough information to enable the common language runtime to locate all implementation bits when the module is loaded.</source>
          <target state="translated">Модули содержат достаточно информации для общеязыковая среда выполнения обнаружила все части реализации, когда модуль был загружен.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.Name">
          <source>Gets the name of the implemented type, with the path removed.</source>
          <target state="translated">Возвращает имя реализуемого типа с удалением пути.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Name">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing the type's non-qualified name.</source>
          <target state="translated">Строка <ph id="ph1">&lt;see langword="String" /&gt;</ph>, содержащая неполное имя типа.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Name">
          <source>A string containing the name of the current <ph id="ph1">`TypeDelegator`</ph>.</source>
          <target state="translated">Строка, содержащая имя текущего объекта<ph id="ph1">`TypeDelegator`</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Name">
          <source>Only the simple name, not the fully qualified name, is returned.</source>
          <target state="translated">Возвращается только простое имя, а не полное доменное имя.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Name">
          <source>To get the name and the path, use <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.FullName%2A&gt;</ph>.</source>
          <target state="translated">Чтобы получить имя и путь, используйте <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.FullName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.Namespace">
          <source>Gets the namespace of the implemented type.</source>
          <target state="translated">Возвращает пространство имен реализуемого типа.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Namespace">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing the type's namespace.</source>
          <target state="translated">Строка <ph id="ph1">&lt;see langword="String" /&gt;</ph>, содержащая пространство имен типа.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Namespace">
          <source>This property gets a string containing the namespace of the current <ph id="ph1">`TypeDelegator`</ph>.</source>
          <target state="translated">Это свойство возвращает строку, содержащую пространство имен текущего <ph id="ph1">`TypeDelegator`</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Namespace">
          <source>For example, if the <ph id="ph1">`TypeDelegator`</ph> is <ph id="ph2">&lt;xref:System.Reflection.TypeFilter&gt;</ph>, the returned namespace is <ph id="ph3">&lt;xref:System.Reflection&gt;</ph>.</source>
          <target state="translated">Например если <ph id="ph1">`TypeDelegator`</ph> — <ph id="ph2">&lt;xref:System.Reflection.TypeFilter&gt;</ph>, возвращается пространство имен <ph id="ph3">&lt;xref:System.Reflection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.TypeHandle">
          <source>Gets a handle to the internal metadata representation of an implemented type.</source>
          <target state="translated">Возвращает дескриптор представления внутренних метаданных реализуемого типа.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.TypeHandle">
          <source>A <ph id="ph1">&lt;see langword="RuntimeTypeHandle" /&gt;</ph> object.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="RuntimeTypeHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.TypeHandle">
          <source>A type handle is a unique integer value associated with each type.</source>
          <target state="translated">Дескриптор типа является уникальным целочисленное значение, связанное с каждым типом.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.TypeHandle">
          <source>The handle is unique during the runtime.</source>
          <target state="translated">Дескриптор является уникальным во время выполнения.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="F:System.Reflection.TypeDelegator.typeImpl">
          <source>A value indicating type information.</source>
          <target state="translated">Значение, содержащее сведения о типе.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.UnderlyingSystemType">
          <source>Gets the underlying <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> that represents the implemented type.</source>
          <target state="translated">Возвращает базовый класс <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который представляет реализуемый тип.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.UnderlyingSystemType">
          <source>The underlying type.</source>
          <target state="translated">Базовый тип.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>