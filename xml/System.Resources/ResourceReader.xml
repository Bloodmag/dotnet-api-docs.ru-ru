<Type Name="ResourceReader" FullName="System.Resources.ResourceReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="682738b4136d074223cbe025a9380b3cca9bc1d0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480258" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ResourceReader : System.Resources.IResourceReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ResourceReader extends System.Object implements class System.Collections.IEnumerable, class System.IDisposable, class System.Resources.IResourceReader" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ResourceReader&#xA;Implements IResourceReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceReader sealed : System::Resources::IResourceReader" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.Reader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Resources.IResourceReader</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Перечисляет ресурсы в двоичном файле ресурсов (RESOURCES) путем последовательного считывания пар "ключ-значение" ресурсов.  
  
 **Примечание по безопасности**. Вызов методов в этом классе с ненадежными данными представляет угрозу безопасности. Вызывайте методы в классе только с надежными данными. Дополнительные сведения см. в разделе [Угрозы безопасности при работе с ненадежными данными](https://docs.com/rick-anderson-1/8710/untrusted-data-security-risks).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader> Класс предоставляет стандартную реализацию <xref:System.Resources.IResourceReader> интерфейса. Объект <xref:System.Resources.ResourceReader> экземпляр представляет отдельный файл .resources или RESOURCES-файл, встроенный в сборку. Он используется для перечисления ресурсов в RESOURCES-файла и получения его пары имя/значение. Она отличается от <xref:System.Resources.ResourceManager> класс, который используется для получения указанных именованных ресурсов из RESOURCES-файла, внедренного в сборку. <xref:System.Resources.ResourceManager> Класс используется для извлечения ресурсов, имена которых известны заранее, тогда как <xref:System.Resources.ResourceReader> класс удобно использовать для извлечения ресурсов, число или точные имена неизвестны во время компиляции. Например приложение может использовать файл ресурсов для хранения сведений о конфигурации, организованных в разделах и элементов в разделе, где число разделов или элементов в разделе не известен заранее. Ресурсы можно назвать затем универсальной (такие как `Section1`, `Section1Item1`, `Section1Item2`и так далее) и получать с помощью <xref:System.Resources.ResourceReader> объекта.  
  
> [!IMPORTANT]
>  Этот тип реализует <xref:System.IDisposable> интерфейса. После завершения с помощью типа следует освободить его прямо или косвенно. Для удаления типа непосредственно вызвать его <xref:System.IDisposable.Dispose%2A> метод в `try` / `catch` блока. Чтобы удалить ее косвенно, использовать языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <xref:System.IDisposable> разделе интерфейса.  
  
 Дополнительные сведения об использовании <xref:System.Resources.ResourceReader> класса, в следующих разделах:  
  
-   [Создание экземпляра объекта ResourceReader](#instantiate)  
  
-   [Перечисление ресурсов объект ResourceReader](#enumerate)  
  
    -   [Извлечение ресурсов с помощью свойства IDictionaryEnumerator](#idictionaryenumerator)  
  
    -   [Извлечение ресурсов по имени с GetResourceData](#getresourcedata)  
  
<a name="instantiate"></a>   
## <a name="instantiating-a-resourcereader-object"></a>Создание экземпляра объекта ResourceReader  
 RESOURCES-файл является двоичным файлом, который был скомпилирован из текстового файла или XML-файл .resx, [Resgen.exe (генератор файлов ресурсов)](~/docs/framework/tools/resgen-exe-resource-file-generator.md). Объект <xref:System.Resources.ResourceReader> объект может представлять отдельный файл .resources или RESOURCES-файл, встроенный в сборку.  
  
 Для создания экземпляра <xref:System.Resources.ResourceReader> , считывает из автономного RESOURCES-файла, используется <xref:System.Resources.ResourceReader> конструктора класса входного потока или строка, содержащая имя файла .resources. В следующем примере кода демонстрируются оба подхода. Создает первый <xref:System.Resources.ResourceReader> , представляющий RESOURCES-файл с именем `Resources1.resources` с помощью имени файла. Создает второй <xref:System.Resources.ResourceReader> , представляющий RESOURCES-файл с именем `Resources2.resources` с помощью потока, созданного из файла.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#2)]  
  
 Для создания <xref:System.Resources.ResourceReader> , представляющий внедренный RESOURCES-файл, создать экземпляр <xref:System.Reflection.Assembly> объекта из сборки, внедренные RESOURCES-файл. Его <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> возвращает <xref:System.IO.Stream> объект, который может быть передан <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> конструктор. В следующем примере создается экземпляр <xref:System.Resources.ResourceReader> , представляющий внедренный RESOURCES-файл.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#3)]
 [!code-vb[System.Resources.ResourceReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#3)]  
  
<a name="enumerate"></a>   
## <a name="enumerating-a-resourcereader-objects-resources"></a>Перечисление ресурсов объект ResourceReader  
 Чтобы перечислить ресурсы в RESOURCES-файл, следует вызвать <xref:System.Resources.ResourceReader.GetEnumerator%2A> метод, возвращающий <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> объекта. Вызывается `IDictionaryEnumerator.MoveNext` способ перехода от одного ресурса к другому. Метод возвращает `false` при перечислены все ресурсы в RESOURCES-файл.  
  
> [!NOTE]
>  Несмотря на то что <xref:System.Resources.ResourceReader> класс реализует <xref:System.Collections.IEnumerable> интерфейс и <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> метода <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> метод не выполняет <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> реализации. Вместо этого <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> возвращает <xref:System.Collections.IDictionaryEnumerator> объект интерфейса, предоставляющий доступ к каждому ресурсу пары имя/значение.  
  
 Можно извлечь отдельные ресурсы в коллекции двумя способами:  
  
-   Можно выполнять перебор ресурсов <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> сбора и использования <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> свойств для извлечения ресурсов имя и значение. Этот способ рекомендуется использовать, если все ресурсы, того же типа или знать тип данных каждого ресурса.  
  
-   При итерации можно получить имя каждого ресурса <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> коллекции и вызовите <xref:System.Resources.ResourceReader.GetResourceData%2A> метод для извлечения данных ресурсов. Такой подход рекомендуется использовать, если вы не знаете тип данных каждого ресурса или если описанный подход будет вызвано исключение.  
  
<a name="idictionaryenumerator"></a>   
### <a name="retrieving-resources-by-using-idictionaryenumerator-properties"></a>Извлечение ресурсов с помощью свойства IDictionaryEnumerator  
 Первый метод перечисление ресурсов в RESOURCES-файл включает в себя непосредственно получение пары имя значение для каждого ресурса. После вызова метода `IDictionaryEnumerator.MoveNext` имя метода, чтобы переместить каждый ресурс в коллекции, можно извлечь ресурс из <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> свойства и данные ресурсов из <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> свойство.  
  
 В следующем примере показано, как получить имя и значение каждого ресурса в RESOURCES-файл с помощью <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> и <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> свойства. Чтобы запустить пример, создайте текстовый файл с именем ApplicationResources.txt для определения строковые ресурсы.  
  
```  
Title="Contact Information"  
Label1="First Name:"  
Label2="Middle Name:"  
Label3="Last Name:"  
Label4="SSN:"  
Label5="Street Address:"  
Label6="City:"  
Label7="State:"  
Label8="Zip Code:"  
Label9="Home Phone:"  
Label10="Business Phone:"  
Label11="Mobile Phone:"  
Label12="Other Phone:"  
Label13="Fax:"  
Label14="Email Address:"  
Label15="Alternate Email Address:"  
```  
  
 Затем можно преобразовать текстовый файл ресурсов в двоичный файл с именем ApplicationResources.resources с помощью следующей команды:  
  
 **resgen ApplicationResources.txt**  
  
 В следующем примере затем используется <xref:System.Resources.ResourceReader> класс перечислить каждый ресурс в автономный двоичный RESOURCES-файл и отобразить его имя ключа и соответствующее значение.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/class1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/class1.vb#1)]  
  
 Попытка получить данные ресурсов из <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> свойства можно вызывать следующие исключения:  
  
-   Объект <xref:System.FormatException> Если данные не в требуемом формате.  
  
-   Объект <xref:System.IO.FileNotFoundException> Если не удается найти сборку, содержащую тип, к которому относятся данные.  
  
-   Объект <xref:System.TypeLoadException> , если тип, к которому принадлежит данных не может быть не найдены.  
  
 Как правило эти исключения возникают, если RESOURCES-файл был изменен вручную, если сборка, в которой определен тип, либо не были включены с помощью приложения или была случайно удалена, или сборка является старой версии, который предшествует тип. Если одно из этих исключений создается, ресурсы можно получить путем перечисления каждого ресурса и вызова <xref:System.Resources.ResourceReader.GetResourceData%2A> метода, как показано в следующем разделе. Такой подход предоставляет вам некоторые сведения о данных, введите <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> попыталась вернуть свойство.  
  
<a name="getresourcedata"></a>   
### <a name="retrieving-resources-by-name-with-getresourcedata"></a>Извлечение ресурсов по имени с GetResourceData  
 Второй подход к перечисление ресурсов в RESOURCES-файл также включает в себя просмотр ресурсов в файле путем вызова `IDictionaryEnumerator.MoveNext` метод. Для каждого ресурса, получения имени ресурса из <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> свойство, которое затем передается <xref:System.Resources.ResourceReader.GetResourceData%28System.String%2CSystem.String%40%2CSystem.Byte%5B%5D%40%29> метод для извлечения данных ресурсов. Это значение возвращается в виде массива байтов в `resourceData` аргумент.  
  
 Этот подход является более удобны, чем извлечение ресурсов имя и значение из <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> и <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> свойства, поскольку он возвращает фактическое количество байтов, которые образуют значение ресурса. Тем не менее, если попытка получить ресурс вызывает исключение, <xref:System.Resources.ResourceReader.GetResourceData%2A> метод позволяет идентифицировать источник исключения, указав сведения о типе данных ресурса. Дополнительные сведения о строке, которая указывает тип ресурса данных см. в разделе <xref:System.Resources.ResourceReader.GetResourceData%2A>.  
  
 В следующем примере для извлечения ресурсов и обработки исключений, создаваемых, используйте этот подход. Программным образом создает двоичный RESOURCES-файл, содержащий четыре строки, одно значение типа Boolean, одним целым числом, одного точечного рисунка и один произвольный `DateTimeTZI` объекта. Чтобы запустить пример, выполните следующие действия:  
  
1.  Создать сборку с именем Library.dll, содержащий `DateTimeTZI` структуры. Ниже приведен исходный код для сборки.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/library.cs#4)]
     [!code-vb[System.Resources.ResourceReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/library.vb#4)]  
  
     Компиляция исходного кода на C# с помощью следующей команды:  
  
    ```  
    csc /t:library library.cs  
    ```  
  
     Или можно скомпилировать его в Visual Basic, используя следующую команду:  
  
    ```  
    vbc library.vb /t:library  
    ```  
  
2.  Скомпилируйте и выполните следующий исходный код, который создает в RESOURCES-файл с именем ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/createresourceex1.cs#5)]
     [!code-vb[System.Resources.ResourceReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/createresourceex1.vb#5)]  
  
     Файл исходного кода, называется CreateResources.cs. Вы можете скомпилировать в C# с помощью следующей команды.  
  
    ```  
    csc CreateResources.cs /r:library.dll  
    ```  
  
     Или можно скомпилировать его в Visual Basic, используя следующую команду:  
  
    ```  
    vbc CreateResources.vb /r:library.dll  
    ```  
  
3.  Скомпилируйте и запустите следующий код, чтобы перечислить ресурсы в файле ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/readresourceex1.cs#6)]
     [!code-vb[System.Resources.ResourceReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/readresourceex1.vb#6)]  
  
     После изменения исходного кода (например, выдавая намеренно <xref:System.FormatException> в конце `try` блок) или переименование Library.dll сборки, чтобы он недоступен во время выполнения, выполнить пример, чтобы увидеть как вызовы <xref:System.Resources.ResourceReader.GetResourceData%2A> позволяют извлекать или повторно создать некоторые сведения о ресурсах.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Используя экземпляр этого объекта с недоверенными данными представляет угрозу безопасности. Этот объект можно используйте только с надежными данными. Дополнительные сведения см. в разделе [проверки данных](https://www.owasp.org/index.php/Data_Validation).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::IO::Stream ^ stream);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Входной поток для чтения ресурсов.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Resources.ResourceReader" /> для заданного потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> Конструктор создает <xref:System.Resources.ResourceReader> объект, который извлекает ресурсы из автономного RESOURCES-файла или из .resources файл, который является встроенный в сборку. Для чтения из автономного RESOURCES-файл, создать экземпляр <xref:System.IO.Stream> и передать его на <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> конструктор. Для чтения внедренные RESOURCES-файл, вызовите <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> метод с именем, с учетом регистра RESOURCES-файл и передайте возвращенный <xref:System.IO.Stream> объект <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> конструктор.  
  
> [!IMPORTANT]
>  Используя экземпляр этого объекта с недоверенными данными представляет угрозу безопасности. Этот объект можно используйте только с надежными данными. Дополнительные сведения см. в разделе [проверки данных](https://www.owasp.org/index.php/Data_Validation).  
  
   
  
## Examples  
 В примере этого раздела используется следующий txt-файл с именем `PatientForm.txt` для определения ресурсов, используемых приложением.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Вы можете скомпилировать txt-файл в RESOURCES-файл, выполнив следующую команду.  
  
 **PatientForm.txt Resgen**  
  
 В следующем примере предполагается, что файл ресурсов внедрен в сборку, содержащую исполняемый код приложения. Он извлекает файл ресурсов с именем `PatientForm.resources` из текущей выполняемой сборки и отображает имя и значение каждого из ресурсов.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream1.vb#1)]  
  
 Если в примере на C# называется `Example.cs`, можно выполнить компиляцию с помощью следующей команды:  
  
 **CSC Example.cs /res:PatientForm.resources**  
  
 Если в примере Visual Basic с именем `Example.vb`, можно выполнить компиляцию с помощью следующей команды:  
  
 **Vbc Example.vb /res:PatientForm.resources**  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="stream" /> недоступен для чтения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="stream" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">При доступе к <paramref name="stream" /> произошла ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для предоставления служб сериализации. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::String ^ fileName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Путь к файлу и имя файла ресурсов для чтения. В параметре <c>filename</c> регистр не учитывается.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Resources.ResourceReader" /> для указанного именованного файла ресурсов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.%23ctor%28System.String%29> Конструктор создает <xref:System.Resources.ResourceReader> объект, который извлекает ресурсы из автономного RESOURCES-файла. Для извлечения ресурсов из внедренные RESOURCES-файл, используйте <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> конструктор.  
  
> [!IMPORTANT]
>  Используя экземпляр этого объекта с недоверенными данными представляет угрозу безопасности. Этот объект можно используйте только с надежными данными. Дополнительные сведения см. в разделе [проверки данных](https://www.owasp.org/index.php/Data_Validation).  
  
   
  
## Examples  
 В примере этого раздела используется следующий txt-файл с именем `PatientForm.txt` для определения ресурсов, используемых приложением.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Txt-файл в RESOURCES-файл можно скомпилировать с помощью следующей команды:  
  
 **PatientForm.txt Resgen**  
  
 В следующем примере перечисляются ресурсы в `PatientForm.resources` и отображает имя и значение каждого объекта.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="fileName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.BadImageFormatException">Файле ресурса имеет недопустимый формат. Например, длина файла может быть равна нулю.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы операционной системы, связанные с этим объектом <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.Close%2A> может безопасно вызываться несколько раз.  
  
   
  
## Examples  
 В следующем примере перемещения по ресурсам файла и отображает все найденные пары ключ значение. В этом коде используется <xref:System.Resources.ResourceReader.Close%2A> метод, чтобы завершить работу <xref:System.Resources.ResourceReader> и чтобы освободить все ресурсы, занятые им.  
  
 [!code-cpp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CPP/getenumerator.cpp#1)]
 [!code-csharp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CS/getenumerator.cs#1)]
 [!code-vb[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда вы закончите, с помощью этого экземпляра <xref:System.Resources.ResourceReader>, вызовите <xref:System.Resources.ResourceReader.Dispose%2A> освободить все ресурсы, используемые этим экземпляром. Следует удалить дальнейшие ссылки на это <xref:System.Resources.ResourceReader> , чтобы сборщик мусора мог освободить память, вместо поддержания финализации.  
  
 <xref:System.Resources.ResourceReader.Dispose%2A> вызывает закрытый метод Dispose(Boolean), который содержит код для освобождения управляемых и неуправляемых ресурсов. Дополнительные сведения см. в разделе [метода](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель для данного объекта <see cref="T:System.Resources.ResourceReader" />.</summary>
        <returns>Перечислитель для этого объекта <see cref="T:System.Resources.ResourceReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило, перечислить ресурсы путем вызова <xref:System.Resources.ResourceReader.GetEnumerator%2A> метода и затем повторно вызвать <xref:System.Collections.IEnumerator.MoveNext%2A> метод в возвращенном <xref:System.Collections.IDictionaryEnumerator> объекта до возвращения методом `false`. Имя ресурса доступна из <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> свойство; свое значение из <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> свойство. В примере показано, как перечислить ресурсы таким образом.  
  
 Реализация <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> свойства <xref:System.Resources.ResourceReader> класса можно вызывать следующие исключения:  
  
-   <xref:System.IO.FileNotFoundException>  
  
     Не удается найти сборку, содержащую тип, к которому относятся данные.  
  
-   <xref:System.FormatException>  
  
     Данные не в требуемом формате.  
  
-   <xref:System.TypeLoadException>  
  
     Не удается найти тип, к которому относятся данные.  
  
 Исключение можно обработать путем вызова <xref:System.Resources.ResourceReader.GetResourceData%2A> метод для извлечения сведений о типе данных и массив байтов, назначенные именованный ресурс. Дополнительные сведения см. в подразделе «Получение ресурсов по имени с GetResourceData» <xref:System.Resources.ResourceReader> разделе, посвященном классу.  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceReader> Класс содержит два метода, которые возвращают перечислителей. <xref:System.Resources.ResourceReader.GetEnumerator%2A> Возвращает метод <xref:System.Collections.IDictionaryEnumerator> объекта интерфейса и рекомендуемый метод, который вызывается, когда перечисление ресурсов.  
  
   
  
## Examples  
 В примере этого раздела используется следующий txt-файл с именем `PatientForm.txt` для определения ресурсов, используемых приложением.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Вы можете скомпилировать txt-файл в RESOURCES-файл, выполнив следующую команду.  
  
 **PatientForm.txt Resgen**  
  
 В следующем примере перечисляются ресурсы в `PatientForm.resources` и отображает имя и значение каждого объекта.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Устройство чтения уже закрыто или удалено, поэтому доступ невозможен.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceData">
      <MemberSignature Language="C#" Value="public void GetResourceData (string resourceName, out string resourceType, out byte[] resourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetResourceData(string resourceName, [out] string&amp; resourceType, [out] unsigned int8[]&amp; resourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetResourceData(System.String,System.String@,System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetResourceData (resourceName As String, ByRef resourceType As String, ByRef resourceData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetResourceData(System::String ^ resourceName, [Runtime::InteropServices::Out] System::String ^ % resourceType, [Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % resourceData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
        <Parameter Name="resourceType" Type="System.String&amp;" RefType="out" />
        <Parameter Name="resourceData" Type="System.Byte[]&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="resourceName">Имя ресурса.</param>
        <param name="resourceType">При возвращении этого метода содержит строку, представляющую имя типа извлекаемого ресурса. Этот параметр передается неинициализированным.</param>
        <param name="resourceData">Когда этот метод возвращает значение, оно содержит массив байтов, являющийся двоичным представлением извлеченного типа. Этот параметр передается неинициализированным.</param>
        <summary>Возвращает имя типа и данные именованного ресурса из открытого файла ресурсов или потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.GetResourceData%2A> Метод извлекает значение именованного ресурса в виде массива байтов. Обычно используется, когда <xref:System.Collections.IDictionaryEnumerator.Value%2A> вызывает исключение при попытке получить значение ресурса.  
  
 `resourceType` является строка, представляющая тип данных ресурса. Он может иметь любое из следующих значений.  
  
-   Строковое представление `ResourceTypeCode` член перечисления, указывающее тип данных ресурса. `ResourceTypeCode` Закрытое перечисление, используемая. Чтобы указать, что специальные двоичный формат используется для хранения одно 19 общие типы данных. К ним относятся типы-примитивы .NET Framework (<xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.Single>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, <xref:System.UInt64>), а также <xref:System.String>, <xref:System.DateTime>, и <xref:System.TimeSpan>, кроме того, `ResourceTypeCode` перечисление содержит значения, указанные в следующей таблице.  
  
    |Значение ResourceTypeCode|Описание:|  
    |----------------------------|-----------------|  
    |`ResourceTypeCode.ByteArray`|Данные представляют собой массив байтов. Эти данные часто тип является результатом вызова метода <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Byte%5B%5D%29?displayProperty=nameWithType> метод.|  
    |`ResourceTypeCode.Null`|Данные является пустой ссылкой. Эти данные часто тип является результатом вызова метода <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Object%29?displayProperty=nameWithType> метод с объект, значение которого равно `null`.|  
    |`ResourceTypeCode.Stream`|Данные хранятся в виде потока. Эти данные часто тип является результатом вызова метода <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%29?displayProperty=nameWithType> или <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%2CSystem.Boolean%29?displayProperty=nameWithType> метод.|  
  
     Предположим, что `resourceData` не была повреждена, ее можно обычно преобразования из массива байтов обратно в исходное значение путем вызова <xref:System.BitConverter> или <xref:System.IO.BinaryReader> метод.  
  
-   Строка, содержащая полное имя типа, назначенные которого сериализованные данные `resourceData` аргумент (например, `System.String`). Кроме того для типов, которые не являются частью библиотеки классов .NET Framework, строка содержит имя, версию, культуру и открытый ключ сборки, содержащей тип. Например, следующая строка указывает, что сериализованные данные представляет экземпляр `Person` введите `Extensions` пространства имен, которое находится в версию 1.0 сборки с именем служебную программу, которая имеет открытый ключ не и без заданного языка и региональных параметров.  
  
     `Extensions.Person, Utility, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`  
  
     Предположим, что `resourceData` не была повреждена и была доступна, исходный тип `resourceData` могут преобразовываться из массива байтов обратно в исходное значение можно преобразовать массив байтов для <xref:System.IO.Stream> объекта и передает поток <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType>метод.  
  
-   Строка, используемая для описания типа данных в <xref:System.Resources.ResourceWriter.AddResourceData%2A?displayProperty=nameWithType> вызова метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="resourceName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceName" /> — не существует.</exception>
        <exception cref="T:System.BadImageFormatException">
          Недопустимый тип параметра <paramref name="resourceName" />.</exception>
        <exception cref="T:System.FormatException">Извлеченные данные ресурсов повреждены.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий объект <see cref="T:System.Resources.ResourceReader" /> не инициализирован (скорее всего, потому что он закрыт).</exception>
        <altmember cref="M:System.Resources.ResourceWriter.AddResourceData(System.String,System.String,System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель для данного объекта <see cref="T:System.Resources.ResourceReader" />.</summary>
        <returns>Перечислитель для этого объекта <see cref="T:System.Resources.ResourceReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.System%23Collections%23IEnumerable%23GetEnumerator%2A?displayProperty=nameWithType> представляет собой явную реализацию интерфейса. Он может использоваться, только если экземпляр <xref:System.Resources.ResourceReader> приведен к типу интерфейса <xref:System.Collections.IEnumerable>. Рекомендуемый подход для перечисление ресурсов в RESOURCES-файл является вызов <xref:System.Collections.IEnumerator.MoveNext%2A> метод <xref:System.Collections.IDictionaryEnumerator> объект, возвращаемый <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Средство чтения уже закрыто, поэтому доступ невозможен.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
  </Members>
</Type>