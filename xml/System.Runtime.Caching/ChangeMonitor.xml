<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ChangeMonitor.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5ef439688d7b98a238cf8640eb07e63804432a3ba.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ef439688d7b98a238cf8640eb07e63804432a3ba</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Provides a base class for a derived custom type that monitors changes in the state of the data which a cache item depends on.</source>
          <target state="translated">Предоставляет базовый класс производного пользовательского типа, отслеживающего изменения в состоянии данных, от которых зависит элемент кэша.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class is used as the base class for derived monitor classes that are specialized for particular cache implementations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> Класс используется как базовый класс для классов производного монитора, предназначенного для реализации конкретного кэша.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance monitors changes in the state of data which a cache item depends on.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> экземпляр отслеживает изменения в состоянии данных, который зависит от элемента кэша.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For example, the item can be a file or data entity whose contents are cached.</source>
          <target state="translated">Например элемент может быть файлом или сущностью данных, содержимое которой кэшируется.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the file or data entity is updated, the associated cache entry must be changed also.</source>
          <target state="translated">При обновлении данных или файлов сущности необходимо также изменить связанная запись кэша.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Common items that can be monitored include data entities (such as database fields, values, rows, or tables), another cache entry, and files and file attributes.</source>
          <target state="translated">Общие элементы, которые могут быть проверены включают сущностей данных (например, поля базы данных, значения, строки или таблицы), другая запись кэша и файлы и атрибуты файлов.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A dependency change is a change in the state of a dependency.</source>
          <target state="translated">Изменение зависимости — изменение в состоянии зависимости.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>In a typical cache implementation, after a <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance notifies the cache that a dependency has changed, the cache performs the required action, such as invalidating the inserted cache entry.</source>
          <target state="translated">В обычной реализации кэша после <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> экземпляр уведомляет измененного зависимость кэша, кэш выполняет необходимое действие, например аннулирование вставленной записи кэша.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Derived <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> classes can be customized to monitor dependency changes for specific different data stores.</source>
          <target state="translated">Производный <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> классы могут быть настроены для наблюдения за изменениями зависимостей для определенных различных хранилищ данных.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For example, there are cache implementations for a file system, physical memory, or a database.</source>
          <target state="translated">Например существуют реализации кэша для файловой системы, физической памяти или базы данных.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class examines changes that occur outside the cache, and then alerts the cache that changes have occurred.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> Класс проверяет изменения, происходящие вне кэша и оповещает кэша, произошли изменения.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> includes the following classes that derive from <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class:</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> Содержит следующие классы, производные от <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> класса:</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Each of these classes works with different types of dependencies.</source>
          <target state="translated">Каждый из этих классов работает с различными типами зависимостей.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For example, the derived <ph id="ph1">&lt;xref:System.Runtime.Caching.FileChangeMonitor&gt;</ph> class monitors changes to a cache for file system data (files and folders) that the cache item depends on.</source>
          <target state="translated">Например, производном <ph id="ph1">&lt;xref:System.Runtime.Caching.FileChangeMonitor&gt;</ph> класс отслеживает изменения в кэш для данных файловой системы (файлы и папки), который зависит от элемента кэша.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>This type is thread safe.</source>
          <target state="translated">Данный тип потокобезопасен.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If you create a custom cache implementation or a derived change monitor type, you must follow certain guidelines.</source>
          <target state="translated">При создании пользовательской реализации кэша или производного типа монитора изменений необходимо следовать определенным правилам.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The following list summarizes these guidelines.</source>
          <target state="translated">В следующем списке перечислены следующие рекомендации.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For more information, see the documentation for individual methods or properties.</source>
          <target state="translated">Дополнительные сведения см. в документации для отдельных методов или свойств.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The constructor of a derived class must set the <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph> property, begin monitoring, and call <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method before the method returns.</source>
          <target state="translated">Конструктор производного класса необходимо задать <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph> , начать мониторинг и вызвать <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> метод перед возвратом метода.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If a constructor encounters an error during constructions and must have to dispose of resources, the constructor can only call the <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload after the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method is called because the <ph id="ph3">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload will throw an <ph id="ph4">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> exception if initialization is not completed.</source>
          <target state="translated">Если конструктор возникнет ошибка во время конструкции и должен иметь для освобождения ресурсов, конструктор можно вызвать только <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> перегрузки после <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> метод вызывается, потому что <ph id="ph3">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> вызовет перегрузку <ph id="ph4">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> исключение, если инициализация не завершена.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If changes occur in the data that is being monitored before initialization is complete, the constructor must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method before calling the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method.</source>
          <target state="translated">При внесении изменений в данных, которые отслеживается до инициализации завершен, необходимо вызвать конструктор <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> метод перед вызовом метода <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After a derived <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> type is instantiated, you must insert the monitor into a custom <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation.</source>
          <target state="translated">После производный <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> создается экземпляр типа, нужно вставить в настраиваемый монитор <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> реализации.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Or if you are finished using the change monitor, call the <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method.</source>
          <target state="translated">Или если с помощью монитор изменений, вызовите <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After a <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance is inserted into a <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation, the <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> instance require that the change monitor is disposed.</source>
          <target state="translated">После <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> экземпляр вставляется в <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> реализации <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> требуется экземпляр, что монитор изменений будет удален.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Even if the insertion is invalid and causes an exception, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation must call the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload.</source>
          <target state="translated">Даже в том случае, если курсор является недопустимым и вызывает исключение, <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> реализация должна вызывать <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> перегрузки.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After a derived change monitor is inserted into a cache, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation must call <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>, by passing a <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> object.</source>
          <target state="translated">После вставки в кэш, монитор производном изменений <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> реализация должна вызывать <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>, передав <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method can be called only one time.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> Метод может вызываться только один раз.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If a dependency change has already occurred, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called immediately when <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is called.</source>
          <target state="translated">Если уже произошло изменение зависимостей, <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> экземпляр будет немедленно вызывается при <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> вызывается.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Otherwise, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called only one time.</source>
          <target state="translated">В противном случае <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> экземпляр будет вызываться только один раз.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>This one time call occurs either when the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called because the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance detected a change, or when the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called on the <ph id="ph4">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>, whichever occurs first.</source>
          <target state="translated">Происходит вызов один раз, либо при <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> метод вызывается, поскольку <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> экземпляр обнаружено изменение, или когда <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> метод будет вызван на <ph id="ph4">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>, какое событие происходит раньше.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance that is provided by an <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation should remove the associated cache entry and specify a reason by using the <ph id="ph3">&lt;see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /&gt;</ph> enumeration.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> Экземпляра, предоставляемая <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> следует удалить связанную запись кэша и указать причину, с помощью реализации <ph id="ph3">&lt;see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance can call the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method either before a cache implementation has called <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method or after.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> экземпляра можно вызвать <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> метод либо перед реализацией кэша вызвал <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> метода или после.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called before <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is called, the base <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> implementation will notify the cache that this has occurred and will trigger the callback to be passed to <ph id="ph4">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> immediately when <ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is invoked.</source>
          <target state="translated">Если <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> метод вызывается перед <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> называется базой <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> реализацию уведомит кэша, это произошло и запускается обратного вызова должен быть передан <ph id="ph4">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> сразу же после <ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> вызывается.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Any state data that is passed to the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is saved by the change monitor and subsequently passed to the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method when the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method is invoked.</source>
          <target state="translated">Данные, передаваемые в любом состоянии <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> метод сохраняется монитор изменений, а впоследствии передается <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> метод при <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> вызывается метод.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A change monitor must implement the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method.</source>
          <target state="translated">Монитор изменений необходимо реализовать <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For more information, see the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method documentation.</source>
          <target state="translated">Дополнительные сведения см. в документации метода <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method overload must be called to dispose of the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> Перегруженный метод должен вызываться для удаления <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The rules for calling Dispose are as follows:</source>
          <target state="translated">Ниже приведены правила для вызова Dispose.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Before an item is inserted into the cache, it is the responsibility of caller to dispose of a <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance.</source>
          <target state="translated">Перед вставкой элемента в кэше, он отвечает вызывающий объект для удаления <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Once cache item and the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instances that are associated with it are passed to a cache, the cache implementer must make sure that that the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called, even if the insert fails.</source>
          <target state="translated">Один раз для элемента кэша и <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> экземпляров, связанных с ним, передаются в кэш, Реализатор кэша убедиться, что, <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> вызывается метод, даже если завершается неудачей.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After an item and its associated <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instances are passed to a cache, the caller must not dispose the dependency because when the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called, the call is treated as if the dependency has changed.</source>
          <target state="translated">После элемента и связанный с ним <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> экземпляры передаются в кэш, так как вызывающий объект не должен располагать зависимость при <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> вызывается метод, вызов обрабатывается, как если бы зависимость изменилась.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>As a result, the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is automatically invoked.</source>
          <target state="translated">В результате <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> автоматически вызывается метод.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Taking these rules into consideration, the <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method must be called in one of the following ways:</source>
          <target state="translated">Учитывая эти правила, <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> метод должен вызываться в одном из следующих способов:</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Users must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method overload if they decide not to insert the derived change-monitor instance into a cache.</source>
          <target state="translated">Пользователи должны вызвать <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> перегруженный метод, если они не вставлять экземпляр производного монитора изменения в кэш.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the implementation tries to insert the change-monitor instance into an object cache but the insertion fails, the cache implementation is responsible for calling the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload.</source>
          <target state="translated">Если реализация пытается вставить экземпляр монитора изменений в кэш объекта Вставка не выполняется, реализация кэша отвечает за вызов метода <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> перегрузки.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>When the insertion attempt causes an exception, the cache implementation must dispose of any associated dependencies.</source>
          <target state="translated">При попытке вставки приводит к исключению, реализация кэша должна освободить все связанные зависимости.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the cache entry is removed, the cache implementation must also dispose of the dependency.</source>
          <target state="translated">Если запись кэша удаляется, реализация кэша должна также удалить зависимости.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The internal implementation of the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method automatically calls the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method after it calls a callback that is registered through <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>.</source>
          <target state="translated">Внутренняя реализация <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> автоматически вызывает метод <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> метод после вызова обратный вызов, регистрируется через <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>This automatic call to the dispose method during the event firing only occurs if the initialization of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance was previously completed.</source>
          <target state="translated">Это автоматический вызов метода dispose во время срабатывания события происходят, если инициализация <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> экземпляр ранее был завершен.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>When a derived change monitor's constructor calls the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method, if the state of the change monitor has already changed (that is, the state that is monitored already changed when the constructor was still active) then the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method will automatically dispose of the change monitor.</source>
          <target state="translated">При вызове конструктора монитор производном изменений <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> метод, если состояние монитора изменений уже была изменена (состояние отслеживаемого уже измененные при конструктор был по-прежнему активен) то <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> будет метод автоматически удалите монитор изменений.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /&gt;</ph> property is set to <ph id="ph2">&lt;see langword="true" /&gt;</ph> after the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called by the derived change-monitor instance, regardless of whether a <ph id="ph4">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> object has been set by a call to the <ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method or not.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /&gt;</ph> Свойству <ph id="ph2">&lt;see langword="true" /&gt;</ph> после <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> метод вызывается методом экземпляра производного монитора изменения, независимо от того, следует ли <ph id="ph4">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> задан объект при вызове <ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> метода или нет.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>This constructor is called from constructors in derived classes to initialize the base class.</source>
          <target state="translated">Этот конструктор вызывается конструкторами в производных классах для инициализации базового класса.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class has a default constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> Класс имеет конструктор по умолчанию.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>However, classes that inherit from the base <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class and define custom change-monitoring behavior must perform initialization in the constructor.</source>
          <target state="translated">Тем не менее, классов, наследующих от базового <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> класса и определение пользовательского наблюдения за изменениями поведение должны выполнять инициализацию в конструкторе.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>For more information, see the Notes for Inheritors section.</source>
          <target state="translated">Дополнительные сведения см. примечания для наследующих объектов раздела.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>The constructor of a derived class must set the <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph> property, begin monitoring, and call the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> class before it returns.</source>
          <target state="translated">Конструктор производного класса необходимо задать <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph> , начать мониторинг и вызвать <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> класса перед возвратом.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>If a dependency changes before initialization is complete (for example, if a dependent cache key is not found in the cache), the constructor must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method before it calls the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method.</source>
          <target state="translated">При изменении зависимости перед инициализацией завершена (например, если ключ зависимых кэша не найден в кэше), необходимо вызвать конструктор <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> метод перед вызовом <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>In this case, constructor can call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method only after the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method is called, because the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method throws an exception if initialization is not completed.</source>
          <target state="translated">В этом случае конструктор может вызвать <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> метод только после <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> вызывается метод, так как <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> метод вызывает исключение, если инициализация не завершена.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated">Освобождает все ресурсы, используемые текущим экземпляром класса <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is used to release the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance and related resources.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> Метод используется для освобождения <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> экземпляра и связанные ресурсы.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The public <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is invoked to coordinate the disposal process with key life-cycle events of derived change-monitor classes (such as initialization), and to release the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance so that the instance can be garbage collected.</source>
          <target state="translated">Открытые <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> метод вызывается для координации процесс реализации с помощью события жизненного цикла ключа классов производного монитора изменения (например, инициализация), а также для освобождения <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> экземпляра, чтобы экземпляр мог быть собраны как мусор.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is implemented by derived change-monitor classes to dispose of their managed and unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> Метод реализуется классами производного монитора изменения для удаления их управляемых и неуправляемых ресурсов.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Releases all resources that are used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated">Освобождает все ресурсы, используемые текущим экземпляром класса <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method invokes the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method of derived classes only one time, the first time it is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> Вызывает метод <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> метода производного класса только один раз, при первом вызове.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Subsequent calls to the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method have no effect.</source>
          <target state="translated">Последующие вызовы <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> метод не действуют.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>After the method has been called, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A&gt;</ph> property is set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">После вызова метода <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A&gt;</ph> свойству <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> overload must be called to dispose of a <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> Для удаления необходимо вызвать перегрузку <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The following are the rules for calling the dispose method:</source>
          <target state="translated">Ниже приведены правила для вызова метода dispose.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Before an item is inserted into the cache, it is the caller's responsibility to dispose of a <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated">Перед вставкой элемента в кэше, это вызывающим для удаления <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Once cache item and the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instances that are associated with it are passed to a cache, the cache implementer that must make sure that <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> is called, even if the insert fails.</source>
          <target state="translated">Один раз для элемента кэша и <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> экземпляров, связанных с ним передаются в кэш, Реализатор кэша, убедиться, что <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> вызывается, даже если завершается неудачей.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>After an item and its associated <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instances are passed to a cache, the caller must not dispose the dependency because when the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is called, the call is treated as if the dependency has changed.</source>
          <target state="translated">После элемента и связанный с ним <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> экземпляры передаются в кэш, так как вызывающий объект не должен располагать зависимость при <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> вызывается метод, вызов обрабатывается, как если бы зависимость изменилась.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>As a result, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is automatically invoked.</source>
          <target state="translated">В результате <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> автоматически вызывается метод.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Taking these rules into consideration, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method must be called in one of the following ways:</source>
          <target state="translated">Учитывая эти правила, <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> метод должен вызываться в одном из следующих способов:</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Users must call the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method overload if they decide not to insert the derived change-monitor instance into a cache.</source>
          <target state="translated">Пользователи должны вызвать <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> перегруженный метод, если они не вставлять экземпляр производного монитора изменения в кэш.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The cache implementation is responsible for calling the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> overload if the implementation tries to insert the change-monitor instance into an object cache but the insertion fails.</source>
          <target state="translated">Реализация кэша отвечает за вызов метода <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> перегрузки, если реализация пытается вставить экземпляр монитора изменений в кэш объекта Вставка не выполняется.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>When the insertion attempt causes an exception, the cache implementation must dispose any associated dependencies.</source>
          <target state="translated">При попытке вставки приводит к исключению, реализация кэша должна освободить все связанные зависимости.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>If the cache entry is removed, the cache implementation must also dispose the dependency.</source>
          <target state="translated">Если запись кэша удаляется, реализация кэша должна также удалить зависимость.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The internal implementation of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method automatically calls the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method after it calls a callback that is registered through the <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method.</source>
          <target state="translated">Внутренняя реализация <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> автоматически вызывает метод <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> метод после вызова обратный вызов, регистрируется через <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>This automatic dispose during the event firing only occurs if the initialization of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance previously completed.</source>
          <target state="translated">Это автоматического удаления во время срабатывания события происходят, если инициализация <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> ранее выполненные экземпляра.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>When a derived change monitor's constructor calls the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> method, if the state of the change monitor has already changed (that is, the state that is monitored has already changed when the constructor was still active) then <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> method will automatically dispose the change monitor.</source>
          <target state="translated">При вызове конструктора монитор производном изменений <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> метод, если состояние монитора изменений уже была изменена (то есть, состояние, которое отслеживается уже изменен при конструктор был по-прежнему активен) затем <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> будет метод автоматически удалите монитор изменений.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Users should not call the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">Пользователи не должны вызывать <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>However, you cannot prevent users from calling the method.</source>
          <target state="translated">Тем не менее можно запретить пользователям вызова метода.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Therefore, if they do, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is invoked.</source>
          <target state="translated">Таким образом, если они есть, <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> вызывается метод.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>In that case, the cache entry is notified as if the dependency has changed.</source>
          <target state="translated">В этом случае запись кэша уведомляется, как если бы зависимость изменилась.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>To prevent derived classes from overriding <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method, the method is not an explicit interface implementation.</source>
          <target state="translated">Чтобы предотвратить переопределения производными классами <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> метод, метод не является явной реализацией интерфейса.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Initialization is not complete in the derived change-monitor class that called the base <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method.</source>
          <target state="translated">Инициализация не завершена в производном классе монитора изменений, который вызвал базовый метод <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release managed and unmanaged resources and any references to a <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance; <ph id="ph3">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы освободить управляемые и неуправляемые ресурсы и любые ссылки на экземпляр <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>; значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>, чтобы освободить только неуправляемые ресурсы.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>When <ph id="ph1">&lt;see langword="false" /&gt;</ph> is passed, the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method is called by a <ph id="ph3">&lt;see langword="finalizer" /&gt;</ph> thread and any external managed references are likely no longer valid because they have already been garbage collected.</source>
          <target state="translated">Если передается значение <ph id="ph1">&lt;see langword="false" /&gt;</ph>, метод <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> вызывается потоком <ph id="ph3">&lt;see langword="finalizer" /&gt;</ph>, а любые внешние управляемые ссылки в большинстве случаев становятся недействительными, так как они уже были очищены сборщиком мусора.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>Releases all managed and unmanaged resources and any references to the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance.</source>
          <target state="translated">Освобождает все управляемые и неуправляемые ресурсы и все ссылки на экземпляр <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>This overload must be implemented by derived change-monitor classes.</source>
          <target state="translated">Эту перегрузку необходимо реализовывать в производных классах, контролирующих изменения.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>When the value of <ph id="ph1">`disposing`</ph> value is <ph id="ph2">`true`</ph>, all managed and unmanaged resources are disposed and any references to this object are released so that the derived change-monitor instance can be garbage collected.</source>
          <target state="translated">Если значение <ph id="ph1">`disposing`</ph> значение <ph id="ph2">`true`</ph>, все управляемые и неуправляемые ресурсы удаляются, и все ссылки на этот объект освобождаются, чтобы экземпляр производного монитора изменения могут быть собраны как мусор.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>It is guaranteed that the base <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method will invoke the implemented <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method only one time.</source>
          <target state="translated">Гарантируется, что базовый <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> метод будет вызывать реализованный <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> метод только один раз.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>A change monitor must implement the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> overload to release all managed and unmanaged resources when the value of <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Монитор изменений необходимо реализовать <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> перегрузку, чтобы освободить все управляемые и неуправляемые ресурсы, когда значение <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> — <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method overload that has a <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> value of <ph id="ph3">&lt;see langword="true" /&gt;</ph> is called only one time, namely, when the instance is disposed for the first time.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> Перегрузку метода, которая имеет <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> значение <ph id="ph3">&lt;see langword="true" /&gt;</ph> вызывается только один раз, а именно: при удалении экземпляра в первый раз.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>A change monitor must not call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> overload directly.</source>
          <target state="translated">Монитор изменений не должны вызывать <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> перегрузить непосредственно.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>A derived change monitor can call the public parameter-less <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method on the base <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated">Монитор производном изменений можно вызывать открытые без параметров <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> метод в базовом <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>Alternatively, a change monitor can implement a finalizer method.</source>
          <target state="translated">Кроме того монитор изменений может реализовать метод завершения.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>In that case, the finalizer can invoke the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method and pass it a <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> value of <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">В этом случае можно вызвать метод завершения <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> метод и передать его <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>However, this is usually unnecessary.</source>
          <target state="translated">Тем не менее это обычно нет необходимости.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>Monitoring for dependency changes is typically performed by a service that maintains a reference to the change-monitor instance.</source>
          <target state="translated">Мониторинг изменений зависимостей обычно выполняется службой, которая содержит ссылку на экземпляр монитора изменений.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>The reference prevents the instance from being garbage collected, and therefore makes a finalizer method unnecessary.</source>
          <target state="translated">Ссылка защищает экземпляр от сборщика мусора и таким образом делает метод завершения ненужные.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>To avoid memory leaks, when a dependency changes, the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method disposes the change-monitor instance (unless initialization has not finished).</source>
          <target state="translated">Во избежание утечки памяти при изменении зависимость, <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> метод удаляет экземпляр монитора изменений (если только не закончил инициализацию).</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>Gets a value that indicates that the state that is monitored by the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class has changed.</source>
          <target state="translated">Получает значение, указывающее, что состояние, отслеживаемое классом <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>, изменилось.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the state that is monitored by the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance has changed; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если состояние отслеживаемое экземпляром <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>, изменилось; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>You can check the value of this property in a derived <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class to see whether a dependency has changed.</source>
          <target state="translated">Можно проверить значение этого свойства в производном <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> класс, чтобы изменился ли зависимости.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>The value is set to <ph id="ph1">`true`</ph> when a dependency change occurs (that is, when the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called).</source>
          <target state="translated">Имеет значение <ph id="ph1">`true`</ph> при изменении зависимостей (то есть, когда <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> вызывается метод).</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>After the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called by the derived class, the value of the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property will be <ph id="ph3">`true`</ph>, regardless of whether a <ph id="ph4">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> instance has been notified by a call to the <ph id="ph5">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method.</source>
          <target state="translated">После <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> метод вызывается из производного класса, значение <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> свойство будет <ph id="ph3">`true`</ph>независимо от того, следует ли <ph id="ph4">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> экземпляр получила уведомление с помощью вызова <ph id="ph5">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>Callers can check the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property to see whether a dependency has changed.</source>
          <target state="translated">Можно проверить, вызывающие объекты <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> свойство, чтобы узнать, изменился ли зависимости.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>However, in a multi-threaded environment, a simpler and more maintainable approach is to insert data into a cache implementation without checking the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property.</source>
          <target state="translated">Однако в многопоточной среде, проще и более простого в сопровождении подход является вставка данных в реализации кэша без проверки <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>Cache implementations must check the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property for you and must not perform an insert or set operation if one or more associated dependencies have already changed.</source>
          <target state="translated">Необходимо проверить реализации кэша <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> свойство для вас и не должно выполнять инструкции insert или операции задания, если один или несколько связанные зависимости уже были изменены.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>Called from the constructor of derived classes to indicate that initialization is finished.</source>
          <target state="translated">Вызывается из конструктора производных классов и указывает на завершение инициализации.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>If a dependency changes before initialization is complete in a derived class, the constructor of the derived class must invoke the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method.</source>
          <target state="translated">В случае изменения зависимостей до завершения в производном классе инициализации, необходимо вызвать конструктор производного класса <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>When the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is invoked, the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property is automatically set to <ph id="ph3">`true`</ph> by the change monitor.</source>
          <target state="translated">Когда <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> вызывается метод, <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> автоматически присваивается свойству <ph id="ph3">`true`</ph> монитор изменений.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>As a result, when the change monitor's constructor calls the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> method, the base class will automatically call the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">В результате, когда монитор изменений конструктор вызывает метод <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> метода базового класса будет автоматически вызывать <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>If initialization is complete, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method automatically disposes the derived change-monitor instance.</source>
          <target state="translated">При завершении инициализации <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> метод автоматически удаляет экземпляр производного монитора изменения.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>The constructor of a derived class must call the base <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method before the constructor returns.</source>
          <target state="translated">Конструктор производного класса необходимо вызвать базовый <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> метода до завершения работы конструктор возвращает.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>The constructor of a derived class can call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method only after <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> is called, because the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method throws an exception if initialization is not completed.</source>
          <target state="translated">Конструктор производного класса может вызвать <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> метод только после <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> вызывается, потому что <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> метод вызывает исключение, если инициализация не завершена.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="P:System.Runtime.Caching.ChangeMonitor.IsDisposed">
          <source>Gets a value that indicates that the derived instance of a <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class is disposed.</source>
          <target state="translated">Получает значение, указывающее, что производный экземпляр класса <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> удален.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.IsDisposed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the instance is disposed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если экземпляр удален; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.IsDisposed">
          <source>The property is set to <ph id="ph1">`true`</ph> after the base <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method calls the <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method in a derived class to dispose of the instance.</source>
          <target state="translated">Свойство имеет значение <ph id="ph1">`true`</ph> после определения базовой <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> вызовы метода <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> метод в производном классе для удаления экземпляра.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>A reference to a method that is invoked when a dependency has changed.</source>
          <target state="translated">Ссылка на метод, вызываемый при изменении зависимости.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Called by Cache implementers to register a callback and notify an <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> instance through the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> delegate when a dependency has changed.</source>
          <target state="translated">Вызывается средствами реализации кэша для регистрации обратного вызова и уведомления экземпляра <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> об изменении зависимости с использованием делегата <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Cache implementers use this method to wire themselves up to a change monitor.</source>
          <target state="translated">Этот метод использовать реализациях кэша для привязки к монитору изменений.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If you associate one or more change monitors with the cache item, you pass a <ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy&gt;</ph> instance with a populated change monitors property to the cache item.</source>
          <target state="translated">Если связать один или несколько мониторов изменений с элементом кэша, то можно передать <ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy&gt;</ph> экземпляр с заполненным свойством мониторов изменений с элементом кэша.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>A cache implementer that supports change monitors is responsible for iterating over the <ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A&gt;</ph> property and register the <ph id="ph2">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> delegates with each change monitor that it finds.</source>
          <target state="translated">Реализация кэша мониторов изменений поддерживает отвечает за итерацию <ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A&gt;</ph> свойство и регистр <ph id="ph2">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> делегатов с каждым изменения монитора, которые найдет.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Because the <ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> delegate includes an optional state parameter, a concrete change monitor implementation can pass optional state information.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> делегат включает необязательный параметр состояния, конкретная реализация монитора изменений может передать необязательную информацию о состоянии.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The cache implementer determines whether an explicit dependency on the type of state that a custom change monitor passes as part of the callback can be taken.</source>
          <target state="translated">Реализатор кэша определяет, могут быть предприняты явная зависимость типа состояния, который передает настраиваемый монитор изменений как часть обратного вызова.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The base cache extensibility API has no requirement for explicit dependency on the type of state.</source>
          <target state="translated">API расширяемости базовый кэша не имеет требования явной зависимости типа состояния.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The implementation of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method automatically determines whether the state of the monitor has already changed at the time <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method is called.</source>
          <target state="translated">Реализация <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> метод автоматически определяет, является ли состояние монитора уже изменен во время <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> вызывается метод.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property is <ph id="ph2">`true`</ph>, then the method automatically calls the <ph id="ph3">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> event handler, that was registered, through the <ph id="ph4">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> свойство <ph id="ph2">`true`</ph>, а затем автоматически вызывает метод <ph id="ph3">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> обработчик событий, который был зарегистрирован, с использованием <ph id="ph4">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>This occurs because it is possible that from the time a cache implementation creates a change monitor, to the time a cache implementation gets the monitor and wires itself up to it, the underlying monitored state has changed.</source>
          <target state="translated">Это происходит потому, что это возможно, с момента реализации кэша создает монитор изменений, во время реализации кэша возвращает монитора и связывает сам вплоть до его базового отслеживаемых состояние изменилось.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If the state has already changed then the object that is passed to the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Если уже изменилось состояние выберите объект, который передается <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> метод <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method can be invoked only one time, and will throw an exception on subsequent calls.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> Метод может вызываться только один раз и возникает исключение при последующих вызовах.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The callback method has already been invoked.</source>
          <target state="translated">Метод обратного вызова уже вызван.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source><ph id="ph1">&lt;paramref name="onChangedCallback" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="onChangedCallback" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>You must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method to be notified of any dependency changes.</source>
          <target state="translated">Необходимо вызвать метод <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> метод, чтобы получать уведомления о любых изменениях зависимостей.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If a dependency change has already occurred, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called when <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is called.</source>
          <target state="translated">Если уже произошло изменение зависимостей, <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> экземпляр будет вызываться при <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> вызывается.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Otherwise, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called one time, either when the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called or when the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called, whichever occurs first.</source>
          <target state="translated">В противном случае <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> экземпляр будет вызван один раз либо если <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> вызове метода или при <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> вызывается метод, какое событие происходит раньше.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance provided by the cache implementation should remove the cache entry and if it is requested by the cache caller, raise the necessary change or update event back to the original cache caller.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> Экземпляр реализации кэша следует удалить запись кэша и если она запрошена вызывающим кэша, событие необходимые изменения или события обновления обратно в исходный вызывающий объект кэша.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The object cache implementation must remove the cache entry that is associated with a dependency change.</source>
          <target state="translated">Реализация кэша объектов необходимо удалить запись кэша, связанную с изменением зависимостей.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>The data for the change event.</source>
          <target state="translated">Данные для события изменения.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>This value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Это значение может быть равно <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>Called by derived classes to raise the event when a dependency changes.</source>
          <target state="translated">Вызывается производными классами для создания события при изменении зависимости.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>Typically, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called when dependency changes occur.</source>
          <target state="translated">Как правило <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> метод вызывается, когда происходят изменения зависимостей.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is also invoked when a change-monitor instance is disposed but the disposal occurs only if the callback has not already been invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> Экземпляр монитора изменений удален, однако реализации происходит только в том случае, если обратный вызов уже не был вызван метод также вызывается.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called before the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method is called, the state data from the call to the <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is saved by the cache implementation.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> метод вызывается перед <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> метод вызывается, данные о состоянии от вызова <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> метод сохраняется с помощью реализации кэша.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>Also, the callback to the <ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> method is invoked immediately when the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method is invoked.</source>
          <target state="translated">Кроме того, обратный вызов, который <ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> сразу вызывается метод при <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> вызывается метод.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>Gets a value that represents the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class instance.</source>
          <target state="translated">Получает значение, представляющее экземпляр класса <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The identifier for a change-monitor instance.</source>
          <target state="translated">Идентификатор экземпляра монитора изменений.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph> property value typically consists of dependency names combined string data that uniquely identifiers the data that is being monitored by a <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph> Значение свойства обычно состоит из зависимостей имена вместе строковые данные, уникальным образом идентификаторы данных, который отслеживается с <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The value of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph> property is a string.</source>
          <target state="translated">Значение <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph> свойство является строкой.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The value of the string is used to assign the unique ID of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated">Значение строки используется для назначения уникальный идентификатор <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>By overriding the property, you can define a custom implementation for the string value of the property in order to assign it a unique ID.</source>
          <target state="translated">Путем переопределения свойства, можно определить пользовательскую реализацию для строкового значения свойства, чтобы назначить ему уникальный идентификатор.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>In derived classes, you must set the value of the property in the constructor.</source>
          <target state="translated">В производных классах необходимо задать значение свойства в конструкторе.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>