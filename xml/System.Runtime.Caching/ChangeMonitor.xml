<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ef439688d7b98a238cf8640eb07e63804432a3ba" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480498" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Предоставляет базовый класс производного пользовательского типа, отслеживающего изменения в состоянии данных, от которых зависит элемент кэша.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor> Класс используется как базовый класс для классов производного монитора, предназначенного для реализации конкретного кэша. Объект <xref:System.Runtime.Caching.ChangeMonitor> экземпляр отслеживает изменения в состоянии данных, который зависит от элемента кэша. Например элемент может быть файлом или сущностью данных, содержимое которой кэшируется. При обновлении данных или файлов сущности необходимо также изменить связанная запись кэша. Общие элементы, которые могут быть проверены включают сущностей данных (например, поля базы данных, значения, строки или таблицы), другая запись кэша и файлы и атрибуты файлов.  
  
 Изменение зависимости — изменение в состоянии зависимости. В обычной реализации кэша после <xref:System.Runtime.Caching.ChangeMonitor> экземпляр уведомляет измененного зависимость кэша, кэш выполняет необходимое действие, например аннулирование вставленной записи кэша.  
  
 Производный <xref:System.Runtime.Caching.ChangeMonitor> классы могут быть настроены для наблюдения за изменениями зависимостей для определенных различных хранилищ данных. Например существуют реализации кэша для файловой системы, физической памяти или базы данных. <xref:System.Runtime.Caching.ChangeMonitor> Класс проверяет изменения, происходящие вне кэша и оповещает кэша, произошли изменения.  
  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Содержит следующие классы, производные от <xref:System.Runtime.Caching.ChangeMonitor> класса:  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 Каждый из этих классов работает с различными типами зависимостей. Например, производном <xref:System.Runtime.Caching.FileChangeMonitor> класс отслеживает изменения в кэш для данных файловой системы (файлы и папки), который зависит от элемента кэша.  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <block subset="none" type="overrides">
      <para>При создании пользовательской реализации кэша или производного типа монитора изменений необходимо следовать определенным правилам. В следующем списке перечислены следующие рекомендации. Дополнительные сведения см. в документации для отдельных методов или свойств.  
  
-   Конструктор производного класса необходимо задать <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> , начать мониторинг и вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> метод перед возвратом метода. Если конструктор возникнет ошибка во время конструкции и должен иметь для освобождения ресурсов, конструктор можно вызвать только <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> перегрузки после <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> метод вызывается, потому что <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> вызовет перегрузку <see cref="T:System.InvalidOperationException" /> исключение, если инициализация не завершена.  
  
-   При внесении изменений в данных, которые отслеживается до инициализации завершен, необходимо вызвать конструктор <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод перед вызовом метода <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> метод.  
  
-   После производный <see cref="T:System.Runtime.Caching.ChangeMonitor" /> создается экземпляр типа, нужно вставить в настраиваемый монитор <see cref="T:System.Runtime.Caching.ObjectCache" /> реализации. Или если с помощью монитор изменений, вызовите <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод.  
  
-   После <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляр вставляется в <see cref="T:System.Runtime.Caching.ObjectCache" /> реализации <see cref="T:System.Runtime.Caching.ObjectCache" /> требуется экземпляр, что монитор изменений будет удален. Даже в том случае, если курсор является недопустимым и вызывает исключение, <see cref="T:System.Runtime.Caching.ObjectCache" /> реализация должна вызывать <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> перегрузки.  
  
-   После вставки в кэш, монитор производном изменений <see cref="T:System.Runtime.Caching.ObjectCache" /> реализация должна вызывать <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, передав <see cref="T:System.Runtime.Caching.OnChangedCallback" /> объекта. <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Метод может вызываться только один раз. Если уже произошло изменение зависимостей, <see cref="T:System.Runtime.Caching.OnChangedCallback" /> экземпляр будет немедленно вызывается при <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> вызывается. В противном случае <see cref="T:System.Runtime.Caching.OnChangedCallback" /> экземпляр будет вызываться только один раз. Происходит вызов один раз, либо при <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод вызывается, поскольку <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляр обнаружено изменение, или когда <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод будет вызван на <see cref="T:System.Runtime.Caching.ChangeMonitor" />, какое событие происходит раньше.  
  
-   <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Экземпляра, предоставляемая <see cref="T:System.Runtime.Caching.ObjectCache" /> следует удалить связанную запись кэша и указать причину, с помощью реализации <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> перечисления.  
  
-   Объект <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляра можно вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод либо перед реализацией кэша вызвал <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> метода или после. Если <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод вызывается перед <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> называется базой <see cref="T:System.Runtime.Caching.ChangeMonitor" /> реализацию уведомит кэша, это произошло и запускается обратного вызова должен быть передан <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> сразу же после <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> вызывается. Данные, передаваемые в любом состоянии <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод сохраняется монитор изменений, а впоследствии передается <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> метод при <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> вызывается метод.  
  
-   Монитор изменений необходимо реализовать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> метод. Дополнительные сведения см. в документации метода <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />.  
  
-   <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Перегруженный метод должен вызываться для удаления <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляра. Ниже приведены правила для вызова Dispose.  
  
    -   Перед вставкой элемента в кэше, он отвечает вызывающий объект для удаления <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляра.  
  
    -   Один раз для элемента кэша и <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляров, связанных с ним, передаются в кэш, Реализатор кэша убедиться, что, <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> вызывается метод, даже если завершается неудачей.  
  
    -   После элемента и связанный с ним <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляры передаются в кэш, так как вызывающий объект не должен располагать зависимость при <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> вызывается метод, вызов обрабатывается, как если бы зависимость изменилась. В результате <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> автоматически вызывается метод.  
  
-   Учитывая эти правила, <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод должен вызываться в одном из следующих способов:  
  
    -   Пользователи должны вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> перегруженный метод, если они не вставлять экземпляр производного монитора изменения в кэш.  
  
    -   Если реализация пытается вставить экземпляр монитора изменений в кэш объекта Вставка не выполняется, реализация кэша отвечает за вызов метода <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> перегрузки. При попытке вставки приводит к исключению, реализация кэша должна освободить все связанные зависимости.  
  
    -   Если запись кэша удаляется, реализация кэша должна также удалить зависимости.  
  
    -   Внутренняя реализация <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> автоматически вызывает метод <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод после вызова обратный вызов, регистрируется через <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />.  
  
 <block subset="none" type="note"><para>  
 Это автоматический вызов метода dispose во время срабатывания события происходят, если инициализация <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляр ранее был завершен.  
  
</para></block>  
  
 При вызове конструктора монитор производном изменений <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> метод, если состояние монитора изменений уже была изменена (состояние отслеживаемого уже измененные при конструктор был по-прежнему активен) то <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> будет метод автоматически удалите монитор изменений.  
  
-   <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /> Свойству <see langword="true" /> после <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод вызывается методом экземпляра производного монитора изменения, независимо от того, следует ли <see cref="T:System.Runtime.Caching.OnChangedCallback" /> задан объект при вызове <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> метода или нет.</para>
    </block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Runtime.Caching.ChangeMonitor" />. Этот конструктор вызывается конструкторами в производных классах для инициализации базового класса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor> Класс имеет конструктор по умолчанию. Тем не менее, классов, наследующих от базового <xref:System.Runtime.Caching.ChangeMonitor> класса и определение пользовательского наблюдения за изменениями поведение должны выполнять инициализацию в конструкторе. Дополнительные сведения см. примечания для наследующих объектов раздела.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Конструктор производного класса необходимо задать <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> , начать мониторинг и вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> класса перед возвратом. При изменении зависимости перед инициализацией завершена (например, если ключ зависимых кэша не найден в кэше), необходимо вызвать конструктор <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод перед вызовом <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> метод. В этом случае конструктор может вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод только после <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> вызывается метод, так как <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод вызывает исключение, если инициализация не завершена.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Метод используется для освобождения <xref:System.Runtime.Caching.ChangeMonitor> экземпляра и связанные ресурсы. Открытые <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод вызывается для координации процесс реализации с помощью события жизненного цикла ключа классов производного монитора изменения (например, инициализация), а также для освобождения <xref:System.Runtime.Caching.ChangeMonitor> экземпляра, чтобы экземпляр мог быть собраны как мусор. <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Метод реализуется классами производного монитора изменения для удаления их управляемых и неуправляемых ресурсов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Вызывает метод <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метода производного класса только один раз, при первом вызове. Последующие вызовы <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод не действуют. После вызова метода <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> свойству `true`.  
  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Для удаления необходимо вызвать перегрузку <xref:System.Runtime.Caching.ChangeMonitor> экземпляра. Ниже приведены правила для вызова метода dispose.  
  
-   Перед вставкой элемента в кэше, это вызывающим для удаления <xref:System.Runtime.Caching.ChangeMonitor> экземпляра.  
  
-   Один раз для элемента кэша и <xref:System.Runtime.Caching.ChangeMonitor> экземпляров, связанных с ним передаются в кэш, Реализатор кэша, убедиться, что <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> вызывается, даже если завершается неудачей.  
  
-   После элемента и связанный с ним <xref:System.Runtime.Caching.ChangeMonitor> экземпляры передаются в кэш, так как вызывающий объект не должен располагать зависимость при <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> вызывается метод, вызов обрабатывается, как если бы зависимость изменилась. В результате <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> автоматически вызывается метод.  
  
-   Учитывая эти правила, <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод должен вызываться в одном из следующих способов:  
  
    -   Пользователи должны вызвать <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> перегруженный метод, если они не вставлять экземпляр производного монитора изменения в кэш.  
  
    -   Реализация кэша отвечает за вызов метода <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> перегрузки, если реализация пытается вставить экземпляр монитора изменений в кэш объекта Вставка не выполняется. При попытке вставки приводит к исключению, реализация кэша должна освободить все связанные зависимости.  
  
    -   Если запись кэша удаляется, реализация кэша должна также удалить зависимость.  
  
 Внутренняя реализация <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> автоматически вызывает метод <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод после вызова обратный вызов, регистрируется через <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> метод.  
  
> [!NOTE]
>  Это автоматического удаления во время срабатывания события происходят, если инициализация <xref:System.Runtime.Caching.ChangeMonitor> ранее выполненные экземпляра.  
  
 При вызове конструктора монитор производном изменений <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> метод, если состояние монитора изменений уже была изменена (то есть, состояние, которое отслеживается уже изменен при конструктор был по-прежнему активен) затем <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> будет метод автоматически удалите монитор изменений.  
  
> [!NOTE]
>  Пользователи не должны вызывать <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод. Тем не менее можно запретить пользователям вызова метода. Таким образом, если они есть, <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> вызывается метод. В этом случае запись кэша уведомляется, как если бы зависимость изменилась.  
  
 Чтобы предотвратить переопределения производными классами <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод, метод не является явной реализацией интерфейса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Инициализация не завершена в производном классе монитора изменений, который вызвал базовый метод <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />.</exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Значение <see langword="true" />, чтобы освободить управляемые и неуправляемые ресурсы и любые ссылки на экземпляр <see cref="T:System.Runtime.Caching.ChangeMonitor" />; значение <see langword="false" />, чтобы освободить только неуправляемые ресурсы. Если передается значение <see langword="false" />, метод <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> вызывается потоком <see langword="finalizer" />, а любые внешние управляемые ссылки в большинстве случаев становятся недействительными, так как они уже были очищены сборщиком мусора.</param>
        <summary>Освобождает все управляемые и неуправляемые ресурсы и все ссылки на экземпляр <see cref="T:System.Runtime.Caching.ChangeMonitor" />. Эту перегрузку необходимо реализовывать в производных классах, контролирующих изменения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение `disposing` значение `true`, все управляемые и неуправляемые ресурсы удаляются, и все ссылки на этот объект освобождаются, чтобы экземпляр производного монитора изменения могут быть собраны как мусор. Гарантируется, что базовый <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод будет вызывать реализованный <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод только один раз.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Монитор изменений необходимо реализовать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> перегрузку, чтобы освободить все управляемые и неуправляемые ресурсы, когда значение <paramref name="disposing" /> — <see langword="true" />. <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> Перегрузку метода, которая имеет <paramref name="disposing" /> значение <see langword="true" /> вызывается только один раз, а именно: при удалении экземпляра в первый раз. Монитор изменений не должны вызывать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> перегрузить непосредственно. Монитор производном изменений можно вызывать открытые без параметров <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод в базовом <see cref="T:System.Runtime.Caching.ChangeMonitor" /> класса.  
  
 Кроме того монитор изменений может реализовать метод завершения. В этом случае можно вызвать метод завершения <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> метод и передать его <paramref name="disposing" /> значение <see langword="false" />. Тем не менее это обычно нет необходимости. Мониторинг изменений зависимостей обычно выполняется службой, которая содержит ссылку на экземпляр монитора изменений. Ссылка защищает экземпляр от сборщика мусора и таким образом делает метод завершения ненужные. Во избежание утечки памяти при изменении зависимость, <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод удаляет экземпляр монитора изменений (если только не закончил инициализацию).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, что состояние, отслеживаемое классом <see cref="T:System.Runtime.Caching.ChangeMonitor" />, изменилось.</summary>
        <value>
          Значение <see langword="true" />, если состояние отслеживаемое экземпляром <see cref="T:System.Runtime.Caching.ChangeMonitor" />, изменилось; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно проверить значение этого свойства в производном <xref:System.Runtime.Caching.ChangeMonitor> класс, чтобы изменился ли зависимости.  
  
 Имеет значение `true` при изменении зависимостей (то есть, когда <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> вызывается метод). После <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод вызывается из производного класса, значение <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> свойство будет `true`независимо от того, следует ли <xref:System.Runtime.Caching.OnChangedCallback> экземпляр получила уведомление с помощью вызова <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> метод.  
  
> [!NOTE]
>  Можно проверить, вызывающие объекты <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> свойство, чтобы узнать, изменился ли зависимости. Однако в многопоточной среде, проще и более простого в сопровождении подход является вставка данных в реализации кэша без проверки <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> свойство. Необходимо проверить реализации кэша <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> свойство для вас и не должно выполнять инструкции insert или операции задания, если один или несколько связанные зависимости уже были изменены.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается из конструктора производных классов и указывает на завершение инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В случае изменения зависимостей до завершения в производном классе инициализации, необходимо вызвать конструктор производного класса <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод.  
  
 Когда <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> вызывается метод, <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> автоматически присваивается свойству `true` монитор изменений. В результате, когда монитор изменений конструктор вызывает метод <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> метода базового класса будет автоматически вызывать <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод. При завершении инициализации <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод автоматически удаляет экземпляр производного монитора изменения.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Конструктор производного класса необходимо вызвать базовый <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> метода до завершения работы конструктор возвращает. Конструктор производного класса может вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод только после <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> вызывается, потому что <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод вызывает исключение, если инициализация не завершена.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, что производный экземпляр класса <see cref="T:System.Runtime.Caching.ChangeMonitor" /> удален.</summary>
        <value>
          Значение <see langword="true" />, если экземпляр удален; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство имеет значение `true` после определения базовой <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> вызовы метода <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод в производном классе для удаления экземпляра.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback">Ссылка на метод, вызываемый при изменении зависимости.</param>
        <summary>Вызывается средствами реализации кэша для регистрации обратного вызова и уведомления экземпляра <see cref="T:System.Runtime.Caching.ObjectCache" /> об изменении зависимости с использованием делегата <see cref="T:System.Runtime.Caching.OnChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использовать реализациях кэша для привязки к монитору изменений. Если связать один или несколько мониторов изменений с элементом кэша, то можно передать <xref:System.Runtime.Caching.CacheItemPolicy> экземпляр с заполненным свойством мониторов изменений с элементом кэша. Реализация кэша мониторов изменений поддерживает отвечает за итерацию <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> свойство и регистр <xref:System.Runtime.Caching.OnChangedCallback> делегатов с каждым изменения монитора, которые найдет.  
  
 Поскольку <xref:System.Runtime.Caching.OnChangedCallback> делегат включает необязательный параметр состояния, конкретная реализация монитора изменений может передать необязательную информацию о состоянии. Реализатор кэша определяет, могут быть предприняты явная зависимость типа состояния, который передает настраиваемый монитор изменений как часть обратного вызова.  
  
> [!NOTE]
>  API расширяемости базовый кэша не имеет требования явной зависимости типа состояния.  
  
 Реализация <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> метод автоматически определяет, является ли состояние монитора уже изменен во время <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> вызывается метод. Если <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> свойство `true`, а затем автоматически вызывает метод <xref:System.Runtime.Caching.OnChangedCallback> обработчик событий, который был зарегистрирован, с использованием <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод. Это происходит потому, что это возможно, с момента реализации кэша создает монитор изменений, во время реализации кэша возвращает монитора и связывает сам вплоть до его базового отслеживаемых состояние изменилось. Если уже изменилось состояние выберите объект, который передается <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод `null`.  
  
 <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Метод может вызываться только один раз и возникает исключение при последующих вызовах.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод обратного вызова уже вызван.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="onChangedCallback" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>1.  Необходимо вызвать метод <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> метод, чтобы получать уведомления о любых изменениях зависимостей. Если уже произошло изменение зависимостей, <see cref="T:System.Runtime.Caching.OnChangedCallback" /> экземпляр будет вызываться при <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> вызывается. В противном случае <see cref="T:System.Runtime.Caching.OnChangedCallback" /> экземпляр будет вызван один раз либо если <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> вызове метода или при <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> вызывается метод, какое событие происходит раньше. <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Экземпляр реализации кэша следует удалить запись кэша и если она запрошена вызывающим кэша, событие необходимые изменения или события обновления обратно в исходный вызывающий объект кэша.  
  
2.  Реализация кэша объектов необходимо удалить запись кэша, связанную с изменением зависимостей.</para>
        </block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Данные для события изменения. Это значение может быть равно <see langword="null" />.</param>
        <summary>Вызывается производными классами для создания события при изменении зависимости.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод вызывается, когда происходят изменения зависимостей. <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Экземпляр монитора изменений удален, однако реализации происходит только в том случае, если обратный вызов уже не был вызван метод также вызывается.  
  
 Если <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод вызывается перед <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> метод вызывается, данные о состоянии от вызова <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод сохраняется с помощью реализации кэша. Кроме того, обратный вызов, который <xref:System.Runtime.Caching.OnChangedCallback> сразу вызывается метод при <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> вызывается метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, представляющее экземпляр класса <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <value>Идентификатор экземпляра монитора изменений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> Значение свойства обычно состоит из зависимостей имена вместе строковые данные, уникальным образом идентификаторы данных, который отслеживается с <xref:System.Runtime.Caching.ChangeMonitor> экземпляра. Значение <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> свойство является строкой. Значение строки используется для назначения уникальный идентификатор <xref:System.Runtime.Caching.ChangeMonitor> экземпляра.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Путем переопределения свойства, можно определить пользовательскую реализацию для строкового значения свойства, чтобы назначить ему уникальный идентификатор.</para>
        </block>
        <block subset="none" type="overrides">
          <para>В производных классах необходимо задать значение свойства в конструкторе.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>