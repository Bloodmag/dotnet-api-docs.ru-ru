<Type Name="ObjectCache" FullName="System.Runtime.Caching.ObjectCache">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1a611d24c5fb21ef987889fe68369933899ab53b" />
    <Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="12/01/2018" />
    <Meta Name="ms.locfileid" Value="52733854" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ObjectCache : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ObjectCache extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ObjectCache" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ObjectCache&#xA;Implements IEnumerable(Of KeyValuePair(Of String, Object))" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectCache abstract : System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type ObjectCache = class&#xA;    interface seq&lt;KeyValuePair&lt;string, obj&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет кэш объекта и предоставляет базовые методы и свойства для доступа к кэша объектов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache> Тип является типом первичного кэша объектов в памяти. Чтобы разработать пользовательскую реализацию кэша, вы наследуете от <xref:System.Runtime.Caching.ObjectCache> класса.  
  
> [!NOTE]
>  <xref:System.Runtime.Caching.ObjectCache> Класс впервые появился начиная с версии [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)].  
  
 Встроенная <xref:System.Runtime.Caching.MemoryCache> класс является производным от <xref:System.Runtime.Caching.ObjectCache> класса. <xref:System.Runtime.Caching.MemoryCache> Класс является реализацией кэша только конкретный объект в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] , производный от <xref:System.Runtime.Caching.ObjectCache> класса.  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <block subset="none" type="overrides">
      <para>Так как <see cref="T:System.Runtime.Caching.ObjectCache" /> тип представляет только общие функции кэша, не требуется для как <see cref="T:System.Runtime.Caching.ObjectCache" /> необходимо создать экземпляр и получить экземпляр. Кроме того, нет необходимости, конкретные реализации <see cref="T:System.Runtime.Caching.ObjectCache" /> класс должен быть одноэлементных экземпляров.  
  
 <block subset="none" type="note"><para><see cref="T:System.Runtime.Caching.MemoryCache" /> не является одноэлементным множеством, но необходимо создать только в одном несколько или потенциально только <see cref="T:System.Runtime.Caching.MemoryCache" /> экземпляра и код, который кэширует элементы следует использовать эти экземпляры.  
  
</para></block>  
  
 При наследовании от <see cref="T:System.Runtime.Caching.ObjectCache" /> класса, необходимо переопределить его методы.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectCache ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectCache();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Вызывается из конструкторов в производных классах для инициализации <see cref="T:System.Runtime.Caching.ObjectCache" /> класса.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе вставляет запись в кэш без обязательного возвращено существующей записи кэша с соответствующим ключом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Перегрузок метода попробуйте вставить запись в кэш, без перезаписи или удаления существующей записи кэша, имеющий тот же ключ. Запись кэша может быть типизированным <xref:System.Runtime.Caching.CacheItem> или универсальный объект.  
  
 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Перегрузок метода и <xref:System.Runtime.Caching.ObjectCache.Add%2A> перегрузок метода имеют одно существенное различие. Когда эти методы вставляют запись кэша, если соответствующая запись находится в кэше, <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> перегрузки метода возвращают существующая запись кэша, но <xref:System.Runtime.Caching.ObjectCache.Add%2A> перегрузок метода — нет. Наличие этих разных перегрузок метода позволяет вызывающим объектам оптимизировать свой код, в зависимости от того, требуется ли существующая запись кэша. В распределенных кэшах, возвращает существующее значение с помощью <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> возможно дороже, чем возвращает логическое значение, используя метод <xref:System.Runtime.Caching.ObjectCache.Add%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool&#xA;override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="objectCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Добавляемый объект.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <summary>При переопределении в производном классе пытается вставить запись в кэш как <see cref="T:System.Runtime.Caching.CacheItem" /> экземпляра и добавляет сведения о том, как операция должна быть удалена.</summary>
        <returns>
          <see langword="true" /> Если вставка выполнена успешно, или <see langword="false" /> при наличии уже запись в кэш, который имеет один и тот же ключ как <paramref name="item" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Перегрузок метода являются виртуальными (а не в абстрактных) на <xref:System.Runtime.Caching.ObjectCache> класса, так как <xref:System.Runtime.Caching.ObjectCache.Add%2A> внутренне вызывает метод <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Это уменьшает количество перегрузок метода, которые должна предоставить реализация кэша. Реализация кэша не требуется специальное поведение при <xref:System.Runtime.Caching.ObjectCache.Add%2A> метод, он может просто реализовать <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> перегрузок метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * DateTimeOffset * string -&gt; bool&#xA;override this.Add : string * obj * DateTimeOffset * string -&gt; bool" Usage="objectCache.Add (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="absoluteExpiration">Фиксированные дата и время истечения срока действия записи кэша. Этот параметр является обязательным, если <see cref="Overload:System.Runtime.Caching.ObjectCache.Add" /> вызывается метод.</param>
        <param name="regionName">Необязательный. Именованная область кэша, к которому можно добавить запись кэша, если области реализованы. Так как в области не реализованы [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], значение по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш без перезаписи существующей в кэше записи.</summary>
        <returns>
          <see langword="true" /> Если вставка выполнена успешно, или <see langword="false" /> при наличии уже запись в кэш, который имеет один и тот же ключ как <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Перегрузок метода являются виртуальными (а не в абстрактных) на <xref:System.Runtime.Caching.ObjectCache> класса, так как <xref:System.Runtime.Caching.ObjectCache.Add%2A> внутренне вызывает метод <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Это уменьшает количество перегрузок метода, которые должна предоставить реализация кэша. Реализация кэша не требуется специальное поведение при <xref:System.Runtime.Caching.ObjectCache.Add%2A> метод, он может просто реализовать <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> перегрузок метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool&#xA;override this.Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool" Usage="objectCache.Add (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <param name="regionName">Необязательный. Именованная область кэша, к которому можно добавить запись кэша, если области реализованы. Значение по умолчанию для необязательного параметра — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш и задает сведения о способе удаления записи.</summary>
        <returns>
          <see langword="true" /> Если вставка производится успешно, или <see langword="false" /> при наличии в кэше тем же ключом, что уже имеется запись <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Перегрузок метода являются виртуальными (а не в абстрактных) на <xref:System.Runtime.Caching.ObjectCache> класса, так как <xref:System.Runtime.Caching.ObjectCache.Add%2A> внутренне вызывает метод <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Это уменьшает количество перегрузок метода, которые должна предоставить реализация кэша. Реализация кэша не требуется специальное поведение при <xref:System.Runtime.Caching.ObjectCache.Add%2A> метод, он может просто реализовать <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> перегрузок метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе пытается вставить запись в кэш и возвращает существующую запись кэша с соответствующим ключом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Перегрузок метода вставить запись в кэш. Если запись кэша с соответствующим ключом уже существует, они возвращают существующую запись. Запись кэша может быть <xref:System.Runtime.Caching.CacheItem> или универсальный объект.  
  
 Есть одно различие между <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> перегрузки и <xref:System.Runtime.Caching.ObjectCache.Add%2A> перегрузки. Эти перегруженные методы попытке вставить запись, при обнаружении существующей записи, что ключ, сопоставляющий существующего вставил запись кэша, <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> перегрузки возвращают существующая запись кэша. <xref:System.Runtime.Caching.ObjectCache.Add%2A> Перегрузки — нет.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem value, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem value, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (value As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ value, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.AddOrGetExisting (value, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="value">Вставляемый объект.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <summary>При переопределении в производном классе вставляет заданный <see cref="T:System.Runtime.Caching.CacheItem" /> объекта в кэш и задает сведения о способе удаления записи.</summary>
        <returns>Если существует запись кэша с таким же ключом, указанная запись кэша; в противном случае <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="absoluteExpiration">Фиксированные дата и время истечения срока действия записи кэша.</param>
        <param name="regionName">Необязательный. Именованная область кэша, к которому можно добавить запись кэша, если области реализованы. Значение по умолчанию для необязательного параметра — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш, с помощью ключа, объект для записи кэша, абсолютное значение срока действия и дополнительная область для добавления в кэш в.</summary>
        <returns>Если существует запись кэша с таким же ключом, указанная запись кэша в значение; в противном случае <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> перегруженный метод не возвращает значение объекта, <xref:System.Runtime.Caching.CacheItem> объекта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <param name="regionName">Необязательный. Именованная область кэша, к которому можно добавить запись кэша, если области реализованы. Значение по умолчанию для необязательного параметра — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш, задавая ключ и значение для записи кэша, а также сведения о способе удаления записи.</summary>
        <returns>Если существует запись кэша с таким же ключом, указанная запись кэша в значение; в противном случае <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.Runtime.Caching.CacheItemPolicy%2CSystem.String%29> Метод возвращает значение объекта, не <xref:System.Runtime.Caching.CacheItem> объекта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public abstract bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Contains : string * string -&gt; bool" Usage="objectCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="regionName">Необязательный. Именованная область кэша, где может быть найден кэш, если области реализованы. Значение по умолчанию для необязательного параметра — <see langword="null" />.</param>
        <summary>При переопределении в производном классе проверяет, существует ли уже записи кэша в кэше.</summary>
        <returns>
          <see langword="true" /> Если в кэше содержится запись с тем же значением ключа как <paramref name="key" />; в противном случае <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="abstract member CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="objectCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Уникальные идентификаторы записей кэша для мониторинга.</param>
        <param name="regionName">Необязательный. Именованная область кэша, где ключи кэша в <paramref name="keys" /> существует параметр, если области реализованы. Значение по умолчанию для необязательного параметра — <see langword="null" />.</param>
        <summary>При переопределении в производном классе создает <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> объект, который может активировать события в ответ на изменения указанных записей кэша.</summary>
        <returns>Монитор изменений, следящий за записями в кэше.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда производный <xref:System.Runtime.Caching.ObjectCache> класс переопределяет базовый <xref:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor%2A> необходимо создать метод, реализация кэша <xref:System.Runtime.Caching.CacheEntryChangeMonitor> объекта. Этот монитор специализированные изменений извещает вызывающие операторы о при внесении изменений в записи кэша, которые указаны в `keys` параметра. Например, если Отслеживаемый объект в `keys` параметра обновляется или удаляется из кэша, монитор изменений, созданные с помощью данного метода инициирует событие.  
  
 Если реализация кэша поддерживает именованные области кэша, как можно указать строковое значение `regionName` параметра. В противном случае — значение по умолчанию `null`.  
  
> [!NOTE]
>  Не все реализации кэша поддерживают мониторы изменений записей кэша. Чтобы определить, поддерживает ли собственную реализацию кэша <xref:System.Runtime.Caching.CacheEntryChangeMonitor> объектов, см. в документации для реализации конкретного кэша.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает описание функций, предоставляемых реализацией кэша.</summary>
        <value>Побитовое сочетание флагов, которое указывает возможности реализации кэша по умолчанию.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public abstract object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Get : string * string -&gt; obj" Usage="objectCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша, которую требуется получить.</param>
        <param name="regionName">Необязательный. Именованная область кэша, в которую была добавлена запись кэша, если области реализованы. Значение по умолчанию для необязательного параметра — <see langword="null" />.</param>
        <summary>При переопределении в производном классе получает из кэша указанную запись кэша как объект.</summary>
        <returns>Запись кэша, который определяется параметром <paramref name="key" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="abstract member GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша, которую требуется получить.</param>
        <param name="regionName">Необязательный. Именованная область кэша, в которую был добавлен кэш, если области реализованы. Так как в области не реализованы [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], по умолчанию используется <see langword="null" />.</param>
        <summary>При переопределении в производном классе, возвращает указанную запись кэша из кэша в виде <see cref="T:System.Runtime.Caching.CacheItem" /> экземпляра.</summary>
        <returns>Запись кэша, который определяется параметром <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка метода существует, так как некоторые реализации кэша может увеличить <xref:System.Runtime.Caching.CacheItem> класса. В этом случае <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> перегруженный метод не обязательно возвращает все сведения о кэшированных данных. Тем не менее <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> перегрузка метода позволяет пользовательских реализаций кэша вернуть больше, чем просто значение кэша.  
  
 <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> Метод аналогичен <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> метода, за исключением случаев, <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> метод возвращает записи кэша как <xref:System.Runtime.Caching.CacheItem> экземпляра.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public abstract long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="abstract member GetCount : string -&gt; int64" Usage="objectCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Необязательный. Именованная область кэша, для которого следует вычислить количество записей кэша, если области реализованы. Значение по умолчанию для необязательного параметра — <see langword="null" />.</param>
        <summary>При переопределении в производном классе получает общее количество вхождений кэша в кэше.</summary>
        <returns>Количество записей кэша в кэше. Если <paramref name="regionName" /> не <see langword="null" />, это число обозначает количество записей в указанной области кэша.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="objectCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создает перечислитель, который может использоваться для перебора коллекции записей кэша.</summary>
        <returns>Объект перечислителя, предоставляющий доступ к записям кэша в кэше.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализации кэша можно переопределить и расширить этот метод для предоставления пользовательских средств итерации по коллекции записей кэша.  
  
> [!NOTE]
>  Возврат перечислителя обычно является операцией дороже, чем возврат всей записи кэша.  
  
 Этот метод вызывается явные реализации интерфейса, <xref:System.Runtime.Caching.ObjectCache> класс имеет для <xref:System.Collections.IEnumerable.GetEnumerator%2A> и <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> методы.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValues">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает набор записей кэша.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Коллекция уникальных идентификаторов записей кэша для получения.</param>
        <param name="regionName">Необязательный. Именованная область кэша, к которой запись кэша или записи были добавлены, если области реализованы. Значение по умолчанию для необязательного параметра — <see langword="null" />.</param>
        <summary>При переопределении в производном классе получает набор записей кэша, соответствующих заданным ключам.</summary>
        <returns>Словарь пар "ключ значение", представляющих записи кэша.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> Перегрузка метода является оптимизация производительности для распределенных кэшей, которые поддерживают получение нескольких записей кэша из кэша во время вызова одной сети.  
  
 Несмотря на то, что вызывающий объект можно передать один или несколько ключей, в метод, нет никакой гарантии, что все ключи представляют записей в кэше. Таким образом возвращенном словаре может содержать меньше элементов, чем количество ключей, которые были переданы в метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (string regionName, params string[] keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(string regionName, string[] keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValues (regionName As String, ParamArray keys As String()) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ GetValues(System::String ^ regionName, ... cli::array &lt;System::String ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="abstract member GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;&#xA;override this.GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (regionName, keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
        <Parameter Name="keys" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="regionName">Необязательный. Именованная область кэша, к которой запись кэша или записи были добавлены, если области реализованы. Так как в области не реализованы [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], по умолчанию используется <see langword="null" />.</param>
        <param name="keys">Коллекция уникальных идентификаторов записей кэша для получения.</param>
        <summary>Получает набор записей кэша, соответствующих заданным ключам.</summary>
        <returns>Словарь пар "ключ значение", представляющих записи кэша.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.GetValues%2A?displayProperty=nameWithType> Перегрузку метода аналогичен <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> перегрузку метода, но позволяет передать именованной области с помощью синтаксиса необязательный параметр, поддерживаемый управляемых языков вроде C#.  
  
 Этот метод является виртуальным методом, так как <xref:System.Runtime.Caching.ObjectCache> класс предоставляет реализацию по умолчанию, который передает `params` массив <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> перегрузки метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public static IServiceProvider Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IServiceProvider Host" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Host" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Host As IServiceProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property IServiceProvider ^ Host { IServiceProvider ^ get(); void set(IServiceProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : IServiceProvider with get, set" Usage="System.Runtime.Caching.ObjectCache.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает ссылку в управляемую среду размещения, которая доступна для <see cref="T:System.Runtime.Caching.ObjectCache" /> реализаций и способную предоставить определенные узлом службы, чтобы <see cref="T:System.Runtime.Caching.ObjectCache" /> реализаций.</summary>
        <value>Ссылка на содержащую средства выявления кэша управляемой среде размещения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Host%2A> Свойство предназначено для использования с [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] размещаются сред и реализациями кэша, которые реализуют поведение, которое зависит от платформы .NET Framework среды.  
  
 В следующей таблице перечислены набор служб среды узла, могут быть доступны в управляемой среде размещения, и, что <xref:System.Runtime.Caching.ObjectCache> реализации посредством <xref:System.Runtime.Caching.ObjectCache.Host%2A> свойство:  
  
|Служба|Описание|  
|-------------|-----------------|  
|<xref:System.Runtime.Caching.Hosting.IApplicationIdentifier>|Позволяет предоставлять идентификаторы доменов приложений, которые могут понадобиться реализацией кэша для функции, такие как идентификация счетчиков производительности среды размещения.|  
|<xref:System.Runtime.Caching.Hosting.IFileChangeNotificationSystem>|Позволяет предоставить пользовательские изменения файла система уведомлений, вместо использования, указанному в средах размещения [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].|  
|<xref:System.Runtime.Caching.Hosting.IMemoryCacheManager>|Позволяет реализации кэша отчета потреблении памяти кэша хост-среды. Это позволяет централизованно управлять потреблением памяти через несколько реализаций кэша средам размещения.|  
  
> [!NOTE]
>  Вызывающие объекты, значения этого свойства требуется неограниченные разрешения безопасности доступа.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значения, присваиваемого свойству является <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Была предпринята попытка задать значение свойства более чем один раз.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">для полного доверия для всех методов доступа этого свойства. Это свойство не может использоваться частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="InfiniteAbsoluteExpiration">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset InfiniteAbsoluteExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteAbsoluteExpiration As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteAbsoluteExpiration : DateTimeOffset" Usage="System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, что запись кэша имеет не абсолютный срок действия.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запись кэша, который вставляется в кэш с <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> значение поля задайте как никогда не истечет срок действия на основе абсолютный точки во времени. Тем не менее запись кэша с помощью этого параметра может быть удалена из кэша по другим причинам, который определяется конкретной реализацией кэша, таких как вытеснение события монитора изменений, из-за нехватки памяти.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public abstract object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.ObjectCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша в кэше.</param>
        <summary>Возвращает или задает индексатор по умолчанию для <see cref="T:System.Runtime.Caching.ObjectCache" /> класса.</summary>
        <value>Ключ, служащий индексатором для экземпляра кэша.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод доступа set этого свойства действует аналогично <xref:System.Runtime.Caching.MemoryCache.Set%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> метод. На внутреннем уровне реализация кэша может задать абсолютный срок действия указанного значения для <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> метод. Тем не менее это поведение является в конечном счете зависит от реализации кэша.  
  
 Поведение метода доступа get, например вызов <xref:System.Collections.Specialized.NameValueCollection.Get%28System.String%29> и использованием `null` регионов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.ObjectCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя конкретного <see cref="T:System.Runtime.Caching.ObjectCache" /> экземпляра.</summary>
        <value>Имя конкретного экземпляра кэша.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые реализации кэша может поддерживать несколько экземпляров кэша, на котором выполняется в одном приложении. Это свойство позволяет кэшу получить имя для идентификации конкретного экземпляра кэша.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoSlidingExpiration">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan NoSlidingExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoSlidingExpiration As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoSlidingExpiration : TimeSpan" Usage="System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что запись кэша не скользящего срока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Срок действия, основанный на длительность или определенный интервал времени, также называется скользящий срок действия. Как правило это реализация кэша, которая исключает элементы, которые основаны на скользящий срок действия будет удалить элемент, не осуществлялся в указанном окне времени.  
  
 Запись кэша, который вставляется в кэш с <xref:System.Runtime.Caching.ObjectCache.NoSlidingExpiration> поле значение, заданное как значение срока действия никогда не должна быть удалена из-за отсутствия активности в скользящего временного окна. Тем не менее элемент кэша может быть исключен, если у него есть абсолютный срок действия или в случае возникновения любого другого события, подвергшиеся удалению в связи, такие изменения монитора или нехватка памяти.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public abstract object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Remove : string * string -&gt; obj" Usage="objectCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="regionName">Необязательный. Именованная область кэша, в которую была добавлена запись кэша, если области реализованы. Значение по умолчанию для необязательного параметра — <see langword="null" />.</param>
        <summary>При переопределении в производном классе удаляет запись кэша из кэша.</summary>
        <returns>Объект, представляющий значение удаленной записи кэша, указанный с помощью ключа или <see langword="null" /> Если указанная запись не найдена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы Переопределите этот метод в пользовательскую реализацию кэша, если имеется запись кэша в кэше, соответствующий `key`, должно возвращаться значение удаленного элемента. Если ничего не был удален из кэша, метод должен вернуть `null`.  
  
> [!NOTE]
>  Некоторые реализации распределенный кэш не могут поддерживать возможность возвращать значение, которое было удалено из кэша. Возможно, реализация кэша поддерживает возвращение значения удаленного элемента кэша. Также возможно маршалинг объекта в качестве возвращаемого значения слишком дорого. В таких случаях реализации кэша могут возвращать `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе вставляет запись в кэш.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обычно поведение <xref:System.Runtime.Caching.ObjectCache.Set%2A> перегрузки методов представляет собой операцию вставки или обновления. Запись является либо вставляется как новая запись, если указанная запись не существует, или записи кэша обновляется новым значением, если он уже существует.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="objectCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Добавляемый элемент кэша.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш как <see cref="T:System.Runtime.Caching.CacheItem" /> экземпляр, указав сведения о способе удаления записи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ключ для `item` не существует, `item` вставляется в качестве новой записи кэша. Если элемент с ключом, соответствующим `item` существует, значение из `item` позволяет обновить или заменить значение существующей записи кэша.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="objectCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="absoluteExpiration">Фиксированные дата и время истечения срока действия записи кэша.</param>
        <param name="regionName">Необязательный. Именованная область кэша, к которому можно добавить запись кэша, если области реализованы. Значение по умолчанию для необязательного параметра — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш и задает сведения о сроке действия на основе времени.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если элемент, соответствующий `key` не существует в кэше, `value` и `key` используются для вставки в виде новой записи кэша. Если элемент с ключом, соответствующим `item` существует, обновляется или путем перезаписи с помощью записи кэша `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="objectCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <param name="regionName">Необязательный. Именованная область кэша, к которому можно добавить запись кэша, если области реализованы. Значение по умолчанию для необязательного параметра — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегруженная версия метода позволяет предоставлять больше информации удаления или истечения срока действия, чем те, которые доступны в абсолютный срок действия на основе времени.  
  
 Если элемент, соответствующий `key` не существует в кэше, `value` и `key` используются для вставки в виде новой записи кэша. Если элемент с ключом, соответствующим `item` существует, обновляется или путем перезаписи с помощью записи кэша `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object)) Implements IEnumerable(Of KeyValuePair(Of String, Object)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Поддерживает выполнение итерации по универсальной коллекции.</summary>
        <returns>Объект перечислителя, предоставляющий доступ к элементам кэша.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться только в том случае, если производный <xref:System.Runtime.Caching.ObjectCache> экземпляр приводится к <xref:System.Collections.IEnumerable> интерфейс.  
  
 Разработчики могут использовать этот метод для выполнения итерации по универсальной коллекции записей кэша.  
  
 Это значение по умолчанию <xref:System.Collections.IEnumerable.GetEnumerator%2A> реализация, которая вызывает <xref:System.Runtime.Caching.ObjectCache.GetEnumerator%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>