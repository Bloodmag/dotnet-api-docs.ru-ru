<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="RuntimeHelpers.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c39d8180904c9260ec3b7f679f09d3791b94ac31.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c39d8180904c9260ec3b7f679f09d3791b94ac31</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>Provides a set of static methods and properties that provide support for compilers.</source>
          <target state="translated">Предоставляет набор статических методов и свойств, которые обеспечивают поддержку компиляторов.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>This class cannot be inherited.</source>
          <target state="translated">Этот класс не наследуется.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>The following example shows how to reliably set handles by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method.</source>
          <target state="translated">Приведенный ниже показано, как надежно задать маркеры с помощью <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is atomic.</source>
          <target state="translated">Чтобы надежно задать дескриптор для заданного ранее существующего дескриптора, необходимо убедиться, что выделения собственного дескриптора и последующей записи этого дескриптора внутри <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> объекта является атомарной.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</source>
          <target state="translated">Любой сбой между этими операциями (например, для прерывания выполнения или исключение нехватки памяти) приведет к утечке собственного дескриптора.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method to make sure that the handle is not leaked.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> метод, чтобы убедиться в том, что дескриптор не попадают.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>Ensures that the remaining stack space is large enough to execute the average .NET Framework function.</source>
          <target state="translated">Обеспечивает достаточный запас пространства стека для выполнения средней функции платформы .NET Framework.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A&gt;</ph> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A&gt;</ph> Предоставляет сведения о искусственно ограниченного стека, который сохраняет недостаточно места для исключения, вызываемого и выполняемое действие восстановления.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.</source>
          <target state="translated">Предел искусственного стека выбирается средой CLR для обеспечения достаточно места для безопасного создания исключения.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>This method is useful in situations where stack overflow might occur as a result of unbounded recursion.</source>
          <target state="translated">Этот метод полезен в ситуациях, где может произойти переполнение стека в результате неограниченной рекурсии.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.</source>
          <target state="translated">Он предназначен для использования в сценариях службы компилятора, несмотря на то, что он может также использоваться безопасно в других сценариях разработки.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.</source>
          <target state="translated">Если достаточно пространство стека, исключение не создается, и большинство типов платформы .NET Framework и члены могут быть вызваны.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>This method is not part of the constrained execution region (CER) support, and should not be confused with the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Этот метод не является частью поддержки ограниченного исполнения область (CER) и их не следует путать с <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>The available stack space is insufficient to execute the average .NET Framework function.</source>
          <target state="translated">Доступного стекового пространства для выполнения средней функции .NET Framework. недостаточно.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>The first object to compare.</source>
          <target state="translated">Первый из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>The second object to compare.</source>
          <target state="translated">Второй из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> instances are considered equal.</source>
          <target state="translated">Определяет, считаются ли равными указанные экземпляры <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="o1" /&gt;</ph> parameter is the same instance as the <ph id="ph3">&lt;paramref name="o2" /&gt;</ph> parameter, or if both are <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or if <bpt id="p1">&lt;c&gt;</bpt>o1.Equals(o2)<ept id="p1">&lt;/c&gt;</ept> returns <ph id="ph5">&lt;see langword="true" /&gt;</ph>; otherwise, <ph id="ph6">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если параметр <ph id="ph2">&lt;paramref name="o1" /&gt;</ph> является тем же экземпляром, что и параметр <ph id="ph3">&lt;paramref name="o2" /&gt;</ph>, или если оба они равны <ph id="ph4">&lt;see langword="null" /&gt;</ph>, или если <bpt id="p1">&lt;c&gt;</bpt>o1.Equals(o2)<ept id="p1">&lt;/c&gt;</ept> возвращает <ph id="ph5">&lt;see langword="true" /&gt;</ph>; в противном случае значение <ph id="ph6">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Этот метод используется компиляторами.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>The following example demonstrates how to compare two objects by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере показано, как для сравнения двух объектов с помощью <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>A delegate to the code to try.</source>
          <target state="translated">Делегат для кода для выполнения попытки.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>A delegate to the code to run if an exception occurs.</source>
          <target state="translated">Делегат для кода, выполняемого в случае исключения.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>The data to pass to <bpt id="p1">&lt;c&gt;</bpt>code<ept id="p1">&lt;/c&gt;</ept> and <bpt id="p2">&lt;c&gt;</bpt>backoutCode<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Данные, передаваемые в <bpt id="p1">&lt;c&gt;</bpt>code<ept id="p1">&lt;/c&gt;</ept> и <bpt id="p2">&lt;c&gt;</bpt>backoutCode<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>Executes code using a <ph id="ph1">&lt;see cref="T:System.Delegate" /&gt;</ph> while using another <ph id="ph2">&lt;see cref="T:System.Delegate" /&gt;</ph> to execute additional code in case of an exception.</source>
          <target state="translated">Выполняет код с помощью делегата <ph id="ph1">&lt;see cref="T:System.Delegate" /&gt;</ph>, используя другой делегат <ph id="ph2">&lt;see cref="T:System.Delegate" /&gt;</ph> для выполнения дополнительного кода в случае исключения.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Этот метод используется компиляторами.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>An object to retrieve the hash code for.</source>
          <target state="translated">Объект, для которого нужно извлечь хэш-код.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.</source>
          <target state="translated">Служит в качестве хэш-функции для конкретного объекта и подходит для использования в алгоритмах и структурах данных, использующих хэш-коды, например в хэш-таблице.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>A hash code for the object identified by the <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter.</source>
          <target state="translated">Хэш-код для объекта, идентифицируемого по параметру <ph id="ph1">&lt;paramref name="o" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method always calls the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method non-virtually, even if the object's type has overridden the <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> Всегда вызывает метод <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> метод невиртуальным, даже если тип объекта переопределил <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Therefore, using <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> might differ from calling <ph id="ph2">`GetHashCode`</ph> directly on the object with the <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Таким образом, использование <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> могут отличаться от вызова <ph id="ph2">`GetHashCode`</ph> непосредственно в объекте с <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Although the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference.</source>
          <target state="translated">Несмотря на то что <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> метод возвращает одинаковые хэш-коды для идентичного объекта ссылки, не следует использовать этот метод для проверки идентификатора объекта, так как этот хэш-код для уникальной идентификации ссылку на объект.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>To test for object identify (that is, to test that two objects reference the same object in memory), call the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Для проверки идентификации объекта (т. е для тестирования два объекты ссылки тот же объект в памяти), вызовите <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Nor should you use <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> to test whether two strings represent equal object references, because the string is interned.</source>
          <target state="translated">И не следует использовать <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> для тестирования ли две строки представляют ссылки на объекты равны, поскольку строка уже интернировано.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>To test for string interning, call the <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Чтобы проверить интернирование строк, вызовите <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> methods differ as follows:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> И <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> методы различаются следующим образом:</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> returns a hash code that is based on the object's definition of equality.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> Возвращает хэш-код, основанный на определении объекта равенства.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>For example, two strings with identical contents will return the same value for <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Например, две строки с идентичное содержимое будет возвращать то же значение для <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> returns a hash code that indicates object identity.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> Возвращает хэш-код, указывающее, удостоверение объекта.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>That is, two string variables whose contents are identical and that represent a string that is interned (see the <bpt id="p1">[</bpt>String Interning<ept id="p1">](#interning)</ept> section) or that represent a single string in memory return identical hash codes.</source>
          <target state="translated">То есть две строковые переменные, содержимое которого идентичны и представляющие собой строку, которая уже интернировано (см. <bpt id="p1">[</bpt>Интернировании<ept id="p1">](#interning)</ept> раздел) или, представляющего одну строку в памяти возвращают одинаковые хэш-коды.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Note that <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> always returns identical hash codes for equal object references.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> всегда возвращает одинаковые хэш-коды для ссылки на объекты равны.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>However, the reverse is not true: equal hash codes do not indicate equal object references.</source>
          <target state="translated">Однако обратное неверно: равно хэш-кодов не указывают ссылки на объекты равны.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.</source>
          <target state="translated">Значение конкретного хэш-кода не является уникальным для ссылки на определенный объект; ссылки на различные объекты могут создавать одинаковые хэш-коды.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Этот метод используется компиляторами.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>String Interning</source>
          <target state="translated">Изоляция строк</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool.</source>
          <target state="translated">Общеязыковая среда выполнения (CLR) поддерживает внутренний пул строк и хранит литералы в пуле.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>If two strings (for example, <ph id="ph1">`str1`</ph> and <ph id="ph2">`str2`</ph>) are formed from an identical string literal, the CLR will set <ph id="ph3">`str1`</ph> and <ph id="ph4">`str2`</ph> to point to the same location on the managed heap to conserve memory.</source>
          <target state="translated">Если две строки (например, <ph id="ph1">`str1`</ph> и <ph id="ph2">`str2`</ph>) состоят из идентичные строки литерала, среда CLR задаст <ph id="ph3">`str1`</ph> и <ph id="ph4">`str2`</ph> для указания местоположения в управляемой куче, для экономии памяти.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Calling <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> этих двух строковых объектов будут получены же хэш-код, в отличие от втором элементе маркированного списка в предыдущем разделе.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The CLR adds only literals to the pool.</source>
          <target state="translated">Среда CLR добавляет только литералы в пул.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal.</source>
          <target state="translated">Результаты строковых операций, таких как объединение не добавляются в пул, если компилятор разрешает объединение строк как один строковый литерал.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Therefore, if <ph id="ph1">`str2`</ph> was created as the result of a concatenation operation, and <ph id="ph2">`str2`</ph> is identical to <ph id="ph3">`str1`</ph>, using <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> on these two string objects will not produce the same hash code.</source>
          <target state="translated">Таким образом Если <ph id="ph1">`str2`</ph> был создан в результате операции объединения и <ph id="ph2">`str2`</ph> идентична <ph id="ph3">`str1`</ph>, с использованием <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> на этих двух строковых объектов не дает тот же хэш-код.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>If you want to add a concatenated string to the pool explicitly, use the <ph id="ph1">&lt;xref:System.String.Intern%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Если требуется явным образом добавить объединенную строку в пул, используйте <ph id="ph1">&lt;xref:System.String.Intern%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> method to check whether a string has an interned reference.</source>
          <target state="translated">Можно также использовать <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> метод для проверки, имеет ли строка интернировано ссылку.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The following example demonstrates the difference between the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">В следующем примере показано различие между <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The output from the example illustrates the following:</source>
          <target state="translated">Выходные данные примера иллюстрирует следующее:</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Both sets of hash codes for the first set of strings passed to the <ph id="ph1">`ShowHashCodes`</ph> method are different, because the strings are completely different.</source>
          <target state="translated">Оба вида хэш-кодов для первого набора строк, передаваемый <ph id="ph1">`ShowHashCodes`</ph> метод различаются, поскольку строки совершенно различны.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> generates the same hash code for the second set of strings passed to the <ph id="ph2">`ShowHashCodes`</ph> method, because the strings are equal.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> Создает же хэш-код для второго набора строк, передаваемых <ph id="ph2">`ShowHashCodes`</ph> метода, так как строки равны.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>However, the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method does not.</source>
          <target state="translated">Тем не менее <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> метод — нет.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The first string is defined by using a string literal and so is interned.</source>
          <target state="translated">Первая строка определяется с помощью строкового литерала и поэтому уже интернировано.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Although the value of the second string is the same, it is not interned, because it is returned by a call to the <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Несмотря на то, что значение второй строки одинаково, оно уже не интернировано, так как он возвращается путем вызова <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>In the case of the third string, the hash codes produced by <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> for both strings are identical, as are the hash codes produced by <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">В случае третьей строки хэш-кодов, полученных при <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> для обеих строк идентичны, как и в случае являются хэш-коды, созданные <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>This is because the compiler has treated the value assigned to both strings as a single string literal, and so the string variables refer to the same interned string.</source>
          <target state="translated">Это потому, что компилятор обрабатываются значение, присваиваемое обе строки как один строковый литерал, и поэтому строковые переменные ссылаться на одну и ту же строку интернировано.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The value type to be boxed.</source>
          <target state="translated">Упаковываемый тип значения.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>Boxes a value type.</source>
          <target state="translated">Упаковывает тип значения.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>A boxed copy of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> if it is a value class; otherwise, <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> itself.</source>
          <target state="translated">Упакованная копия <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>, если это класс значения; в противном случае — <ph id="ph2">&lt;paramref name="obj" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.</source>
          <target state="translated">При упаковке типа значения создается объект и создает неполную копию полей заданного типа значения в новый объект.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.</source>
          <target state="translated">Этот метод позволяет класс значения должны обрабатываться как объект при сохранении его поведения с псевдонимами класса значений.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The return value depends on whether the value class is mutable or immutable:</source>
          <target state="translated">Возвращаемое значение зависит от того, является ли класс значения изменяемым или неизменяемым:</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.</source>
          <target state="translated">Если значения, присваиваемого является изменяемым классом значения, метод возвращает неполную копию класса, так как классы значений имеют семантику копирования.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.</source>
          <target state="translated">Если назначаемое значение является неизменяемым классом значения, метод возвращает сам объект вместо копии класса.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types.</source>
          <target state="translated">Этот метод можно использовать компиляторы языков динамического типа убедиться одинаково работают упакованные типы значений упакованных типов значений.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>That is, boxed value types get cloned when you pass them around, and they are always passed by value.</source>
          <target state="translated">То есть типы упакованных значений клонируются, при их передаче и всегда передаются по значению.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The compiler can call <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> to assign a value type to an object or to pass a value type as a parameter of a type object.</source>
          <target state="translated">Можно вызвать компилятор <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> присвоить тип значения объекта или для передачи типа значения в качестве параметра тип объекта.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Этот метод используется компиляторами.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The following example demonstrates how to box a value class by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> method.</source>
          <target state="translated">Следующий пример демонстрирует поле класса значений с помощью <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>The array to be initialized.</source>
          <target state="translated">Инициализируемый массив.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>A field handle that specifies the location of the data used to initialize the array.</source>
          <target state="translated">Дескриптор поля, указывающий расположение данных, используемых для инициализации массива.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>Provides a fast way to initialize an array from data that is stored in a module.</source>
          <target state="translated">Предоставляет быстрый способ инициализации массива данных, хранящихся в модуле.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>This method is used by compilers.</source>
          <target state="translated">Этот метод используется компиляторами.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Gets the offset, in bytes, to the data in the given string.</source>
          <target state="translated">Получает смещение в байтах к данным в указанной строке.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>The byte offset, from the start of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object to the first character in the string.</source>
          <target state="translated">Смещение в байтах от начала объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> до первого символа строки.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string.</source>
          <target state="translated">Компиляторы используют это свойство для unsafe, но эффективной работы с указателями от символов в управляемая строка.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Compilers should pin the string against movement by the garbage collector before use.</source>
          <target state="translated">Компиляторы должны оградить строки от перемещения сборщиком мусора перед использованием.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Note that common language runtime strings are immutable; that is, their contents can be read but not changed.</source>
          <target state="translated">Обратите внимание, что строки среды CLR являются неизменными. то есть можно читать но не изменять их содержимое.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Designates a body of code as a constrained execution region (CER).</source>
          <target state="translated">Назначает основную часть кода как область с ограничением исполнения (CER).</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Compilers use this method to mark <ph id="ph1">`catch`</ph>, <ph id="ph2">`finally`</ph>, and <ph id="ph3">`fault`</ph> blocks as constrained execution regions (CERs).</source>
          <target state="translated">Компиляторы используют этот метод для пометки <ph id="ph1">`catch`</ph>, <ph id="ph2">`finally`</ph>, и <ph id="ph3">`fault`</ph> блоки как области с ограничением выполнения (CER).</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Code that is marked as a constrained region must only call other code with strong reliability contracts.</source>
          <target state="translated">Код, помеченный как область с ограничением, должен вызывать только другой код с контрактами большой надежности.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.</source>
          <target state="translated">Его не следует выделить или делать виртуальные вызовы неподготовленных или ненадежных методов, если он не подготовлен для обработки сбоев.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Note that no intermediate language opcodes, except <ph id="ph1">`NOP`</ph>, are allowed between a call to the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method and the <ph id="ph3">`try`</ph> block.</source>
          <target state="translated">Обратите внимание, что нет промежуточных кодов операций языка, кроме <ph id="ph1">`NOP`</ph>, разрешенные между вызов <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> метод и <ph id="ph3">`try`</ph> блока.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>For more information about CERs, see the classes in the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution&gt;</ph> namespace.</source>
          <target state="translated">Дополнительные сведения об областях CER см <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution&gt;</ph> пространства имен.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>CERs that are marked using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method do not work perfectly when a <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> is generated from the <ph id="ph3">`try`</ph> block.</source>
          <target state="translated">CER, которые помечены с помощью <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> метод полностью не работают при <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> создается на основе <ph id="ph3">`try`</ph> блока.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A&gt;</ph> method.</source>
          <target state="translated">Дополнительные сведения см. в описании метода <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method calls the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> method.</source>
          <target state="translated">Метод <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> вызывает метод <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>The following example shows how to reliably set handles by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method.</source>
          <target state="translated">Приведенный ниже показано, как надежно задать маркеры с помощью <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is atomic.</source>
          <target state="translated">Чтобы надежно задать дескриптор для заданного ранее существующего дескриптора, необходимо убедиться, что выделения собственного дескриптора и последующей записи этого дескриптора внутри <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> объекта является атомарной.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</source>
          <target state="translated">Любой сбой между этими операциями (например, для прерывания выполнения или исключение нехватки памяти) приведет к утечке собственного дескриптора.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method to make sure that the handle is not leaked.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> метод, чтобы убедиться в том, что дескриптор не попадают.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>Designates a body of code as a constrained execution region (CER) without performing any probing.</source>
          <target state="translated">Назначает основную часть кода областью с ограничением исполнения (CER) без какой-либо проверки.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>Compilers should not call this method directly.</source>
          <target state="translated">Компиляторы не должны напрямую вызывать этот метод.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>Instead, define a CER by calling the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Вместо этого определите CER, вызвав <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>The event delegate to prepare.</source>
          <target state="translated">Делегат события, который следует подготовить.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Provides a way for applications to dynamically prepare <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> event delegates.</source>
          <target state="translated">Предоставляет приложению способ динамической подготовки делегатов событий <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> event delegates such as <ph id="ph2">&lt;xref:System.AppDomain.DomainUnload&gt;</ph>, <ph id="ph3">&lt;xref:System.AppDomain.ProcessExit&gt;</ph>, and <ph id="ph4">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> are not automatically prepared at startup.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> событие делегаты, такие как <ph id="ph2">&lt;xref:System.AppDomain.DomainUnload&gt;</ph>, <ph id="ph3">&lt;xref:System.AppDomain.ProcessExit&gt;</ph>, и <ph id="ph4">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> не подготовлен автоматически при запуске.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>You can use the following methods to prepare them:</source>
          <target state="translated">Чтобы подготовить их можно использовать следующие методы:</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Attribute the method by using the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute&gt;</ph> attribute.</source>
          <target state="translated">Атрибут с помощью метода <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute&gt;</ph> атрибут.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Attribute the method by using the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute.</source>
          <target state="translated">Атрибут с помощью метода <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> атрибут.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A&gt;</ph> method to dynamically prepare the delegate.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A&gt;</ph> метод динамической подготовки делегата.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>For more information, see the article <bpt id="p1">[</bpt>Keep Your Code Running with the Reliability Features of the .NET Framework<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=145491)</ept> in the MSDN Magazine.</source>
          <target state="translated">Дополнительные сведения см. в статье <bpt id="p1">[</bpt>ваш код работу с надежность платформы .NET Framework<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=145491)</ept> в журнале MSDN Magazine.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>The delegate type to prepare.</source>
          <target state="translated">Тип делегата, который следует подготовить.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).</source>
          <target state="translated">Указывает, что заданный делегат следует подготовить к включению в область с ограничением исполнения (CER).</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).</source>
          <target state="translated">Компиляторы используют этот метод для подготовки метода вызова делегата и для подготовки цели этого вызова (и статически определимый граф вызова делегата) как область ограниченного исполнения (CER).</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>Prepares a method for inclusion in a constrained execution region (CER).</source>
          <target state="translated">Подготавливает метод к включению в область с ограничением исполнения (CER).</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>A handle to the method to prepare.</source>
          <target state="translated">Дескриптор метода, который следует подготовить.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>Prepares a method for inclusion in a constrained execution region (CER).</source>
          <target state="translated">Подготавливает метод к включению в область с ограничением исполнения (CER).</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>Compilers use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> method to handle virtual calls that are made inside a constrained execution region (CER).</source>
          <target state="translated">Компиляторы используют <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> метод для обработки виртуальные вызовы, сделанные внутри области ограниченного исполнения (CER).</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call.</source>
          <target state="translated">Во время JIT-компиляции среда обычно не содержать достаточно информации о цели виртуального вызова.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>Therefore, the runtime does not initially prepare that segment of the call graph.</source>
          <target state="translated">Таким образом среда выполнения не подготавливает изначально соответствующий сегмент графа вызовов.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.</source>
          <target state="translated">Если код, который использует CER имеет достаточно сведений для определения целевой объект в любой момент времени до CER фактически указывается, оно может вызвать <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> для выполнения одной среды выполнения подготовки, обычно осуществляется для CER с корнем метода, указанное в качестве аргумента.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>A handle to the method to prepare.</source>
          <target state="translated">Дескриптор метода, который следует подготовить.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>The instantiation to pass to the method.</source>
          <target state="translated">Экземпляр для передачи в метод.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.</source>
          <target state="translated">Подготавливает метод для включения в область с ограничением исполнения (CER) с указанной реализацией.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>You can provide generics support for compilers by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Вы можете предоставить поддержки универсальных типов с помощью компиляторов <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.</source>
          <target state="translated">Общеязыковая среда выполнения не удается подготовить области с ограничением выполнения (CER) в метод, который имеет параметры универсального типа (либо параметром типа класса, содержащего метод, либо параметром самого метода) при создании экземпляра таких параметров типа как ссылочные типы.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any).</source>
          <target state="translated">Эта перегрузка позволяет передать конкретную реализацию (например, массив типов), сначала указав параметры типа класса (если таковые имеются), а затем параметры типа метода (если таковые имеются).</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>The runtime prepares that instantiation of the method.</source>
          <target state="translated">Среда выполнения подготавливает соответствующую реализацию метода.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>(This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style <ph id="ph1">`try`</ph> clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <ph id="ph2">&lt;xref:System.Int32&gt;</ph> or other value types.</source>
          <target state="translated">(Это необходимо только в том случае, если используемые содержат по крайней мере один параметр ссылочного типа.) Таким образом, можно использовать CER-стиль <ph id="ph1">`try`</ph> предложение в универсальный метод (или в неуниверсальном методе универсального класса) и он будет надежно работать с реализациями <ph id="ph2">&lt;xref:System.Int32&gt;</ph> и других типов значений.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>To instantiate reference types such as <ph id="ph1">&lt;xref:System.String&gt;</ph>, you must use an explicit <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> method on the CER root method first.</source>
          <target state="translated">Чтобы создать ссылку типы, такие как <ph id="ph1">&lt;xref:System.String&gt;</ph>, необходимо использовать явную <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> метод CER корневой метод сначала.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space).</source>
          <target state="translated">Проверяет наличие определенного объема стекового пространства, чтобы предотвратить переполнение стека в последующем блоке кода (предполагая, что код использует только конечный и небольшой объем стекового пространства).</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>We recommend that you use a constrained execution region (CER) instead of this method.</source>
          <target state="translated">Рекомендуется вместо этого метода использовать область с ограничением исполнения (CER).</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server.</source>
          <target state="translated">Этот метод используется инфраструктурой ограниченного исполнения область (CER) при запуске на хостах, устойчивых к переполнению стека, например Microsoft SQL Server и Microsoft Exchange Server.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.</source>
          <target state="translated">Этот метод в настоящее время проверяет наличие 48 КБ пространство стека на x86 платформы, но точный объем может изменяться со временем и может отличаться на других платформах.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This method is also used by compilers.</source>
          <target state="translated">Этот метод также используется компиляторами.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>Instead of using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> method, you should use a standard CER.</source>
          <target state="translated">Вместо использования <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> метода, следует использовать стандартный CER.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>That is, if you are planning to use a moderate amount of stack space, call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> method immediately before your <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`finally`</ph> or <ph id="ph5">`try`</ph><ph id="ph6">/</ph><ph id="ph7">`catch`</ph> block.</source>
          <target state="translated">То есть, если вы планируете использовать средний объем места в стеке, вызовите <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> метод непосредственно перед вашей <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`finally`</ph> или <ph id="ph5">`try`</ph> <ph id="ph6">/</ph> <ph id="ph7">`catch`</ph> блока.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>If you are calling a recursive method or plan to use a lot of stack space, you must use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">При вызове рекурсивный метод или планируется использовать большой объем места в стеке, необходимо использовать <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>A type handle that specifies the class constructor method to run.</source>
          <target state="translated">Дескриптор типа, определяющий метод конструктора класса, который нужно выполнить.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>Runs a specified class constructor method.</source>
          <target state="translated">Выполняет указанный метод конструктора класса.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>This method is used by compilers.</source>
          <target state="translated">Этот метод используется компиляторами.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>The class initializer throws an exception.</source>
          <target state="translated">Инициализатор класса создает исключение.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>A handle that specifies the module constructor method to run.</source>
          <target state="translated">Дескриптор, определяющий метод конструктора модуля, который нужно выполнить.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>Runs a specified module constructor method.</source>
          <target state="translated">Выполняет указанный метод конструктора модуля.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>This method is used by compilers.</source>
          <target state="translated">Этот метод используется компиляторами.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>The module constructor throws an exception.</source>
          <target state="translated">Конструктор модуля выдает исключение.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>