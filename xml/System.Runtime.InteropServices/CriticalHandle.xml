<Type Name="CriticalHandle" FullName="System.Runtime.InteropServices.CriticalHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="56d9d023a154981435b37666fa081861ca0100c2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480148" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CriticalHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CriticalHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.CriticalHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CriticalHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class CriticalHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="d24e3-101">Представляет класс-оболочку для ресурсов обработчика.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d24e3-101">Represents a wrapper class for handle resources.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d24e3-102"><xref:System.Runtime.InteropServices.CriticalHandle> Класс аналогичен <xref:System.Runtime.InteropServices.SafeHandle> класса, за исключением того, что <xref:System.Runtime.InteropServices.SafeHandle> реализует подсчета ссылок.</span><span class="sxs-lookup"><span data-stu-id="d24e3-102">The <xref:System.Runtime.InteropServices.CriticalHandle> class is similar to the <xref:System.Runtime.InteropServices.SafeHandle> class, except that <xref:System.Runtime.InteropServices.SafeHandle> implements reference counting.</span></span> <span data-ttu-id="d24e3-103">Можно использовать <xref:System.Runtime.InteropServices.CriticalHandle> вместо <xref:System.Runtime.InteropServices.SafeHandle> для адресов вопросы производительности при предоставлении необходимости синхронизации более эффективно самостоятельно.</span><span class="sxs-lookup"><span data-stu-id="d24e3-103">You can use <xref:System.Runtime.InteropServices.CriticalHandle> instead of <xref:System.Runtime.InteropServices.SafeHandle> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.</span></span>  
  
 <span data-ttu-id="d24e3-104">Поскольку <xref:System.Runtime.InteropServices.CriticalHandle> класса не выполняет подсчет ссылок, он не обеспечивает защиту от атак на систему безопасности повторного использования дескриптора.</span><span class="sxs-lookup"><span data-stu-id="d24e3-104">Because the <xref:System.Runtime.InteropServices.CriticalHandle> class does not perform reference counting, it does not provide protection from handle recycling security attacks.</span></span> <span data-ttu-id="d24e3-105">Поскольку алгоритм подсчета ссылок неявно сериализует операции, определенный объем потокобезопасности также теряются.</span><span class="sxs-lookup"><span data-stu-id="d24e3-105">Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost.</span></span> <span data-ttu-id="d24e3-106">При вызове метода <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> или <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> метод во время операции, использующего дескриптор остается необработанной в другом потоке и при вызове метода <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> или <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> из двух потоков одновременно результаты являются недетерминированными.</span><span class="sxs-lookup"><span data-stu-id="d24e3-106">If you call the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method while an operation that is using the handle is outstanding on another thread, or if you call <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> from two threads at the same time, the results are non-deterministic.</span></span> <span data-ttu-id="d24e3-107"><xref:System.Runtime.InteropServices.CriticalHandle> Класс по-прежнему обеспечивает гарантированную критическое завершение, предоставляемые <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> класса.</span><span class="sxs-lookup"><span data-stu-id="d24e3-107">The <xref:System.Runtime.InteropServices.CriticalHandle> class still provides the guaranteed critical finalization provided by the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="d24e3-108">для полного доверия для разработчиков производных классов.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d24e3-108">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="d24e3-109">Этот член не может наследоваться частично доверенным кодом.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d24e3-109">This member cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">
      <span data-ttu-id="d24e3-110">требуется полное доверие для непосредственно вызывающего метода.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d24e3-110">requires full trust for the immediate caller.</span>
      </span>
      <span data-ttu-id="d24e3-111">Этот класс не может использоваться частично доверенным или прозрачным кодом.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d24e3-111">This class cannot be used by partially trusted or transparent code.</span>
      </span>
    </permission>
    <altmember cref="T:System.Runtime.InteropServices.SafeHandle" />
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CriticalHandle (IntPtr invalidHandleValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CriticalHandle(IntPtr invalidHandleValue);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">
          <span data-ttu-id="d24e3-112">Значение недопустимого дескриптора (обычно 0 или -1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-112">The value of an invalid handle (usually 0 or -1).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d24e3-113">Инициализирует новый экземпляр класса <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> с заданным значением недопустимого дескриптора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-113">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class with the specified invalid handle value.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="d24e3-114">Производный класс находится в сборке без разрешения на доступ к неуправляемому коду.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-114">The derived class resides in an assembly without unmanaged code access permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="d24e3-115">для полного доверия для разработчиков производных классов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-115">for full trust for inheritors.</span>
          </span>
          <span data-ttu-id="d24e3-116">Этот член не может наследоваться частично доверенным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-116">This member cannot be inherited by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="d24e3-117">требуется полное доверие для непосредственно вызывающего метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-117">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d24e3-118">Этот класс не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-118">This class cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d24e3-119">Помечает дескриптор для освобождения самого дескриптора и соответствующих ресурсов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-119">Marks the handle for releasing and freeing resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d24e3-120">Вызов <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> или <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> метод позволяет освободить ресурсы.</span><span class="sxs-lookup"><span data-stu-id="d24e3-120">Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="d24e3-121">В отличие от <xref:System.Runtime.InteropServices.SafeHandle> класса, это всегда происходит немедленно, поскольку указывают, что другие потоки используют этот дескриптор счетчика ссылок.</span><span class="sxs-lookup"><span data-stu-id="d24e3-121">Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</span></span> <span data-ttu-id="d24e3-122">Таким образом, необходимо использовать механизм синхронизации, чтобы его можно вызвать <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="d24e3-122">Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method.</span></span> <span data-ttu-id="d24e3-123">Несмотря на то, что большинство классов, использующие <xref:System.Runtime.InteropServices.CriticalHandle> классу не требуется предоставлять метод завершения, иногда это необходимо (например, чтобы очистить буферы файлов или записать некоторые данные обратно в память).</span><span class="sxs-lookup"><span data-stu-id="d24e3-123">Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="d24e3-124">В этом случае класс может предоставить метод завершения, который обязательно выполняется перед <xref:System.Runtime.InteropServices.CriticalHandle> запусков критический метод завершения.</span><span class="sxs-lookup"><span data-stu-id="d24e3-124">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="d24e3-125">Вызовите <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> или <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> метод при завершении с помощью <xref:System.Runtime.InteropServices.CriticalHandle> объекта.</span><span class="sxs-lookup"><span data-stu-id="d24e3-125">Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="d24e3-126"><xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> Метода <xref:System.Runtime.InteropServices.CriticalHandle> объекта окажется в неработоспособном состоянии.</span><span class="sxs-lookup"><span data-stu-id="d24e3-126">The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.</span></span>  
  
 <span data-ttu-id="d24e3-127">**Примечание** вызова всегда <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> или <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> перед освобождением последней ссылки на <xref:System.Runtime.InteropServices.CriticalHandle> объекта.</span><span class="sxs-lookup"><span data-stu-id="d24e3-127">**Note** Always call <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="d24e3-128">В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.Runtime.InteropServices.CriticalHandle> метод <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="d24e3-128">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d24e3-129">Помечает дескриптор для освобождения самого дескриптора и соответствующих ресурсов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-129">Marks the handle for releasing and freeing resources.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d24e3-130">Освобождает все ресурсы, занятые модулем <see cref="T:System.Runtime.InteropServices.CriticalHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-130">Releases all resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d24e3-131">Вызов <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> или <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> метод позволяет освободить ресурсы.</span><span class="sxs-lookup"><span data-stu-id="d24e3-131">Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="d24e3-132">В отличие от <xref:System.Runtime.InteropServices.SafeHandle> класса, это всегда происходит немедленно, поскольку указывают, что другие потоки используют этот дескриптор счетчика ссылок.</span><span class="sxs-lookup"><span data-stu-id="d24e3-132">Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</span></span> <span data-ttu-id="d24e3-133">Таким образом, необходимо использовать механизм синхронизации, чтобы его можно вызвать <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="d24e3-133">Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method.</span></span> <span data-ttu-id="d24e3-134">Несмотря на то, что большинство классов, использующие <xref:System.Runtime.InteropServices.CriticalHandle> классу не требуется предоставлять метод завершения, иногда это необходимо (например, чтобы очистить буферы файлов или записать некоторые данные обратно в память).</span><span class="sxs-lookup"><span data-stu-id="d24e3-134">Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="d24e3-135">В этом случае класс может предоставить метод завершения, который обязательно выполняется перед <xref:System.Runtime.InteropServices.CriticalHandle> запусков критический метод завершения.</span><span class="sxs-lookup"><span data-stu-id="d24e3-135">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="d24e3-136">Вызовите <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> или <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> метод при завершении с помощью <xref:System.Runtime.InteropServices.CriticalHandle> объекта.</span><span class="sxs-lookup"><span data-stu-id="d24e3-136">Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="d24e3-137"><xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> Метода <xref:System.Runtime.InteropServices.CriticalHandle> объекта окажется в неработоспособном состоянии.</span><span class="sxs-lookup"><span data-stu-id="d24e3-137">The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.</span></span>  
  
 <span data-ttu-id="d24e3-138">**Примечание** вызова всегда <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> или <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> метод перед освобождением последней ссылки на <xref:System.Runtime.InteropServices.CriticalHandle> объекта.</span><span class="sxs-lookup"><span data-stu-id="d24e3-138">**Note** Always call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="d24e3-139">В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.Runtime.InteropServices.CriticalHandle> метод <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="d24e3-139">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="d24e3-140">Значение <see langword="true" /> для обычной операции удаления и значение <see langword="false" /> для завершения работы с дескриптором.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-140">
              <see langword="true" /> for a normal dispose operation; <see langword="false" /> to finalize the handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d24e3-141">Освобождает неуправляемые ресурсы, используемые классом <see cref="T:System.Runtime.InteropServices.CriticalHandle" />, определяя, нужно ли выполнять обычную операцию удаления.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-141">Releases the unmanaged resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class specifying whether to perform a normal dispose operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d24e3-142">Следует явно вызывать <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> метод с `disposing` равным `false`.</span><span class="sxs-lookup"><span data-stu-id="d24e3-142">You should never explicitly call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method with the `disposing` parameter set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CriticalHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!CriticalHandle ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d24e3-143">Освобождает все ресурсы, связанные с дескриптором.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-143">Frees all resources associated with the handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d24e3-144"><xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> Деструктор является методом <xref:System.Runtime.InteropServices.CriticalHandle> класса.</span><span class="sxs-lookup"><span data-stu-id="d24e3-144">The <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.CriticalHandle> class.</span></span> <span data-ttu-id="d24e3-145">Код приложения не должны напрямую вызывать этот метод.</span><span class="sxs-lookup"><span data-stu-id="d24e3-145">Application code should not call this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.CriticalHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d24e3-146">Определяет инкапсулируемый дескриптор.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-146">Specifies the handle to be wrapped.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d24e3-147">Не предоставляйте к этому дескриптору публично (то есть, вне производного класса).</span><span class="sxs-lookup"><span data-stu-id="d24e3-147">Do not expose the handle publicly (that is, outside of the derived class).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d24e3-148">Возвращает значение, показывающее, является ли дескриптор закрытым.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-148">Gets a value indicating whether the handle is closed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d24e3-149">Значение <see langword="true" />, если дескриптор закрыт, в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-149">
              <see langword="true" /> if the handle is closed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d24e3-150"><xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> Метод возвращает значение, указывающее, является ли <xref:System.Runtime.InteropServices.CriticalHandle> дескриптор объекта больше не связана с машинным ресурсом.</span><span class="sxs-lookup"><span data-stu-id="d24e3-150">The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.CriticalHandle> object's handle is no longer associated with a native resource.</span></span> <span data-ttu-id="d24e3-151">Это отличается от определения <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> свойство, которое вычисляет ли данным дескриптором всегда считается недействительным.</span><span class="sxs-lookup"><span data-stu-id="d24e3-151">This differs from the definition of the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid.</span></span> <span data-ttu-id="d24e3-152"><xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> Возвращает `true` значение в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="d24e3-152">The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a `true` value in the following cases:</span></span>  
  
-   <span data-ttu-id="d24e3-153"><xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> Был вызван метод.</span><span class="sxs-lookup"><span data-stu-id="d24e3-153">The <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method was called.</span></span>  
  
-   <span data-ttu-id="d24e3-154"><xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> Метода или <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> метод был вызван и нет ссылок на <xref:System.Runtime.InteropServices.CriticalHandle> объект в других потоках.</span><span class="sxs-lookup"><span data-stu-id="d24e3-154">The <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.CriticalHandle> object on other threads.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d24e3-155">При переопределении в производном классе возвращает значение, показывающее, допустимо ли значение дескриптора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-155">When overridden in a derived class, gets a value indicating whether the handle value is invalid.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d24e3-156">Значение <see langword="true" />, если дескриптор является допустимым, в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-156">
              <see langword="true" /> if the handle is valid; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d24e3-157">Производные классы должны реализовывать <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> свойство, чтобы общеязыковая среда выполнения может определить, требуется ли критическое завершение.</span><span class="sxs-lookup"><span data-stu-id="d24e3-157">Derived classes must implement the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required.</span></span> <span data-ttu-id="d24e3-158">Производные классы должны предоставлять реализацию, которая соответствует общему типу дескриптора, они поддерживают (0 или -1 является недопустимым).</span><span class="sxs-lookup"><span data-stu-id="d24e3-158">Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</span></span> <span data-ttu-id="d24e3-159">Эти классы могут быть дополнительными производными для конкретных типов безопасных дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="d24e3-159">These classes can then be further derived for specific safe handle types.</span></span>  
  
 <span data-ttu-id="d24e3-160">В отличие от <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> свойство, которое сообщает ли <xref:System.Runtime.InteropServices.CriticalHandle> завершения с помощью базовый дескриптор объекта <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> свойство вычисляет, является ли значение данного дескриптора всегда считается недействительным.</span><span class="sxs-lookup"><span data-stu-id="d24e3-160">Unlike the <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.CriticalHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid.</span></span> <span data-ttu-id="d24e3-161">Таким образом <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> свойство всегда возвращает то же значение для любого значения одного дескриптора.</span><span class="sxs-lookup"><span data-stu-id="d24e3-161">Therefore, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property always returns the same value for any one handle value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d24e3-162">При переопределении в производном классе выполняет код, необходимый для освобождения дескриптора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-162">When overridden in a derived class, executes the code required to free the handle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d24e3-163">Значение <see langword="true" />, если дескриптор освобождается успешно; в противном случае при катастрофическом сбое — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-163">
              <see langword="true" /> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d24e3-164">В таком случае создается управляемый помощник по отладке [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-164">In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d24e3-165"><xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> Метод гарантированно вызываться только один раз, при условии, что вы применяете механизмы правильную синхронизацию, чтобы убедиться, что только один вызов <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> или <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> метода.</span><span class="sxs-lookup"><span data-stu-id="d24e3-165">The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method is made.</span></span> <span data-ttu-id="d24e3-166"><xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> Не будет вызван метод, если <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> или <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> свойство `true`.</span><span class="sxs-lookup"><span data-stu-id="d24e3-166">The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method will not be called if the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property is `true`.</span></span> <span data-ttu-id="d24e3-167">Реализация этого метода в вашей <xref:System.Runtime.InteropServices.CriticalHandle> производными классами для выполнения любой код, необходимый для освобождения дескриптора.</span><span class="sxs-lookup"><span data-stu-id="d24e3-167">Implement this method in your <xref:System.Runtime.InteropServices.CriticalHandle> derived classes to execute any code that is required to free the handle.</span></span> <span data-ttu-id="d24e3-168">Так как одна из функций <xref:System.Runtime.InteropServices.CriticalHandle> — для обеспечения защиты от утечки ресурсов, код в реализации <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> никогда не должна закончиться откатом.</span><span class="sxs-lookup"><span data-stu-id="d24e3-168">Because one of the functions of <xref:System.Runtime.InteropServices.CriticalHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> must never fail.</span></span> <span data-ttu-id="d24e3-169">Сборщик мусора вызывает <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> после обычные методы завершения будут выполнены для объектов, которые были собраны в то же время сборки мусора и ресурсы для вызова и что он не будет прерван во время его гарантии выполняется в данный момент.</span><span class="sxs-lookup"><span data-stu-id="d24e3-169">The garbage collector calls <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress.</span></span> <span data-ttu-id="d24e3-170">Этот метод будет подготовлен как область с ограничением выполнения (CER) во время создания экземпляра (а также все методы в его статично определимый граф вызова).</span><span class="sxs-lookup"><span data-stu-id="d24e3-170">This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</span></span> <span data-ttu-id="d24e3-171">Несмотря на то, что это предотвращает прерывание прерывания потока, по-прежнему Будьте внимательны, чтобы не следует вводить все пути ошибок в переопределенном <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="d24e3-171">Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method.</span></span> <span data-ttu-id="d24e3-172">В частности, применение <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> для методов вызова из атрибута <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="d24e3-172">In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>.</span></span> <span data-ttu-id="d24e3-173">В большинстве случаев этот код должен быть:</span><span class="sxs-lookup"><span data-stu-id="d24e3-173">In most cases this code should be:</span></span>  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 <span data-ttu-id="d24e3-174">Кроме того, для простой очистки (например, вызов API-интерфейса Win32 `CloseHandle` на дескриптор файла) можно проверить возвращаемое значение для одного вызова неуправляемого.</span><span class="sxs-lookup"><span data-stu-id="d24e3-174">Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call.</span></span> <span data-ttu-id="d24e3-175">Для сложных очистки может иметь много логики программы и количестве вызовов, некоторые из которых может завершиться ошибкой.</span><span class="sxs-lookup"><span data-stu-id="d24e3-175">For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</span></span> <span data-ttu-id="d24e3-176">Необходимо убедиться, что логику программы имеет код отката для каждого из этих вариантов.</span><span class="sxs-lookup"><span data-stu-id="d24e3-176">You must ensure that your program logic has fallback code for each of those cases.</span></span>  
  
 <span data-ttu-id="d24e3-177">Если <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> возвращает `false` по любой причине, он создает [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) управляемый помощник по отладке.</span><span class="sxs-lookup"><span data-stu-id="d24e3-177">If the <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="d24e3-178">Ранее существующий дескриптор для использования.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-178">The pre-existing handle to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d24e3-179">Определяет дескриптор для заданного ранее существующего дескриптора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-179">Sets the handle to the specified pre-existing handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d24e3-180">Используйте <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> обрабатывает метод только в том случае, если необходима поддержка ранее существующий дескриптор (например, если маркер возвращается в структуре) из-за взаимодействия инфраструктуры .NET Framework COM не поддерживает маршалинг в структуре.</span><span class="sxs-lookup"><span data-stu-id="d24e3-180">Use the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d24e3-181">Помечает дескриптор как недопустимый.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d24e3-181">Marks a handle as invalid.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d24e3-182">Вызовите <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> метод только в том случае, если известно, что маркер является недопустимым, и пометить его таким образом.</span><span class="sxs-lookup"><span data-stu-id="d24e3-182">Call the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method only when you know that your handle is invalid and you want to mark it as such.</span></span> <span data-ttu-id="d24e3-183">При этом не изменяет значение <xref:System.Runtime.InteropServices.CriticalHandle.handle> поле; он только Помечает дескриптор как недопустимый.</span><span class="sxs-lookup"><span data-stu-id="d24e3-183">Doing so does not change the value of the <xref:System.Runtime.InteropServices.CriticalHandle.handle> field; it only marks the handle as invalid.</span></span> <span data-ttu-id="d24e3-184">Дескриптор затем может содержать потенциально устаревшее значение.</span><span class="sxs-lookup"><span data-stu-id="d24e3-184">The handle might then contain a potentially stale value.</span></span> <span data-ttu-id="d24e3-185">Результат этого вызова является не попытка освободить ресурсы.</span><span class="sxs-lookup"><span data-stu-id="d24e3-185">The effect of this call is that no attempt is made to free the resources.</span></span>  
  
 <span data-ttu-id="d24e3-186">Как и в <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> используйте <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> только в том случае, если требуется обеспечить поддержку ранее существующий дескриптор.</span><span class="sxs-lookup"><span data-stu-id="d24e3-186">As with the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>