<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CriticalHandle.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac556d9d023a154981435b37666fa081861ca0100c2.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">56d9d023a154981435b37666fa081861ca0100c2</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Represents a wrapper class for handle resources.</source>
          <target state="translated">Представляет класс-оболочку для ресурсов обработчика.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class is similar to the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, except that <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> implements reference counting.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Класс аналогичен <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> класса, за исключением того, что <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> реализует подсчета ссылок.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> вместо <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> для адресов вопросы производительности при предоставлении необходимости синхронизации более эффективно самостоятельно.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Because the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class does not perform reference counting, it does not provide protection from handle recycling security attacks.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> класса не выполняет подсчет ссылок, он не обеспечивает защиту от атак на систему безопасности повторного использования дескриптора.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost.</source>
          <target state="translated">Поскольку алгоритм подсчета ссылок неявно сериализует операции, определенный объем потокобезопасности также теряются.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>If you call the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> method while an operation that is using the handle is outstanding on another thread, or if you call <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph4">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> from two threads at the same time, the results are non-deterministic.</source>
          <target state="translated">При вызове метода <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> метод во время операции, использующего дескриптор остается необработанной в другом потоке и при вызове метода <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph4">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> из двух потоков одновременно результаты являются недетерминированными.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class still provides the guaranteed critical finalization provided by the <ph id="ph2">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Класс по-прежнему обеспечивает гарантированную критическое завершение, предоставляемые <ph id="ph2">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>for full trust for inheritors.</source>
          <target state="translated">для полного доверия для разработчиков производных классов.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>This member cannot be inherited by partially trusted code.</source>
          <target state="translated">Этот член не может наследоваться частично доверенным кодом.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>This class cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот класс не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>The value of an invalid handle (usually 0 or -1).</source>
          <target state="translated">Значение недопустимого дескриптора (обычно 0 или -1).</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> class with the specified invalid handle value.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> с заданным значением недопустимого дескриптора.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>The derived class resides in an assembly without unmanaged code access permission.</source>
          <target state="translated">Производный класс находится в сборке без разрешения на доступ к неуправляемому коду.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>for full trust for inheritors.</source>
          <target state="translated">для полного доверия для разработчиков производных классов.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>This member cannot be inherited by partially trusted code.</source>
          <target state="translated">Этот член не может наследоваться частично доверенным кодом.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>This class cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот класс не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Marks the handle for releasing and freeing resources.</source>
          <target state="translated">Помечает дескриптор для освобождения самого дескриптора и соответствующих ресурсов.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> метод позволяет освободить ресурсы.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</source>
          <target state="translated">В отличие от <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> класса, это всегда происходит немедленно, поскольку указывают, что другие потоки используют этот дескриптор счетчика ссылок.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method.</source>
          <target state="translated">Таким образом, необходимо использовать механизм синхронизации, чтобы его можно вызвать <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Although most classes that use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</source>
          <target state="translated">Несмотря на то, что большинство классов, использующие <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> классу не требуется предоставлять метод завершения, иногда это необходимо (например, чтобы очистить буферы файлов или записать некоторые данные обратно в память).</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>In this case, the class can provide a finalizer that is guaranteed to run before the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> critical finalizer runs.</source>
          <target state="translated">В этом случае класс может предоставить метод завершения, который обязательно выполняется перед <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> запусков критический метод завершения.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> метод при завершении с помощью <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object in an unusable state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> Метода <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> объекта окажется в неработоспособном состоянии.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> Always call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> before you release your last reference to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>Примечание<ept id="p1">**</ept> вызова всегда <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> перед освобождением последней ссылки на <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> метод <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Marks the handle for releasing and freeing resources.</source>
          <target state="translated">Помечает дескриптор для освобождения самого дескриптора и соответствующих ресурсов.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Releases all resources used by the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph>.</source>
          <target state="translated">Освобождает все ресурсы, занятые модулем <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> метод позволяет освободить ресурсы.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</source>
          <target state="translated">В отличие от <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> класса, это всегда происходит немедленно, поскольку указывают, что другие потоки используют этот дескриптор счетчика ссылок.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">Таким образом, необходимо использовать механизм синхронизации, чтобы его можно вызвать <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Although most classes that use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</source>
          <target state="translated">Несмотря на то, что большинство классов, использующие <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> классу не требуется предоставлять метод завершения, иногда это необходимо (например, чтобы очистить буферы файлов или записать некоторые данные обратно в память).</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>In this case, the class can provide a finalizer that is guaranteed to run before the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> critical finalizer runs.</source>
          <target state="translated">В этом случае класс может предоставить метод завершения, который обязательно выполняется перед <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> запусков критический метод завершения.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> метод при завершении с помощью <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object in an unusable state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> Метода <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> объекта окажется в неработоспособном состоянии.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> Always call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method before you release your last reference to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>Примечание<ept id="p1">**</ept> вызова всегда <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> метод перед освобождением последней ссылки на <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> метод <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> for a normal dispose operation; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to finalize the handle.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> для обычной операции удаления и значение <ph id="ph2">&lt;see langword="false" /&gt;</ph> для завершения работы с дескриптором.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> class specifying whether to perform a normal dispose operation.</source>
          <target state="translated">Освобождает неуправляемые ресурсы, используемые классом <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph>, определяя, нужно ли выполнять обычную операцию удаления.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)">
          <source>You should never explicitly call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method with the <ph id="ph2">`disposing`</ph> parameter set to <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Следует явно вызывать <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> метод с <ph id="ph2">`disposing`</ph> равным <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Finalize">
          <source>Frees all resources associated with the handle.</source>
          <target state="translated">Освобождает все ресурсы, связанные с дескриптором.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method is the destructor for the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> Деструктор является методом <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Finalize">
          <source>Application code should not call this method directly.</source>
          <target state="translated">Код приложения не должны напрямую вызывать этот метод.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.CriticalHandle.handle">
          <source>Specifies the handle to be wrapped.</source>
          <target state="translated">Определяет инкапсулируемый дескриптор.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.CriticalHandle.handle">
          <source>Do not expose the handle publicly (that is, outside of the derived class).</source>
          <target state="translated">Не предоставляйте к этому дескриптору публично (то есть, вне производного класса).</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>Gets a value indicating whether the handle is closed.</source>
          <target state="translated">Возвращает значение, показывающее, является ли дескриптор закрытым.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если дескриптор закрыт, в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> method returns a value indicating whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's handle is no longer associated with a native resource.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> Метод возвращает значение, указывающее, является ли <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> дескриптор объекта больше не связана с машинным ресурсом.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>This differs from the definition of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property, which computes whether a given handle is always considered invalid.</source>
          <target state="translated">Это отличается от определения <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> свойство, которое вычисляет ли данным дескриптором всегда считается недействительным.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> method returns a <ph id="ph2">`true`</ph> value in the following cases:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> Возвращает <ph id="ph2">`true`</ph> значение в следующих случаях:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> method was called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> Был вызван метод.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method was called and there are no references to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object on other threads.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> Метода или <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> метод был вызван и нет ссылок на <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> объект в других потоках.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>When overridden in a derived class, gets a value indicating whether the handle value is invalid.</source>
          <target state="translated">При переопределении в производном классе возвращает значение, показывающее, допустимо ли значение дескриптора.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is valid; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если дескриптор является допустимым, в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Derived classes must implement the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property so that the common language runtime can determine whether critical finalization is required.</source>
          <target state="translated">Производные классы должны реализовывать <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> свойство, чтобы общеязыковая среда выполнения может определить, требуется ли критическое завершение.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</source>
          <target state="translated">Производные классы должны предоставлять реализацию, которая соответствует общему типу дескриптора, они поддерживают (0 или -1 является недопустимым).</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>These classes can then be further derived for specific safe handle types.</source>
          <target state="translated">Эти классы могут быть дополнительными производными для конкретных типов безопасных дескрипторов.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> property, which reports whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object has finished using the underlying handle, the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property calculates whether the given handle value is always considered invalid.</source>
          <target state="translated">В отличие от <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> свойство, которое сообщает ли <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> завершения с помощью базовый дескриптор объекта <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> свойство вычисляет, является ли значение данного дескриптора всегда считается недействительным.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property always returns the same value for any one handle value.</source>
          <target state="translated">Таким образом <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> свойство всегда возвращает то же значение для любого значения одного дескриптора.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>When overridden in a derived class, executes the code required to free the handle.</source>
          <target state="translated">При переопределении в производном классе выполняет код, необходимый для освобождения дескриптора.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если дескриптор освобождается успешно; в противном случае при катастрофическом сбое — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>In this case, it generates a <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.</source>
          <target state="translated">В таком случае создается управляемый помощник по отладке <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method is made.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> Метод гарантированно вызываться только один раз, при условии, что вы применяете механизмы правильную синхронизацию, чтобы убедиться, что только один вызов <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> или <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method will not be called if the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> property is <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> Не будет вызван метод, если <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> или <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> свойство <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Implement this method in your <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> derived classes to execute any code that is required to free the handle.</source>
          <target state="translated">Реализация этого метода в вашей <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> производными классами для выполнения любой код, необходимый для освобождения дескриптора.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Because one of the functions of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> is to guarantee prevention of resource leaks, the code in your implementation of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> must never fail.</source>
          <target state="translated">Так как одна из функций <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> — для обеспечения защиты от утечки ресурсов, код в реализации <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> никогда не должна закончиться откатом.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>The garbage collector calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress.</source>
          <target state="translated">Сборщик мусора вызывает <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> после обычные методы завершения будут выполнены для объектов, которые были собраны в то же время сборки мусора и ресурсы для вызова и что он не будет прерван во время его гарантии выполняется в данный момент.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</source>
          <target state="translated">Этот метод будет подготовлен как область с ограничением выполнения (CER) во время создания экземпляра (а также все методы в его статично определимый граф вызова).</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method.</source>
          <target state="translated">Несмотря на то, что это предотвращает прерывание прерывания потока, по-прежнему Будьте внимательны, чтобы не следует вводить все пути ошибок в переопределенном <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>In particular, apply the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute to any methods you call from <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>.</source>
          <target state="translated">В частности, применение <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> для методов вызова из атрибута <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>In most cases this code should be:</source>
          <target state="translated">В большинстве случаев этот код должен быть:</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Additionally, for simple cleanup (for example, calling the Win32 API <ph id="ph1">`CloseHandle`</ph> on a file handle) you can check the return value for the single platform invoke call.</source>
          <target state="translated">Кроме того, для простой очистки (например, вызов API-интерфейса Win32 <ph id="ph1">`CloseHandle`</ph> на дескриптор файла) можно проверить возвращаемое значение для одного вызова неуправляемого.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</source>
          <target state="translated">Для сложных очистки может иметь много логики программы и количестве вызовов, некоторые из которых может завершиться ошибкой.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>You must ensure that your program logic has fallback code for each of those cases.</source>
          <target state="translated">Необходимо убедиться, что логику программы имеет код отката для каждого из этих вариантов.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>If the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method returns <ph id="ph2">`false`</ph> for any reason, it generates a <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> возвращает <ph id="ph2">`false`</ph> по любой причине, он создает <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> управляемый помощник по отладке.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)">
          <source>The pre-existing handle to use.</source>
          <target state="translated">Ранее существующий дескриптор для использования.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)">
          <source>Sets the handle to the specified pre-existing handle.</source>
          <target state="translated">Определяет дескриптор для заданного ранее существующего дескриптора.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> обрабатывает метод только в том случае, если необходима поддержка ранее существующий дескриптор (например, если маркер возвращается в структуре) из-за взаимодействия инфраструктуры .NET Framework COM не поддерживает маршалинг в структуре.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>Marks a handle as invalid.</source>
          <target state="translated">Помечает дескриптор как недопустимый.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> method only when you know that your handle is invalid and you want to mark it as such.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> метод только в том случае, если известно, что маркер является недопустимым, и пометить его таким образом.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>Doing so does not change the value of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.handle&gt;</ph> field; it only marks the handle as invalid.</source>
          <target state="translated">При этом не изменяет значение <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.handle&gt;</ph> поле; он только Помечает дескриптор как недопустимый.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>The handle might then contain a potentially stale value.</source>
          <target state="translated">Дескриптор затем может содержать потенциально устаревшее значение.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>The effect of this call is that no attempt is made to free the resources.</source>
          <target state="translated">Результат этого вызова является не попытка освободить ресурсы.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>As with the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> only if you need to support a pre-existing handle.</source>
          <target state="translated">Как и в <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> используйте <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> только в том случае, если требуется обеспечить поддержку ранее существующий дескриптор.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>