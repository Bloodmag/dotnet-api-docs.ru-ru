<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6c4334868cde5130ed9da65bfda7e798c24b12cd" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480628" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет класс-оболочку для дескрипторов операционной системы. Этот класс должен наследоваться.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle> Класс обеспечивает критическое завершение для ресурсов дескрипторов, предотвращая дескрипторов сборщиком мусора преждевременное освобождение и их очистку операционной системой Windows для ссылки на непредусмотренные неуправляемые объекты.  
  
 Этот раздел включает следующие подразделы:  
  
 [Почему SafeHandle?](#Why)   
 [Что делает SafeHandle](#Does)   
 [Классы, производные от SafeHandle](#Derived)  
  
<a name="Why"></a>   
## <a name="why-safehandle"></a>Почему SafeHandle?  
 До .NET Framework версии 2.0, все операционной системы, дескрипторы могли инкапсулироваться только в <xref:System.IntPtr> управляемую оболочку объекта. При это удобный способ взаимодействия с машинным кодом, возможна утечка дескрипторов за асинхронных исключений, например, неожиданного прерывания потока или переполнения стека. Эти асинхронные исключения, являющиеся препятствием для очистки ресурсов операционной системы и может появляться в любом месте в вашем приложении.  
  
 Несмотря на то что для переопределения <xref:System.Object.Finalize%2A?displayProperty=nameWithType> метод разрешить очистки неуправляемых ресурсов, когда объект обрабатывается сборщиком мусора, в некоторых случаях, Завершаемые объекты можно удалять его сборщику мусора во время выполнения метода в вызова неуправляемого кода вызов. Если метод завершения освобождает дескриптор, переданный вызову неуправляемого кода, это может привести к повреждению дескриптора. Дескриптор также может быть освобожден, если метод блокирован во время вызова неуправляемого кода, например, при чтении файла.  
  
 Более важно то так как Windows агрессивно удаляет дескрипторы, дескриптор может быть перезапущен и указывать на другой ресурс, могут содержать конфиденциальные данные. Это известно как атака путем повторного использования и могут привести к повреждению данных и представлять угрозу безопасности.  
  
<a name="Does"></a>   
## <a name="what-safehandle-does"></a>Что делает SafeHandle  
 <xref:System.Runtime.InteropServices.SafeHandle> Класс упрощает несколько эти проблемы времени существования объекта и интегрируются с платформой вызова неуправляемого кода, чтобы не утечки ресурсов операционной системы. <xref:System.Runtime.InteropServices.SafeHandle> Класс устраняет проблемы времени существования объекта путем назначения и освобождения дескрипторов без прерываний. Он содержит критический метод завершения, который гарантирует, что дескриптор закрывается и обязательно выполняется во время Непредвиденная <xref:System.AppDomain> выгрузки, даже в случаях, когда вызова платформы считается в поврежденном состоянии.  
  
 Поскольку <xref:System.Runtime.InteropServices.SafeHandle> наследует от <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, все некритические методы завершения вызываются перед критическими. Методы завершения вызываются для объектов, которые больше не являются динамическими во время одного прохода сборщика мусора. Например <xref:System.IO.FileStream> объекта можно запустить обычный метод завершения, чтобы сбросить существующие буферизованные данные без риска утечки или повторного использования дескриптора. Это очень слабое упорядочение критических и некритических методов завершения не предназначен для общего использования. Он существует в первую очередь, чтобы помочь выполнить миграцию существующих библиотек, позволяя этим библиотекам использовать <xref:System.Runtime.InteropServices.SafeHandle> без изменения своей семантики. Кроме того, критический метод завершения и все его вызовы, например <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> метод, должен быть в области ограниченного выполнения. Это накладывает ограничения на какой код могут быть записаны в графе вызовов метода завершения.  
  
 Платформозависимый вызов операции автоматически увеличивает число ссылок для дескрипторов, инкапсулированных <xref:System.Runtime.InteropServices.SafeHandle> и уменьшения их после завершения. Это гарантирует, что дескриптор не будет перезапущен или было неожиданно закрыто.  
  
 Можно указать владельца базовый дескриптор при создании <xref:System.Runtime.InteropServices.SafeHandle> объектов путем указания значения для `ownsHandle` аргумент в <xref:System.Runtime.InteropServices.SafeHandle> конструктора класса. Определяет, является ли <xref:System.Runtime.InteropServices.SafeHandle> объекта будет освобождать этот дескриптор после удаления объекта.  Это полезно для дескрипторов с требованиями необычное время существования или для использования дескриптора, время существования которых управляется другим пользователем.  
  
<a name="Derived"></a>   
## <a name="classes-derived-from-safehandle"></a>Классы, производные от SafeHandle  
 <xref:System.Runtime.InteropServices.SafeHandle> является абстрактным классом-оболочкой для дескрипторов операционной системы. Наследовать от этого класса сложно. Вместо этого используйте производные классы в пространстве имен <xref:Microsoft.Win32.SafeHandles>, которые предоставляют безопасные дескрипторы для следующих элементов:  
  
-   Файлы ( <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> класса).  
  
-   Файлы распределения памяти ( <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> класса).  
  
-   Каналы ( <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> класса).  
  
-   Представления в памяти ( <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> класса).  
  
-   Конструкции шифрования ( <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, и <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> классы).  
  
-   Процессы ( <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> класса).  
  
-   Разделы реестра ( <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> класса).  
  
-   Дескрипторы ожидания ( <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> класса).  
  
   
  
## Examples  
 В следующем примере кода создается пользовательский безопасного дескриптора для дескриптора файла операционной системы, производные от <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>. Считывает байт из файла и отображает их шестнадцатеричных значений. Он также содержит средство проверки отказов, вызывает прерывание потока, но значение дескриптора освобождается.  При использовании <xref:System.IntPtr> для представления дескрипторов, дескриптор иногда утечки из-за асинхронного прерывания.  
  
 Вам потребуется в текстовый файл в той же папке скомпилированного приложения. Предположим, что имя приложения «HexViewer» и является использование командной строки:  
  
 `HexViewer <filename> -Fault`  
  
 При необходимости укажите `-Fault` чтобы намеренно попытаться инициировать утечку дескриптора путем прерывания потока в конкретном окне. Используйте средство Windows Perform.exe для отслеживания количества дескриптора во время добавления ошибок.  
  
 [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">для полного доверия для разработчиков производных классов. Этот член не может наследоваться частично доверенным кодом.</permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
    <block subset="none" type="overrides">
      <para>Чтобы создать класс, производный от <see cref="T:System.Runtime.InteropServices.SafeHandle" />, необходимо знать, как создать и освободить дескриптор операционной системы. Этот процесс отличается для различных дескриптор типов так, как использовать некоторые [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) работать другие используют более конкретные функции, такие как [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) или [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx). По этой причине необходимо создать производный класс <see cref="T:System.Runtime.InteropServices.SafeHandle" /> для каждого типа дескриптора операционной системы, которую необходимо включить в безопасном дескрипторе.  
  
 При наследовании от класса <see cref="T:System.Runtime.InteropServices.SafeHandle" /> необходимо переопределить следующие члены: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> и <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.  
  
 Должен предоставлять конструктор по умолчанию, который вызывает базовый конструктор со значением, которое представляет значение недопустимого дескриптора и <see cref="T:System.Boolean" /> значение, указывающее, принадлежит ли собственный дескриптор <see cref="T:System.Runtime.InteropServices.SafeHandle" /> и поэтому должна освобождаться при <see cref="T:System.Runtime.InteropServices.SafeHandle" /> был удален.</para>
    </block>
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">Значение недопустимого дескриптора (обычно 0 или -1).  Реализация <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> должна возвращать <see langword="true" /> для этого значения.</param>
        <param name="ownsHandle">
          Значение <see langword="true" />, если нужно надежно разрешить <see cref="T:System.Runtime.InteropServices.SafeHandle" /> освободить дескриптор на стадии завершения; в противном случае — значение <see langword="false" /> (не рекомендуется).</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Runtime.InteropServices.SafeHandle" /> с заданным значением недопустимого дескриптора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `ownsHandle` параметр `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> никогда не вызывается; таким образом, не рекомендуется использовать это значение параметра, как ваш код может вызвать утечку ресурсов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException">Производный класс находится в сборке без разрешения на доступ к неуправляемому коду.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">для полного доверия для разработчиков производных классов. Этот член не может наследоваться частично доверенным кодом.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Помечает дескриптор для освобождения самого дескриптора и соответствующих ресурсов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> или <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> метод позволяет освободить ресурсы. Это может происходить не сразу, если другие потоки используют один и тот же объект безопасный дескриптор, но произойдет, как только это не так. Несмотря на то, что большинство классов, использующие <xref:System.Runtime.InteropServices.SafeHandle> классу не требуется предоставлять метод завершения, иногда это необходимо (например, чтобы очистить буферы файлов или записать некоторые данные обратно в память). В этом случае класс может предоставить метод завершения, который обязательно выполняется перед <xref:System.Runtime.InteropServices.SafeHandle> запусков критический метод завершения.  
  
 Вызовите <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> или <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> метод при завершении с помощью <xref:System.Runtime.InteropServices.SafeHandle> объекта.  
  
> [!NOTE]
>  Всегда вызывайте метод <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> или <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> перед освобождением последней ссылки на <xref:System.Runtime.InteropServices.SafeHandle> объекта. В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.Runtime.InteropServices.SafeHandle> метод <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool&amp; success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousAddRef (ByRef success As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousAddRef(bool % success);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success">
          Значение <see langword="true" />, если счетчик ссылок был успешно увеличен; в противном случае — значение <see langword="false" />.</param>
        <summary>Вручную увеличивает счетчик ссылок для экземпляров <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Метод не позволяет освободить память, занятая дескриптор общеязыковая среда выполнения (что происходит, когда среда выполнения вызывает <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> метода). Можно использовать этот метод, чтобы вручную приращения счетчика ссылок на <xref:System.Runtime.InteropServices.SafeHandle> экземпляра. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Возвращает логическое значение, используя `ref` параметра (`success`), указывает ли счетчик ссылок был успешно увеличен. Это позволяет выполнить откат в случае сбоя в логике программы. Необходимо задать `success` для `false` перед вызовом <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Если `success` — `true`, избежать утечки ресурсов, сопоставляя вызов <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> с соответствующим вызовом <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.  
  
> [!CAUTION]
>  Этот метод предназначен для опытных пользователей и всегда следует использовать осторожно. Во избежание утечки ресурсов, всегда вызывайте этот метод внутри области ограниченного исполнения (CER), где прерывание потока не может прервать обработку.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr DangerousGetHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение поля <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />.</summary>
        <returns>Указатель <see langword="IntPtr" />, представляющий значение поля <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />. Если дескриптор был помечен как недопустимый с помощью <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, этот метод, тем не менее, возвращает исходное значение дескриптора, которое может быть устаревшим.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для извлечения значения дескриптора значения из экземпляра <xref:System.Runtime.InteropServices.SafeHandle> производного класса. Этот метод является необходимым для обратной совместимости, так как многие свойства в платформе .NET Framework возвращают `IntPtr` обработки типов. `IntPtr` Дескриптор типы являются типами специфический для платформы, используемых для представления указателя или дескриптора.  
  
> [!CAUTION]
>  С помощью <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> метод может представлять угрозу безопасности, поскольку, если дескриптор был помечен как недопустимый с <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> по-прежнему возвращает значение исходного, потенциально устаревшее дескриптора. Возвращенный дескриптор может быть также очищен в любой момент. В лучшем случае это означает, что дескриптор может неожиданно прекратить работу. В худшем случае если дескриптор или ресурс, который представляет дескриптор предоставляется ненадежного кода, это может привести к нарушению безопасности при повторном использовании или возвращении дескриптора. Например ненадежный вызывающий объект можно запрашивать данные на дескриптор просто возвращается и получать сведения для полностью несвязанного ресурса. В разделе <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> и <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> Дополнительные сведения об использовании <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousRelease ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousRelease();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вручную уменьшает счетчик ссылок для экземпляра <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> Метод является аналогом <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Вызов должен соответствовать всегда <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> метод с успешным вызовом <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.  
  
> [!CAUTION]
>  Этот метод предназначен для опытных пользователей и всегда следует использовать осторожно. Во избежание утечки ресурсов, всегда вызывайте этот метод внутри области ограниченного исполнения (CER), где прерывание потока не может прервать обработку. Так же, каким образом это несовпадающие <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> вызовов может вызвать утечку ресурсов, несовпадающие <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> вызовов может вызвать недопустимый дескриптор состояния становятся видимыми для других потоков. Не предоставляйте <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> или <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> вызовы ненадежный код.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Освобождение ресурсов, используемых классом <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые классом <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> или <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> метод позволяет освободить ресурсы. Это может происходить не сразу, если другие потоки используют один и тот же экземпляр безопасного дескриптора, но произойдет, как только это не так. Несмотря на то что наиболее классов, использующих <xref:System.Runtime.InteropServices.SafeHandle> не нужно предоставлять метод завершения, иногда это необходимо (например, чтобы очистить буферы файлов или записать некоторые данные обратно в память). В этом случае они предоставляют метод завершения, который обязательно выполняется перед <xref:System.Runtime.InteropServices.SafeHandle> запусков критический метод завершения.  
  
 Вызовите <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> или <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> метод при завершении с помощью <xref:System.Runtime.InteropServices.SafeHandle> объекта. <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> Метода <xref:System.Runtime.InteropServices.SafeHandle> объекта окажется в неработоспособном состоянии.  
  
> [!NOTE]
>  Всегда вызывайте метод <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> или <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> метод перед освобождением последней ссылки на <xref:System.Runtime.InteropServices.SafeHandle> объекта. В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.Runtime.InteropServices.SafeHandle> метод <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Значение <see langword="true" /> для обычной операции удаления и значение <see langword="false" /> для завершения работы с дескриптором.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые классом <see cref="T:System.Runtime.InteropServices.SafeHandle" />, определяя, нужно ли выполнять обычную операцию удаления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следует явно вызывать <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> метод с `disposing` равным `false`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SafeHandle ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, связанные с дескриптором.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> Деструктор является методом <xref:System.Runtime.InteropServices.SafeHandle> класса. Код приложения не должны напрямую вызывать этот метод.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет инкапсулируемый дескриптор.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не предоставляйте к этому дескриптору публично (то есть, вне производного класса).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, является ли дескриптор закрытым.</summary>
        <value>
          Значение <see langword="true" />, если дескриптор закрыт, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> Метод возвращает значение, указывающее, является ли <xref:System.Runtime.InteropServices.SafeHandle> дескриптор объекта больше не связана с машинным ресурсом. Это отличается от определения <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> свойство, которое вычисляет ли данным дескриптором всегда считается недействительным. <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> Возвращает `true` значение в следующих случаях:  
  
-   <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> Был вызван метод.  
  
-   <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> Метода или <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> метод был вызван и нет ссылок на <xref:System.Runtime.InteropServices.SafeHandle> объект в других потоках.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе возвращает значение, показывающее, допустимо ли значение дескриптора.</summary>
        <value>
          Значение <see langword="true" />, если значение дескриптора является неправильным; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производные классы должны реализовывать <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> свойство, чтобы общеязыковая среда выполнения может определить, требуется ли критическое завершение. Производные классы должны предоставлять реализацию, которая соответствует общему типу дескриптора, они поддерживают (0 или -1 является недопустимым). Эти классы могут быть дополнительными производными для конкретных типов безопасных дескрипторов.  
  
 В отличие от <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> свойство, которое сообщает ли <xref:System.Runtime.InteropServices.SafeHandle> завершения с помощью базовый дескриптор объекта <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> свойство вычисляет, является ли значение данного дескриптора всегда считается недействительным. Таким образом <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> свойство всегда возвращает то же значение для любого значения одного дескриптора.  
  
   
  
## Examples  
 В следующем примере проверяется, если файл был успешно открыт. Данный пример кода является частью большего примера, приведенного для <xref:System.Runtime.InteropServices.SafeHandle> класса.  
  
 [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе выполняет код, необходимый для освобождения дескриптора.</summary>
        <returns>
          Значение <see langword="true" />, если дескриптор освобождается успешно; в противном случае при катастрофическом сбое — значение <see langword="false" />. В таком случае создается управляемый помощник по отладке [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> Метод гарантированно вызываться только один раз и только если дескриптор действителен в соответствии с определением <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> свойство. Реализация этого метода в вашей <xref:System.Runtime.InteropServices.SafeHandle> производными классами для выполнения любой код, необходимый для освобождения дескриптора. Так как одна из функций <xref:System.Runtime.InteropServices.SafeHandle> — для обеспечения защиты от утечки ресурсов, код в реализации <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> никогда не должна закончиться откатом. Сборщик мусора вызывает <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> после выполнения обычные методы завершения для объектов, которые были собраны в то же время сборки мусора. Сборщик мусора гарантирует, что ресурсы для вызова этого метода и что метод не будет прерван во время его выполняется в данный момент. Этот метод будет подготовлен как область с ограничением выполнения (CER) во время создания экземпляра (а также все методы в его статично определимый граф вызова). Несмотря на то, что это предотвращает прерывание прерывания потока, по-прежнему Будьте внимательны, чтобы не следует вводить все пути ошибок в переопределенном <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> метод. В частности, применение <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> для методов вызова из атрибута <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>. В большинстве случаев этот код должен быть:  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 Кроме того, для простой очистки (например, вызов API-интерфейса Win32 `CloseHandle` на дескриптор файла) можно проверить возвращаемое значение для одного вызова неуправляемого. Для сложных очистки может иметь много логики программы и количестве вызовов, некоторые из которых может завершиться ошибкой. Необходимо убедиться, что логику программы имеет код отката для каждого из этих вариантов.  
  
 Если <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> возвращает `false` по любой причине, он создает [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) управляемый помощник по отладке.  Это помогает обнаруживать случаи, когда не попытку освободить ресурсы.  
  
   
  
## Examples  
 В следующем примере кода освобождает дескриптор и является частью большего примера, приведенного для <xref:System.Runtime.InteropServices.SafeHandle> класса.  
  
 [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Ранее существующий дескриптор для использования.</param>
        <summary>Определяет дескриптор для заданного ранее существующего дескриптора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> метод только в том случае, если необходима поддержка ранее существующий дескриптор (например, если маркер возвращается в структуре) из-за взаимодействия инфраструктуры .NET Framework COM не поддерживает маршалинг вывода дескрипторов в структуре.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Помечает дескриптор как больше не используемый.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> метод только в том случае, если известно, что маркер больше не ссылается на ресурс. При этом не изменяет значение <xref:System.Runtime.InteropServices.SafeHandle.handle> поле; только Помечает дескриптор как закрытую. Дескриптор затем может содержать потенциально устаревшее значение. Результат этого вызова является не попытка освободить ресурсы.  
  
 Как и в <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> используйте <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> только в том случае, если требуется обеспечить поддержку ранее существующий дескриптор.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>