<Type Name="AsyncResult" FullName="System.Runtime.Remoting.Messaging.AsyncResult">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d8dcfaa989a8bc907f295feb15394366e5aa96ac" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30490118" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class AsyncResult : IAsyncResult, System.Runtime.Remoting.Messaging.IMessageSink" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit AsyncResult extends System.Object implements class System.IAsyncResult, class System.Runtime.Remoting.Messaging.IMessageSink" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.Messaging.AsyncResult" />
  <TypeSignature Language="VB.NET" Value="Public Class AsyncResult&#xA;Implements IAsyncResult, IMessageSink" />
  <TypeSignature Language="C++ CLI" Value="public ref class AsyncResult : IAsyncResult, System::Runtime::Remoting::Messaging::IMessageSink" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Remoting.Messaging.IMessageSink</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Инкапсулирует результаты асинхронной операции на делегате.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult> Класс используется в сочетании с асинхронными вызовами методов с использованием делегатов. <xref:System.IAsyncResult> Возвращенные делегата `BeginInvoke` метод может быть приведен к <xref:System.Runtime.Remoting.Messaging.AsyncResult>. <xref:System.Runtime.Remoting.Messaging.AsyncResult> Имеет <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A> объекта свойство, которое содержит делегат, на которой был вызван асинхронный вызов.  
  
 Дополнительные сведения о `BeginInvoke` и асинхронные вызовы с использованием делегатов см [асинхронного программирования с использованием делегатов](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-using-delegates.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle%2A> свойства <xref:System.Threading.WaitHandle>и Ожидание асинхронного вызова для делегата. Объект <xref:System.Threading.WaitHandle> получает сигнал после завершения асинхронного вызова; его можно дождаться путем вызова метода <xref:System.Threading.WaitHandle.WaitOne%2A> .  
  
 Пример состоит из двух классов: класса, содержащего метод, который вызывается асинхронно, и класс, содержащий `Main` метод, который выполняет вызов.  
  
 Дополнительные сведения и примеры асинхронного вызова методов с помощью делегатов см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#3](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/waithandle.cpp#3)]
[!code-csharp[AsyncDelegateExamples#3](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/waithandle.cs#3)]
[!code-vb[AsyncDelegateExamples#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/WaitHandle.vb#3)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AsyncDelegate">
      <MemberSignature Language="C#" Value="public virtual object AsyncDelegate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AsyncDelegate As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ AsyncDelegate { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект делегата, для которого был вызван асинхронный вызов.</summary>
        <value>Объект делегата, для которого был вызван асинхронный вызов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A> Свойство может быть приведен к фактическому классу пользовательский делегат.  
  
 Например, если тип делегата, который был использован для асинхронного вызова `MyDelegate`, делегат, который возвращается этим свойством, которые должны быть приведены к `MyDelegate`. Метод обратного вызова может затем вызвать делегат `EndInvoke` метода с правильной подписью, чтобы получить результаты асинхронного вызова метода.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A> свойство для получения делегата, который был использован для асинхронного вызова для вызова `EndInvoke`. Пример приведения <xref:System.IAsyncResult>, который является единственным параметром метода обратного вызова, в <xref:System.Runtime.Remoting.Messaging.AsyncResult> объекта.  
  
 Пример состоит из двух классов: класса, содержащего метод, который вызывается асинхронно, и класс, содержащий `Main` метод, который выполняет вызов.  
  
 Дополнительные сведения о механизме работы данного примера обратного вызова, а также дополнительные примеры асинхронного вызова методов с помощью делегатов см [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#5](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/callback.cpp#5)]
[!code-csharp[AsyncDelegateExamples#5](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/callback.cs#5)]
[!code-vb[AsyncDelegateExamples#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/callback.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncProcessMessage">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(class System.Runtime.Remoting.Messaging.IMessage msg, class System.Runtime.Remoting.Messaging.IMessageSink replySink) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AsyncProcessMessage (msg As IMessage, replySink As IMessageSink) As IMessageCtrl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::Messaging::IMessageCtrl ^ AsyncProcessMessage(System::Runtime::Remoting::Messaging::IMessage ^ msg, System::Runtime::Remoting::Messaging::IMessageSink ^ replySink);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Remoting.Messaging.IMessageSink.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageCtrl</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMessage" />
        <Parameter Name="replySink" Type="System.Runtime.Remoting.Messaging.IMessageSink" />
      </Parameters>
      <Docs>
        <param name="msg">Интерфейс запроса <see cref="T:System.Runtime.Remoting.Messaging.IMessage" />.</param>
        <param name="replySink">Интерфейс ответа <see cref="T:System.Runtime.Remoting.Messaging.IMessageSink" />.</param>
        <summary>Реализует интерфейс <see cref="T:System.Runtime.Remoting.Messaging.IMessageSink" />.</summary>
        <returns>Возвращаемое значение отсутствует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncProcessMessage%2A> Метод <xref:System.Runtime.Remoting.Messaging.IMessageSink> интерфейса не имеет отношения к <xref:System.Runtime.Remoting.Messaging.AsyncResult> класса. Реализация по <xref:System.Runtime.Remoting.Messaging.AsyncResult> вызывает <xref:System.NotSupportedException>. Вместо этого получите <xref:System.Runtime.Remoting.Messaging.AsyncResult> путем приведения <xref:System.IAsyncResult> интерфейса, возвращаемого методом асинхронного вызова, сделанного с помощью делегата.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public virtual object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект, предоставленный как последний параметр вызова метода <see langword="BeginInvoke" />.</summary>
        <value>Объект, предоставленный как последний параметр вызова метода <see langword="BeginInvoke" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о `BeginInvoke` метода, в разделе [асинхронного программирования с использованием делегатов](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-using-delegates.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncState%2A> свойство используется для передачи сведений в метод обратного вызова. Последний параметр `BeginInvoke` вызов метода — это строка форматирования, используемую методом обратного вызова для форматирования выходного сообщения.  
  
 Пример состоит из двух классов: класса, содержащего метод, который вызывается асинхронно, и класс, содержащий `Main` метод, который выполняет вызов.  
  
 Дополнительные сведения о механизме работы данного примера обратного вызова, а также дополнительные примеры асинхронного вызова методов с помощью делегатов см [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#5](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/callback.cpp#5)]
[!code-csharp[AsyncDelegateExamples#5](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/callback.cs#5)]
[!code-vb[AsyncDelegateExamples#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/callback.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncWaitHandle">
      <MemberSignature Language="C#" Value="public virtual System.Threading.WaitHandle AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AsyncWaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Threading::WaitHandle ^ AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:System.Threading.WaitHandle" />, который инкапсулирует дескрипторы синхронизации Win32 и разрешает реализацию различных схем синхронизации.</summary>
        <value>
          <see cref="T:System.Threading.WaitHandle" />, который инкапсулирует дескрипторы синхронизации Win32 и разрешает реализацию различных схем синхронизации.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.WaitHandle> Возвращает этот метод автоматически получает сигнал после завершения асинхронной операции.  
  
 Дескриптор ожидания не закрывается автоматически при вызове `EndInvoke` в делегате, использованном для асинхронного вызова метода. Если удалить все ссылки на дескриптор ожидания, системные ресурсы будут освобождены при удалении дескриптора ожидания сборщиком мусора. Чтобы освободить системные ресурсы сразу после завершения использования дескриптора ожидания, вызовите <xref:System.Threading.WaitHandle.Close%2A?displayProperty=nameWithType> метод. Сборщик мусора работает более эффективно высвобождаемые объекты явно закрыт или удален.  
  
> [!CAUTION]
>  <xref:System.Threading.WaitHandle> Содержащихся в <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle%2A> свойство может использоваться для блокирует текущий поток до завершения асинхронного вызова. Однако <xref:System.Threading.WaitHandle> будет игнорировать <xref:System.AsyncCallback>, если он был задан во время `BeginInvoke` вызова. Таким образом, ситуация может возникнуть, когда приложение завершает работу перед <xref:System.AsyncCallback> завершения выполнения, даже если <xref:System.Threading.WaitHandle> используется блок до завершения асинхронного вызова. Пример такой ситуации, см. пример для <xref:System.Runtime.Remoting.Messaging.AsyncResult> класса и удалите <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> инструкции.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle%2A> свойства <xref:System.Threading.WaitHandle>и Ожидание асинхронного вызова для делегата. Объект <xref:System.Threading.WaitHandle> получает сигнал после завершения асинхронного вызова; его можно дождаться путем вызова метода <xref:System.Threading.WaitHandle.WaitOne%2A> .  
  
 Пример состоит из двух классов: класса, содержащего метод, который вызывается асинхронно, и класс, содержащий `Main` метод, который выполняет вызов.  
  
 Дополнительные сведения и примеры асинхронного вызова методов с помощью делегатов см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#3](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/waithandle.cpp#3)]
[!code-csharp[AsyncDelegateExamples#3](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/waithandle.cs#3)]
[!code-vb[AsyncDelegateExamples#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/WaitHandle.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.WaitHandle" />
      </Docs>
    </Member>
    <Member MemberName="CompletedSynchronously">
      <MemberSignature Language="C#" Value="public virtual bool CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CompletedSynchronously As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CompletedSynchronously { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, завершен ли вызов <see langword="BeginInvoke" /> синхронно.</summary>
        <value>
          <see langword="true" />, если вызов <see langword="BeginInvoke" /> завершен синхронно; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если обнаруживается, `BeginInvoke` вызов завершен синхронно в <xref:System.AsyncCallback> делегата, вполне вероятно, что поток, который вызывал BeginInvoke является текущего потока. Большинство поставщиков <xref:System.IAsyncResult> интерфейс не будут использовать данную возможность и возвратят значение по умолчанию `false`.  
  
 Текущая реализация <xref:System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously%2A> всегда возвращает `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInvokeCalled">
      <MemberSignature Language="C#" Value="public bool EndInvokeCalled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndInvokeCalled" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.EndInvokeCalled" />
      <MemberSignature Language="VB.NET" Value="Public Property EndInvokeCalled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndInvokeCalled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, вызван ли <see langword="EndInvoke" /> в текущем <see cref="T:System.Runtime.Remoting.Messaging.AsyncResult" />.</summary>
        <value>
          <see langword="true" />, если <see langword="EndInvoke" /> вызван в текущем <see cref="T:System.Runtime.Remoting.Messaging.AsyncResult" />; в противном случае — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReplyMessage">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.Messaging.IMessage GetReplyMessage ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessage GetReplyMessage() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReplyMessage () As IMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::Messaging::IMessage ^ GetReplyMessage();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает сообщение ответа на асинхронный вызов.</summary>
        <returns>Сообщение удаленного взаимодействие, которое должно представлять ответ на вызов метода удаленного объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A> Метод может возвращать объект после <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A> вызывается метод. <xref:System.Runtime.Remoting.Messaging.IMessage> Возвращаемое значение может быть приведено к <xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage>.  
  
 Тем не менее необязательно для прямого вызова любого из этих методов. Они предназначены для использования инфраструктурой удаленного взаимодействия платформы .NET Framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public virtual bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCompleted { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, завершил ли сервер вызов.</summary>
        <value>
          <see langword="true" /> после завершения вызова сервером; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сервер не должен использовать все предоставленные клиентом ресурсы помимо обусловленных разделением семантики после установки <xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A> свойства `true`. Таким образом, является безопасным для клиента, чтобы удалить ресурсы после <xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A> возвращает `true`.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.IAsyncResult.IsCompleted%2A> свойство <xref:System.Runtime.Remoting.Messaging.AsyncResult> возвращенных `BeginInvoke` для обнаружения после завершения асинхронного вызова. Это можно делать, когда асинхронный вызов выполнен из потока, обслуживающего пользовательский интерфейс. Опрос завершения позволяет вызывающему потоку продолжить выполнение при асинхронном вызове для потока <xref:System.Threading.ThreadPool> .  
  
 Пример состоит из двух классов: класса, содержащего метод, который вызывается асинхронно, и класс, содержащий `Main` метод, который выполняет вызов.  
  
 Дополнительные сведения и примеры асинхронного вызова методов с помощью делегатов см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#4](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/polling.cpp#4)]
[!code-csharp[AsyncDelegateExamples#4](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/polling.cs#4)]
[!code-vb[AsyncDelegateExamples#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/polling.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextSink">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.Messaging.IMessageSink NextSink { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Remoting.Messaging.IMessageSink NextSink" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.NextSink" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextSink As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Remoting::Messaging::IMessageSink ^ NextSink { System::Runtime::Remoting::Messaging::IMessageSink ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.Remoting.Messaging.IMessageSink.NextSink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает следующий приемник сообщений в цепочке приемников.</summary>
        <value>Интерфейс <see cref="T:System.Runtime.Remoting.Messaging.IMessageSink" />, представляющий следующий приемник сообщений в цепочке приемников.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущая реализация <xref:System.Runtime.Remoting.Messaging.AsyncResult.NextSink%2A> возвращает `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMessageCtrl">
      <MemberSignature Language="C#" Value="public virtual void SetMessageCtrl (System.Runtime.Remoting.Messaging.IMessageCtrl mc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetMessageCtrl(class System.Runtime.Remoting.Messaging.IMessageCtrl mc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.SetMessageCtrl(System.Runtime.Remoting.Messaging.IMessageCtrl)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetMessageCtrl (mc As IMessageCtrl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetMessageCtrl(System::Runtime::Remoting::Messaging::IMessageCtrl ^ mc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mc" Type="System.Runtime.Remoting.Messaging.IMessageCtrl" />
      </Parameters>
      <Docs>
        <param name="mc">
          <see cref="T:System.Runtime.Remoting.Messaging.IMessageCtrl" /> для текущего удаленного вызова метода.</param>
        <summary>Задает <see cref="T:System.Runtime.Remoting.Messaging.IMessageCtrl" /> для текущего вызова удаленного метода, что позволяет управлять асинхронными сообщениями после их отправки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо вызвать <xref:System.Runtime.Remoting.Messaging.AsyncResult.SetMessageCtrl%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncProcessMessage">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(class System.Runtime.Remoting.Messaging.IMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SyncProcessMessage (msg As IMessage) As IMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::Messaging::IMessage ^ SyncProcessMessage(System::Runtime::Remoting::Messaging::IMessage ^ msg);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Remoting.Messaging.IMessageSink.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Сообщение ответа на вызов метода удаленного объекта.</param>
        <summary>Синхронно обрабатывает сообщение ответа, возвращенное вызовом метода удаленного объекта.</summary>
        <returns>Возвращает <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A> Реализует метод <xref:System.Runtime.Remoting.Messaging.IMessageSink> интерфейса. Необходимо вызывать этот метод непосредственно. Он предназначен для использования инфраструктурой удаленного взаимодействия платформы .NET Framework.  
  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A> вызывает код потребителя <xref:System.AsyncCallback> делегата. Кроме того, задается <xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage> экземпляр, возвращаемый <xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A> метод. Если `msg` параметр имеет тип <xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage>, возвращается тот же объект <xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A>. В противном случае возвращается ответное сообщение, содержащее исключение удаленного доступа.  
  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A> также изменяет значения, возвращенного <xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A> свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>