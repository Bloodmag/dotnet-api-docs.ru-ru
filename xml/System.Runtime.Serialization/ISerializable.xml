<Type Name="ISerializable" FullName="System.Runtime.Serialization.ISerializable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="93cba3467c895b67f4a77cea665837530a382f08" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36629193" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="VB.NET" Value="Public Interface ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public interface class ISerializable" />
  <TypeSignature Language="F#" Value="type ISerializable = interface" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Serialization.Formatters</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Позволяет объекту управлять его собственной сериализацией и десериализацией.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Любой класс, который может быть сериализован должен быть помечен атрибутом <xref:System.SerializableAttribute>. Если класс должен управлять своим процессом сериализации, он может реализовывать <xref:System.Runtime.Serialization.ISerializable> интерфейса. <xref:System.Runtime.Serialization.Formatter> Вызовы <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A> во время сериализации и заполняет предоставленный <xref:System.Runtime.Serialization.SerializationInfo> со всеми данными, необходимыми для представления объекта. <xref:System.Runtime.Serialization.Formatter> Создает <xref:System.Runtime.Serialization.SerializationInfo> с типом объекта в графе. Объекты, которые необходимо отправить прокси для самих может использовать <xref:System.Runtime.Serialization.SerializationInfo.FullTypeName%2A> и <xref:System.Runtime.Serialization.SerializationInfo.AssemblyName%2A> методы <xref:System.Runtime.Serialization.SerializationInfo> для изменения передаваемых данных.  
  
 В случае наследования класса сериализуемыми класс, производный от базового класса, который реализует <xref:System.Runtime.Serialization.ISerializable>. В этом случае производный класс должен вызвать реализацию базового класса <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A> внутри своей реализации <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A>. В противном случае данные из базового класса не будут сериализованы.  
  
 <xref:System.Runtime.Serialization.ISerializable> Один интерфейс подразумевает наличие конструктор с помощью конструктора подписи (<xref:System.Runtime.Serialization.SerializationInfo> сведения <xref:System.Runtime.Serialization.StreamingContext> контекста). Во время десериализации текущий конструктор вызывается только после данных в <xref:System.Runtime.Serialization.SerializationInfo> десериализован модулем форматирования. Как правило этот конструктор должен быть защищен, если класс не запечатан.  
  
 Порядок десериализации объектов не гарантируется. Например если один тип ссылается на тип, который не был десериализован, возникнет исключение. При создании типов, которые имеют такие зависимости проблему путем реализации можно обойти `IDeserializationCallback` интерфейс и `OnDeserialization` метод.  
  
 Архитектура сериализации обрабатывает типы объектов, которые расширяют <xref:System.MarshalByRefObject> таким же, как типы, расширяющие <xref:System.Object>. Эти типы могут быть помечены с помощью <xref:System.SerializableAttribute> и реализовать <xref:System.Runtime.Serialization.ISerializable> интерфейс как любой другой тип объекта. Их состояния объекта будет захвачен и сохранены в потоке.  
  
 Если эти типы используются через <xref:System.Runtime.Remoting>, инфраструктура удаленного взаимодействия предоставляет суррогат, который выгружает типичные сериализации и вместо этого сериализует прокси <xref:System.MarshalByRefObject>. Суррогат — это вспомогательный класс, который знает, как выполнять сериализацию и десериализацию объектов определенного типа. Прокси-сервер, невидимой для пользователя в большинстве случаев будет иметь тип <xref:System.Runtime.Remoting.ObjRef>.  
  
 В рамках общего конструктивного шаблона не принято помечать класс с помощью сериализуемого атрибута и расширять <xref:System.MarshalByRefObject>. Разработчикам следует учитывать возможные сценарии сериализации и удаленного взаимодействия при объединении этих двух характеристик. Является одним из примеров, она может быть применимо с <xref:System.IO.MemoryStream>. Хотя базовый класс для <xref:System.IO.MemoryStream> (<xref:System.IO.Stream>) расширяет из <xref:System.MarshalByRefObject>, можно записать состояние <xref:System.IO.MemoryStream> и восстановить ее на будут. Таким образом, может быть может применяться для сериализации состояния этого потока в базу данных и восстановить в более поздний момент времени. Тем не менее при использовании с помощью удаленного взаимодействия, этот тип объекта будет осуществляться.  
  
 Дополнительные сведения о сериализации классов, расширяющих <xref:System.MarshalByRefObject>, в разделе <xref:System.Runtime.Remoting.Messaging.RemotingSurrogateSelector>. Дополнительные сведения о реализации <xref:System.Runtime.Serialization.ISerializable>, в разделе [сериализации пользовательский](~/docs/standard/serialization/custom-serialization.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Runtime.Serialization.ISerializable> интерфейс, чтобы определить поведение пользовательской сериализации для класса.  
  
 [!code-cpp[ISerializable Interface Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/ISerializable Interface Example/CPP/iobjectreference.cpp#1)]
 [!code-csharp[ISerializable Interface Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/ISerializable Interface Example/CS/iobjectreference.cs#1)]
 [!code-vb[ISerializable Interface Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ISerializable Interface Example/VB/iobjectreference.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Реализуйте этот интерфейс позволяет объекту участвовать в сериализации и десериализации.</para>
    </block>
    <altmember cref="T:System.Runtime.Remoting.Messaging.RemotingSurrogateSelector" />
  </Docs>
  <Members>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="iSerializable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Formatters</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> для заполнения данными.</param>
        <param name="context">Конечный объект (см. <see cref="T:System.Runtime.Serialization.StreamingContext" />) для этой сериализации.</param>
        <summary>Заполняет объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> данными, необходимыми для сериализации целевого объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все объекты, которые включены в <xref:System.Runtime.Serialization.SerializationInfo> , автоматически отслеживаются и сериализации модулем форматирования.  
  
 Код, который вызывает <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A> требует <xref:System.Security.Permissions.SecurityPermission> для предоставления служб сериализации. Связанное перечисление: <xref:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Не гарантируется, что этот метод будет вызываться только один раз для экземпляра объекта во время сериализации. Таким образом метод должен быть реализован таким образом, что его поведение будет таким же, независимо от того, сколько раз он вызывается.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A> метод, чтобы задать альтернативные значения для сериализованного объекта. Код использует <xref:System.Runtime.Serialization.SerializationInfo.AddValue%2A> метод <xref:System.Runtime.Serialization.SerializationInfo> класса для хранения альтернативные значения, при сериализации объекта. И наоборот, если конструктор `Person` класса вызывается во время десериализации, alternatve значения можно получить с помощью <xref:System.Runtime.Serialization.SerializationInfo.GetValue%2A> метод и маршрутизацию полей объекта.  
  
 [!code-csharp[ISerializable_GetObjectData#0](~/samples/snippets/csharp/VS_Snippets_Remoting/ISerializable_GetObjectData/cs/ISerializable_GetObjectData.cs#0)]
 [!code-vb[ISerializable_GetObjectData#0](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ISerializable_GetObjectData/vb/ISerializable_GetObjectData.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
      </Docs>
    </Member>
  </Members>
</Type>