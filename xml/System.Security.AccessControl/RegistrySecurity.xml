<Type Name="RegistrySecurity" FullName="System.Security.AccessControl.RegistrySecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e52f3b248c05ba047d59c24d923733a12bfa7839" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30490738" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RegistrySecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.RegistrySecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistrySecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistrySecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Обеспечивает безопасность управления доступом Windows для раздела реестра. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Security.AccessControl.RegistrySecurity> объекта указывает права доступа к ключу реестра, а также указывает как попытки доступа подлежат аудиту. Права доступа к разделу реестра представляют собой правила, с каждым правилом доступа, представленного <xref:System.Security.AccessControl.RegistryAccessRule> объекта. Каждое правило аудита представленного <xref:System.Security.AccessControl.RegistryAuditRule> объекта.  
  
 Это отражает базовая система безопасности Windows, в которой каждый защищаемый объект имеет максимум один список управления доступом (DACL), которая управляет доступом к защищенному объекту, а не более одной системы управления доступом (SACL), указывающее, какой доступ попытки подлежат аудиту. Список DACL и SACL упорядоченные списки записи управления доступом (ACE), которые определяют правила доступа и аудита для пользователей и групп. Объект <xref:System.Security.AccessControl.RegistryAccessRule> или <xref:System.Security.AccessControl.RegistryAuditRule> объект может представлять более одного элемента управления ДОСТУПОМ.  
  
> [!NOTE]
>  Безопасность управления доступом Windows может применяться только к разделам реестра. Он не может применяться к пар отдельных ключей и значений, хранимых в ключе.  
  
 <xref:System.Security.AccessControl.RegistrySecurity>, <xref:System.Security.AccessControl.RegistryAccessRule>, И <xref:System.Security.AccessControl.RegistryAuditRule> классы скрыть детали реализации, списки управления доступом и элементы управления доступом. Они дают возможность игнорировать семнадцать разных типах элементов управления ДОСТУПОМ и сложных процедурах наследования и распространения прав доступа. Эти объекты также позволяют предотвратить следующих распространенных ошибок управления доступом:  
  
-   Создание дескриптора безопасности с нулевой DACL. Пустая ссылка на список DACL позволяет любому пользователю добавить правила доступа к объекту, потенциально создания атаки типа "отказ в обслуживании". Новый <xref:System.Security.AccessControl.RegistrySecurity> объект всегда начинается с пустым DACL запрещает любой доступ для всех пользователей.  
  
-   Изменение канонического порядка элементов ACE. Если список управления ДОСТУПОМ в список DACL не содержится в каноническом порядке, пользователи могут случайно получить доступ к защищенному объекту. Например запрещающие права доступа всегда должны предшествовать правам разрешенного доступа. <xref:System.Security.AccessControl.RegistrySecurity> объекты внутренне сохранить правильный порядок.  
  
-   Управление флагами дескрипторов безопасности, которые должны быть под управлением диспетчера ресурсов только.  
  
-   Создание недопустимых сочетаний флагов элементов управления ДОСТУПОМ.  
  
-   Управление (ACE). Наследование и распространение обрабатываются диспетчером ресурсов в ответ на изменения, внесенные в правила доступа и аудита.  
  
-   Вставка смысла элементов управления доступом в списки управления доступом.  
  
 Только возможности, не поддерживается для объектов безопасности .NET, опасные операции, которые следует избегать большинством разработчиками приложений, таких как следующие:  
  
-   Низкоуровневые задачи, которые обычно выполняются диспетчером ресурсов.  
  
-   Добавление или удаление записей управления доступом способами, которые не поддерживают канонического порядка.  
  
 Чтобы изменить безопасность управления доступом Windows для раздела реестра, используйте <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> метода <xref:System.Security.AccessControl.RegistrySecurity> объекта. Изменение объекта безопасности, добавляя и удаляя правила, а затем используйте <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> метод присоединяет ее повторно.  
  
> [!IMPORTANT]
>  Изменения, внесенные в <xref:System.Security.AccessControl.RegistrySecurity> объекта не влияют на уровни доступа раздела реестра, пока не будет вызван <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> метод назначения объекта измененного безопасности для раздела реестра.  
  
 Чтобы скопировать безопасность управления доступом из одного раздела реестра в другой, используйте <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> метод, чтобы получить <xref:System.Security.AccessControl.RegistrySecurity> объект, представляющий правил доступа и аудита для первого раздела реестра, а затем используйте <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> метод назначения этих правил для второго раздела реестра. Можно также назначить правила для второй раздел реестра <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=nameWithType> или <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=nameWithType> метода, принимающего <xref:System.Security.AccessControl.RegistrySecurity> параметра объекта.  
  
 Пользователи с инвестиции в языке определения дескриптора безопасности (SDDL) могут использовать <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> метод, чтобы задать правила доступа для раздела реестра и <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> метод, чтобы получить строку, представляющую правила доступа в формате SDDL. Не рекомендуется для разработки новых приложений.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. В первом примере показано объединение совместимых правил при добавлении и удалении, а во втором демонстрируется влияние флаги наследования и распространения на добавление и удаление правил.  
  
 Пример 1  
  
 В следующем примере кода показан как <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> метода выполняется удаление прав из совместимого правила и как <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> метод объединяет права совместимые правилам.  
  
 В примере создается <xref:System.Security.AccessControl.RegistrySecurity> объекта и добавляет правило, текущий пользователь <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> права. Затем пример создает правило, которое предоставляет пользователю <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>с же наследования и распространения права, что первое правило, а также используется <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> метод, чтобы удалить это новое правило из <xref:System.Security.AccessControl.RegistrySecurity> объекта. <xref:System.Security.AccessControl.RegistryRights.SetValue> составные части является <xref:System.Security.AccessControl.RegistryRights.ReadKey>, поэтому он удаляется из совместимого правила. Правила в <xref:System.Security.AccessControl.RegistrySecurity> отображаются объект, показывающий оставшиеся составными элементами <xref:System.Security.AccessControl.RegistryRights.ReadKey>.  
  
 Пример кода вызывает <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> метод для слияния <xref:System.Security.AccessControl.RegistryRights.SetValue> правой обратно в правило в <xref:System.Security.AccessControl.RegistrySecurity> объекта.  
  
> [!NOTE]
>  В этом примере не присоединяется объект безопасности <xref:Microsoft.Win32.RegistryKey> объекта. Во втором примере в этом разделе Присоединяет объект безопасности и поэтому примеров <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> и <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 Пример 2  
  
 В следующем примере кода демонстрируется правила доступа с наследования и распространения. В примере создается <xref:System.Security.AccessControl.RegistrySecurity> объекта, создает и добавляет два правила, имеющие <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> флаг. Первое правило имеет не Флаги распространения, а второй имеет <xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit> и <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>.  
  
 Программа отображает правила в <xref:System.Security.AccessControl.RegistrySecurity> объекта, а затем используется <xref:System.Security.AccessControl.RegistrySecurity> объекта, чтобы создать подраздел. Программа создает дочерний подраздел и раздел внукам, а затем выводятся параметры безопасности для каждого из этих подразделов. Наконец программа удаляет ключи теста.  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistrySecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistrySecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Security.AccessControl.RegistrySecurity" /> со значениями по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Новый <xref:System.Security.AccessControl.RegistrySecurity> объект всегда начинается со списком пустой доступом на уровне пользователей (DACL), который запрещает любой доступ для всех пользователей.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение перечисления, используемое классом <see cref="T:System.Security.AccessControl.RegistrySecurity" /> для обозначения прав доступа.</summary>
        <value>Объект <see cref="T:System.Type" />, представляющий перечисление <see cref="T:System.Security.AccessControl.RegistryRights" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Security.AccessControl.ObjectSecurity> класса переопределение <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> свойства и возвращаемые типа, они используют для представления права доступа. При работе с массивами или коллекциями, содержащими объекты безопасности нескольких типов, используйте это свойство для определения типа перечисления подходит для использования с каждым объектом безопасности.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">Объект <see cref="T:System.Security.Principal.IdentityReference" />, идентифицирующий пользователя или группу, к которым относится данное правило.</param>
        <param name="accessMask">Побитовое сочетание значений <see cref="T:System.Security.AccessControl.RegistryRights" />, определяющее разрешаемые или запрещаемые права доступа, приведенное к целочисленному типу.</param>
        <param name="isInherited">Логическое значение, которое определяет, наследуется ли правило.</param>
        <param name="inheritanceFlags">Побитовое сочетание значений <see cref="T:System.Security.AccessControl.InheritanceFlags" />, определяющее порядок наследования правила подразделами.</param>
        <param name="propagationFlags">Побитовое сочетание значений <see cref="T:System.Security.AccessControl.PropagationFlags" />, изменяющее порядок наследования правила подразделами. Не имеет смысла, если свойство <c>inheritanceFlags</c> имеет значение <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="type">Одно из значений <see cref="T:System.Security.AccessControl.AccessControlType" />, определяющее тип правила ("разрешить" или "запретить").</param>
        <summary>Создает новое правило управления доступом для указанного пользователя с указанными правами, типом управления доступом и флагами.</summary>
        <returns>Объект <see cref="T:System.Security.AccessControl.RegistryAccessRule" />, представляющий указанные права для указанного пользователя.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для создания правила управления доступом рекомендуется использовать конструкторы <xref:System.Security.AccessControl.RegistryAccessRule> класса.  
  
> [!NOTE]
>  Несмотря на то, что можно указать <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> флаг, при этом нет смысла. В целях управления доступом пары "имя значение" в подразделах не являются отдельными объектами. Права доступа к пары имя значение, определяются правами для подраздела. Кроме того поскольку все подразделы представляют собой контейнеры (то есть они могут содержать другие подразделы), не затрагиваются управлением <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> флаг. Наконец, указав <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> флаг ненужной усложняет обслуживания правил, так как он мешает обычный сочетание совместимых правил.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Параметр <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> или <paramref name="type" /> имеет недопустимое значение.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="identityReference" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 <paramref name="accessMask" /> равен нулю.</exception>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="identityReference" /> не относится к типу <see cref="T:System.Security.Principal.SecurityIdentifier" /> и к такому типу, как <see cref="T:System.Security.Principal.NTAccount" />, который можно преобразовать в тип <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип, используемый классом <see cref="T:System.Security.AccessControl.RegistrySecurity" /> для обозначения правил доступа.</summary>
        <value>Объект <see cref="T:System.Type" />, представляющий класс <see cref="T:System.Security.AccessControl.RegistryAccessRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Security.AccessControl.ObjectSecurity> класса переопределение <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> свойства и возвращаемые типа, они используют для представления правила доступа. При работе с массивами или коллекциями, содержащими объекты безопасности нескольких типов, используйте это свойство для определения тип правила доступа подходит для использования с каждым объектом безопасности.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Добавляемое правило управления доступом.</param>
        <summary>Выполняет поиск подходящего элемента управления доступом, с которым можно объединить новое правило. Если поиск не дал результатов, добавляется новое правило.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> Метод осуществляет поиск правил с тем же пользователем или группой, а также же <xref:System.Security.AccessControl.AccessControlType> как `rule`. Если ничего не найдено, `rule` добавляется. Если правило сопоставления обнаруживается, права в `rule` объединяются с существующим правилом.  
  
 Правила нельзя объединять, если они имеют различных флагов. Например, если пользователь может доступ на чтение с флагами отсутствия наследования и <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> используется для добавления правила, предоставляя доступ на запись пользователя с помощью наследования для подразделов (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), не удается выполнить слияние двух правил.  
  
 Правила с различными <xref:System.Security.AccessControl.AccessControlType> значения никогда не объединяются.  
  
 Правила выражают права наиболее экономичным способом. Например, если у пользователя есть <xref:System.Security.AccessControl.RegistryRights.QueryValues>, <xref:System.Security.AccessControl.RegistryRights.Notify> и <xref:System.Security.AccessControl.RegistryRights.ReadPermissions> права и добавьте правило, что позволяет <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> прав, пользователь имеет все составные части <xref:System.Security.AccessControl.RegistryRights.ReadKey> права. Если вы выполняете запрос прав пользователя, вы увидите правила, содержащее <xref:System.Security.AccessControl.RegistryRights.ReadKey> права. Аналогичным образом при удалении <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> правами других составляющих <xref:System.Security.AccessControl.RegistryRights.ReadKey> права появится снова.  
  
   
  
## Examples  
 В следующем примере кода создается реестра правила доступа и добавляет их в <xref:System.Security.AccessControl.RegistrySecurity> объекта, отображаются как правила, разрешающие и запрещающие права остаются отдельные при совместимые правила одной и той же kind объединяются.  
  
> [!NOTE]
>  В этом примере не присоединяется объект безопасности <xref:Microsoft.Win32.RegistryKey> объекта. Примеры, в которых присоединить объекты безопасности можно найти в <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> и <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 Пример кода, демонстрирующий флаги наследования и распространения можно найти в <xref:System.Security.AccessControl.RegistryAccessRule> класса.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="rule" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Добавляемое правило аудита. Поиск ведется по имени пользователя, указанному в этом правиле.</param>
        <summary>Осуществляет поиск правила аудита, с которым можно объединить новое правило. Если поиск не дал результатов, добавляется новое правило.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> Метод ищет правила с одного пользователя или группу в качестве `rule`. Если ничего не найдено, `rule` добавляется. Если правило сопоставления обнаруживается, что флаги в `rule` объединяются в существующее правило.  
  
 Правила нельзя объединять, если они имеют различных флагов. Например, если Сбой попытки записи в раздел подлежат аудиту для конкретного пользователя, не флаги наследования, и <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> используется для добавления правила, указав, что неудачных попыток входа, чтобы изменить разрешения, проверяемые для одного пользователя, но с наследованием для Подразделы (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), не удается выполнить слияние двух правил.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">Объект <see cref="T:System.Security.Principal.IdentityReference" />, идентифицирующий пользователя или группу, к которым относится данное правило.</param>
        <param name="accessMask">Побитовое сочетание значений <see cref="T:System.Security.AccessControl.RegistryRights" />, определяющее права доступа для аудита, приведенное к целочисленному типу.</param>
        <param name="isInherited">Логическое значение, которое определяет, наследуется ли правило.</param>
        <param name="inheritanceFlags">Побитовое сочетание значений <see cref="T:System.Security.AccessControl.InheritanceFlags" />, определяющее порядок наследования правила подразделами.</param>
        <param name="propagationFlags">Побитовое сочетание значений <see cref="T:System.Security.AccessControl.PropagationFlags" />, изменяющее порядок наследования правила подразделами. Не имеет смысла, если свойство <c>inheritanceFlags</c> имеет значение <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="flags">Побитовое сочетание значений <see cref="T:System.Security.AccessControl.AuditFlags" />, определяющее предмет аудита — успешные попытки доступа, неудачные попытки доступа или все попытки доступа.</param>
        <summary>Создает новое правило аудита, в котором указывается пользователь, к которому относится правило, права доступа для аудита, параметры наследования и распространения правила, а также событие, вызывающее срабатывание правила.</summary>
        <returns>Объект <see cref="T:System.Security.AccessControl.RegistryAuditRule" />, представляющий указанное правило аудита для заданного пользователя с заданными флагами. Метод возвращает объект базового класса (<see cref="T:System.Security.AccessControl.AuditRule" />), но возвращаемое значение можно безопасно привести к производному классу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для создания правила аудита рекомендуется использовать конструкторы <xref:System.Security.AccessControl.RegistryAuditRule> класса.  
  
> [!NOTE]
>  Несмотря на то, что можно указать <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> флаг, при этом нет смысла. В целях аудита пары "имя значение" в подразделах не являются отдельными объектами. Права аудита для пары "имя значение", определяются правами для подраздела. Кроме того поскольку все подразделы представляют собой контейнеры (то есть они могут содержать другие подразделы), не затрагиваются управлением <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> флаг. Наконец, указав <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> флаг ненужной усложняет обслуживания правил, так как он мешает обычный сочетание совместимых правил.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Параметр <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> или <paramref name="flags" /> имеет недопустимое значение.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="identityReference" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 <paramref name="accessMask" /> равен нулю.</exception>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="identityReference" /> не относится к типу <see cref="T:System.Security.Principal.SecurityIdentifier" /> и к такому типу, как <see cref="T:System.Security.Principal.NTAccount" />, который можно преобразовать в тип <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип, используемый классом <see cref="T:System.Security.AccessControl.RegistrySecurity" /> для обозначения правил аудита.</summary>
        <value>Объект <see cref="T:System.Type" />, представляющий класс <see cref="T:System.Security.AccessControl.RegistryAuditRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Security.AccessControl.ObjectSecurity> класса переопределение <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> свойства и возвращаемые типа, они используют для представления права аудита. При работе с массивами или коллекциями, содержащими объекты безопасности нескольких типов, используйте это свойство для определения тип правила аудита подходит для использования с каждым объектом безопасности.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As RegistryAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Объект <see cref="T:System.Security.AccessControl.RegistryAccessRule" />, определяющий пользователя и тип <see cref="T:System.Security.AccessControl.AccessControlType" /> для поиска, а также набор флагов наследования и распространения, с которыми должно быть совместимо найденное правило. Задает права, которые требуется удалить из совместимого правила, если оно будет найдено.</param>
        <summary>Осуществляет поиск правила управления доступом с тем же именем пользователя и значением <see cref="T:System.Security.AccessControl.AccessControlType" /> ("разрешить" или "запретить"), что и указанного правила доступа, а также с совместимыми флагами наследования и распространения; если правило найдено, содержащиеся в указанном правиле доступа права удаляются.</summary>
        <returns>
          Значение <see langword="true" />, если совместимое правило найдено; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий <xref:System.Security.AccessControl.RegistrySecurity> ищется правило с тем же пользователем и одного <xref:System.Security.AccessControl.AccessControlType> как `rule`. Если такие правило не найдено, никакие действия не выполняются и метод возвращает `false`. При обнаружении правил сопоставления флагов наследования и выполняется проверка на совместимость с флагами, установленными в `rule`. Если совместимые правило не найдено, никакие действия не выполняются и метод возвращает `false`. Если найдено правило с совместимыми флагами, права, указанные в `rule` удаляются из совместимого правила, а метод возвращает `true`. Если `rule` задает права, не содержащиеся в совместимом правиле, никакие действия не выполняются по отношению к эти права. Если все права, удаляются из совместимого правила, правило целиком удаляется из текущей <xref:System.Security.AccessControl.RegistrySecurity> объекта.  
  
   
  
## Examples  
 В следующем примере кода показан как <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> метода выполняется удаление прав из совместимого правила и как <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> метод объединяет права совместимые правилам.  
  
 В примере создается <xref:System.Security.AccessControl.RegistrySecurity> объекта и добавляет правило, текущий пользователь <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> права. Затем пример создает правило, которое предоставляет пользователю <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>с же наследования и распространения права, что первое правило, а также используется <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> метод, чтобы удалить это новое правило из <xref:System.Security.AccessControl.RegistrySecurity> объекта. <xref:System.Security.AccessControl.RegistryRights.SetValue> составные части является <xref:System.Security.AccessControl.RegistryRights.ReadKey>, поэтому он удаляется из совместимого правила. Правила в <xref:System.Security.AccessControl.RegistrySecurity> отображаются объект, показывающий оставшиеся составными элементами <xref:System.Security.AccessControl.RegistryRights.ReadKey>.  
  
 Пример кода вызывает <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> метод для слияния <xref:System.Security.AccessControl.RegistryRights.SetValue> правой обратно в правило в <xref:System.Security.AccessControl.RegistrySecurity> объекта.  
  
> [!NOTE]
>  В этом примере не присоединяется объект безопасности <xref:Microsoft.Win32.RegistryKey> объекта. Во втором примере в этом разделе Присоединяет объект безопасности и поэтому примеров <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="rule" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Объект <see cref="T:System.Security.AccessControl.RegistryAccessRule" />, определяющий пользователя и значение <see cref="T:System.Security.AccessControl.AccessControlType" /> для поиска. Никакие указанные в этом правиле права, флаги наследования и распространения не учитываются.</param>
        <summary>Осуществляет поиск всех правил управления доступом с тем же именем пользователя и значением свойства <see cref="T:System.Security.AccessControl.AccessControlType" /> ("разрешить" или "запретить"), что и у указанного правила, и удаляет найденные правила.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий <xref:System.Security.AccessControl.RegistrySecurity> ищется правила, имеющие тот же пользователь и соответствует <xref:System.Security.AccessControl.AccessControlType> как `rule`. Все права, флаги наследования или заданные Флаги распространения `rule` при поиске игнорируются. Если соответствующие правила не найдены, никакие действия не выполняются.  
  
 Например, если у пользователя есть несколько правил, позволяющих различные права на доступ с флагами различных наследования и распространения, можно удалить все правила, создав <xref:System.Security.AccessControl.RegistryAccessRule> объекта, указывающее пользователя и <xref:System.Security.AccessControl.AccessControlType.Allow?displayProperty=nameWithType>с любой произвольный права и флаги и передав это правило, чтобы <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода показано, что <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> метод удаляет все правила, которые соответствуют пользователя и <xref:System.Security.AccessControl.AccessControlType>, без учета права и флаги.  
  
 В примере создается <xref:System.Security.AccessControl.RegistrySecurity> и добавляющий правил, разрешающих и запрещающих различные права для текущего пользователя, с другой флаги наследования и распространения. Затем в примере создается новое правило, текущий пользователь может стать владельцем и передает это правило, чтобы <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> метод, чтобы удалить два правила, разрешающие доступ.  
  
> [!NOTE]
>  В этом примере не присоединяется объект безопасности <xref:Microsoft.Win32.RegistryKey> объекта. В разделе <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> метод и <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> метод.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="rule" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Объект <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> для удаления.</param>
        <summary>Осуществляет поиск правила управления доступом, в точности соответствующего указанному правилу, и удаляет найденное правило.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Правило удаляется только в том случае, если он точно соответствует `rule` во всех деталях, включая флаги. Другие правила с тем же пользователем и <xref:System.Security.AccessControl.AccessControlType> не затрагиваются.  
  
> [!IMPORTANT]
>  Правило соответствует одному или более базовые элементы управления доступом (ACE) и эти записи делятся или объединяются при необходимости, при изменении правил доступа для пользователя. Таким образом, правило больше не существует в определенной форме, существовавший, когда он был добавлен и в этом случае <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> метод удалить нельзя.  
  
   
  
## Examples  
 В следующем примере кода показано, что <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> метод удаляет правило только в том случае, если он соответствует в точности.  
  
 В примере создаются два правила, предоставляющие различные права. Правила имеют совместимыми флагами наследования и распространения, поэтому при добавлении второго правила он объединяется с первым. В примере вызывается <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> метод, указывая первое правило, но так как правила объединяются нет правил, соответствующий. Затем в примере вызывается <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> метод для удаления второе правило из объединенных правила и наконец вызывает <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> метод для удаления первого правила.  
  
> [!NOTE]
>  В этом примере не присоединяется объект безопасности <xref:Microsoft.Win32.RegistryKey> объекта. В разделе <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> метод и <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> метод.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="rule" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As RegistryAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Объект <see cref="T:System.Security.AccessControl.RegistryAuditRule" />, определяющий пользователя для поиска, а также набор флагов наследования и распространения, с которыми должно быть совместимо найденное правило. Задает права, которые требуется удалить из совместимого правила, если оно будет найдено.</param>
        <summary>Осуществляет поиск правила управления аудитом с тем же именем пользователя, что и указанного правила доступа, а также с совместимыми флагами наследования и распространения; если совместимое правило найдено, содержащиеся в указанном правиле права удаляются.</summary>
        <returns>
          Значение <see langword="true" />, если совместимое правило найдено; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий <xref:System.Security.AccessControl.RegistrySecurity> поиск правила аудита, которое имеет того же пользователя `rule`. Если такие правило не найдено, никакие действия не выполняются и метод возвращает `false`. При обнаружении правил сопоставления флагов наследования и выполняется проверка на совместимость с флагами, установленными в `rule`. Если совместимые правило не найдено, никакие действия не выполняются и метод возвращает `false`. Если найдено правило с совместимыми флагами, права, указанные в `rule` удаляются из совместимого правила, а метод возвращает `true`. Если `rule` задает права, не содержащиеся в совместимом правиле, никакие действия не выполняются по отношению к эти права. Если все права, удаляются из совместимого правила, правило целиком удаляется из текущей <xref:System.Security.AccessControl.RegistrySecurity> объекта.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="rule" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Объект <see cref="T:System.Security.AccessControl.RegistryAuditRule" />, определяющий пользователя для поиска. Никакие указанные в этом правиле права, флаги наследования и распространения не учитываются.</param>
        <summary>Производит поиск всех правил аудита с тем же пользователем, что и у указанного правила, и удаляет найденные правила.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий <xref:System.Security.AccessControl.RegistrySecurity> поиск правила аудита с того же пользователя `rule`. Все права, флаги наследования или заданные Флаги распространения `rule` при поиске игнорируются. Если соответствующие правила не найдены, никакие действия не выполняются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="rule" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Удаляемый объект <see cref="T:System.Security.AccessControl.RegistryAuditRule" />.</param>
        <summary>Осуществляет поиск правила аудита, в точности соответствующего указанному правилу, и удаляет найденное правило.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Правило удаляется только в том случае, если он точно соответствует `rule` во всех деталях, включая флаги. Другие правила аудита для одного пользователя, не затрагиваются.  
  
> [!IMPORTANT]
>  Правило соответствует одному или более базовые элементы управления доступом (ACE) и эти записи делятся или объединяются при необходимости, при изменении правил аудита для пользователя. Таким образом, правило больше не существует в определенной форме, существовавший, когда он был добавлен и в этом случае <xref:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific%2A> метод удалить нельзя.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="rule" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Добавляемый объект <see cref="T:System.Security.AccessControl.RegistryAccessRule" />. Имя пользователя, заданное в этом правиле, определяет правила, которые необходимо удалить перед добавлением данного правила.</param>
        <summary>Удаляет все правила управления доступом с тем же именем пользователя, что и у указанного правила, вне зависимости от значения свойства <see cref="T:System.Security.AccessControl.AccessControlType" />, после чего добавляет указанное правило.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если нет правил доступа пользователя, которого совпадают с указанным правилом, `rule` добавляется.  
  
   
  
## Examples  
 В следующем примере кода показан способ <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> метод заменяет указанное правило соответствия всех правил для соответствующего пользователя.  
  
 В примере создается <xref:System.Security.AccessControl.RegistrySecurity> и добавляющий правил, разрешающих и запрещающих различные права для текущего пользователя, с другой флаги наследования и распространения. Затем в примере создается новое правило, который позволяет пользователю только для чтения ключ и использует <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> метод, чтобы удалить все правила для пользователя и замените их с новым правилом.  
  
> [!NOTE]
>  В этом примере не присоединяется объект безопасности <xref:Microsoft.Win32.RegistryKey> объекта. В разделе <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> метод и <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> метод.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Добавляемый объект <see cref="T:System.Security.AccessControl.RegistryAccessRule" />. Имя пользователя и значение <see cref="T:System.Security.AccessControl.AccessControlType" /> определяют правила, которые необходимо удалить перед добавлением этого правила.</param>
        <summary>Удаляет все правила управления доступом с тем же именем пользователя и значением свойства <see cref="T:System.Security.AccessControl.AccessControlType" /> ("разрешить" или "запретить"), что и у указанного правила, после чего добавляет указанное правило.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если указанное правило имеет <xref:System.Security.AccessControl.AccessControlType.Allow>, этот метод действует для удаления всех <xref:System.Security.AccessControl.AccessControlType.Allow> правила для указанного пользователя, заменив указанного правила. Если указанное правило имеет <xref:System.Security.AccessControl.AccessControlType.Deny>, что все <xref:System.Security.AccessControl.AccessControlType.Deny> указанное правило замещается правила для указанного пользователя.  
  
 Если нет правил, пользователя и <xref:System.Security.AccessControl.AccessControlType> соответствует указанное правило `rule` добавляется.  
  
   
  
## Examples  
 В следующем примере кода показано, что <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> метод удаляет все правила, соответствующие как пользователей, так и <xref:System.Security.AccessControl.AccessControlType> из `rule`, без учета права и флаги и заменяет их значением `rule`.  
  
 В примере создается <xref:System.Security.AccessControl.RegistrySecurity> и добавляющий правил, разрешающих и запрещающих различные права для текущего пользователя, с другой флаги наследования и распространения. Затем в примере создается новое правило, который позволяет пользователю только для чтения ключ и использует <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> метод, чтобы удалить два правила, разрешающие доступ и заменить их с новым правилом. Правило, запрещающее доступ не влияет.  
  
> [!NOTE]
>  В этом примере не присоединяется объект безопасности <xref:Microsoft.Win32.RegistryKey> объекта. В разделе <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> метод и <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> метод.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="rule" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Добавляемый объект <see cref="T:System.Security.AccessControl.RegistryAuditRule" />. Имя пользователя, заданное в этом правиле, определяет правила, которые необходимо удалить перед добавлением данного правила.</param>
        <summary>Удаляет все правила аудита с тем же именем пользователя, что и у указанного правила, вне зависимости от значения свойства <see cref="T:System.Security.AccessControl.AuditFlags" />, после чего добавляет указанное правило.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если нет которого пользователя совпадает с указанным правилом правил аудита `rule` добавляется.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="rule" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>