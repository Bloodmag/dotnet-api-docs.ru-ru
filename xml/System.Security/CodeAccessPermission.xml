<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CodeAccessPermission.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b497a3cd20cb1d0ae8172ce6caf259ae001ddee0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b497a3cd20cb1d0ae8172ce6caf259ae001ddee0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.CodeAccessPermission">
          <source>Defines the underlying structure of all code access permissions.</source>
          <target state="translated">Определяет базовую структуру всех разрешений доступа к коду.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission.</source>
          <target state="translated">Разрешения доступа к коду использовать проверку стека для убедитесь, что все вызывающие объекты кода были предоставлены разрешения.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>If a permission object is <ph id="ph1">`null`</ph>, it is handled the same as a permission object with the state <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если объект разрешения <ph id="ph1">`null`</ph>, он обрабатывается таким же, как объект разрешения с состоянием <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">Стек вызовов обычно представляется как растет вниз, так что методы, расположенные выше в стеке вызовов вызывать методы, расположенные в стеке вызовов.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>Inheritors of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class must be granted full trust to function correctly as permissions extending the security infrastructure.</source>
          <target state="translated">Наследники <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> должно быть предоставлено полное доверие для правильной работы как разрешения, расширяющие инфраструктуру безопасности.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>To determine that the inheritors are fully trusted, <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> issues an <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityAction.InheritanceDemand&gt;</ph> for <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence&gt;</ph><ph id="ph4"> = </ph><ph id="ph5">`true`</ph> and <ph id="ph6">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy&gt;</ph><ph id="ph7"> = </ph><ph id="ph8">`true`</ph>.</source>
          <target state="translated">Чтобы определить, что наследники являются полностью доверенными, <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> проблемы <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityAction.InheritanceDemand&gt;</ph> для <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence&gt;</ph> <ph id="ph4"> = </ph> <ph id="ph5">`true`</ph> и <ph id="ph6">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy&gt;</ph> <ph id="ph7"> = </ph> <ph id="ph8">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>The following code example shows a permission derived from the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">В следующем примере кода показаны разрешения, производным от <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>for the ability of inheritors to provide evidence and view and modify policy.</source>
          <target state="translated">для возможности классов-наследников предоставления свидетельств, просмотра и изменения политики.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /&gt;</ph>.</source>
          <target state="translated">Связанные перечисления: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>When you inherit from <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>, you must also implement the <ph id="ph2">&lt;see cref="T:System.Security.Permissions.IUnrestrictedPermission" /&gt;</ph> interface.</source>
          <target state="translated">При наследовании от <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>, необходимо также реализовать <ph id="ph2">&lt;see cref="T:System.Security.Permissions.IUnrestrictedPermission" /&gt;</ph> интерфейса.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>The following <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> members must be overridden: <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Copy" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" /&gt;</ph>, <ph id="ph5">&lt;see cref="M:System.Security.CodeAccessPermission.ToXml" /&gt;</ph>, <ph id="ph6">&lt;see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" /&gt;</ph>, and <ph id="ph7">&lt;see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" /&gt;</ph>.</source>
          <target state="translated">Следующие <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> члены должны быть переопределены: <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Copy" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" /&gt;</ph>, <ph id="ph5">&lt;see cref="M:System.Security.CodeAccessPermission.ToXml" /&gt;</ph>, <ph id="ph6">&lt;see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" /&gt;</ph>, и <ph id="ph7">&lt;see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>You must also define a constructor that takes a <ph id="ph1">&lt;see cref="T:System.Security.Permissions.PermissionState" /&gt;</ph> as its only parameter.</source>
          <target state="translated">Необходимо также определить конструктор, принимающий <ph id="ph1">&lt;see cref="T:System.Security.Permissions.PermissionState" /&gt;</ph> качестве единственного параметра.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>You must apply the <ph id="ph1">&lt;see cref="T:System.SerializableAttribute" /&gt;</ph> attribute to a class that inherits from <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</source>
          <target state="translated">Необходимо применить <ph id="ph1">&lt;see cref="T:System.SerializableAttribute" /&gt;</ph> класс, который наследует от атрибут <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.#ctor">
          <source>This constructor is called to initialize state in the type whenever an instance of the derived class is created.</source>
          <target state="translated">Данный конструктор вызывается для инициализации состояния типа при создании экземпляра производного класса.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.#ctor">
          <source>Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.</source>
          <target state="translated">Хотя можно явно вызвать этот конструктор в объявлении конструктора конструктор производного класса, это обычно нет необходимости; Большинство компиляторов автоматически создают такой вызов.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource.</source>
          <target state="translated">Объявляет, что вызывающий код может получить доступ к ресурсу, защищенному требованием разрешения, через код, вызывающий этот метод, даже если вызывающим объектам выше в стеке вызовов не предоставлено разрешение на доступ к ресурсу.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Using <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> can create security issues.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> может вызвать проблемы системы безопасности.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">Стек вызовов обычно представляется как растет вниз, так что методы, расположенные выше в стеке вызовов вызывать методы, расположенные в стеке вызовов.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Calling <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> предотвращает обход стека, начавшейся ниже в стеке вызовов, перебирать элементы стека выше код, который вызывает этот метод.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission.</source>
          <target state="translated">Таким образом даже если вызывающим объектам выше в стеке вызовов нет необходимых разрешений на доступ к ресурсу, они по-прежнему доступен через код, который вызывает этот метод для проверки наличия необходимых разрешений.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>An assertion is effective only if the code that calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> passes the security check for the permission that it is asserting.</source>
          <target state="translated">Утверждение действует только в том случае, если код, вызывающий <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> проходит проверку безопасности на наличие утверждающего разрешения.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>The call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> is effective until the calling code returns to its caller.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> действует до возвращается вызывающему коду, вызвавшему его.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Only one <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> can be active on a frame.</source>
          <target state="translated">Только один <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> могут быть активными в каждом кадре.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> when an active <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> exists on the frame results in a <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</source>
          <target state="translated">Попытка вызвать <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> при наличии активного <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> существует на кадре приводит <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> to remove an active <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> удаление активной <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> учитывается для разрешения не предоставляются, так как запрос на это разрешение не будет успешным.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>However, if code lower on the call stack calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for that permission, a <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the stack walk reaches the code that tried to call <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">Тем не менее если код, расположенный ниже в стеке вызовов вызывает <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> этим разрешением, <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> возникает при проверке стека достигается код, который пытался вызвать <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>This happens because the code that called <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> has not been granted the permission, even though it tried to <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> it.</source>
          <target state="translated">Это происходит потому, что код, вызвавший <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> не предоставлено разрешение, несмотря на то, что он пытался <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> его.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Because calling <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately.</source>
          <target state="translated">Поскольку вызов <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> удаляет требование, что весь код в цепочке вызовов должно быть предоставлено разрешение на доступ к указанному ресурсу, может привести к возникновению проблем безопасности неправильное или неверно.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Therefore, it should be used with great caution.</source>
          <target state="translated">Таким образом он должен использоваться с большой осторожностью.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>The calling code does not have <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph>.</source>
          <target state="translated">У вызывающего кода отсутствует <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>There is already an active <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> for the current frame.</source>
          <target state="translated">Уже имеется активное утверждение <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> для текущего кадра.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>for the ability to call <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>.</source>
          <target state="translated">для возможности вызова <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph></source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>You cannot override this method.</source>
          <target state="translated">Этот метод нельзя переопределить.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>When implemented by a derived class, creates and returns an identical copy of the current permission object.</source>
          <target state="translated">При реализации производным классом создает и возвращает идентичную копию текущего объекта разрешения.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>A copy of the current permission object.</source>
          <target state="translated">Копия текущего объекта разрешения.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>A copy of a permission object represents the same access to resources as the original permission object.</source>
          <target state="translated">Копия объекта разрешений представляет тот же уровень доступа к ресурсам, как исходный объект разрешения.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Copy%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере кода показано переопределение <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Copy%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>You must override this method in a derived class.</source>
          <target state="translated">Необходимо переопределить этот метод в производном классе.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>Forces a <ph id="ph1">&lt;see cref="T:System.Security.SecurityException" /&gt;</ph> at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.</source>
          <target state="translated">Принудительно создает <ph id="ph1">&lt;see cref="T:System.Security.SecurityException" /&gt;</ph> во время выполнения, если все вызывающие методы, расположенные выше в стеке вызовов, не получили разрешения, указанного текущим экземпляром.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>This method is typically used by secure libraries to ensure that callers have permission to access a resource.</source>
          <target state="translated">Этот метод обычно используется с защищенными библиотеками для обеспечения наличия у вызывающих объектов разрешений на доступ к ресурсу.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>For example, a file class in a secure class library calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for the necessary <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> before performing a file operation requested by the caller.</source>
          <target state="translated">Например, файл класса в безопасной библиотеке классов вызывает <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> для необходимого <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> перед выполнением операции файл запрошенную вызывающим.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</source>
          <target state="translated">Разрешения для кода, который вызывает этот метод, не проверяется; Проверка начинается с непосредственный вызывающий объект кода и продолжается вверх по стеку.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">Стек вызовов обычно представляется как растет вниз, так что методы, расположенные выше в стеке вызовов вызывать методы, расположенные в стеке вызовов.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> succeeds only if no <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is raised.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> выполняется успешно, только если не <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> возникает.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>A caller higher in the call stack does not have the permission specified by the current instance.</source>
          <target state="translated">Вызывающий метод, расположенный выше в стеке вызовов, не имеет разрешения, указанного текущим экземпляром.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>A caller higher in the call stack has called <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> on the current permission object.</source>
          <target state="translated">Вызывающий метод, расположенный выше в стеке вызовов, вызвал <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> в текущем объекте разрешений.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>You cannot override this method.</source>
          <target state="translated">Этот метод нельзя переопределить.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.</source>
          <target state="translated">Запрещает вызывающим объектам выше в стеке вызовов использовать код, который вызывает этот метод для доступа к ресурсу, указанному текущим экземпляром.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> method should be used only to protect resources from accidental access by fully trusted code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> Метод должен использоваться только для защиты ресурсов от случайного доступа полностью доверенным кодом.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>It should not be used to protect resources from intentional misuse by untrusted code.</source>
          <target state="translated">Он не должен использоваться для защиты ресурсов от умышленного злоупотребления ненадежным кодом.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>For example, if method <ph id="ph1">`A`</ph> issues a <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> for a permission and then calls method <ph id="ph3">`B`</ph>, method <ph id="ph4">`B`</ph> can overtly override the <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> by issuing an <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">Например если метод <ph id="ph1">`A`</ph> проблемы <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> разрешения и вызывает метод <ph id="ph3">`B`</ph>, метод <ph id="ph4">`B`</ph> описания можно переопределить <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> , выполнив <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The called method is always higher in the stack.</source>
          <target state="translated">Вызываемый метод всегда выше в стеке.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Therefore, if method <ph id="ph1">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id="ph2">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> lower in the stack.</source>
          <target state="translated">Таким образом Если метод <ph id="ph1">`B`</ph> попытается получить доступ к защищенному ресурсу, система безопасности начинается проверка наличия разрешения с ним, так как метод <ph id="ph2">`B`</ph> является непосредственного вызывающего объекта, а затем последовательно вниз в стек, чтобы подтвердить, что не <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> или <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> ниже в стеке.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Method <ph id="ph1">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> method.</source>
          <target state="translated">Метод <ph id="ph1">`B`</ph>, который пытается получить доступ к ресурсу, можно остановить обход стека немедленно с помощью <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>In that case, the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> placed on the stack by method <ph id="ph2">`A`</ph> (the calling method) is never discovered.</source>
          <target state="translated">В этом случае <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> помещаются в стек с помощью метода <ph id="ph2">`A`</ph> (метод вызова) никогда не будет обнаружен.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</source>
          <target state="translated">Этот метод не позволяет вызывающим объектам выше в стеке вызовов доступ к защищенному ресурсу через код, вызывающий этот метод, даже если этим вызывающим предоставлено разрешение на доступ к нему.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">Стек вызовов обычно представляется как растет вниз, так что методы, расположенные выше в стеке вызовов вызывать методы, расположенные в стеке вызовов.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> from being used to access the resource protected by the denied permission.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> можно ограничить ответственность программиста или предотвратить случайного характера, поскольку он не позволяет использовать метод, вызывающий <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> не могут использоваться для доступа к ресурсу, защищенному путем отказа в разрешении.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>If a method calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> on a permission, and if a <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>.</source>
          <target state="translated">Если метод вызывает метод <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> для разрешения и если <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> для этого разрешения вызывающий объект, расположенный ниже в стеке вызовов, то проверка безопасности завершится ошибкой при достижении <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> is effective until the calling code returns to its caller.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> действует до возвращается вызывающему коду, вызвавшему его.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Only one <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> can be active on a frame.</source>
          <target state="translated">Только один <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> могут быть активными в каждом кадре.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> when an active <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> exists on the frame results in a <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</source>
          <target state="translated">Попытка вызвать <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> при наличии активного <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> существует на кадре приводит <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> to remove an active <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> удаление активной <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> учитывается для разрешения не предоставляются, так как запрос на это разрешение не будет успешным.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>There is already an active <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> for the current frame.</source>
          <target state="translated">Уже имеется активное утверждение <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> для текущего кадра.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>You cannot override this method.</source>
          <target state="translated">Этот метод нельзя переопределить.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object to compare with the current <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>, который требуется сравнить с текущим объектом <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object is equal to the current <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</source>
          <target state="translated">Определяет, равен ли заданный объект <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> текущему объекту <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object is equal to the current <ph id="ph3">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если заданный объект <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> равен текущему объекту <ph id="ph3">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>. </target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The XML encoding to use to reconstruct the security object.</source>
          <target state="translated">Кодировка XML, используемая для восстановления объекта безопасности.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.</source>
          <target state="translated">Если переопределено в производном классе, восстанавливает объект безопасности с заданным состоянием из данных в формате XML.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>Custom code that extends security objects needs to implement the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> methods to make the objects security-encodable.</source>
          <target state="translated">Пользовательский код, который расширяет объекты безопасности необходимо реализовать <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> методов, чтобы объекты можно было кодировать безопасности.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере кода показано переопределение <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> parameter does not contain the XML encoding for an instance of the same type as the current instance.</source>
          <target state="translated">Тип экземпляра, который описывается содержащимся в параметре <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> кодом XML, не соответствует типу текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The version number of the <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> parameter is not supported.</source>
          <target state="translated">Номер версии параметра <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> не поддерживается.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">Необходимо переопределить этот метод в производном классе.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.GetHashCode">
          <source>Gets a hash code for the <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object that is suitable for use in hashing algorithms and data structures such as a hash table.</source>
          <target state="translated">Возвращает хэш-код для объекта <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>, который можно использовать в алгоритмах хэширования и структурах данных, например в хэш-таблице.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.GetHashCode">
          <source>A hash code for the current <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object.</source>
          <target state="translated">Хэш-код для текущего объекта <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.GetHashCode">
          <source>The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> objects.</source>
          <target state="translated">Хэш-код для двух экземпляров одного разрешения, может отличаться, поэтому хэш-код не следует использовать для сравнения двух <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> объектов.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>A permission to intersect with the current permission.</source>
          <target state="translated">Разрешение, пересекающееся с текущим разрешением.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">Его тип должен совпадать с типом текущего разрешения.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.</source>
          <target state="translated">При реализации производным классом создает и возвращает разрешение, представляющее собой пересечение текущего и указанного разрешений.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>A new permission that represents the intersection of the current permission and the specified permission.</source>
          <target state="translated">Новое разрешение, представляющее собой пересечение текущего и указанного разрешений.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>This new permission is <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the intersection is empty.</source>
          <target state="translated">Если пересечение пусто, новое разрешение имеет значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>The intersection of two permissions is a permission that describes the set of operations they both describe in common.</source>
          <target state="translated">Пересечение двух разрешений является разрешением, которое описывает набор операций, в обоих разрешениях.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>Only a demand that passes both original permissions will pass the intersection.</source>
          <target state="translated">Только запрос, передающий оба исходных разрешения, передает их пересечение.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Intersect%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере кода показано переопределение <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Intersect%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and is not an instance of the same class as the current permission.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="target" /&gt;</ph> не равен <ph id="ph2">&lt;see langword="null" /&gt;</ph> и не является экземпляром того же класса, что и текущее разрешение.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">Необходимо переопределить этот метод в производном классе.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>A permission that is to be tested for the subset relationship.</source>
          <target state="translated">Разрешение, для которого требуется проверить отношение подмножества.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>This permission must be of the same type as the current permission.</source>
          <target state="translated">Его тип должен совпадать с типом текущего разрешения.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>When implemented by a derived class, determines whether the current permission is a subset of the specified permission.</source>
          <target state="translated">Когда реализован производным классом, определяет, является ли текущее разрешение подмножеством указанного разрешения.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current permission is a subset of the specified permission; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущее разрешение является подмножеством заданного разрешения; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The current permission is a subset of the specified permission if the current permission specifies a set of operations that is wholly contained by the specified permission.</source>
          <target state="translated">Текущее разрешение является подмножеством указанного разрешения, если текущее разрешение задает набор операций, полностью содержащихся в заданном разрешении.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>For example, a permission that represents access to C:\example.txt is a subset of a permission that represents access to C:<ph id="ph1">\\</ph>.</source>
          <target state="translated">Например, разрешение, которое предоставляет доступ к C:\example.txt является подмножеством разрешения, предоставляющего доступ к C:<ph id="ph1">\\</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If this method returns <ph id="ph1">`true`</ph>, the current permission represents no more access to the protected resource than does the specified permission.</source>
          <target state="translated">Если этот метод возвращает <ph id="ph1">`true`</ph>, текущее разрешение не предоставляет большего доступа к защищенному ресурсу, чем указанное разрешение.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The following statements are required to be <ph id="ph1">`true`</ph> for all overrides of the <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> method.</source>
          <target state="translated">Следующие инструкции, обязательно <ph id="ph1">`true`</ph> для всех переопределений <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>, <bpt id="p2">*</bpt>Y<ept id="p2">*</ept>, and <bpt id="p3">*</bpt>Z<ept id="p3">*</ept> represent custom code access permission objects that are not null references, <bpt id="p4">*</bpt>U<ept id="p4">*</ept> represents an unrestricted code access permission, and <bpt id="p5">*</bpt>N<ept id="p5">*</ept> represents an empty permission with a <ph id="ph1">&lt;xref:System.Security.Permissions.PermissionState&gt;</ph> of <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>, <bpt id="p2">*</bpt>Y<ept id="p2">*</ept>, и <bpt id="p3">*</bpt>Z<ept id="p3">*</ept> представляют объекты разрешений доступа пользовательского кода, которые не являются пустыми ссылками <bpt id="p4">*</bpt>U<ept id="p4">*</ept> представляет неограниченное разрешение доступа к коду, и <bpt id="p5">*</bpt>N<ept id="p5">*</ept> представляет пустое разрешение с <ph id="ph1">&lt;xref:System.Security.Permissions.PermissionState&gt;</ph> из <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) возвращает <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>) returns the same value as <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>.IsSubsetOf(<bpt id="p4">*</bpt>X<ept id="p4">*</ept>) if and only if <bpt id="p5">*</bpt>X<ept id="p5">*</ept> and <bpt id="p6">*</bpt>Y<ept id="p6">*</ept> represent the same set of permissions.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>) возвращает то же значение, что <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>. IsSubsetOf (<bpt id="p4">*</bpt>X<ept id="p4">*</ept>), только если <bpt id="p5">*</bpt>X<ept id="p5">*</ept> и <bpt id="p6">*</bpt>Y<ept id="p6">*</ept> представляет тот же набор разрешений.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If <bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>) and <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>.IsSubsetOf(<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>) both return <ph id="ph1">`true`</ph>, <bpt id="p5">*</bpt>X<ept id="p5">*</ept>.IsSubsetOf(<bpt id="p6">*</bpt>Z<ept id="p6">*</ept>) returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Если <bpt id="p1">*</bpt>X<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>) и <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>. IsSubsetOf (<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>) в обоих случаях возвращается <ph id="ph1">`true`</ph>, <bpt id="p5">*</bpt>X<ept id="p5">*</ept>. IsSubsetOf (<bpt id="p6">*</bpt>Z<ept id="p6">*</ept>) возвращает <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>U<ept id="p2">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>U<ept id="p2">*</ept>) возвращает <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>N<ept id="p2">*</ept>) returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>N<ept id="p2">*</ept>) возвращает <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>N<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>N<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) возвращает <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If <bpt id="p1">*</bpt>X<ept id="p1">*</ept> and <bpt id="p2">*</bpt>Y<ept id="p2">*</ept> represent custom code access permission objects that are null references, <bpt id="p3">*</bpt>X<ept id="p3">*</ept>.IsSubsetOf(<bpt id="p4">*</bpt>Y<ept id="p4">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Если <bpt id="p1">*</bpt>X<ept id="p1">*</ept> и <bpt id="p2">*</bpt>Y<ept id="p2">*</ept> представляют объекты разрешений доступа пользовательского кода, которые являются пустыми ссылками <bpt id="p3">*</bpt>X<ept id="p3">*</ept>. IsSubsetOf (<bpt id="p4">*</bpt>Y<ept id="p4">*</ept>) возвращает <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If <bpt id="p1">*</bpt>Z<ept id="p1">*</ept> is also null, the compound set operation <bpt id="p2">*</bpt>X<ept id="p2">*</ept>.Union(<bpt id="p3">*</bpt>Y<ept id="p3">*</ept>).IsSubsetOf(<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>) also returns <ph id="ph1">`true`</ph> because the union of two null permissions is a null permission.</source>
          <target state="translated">Если <bpt id="p1">*</bpt>Z<ept id="p1">*</ept> также имеет значение null, то составная операция <bpt id="p2">*</bpt>X<ept id="p2">*</ept>. UNION (<bpt id="p3">*</bpt>Y<ept id="p3">*</ept>). IsSubsetOf (<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>) также возвращает <ph id="ph1">`true`</ph> поскольку объединение двух пустых разрешений является разрешением значение null.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере кода показано переопределение <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and is not of the same type as the current permission.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="target" /&gt;</ph> не равен <ph id="ph2">&lt;see langword="null" /&gt;</ph> и не относится к тому же типу, что и текущее разрешение.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">Необходимо переопределить этот метод в производном классе.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.</source>
          <target state="translated">Запрещает вызывающим объектам выше в стеке вызовов использовать код, который вызывает этот метод для доступа ко всем ресурсам, за исключением ресурса, указанного текущим экземпляром.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> method should be used only to protect resources from accidental access by fully trusted code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> Метод должен использоваться только для защиты ресурсов от случайного доступа полностью доверенным кодом.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>It should not be used to protect resources from intentional misuse by untrusted code.</source>
          <target state="translated">Он не должен использоваться для защиты ресурсов от умышленного злоупотребления ненадежным кодом.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>For example, if method <ph id="ph1">`A`</ph> issues a <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> for a permission and then calls method <ph id="ph3">`B`</ph>, method <ph id="ph4">`B`</ph> can overtly override the <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> by issuing an <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">Например если метод <ph id="ph1">`A`</ph> проблемы <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> разрешения и вызывает метод <ph id="ph3">`B`</ph>, метод <ph id="ph4">`B`</ph> описания можно переопределить <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> , выполнив <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The called method is always higher in the stack.</source>
          <target state="translated">Вызываемый метод всегда выше в стеке.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Therefore, if method <ph id="ph1">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id="ph2">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> lower in the stack.</source>
          <target state="translated">Таким образом Если метод <ph id="ph1">`B`</ph> попытается получить доступ к защищенному ресурсу, система безопасности начинается проверка наличия разрешения с ним, так как метод <ph id="ph2">`B`</ph> является непосредственного вызывающего объекта, а затем последовательно вниз в стек, чтобы подтвердить, что не <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> или <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> ниже в стеке.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Method <ph id="ph1">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> method.</source>
          <target state="translated">Метод <ph id="ph1">`B`</ph>, который пытается получить доступ к ресурсу, можно остановить обход стека немедленно с помощью <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>In that case, the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> placed on the stack by method <ph id="ph2">`A`</ph> (the calling method) is never discovered.</source>
          <target state="translated">В этом случае <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> помещаются в стек с помощью метода <ph id="ph2">`A`</ph> (метод вызова) никогда не будет обнаружен.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> is similar to <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>, in that both cause stack walks to fail when they would otherwise succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> Аналогично <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>, в том, что оба метода приводят стека возвращать ошибку, если они в противном случае будет выполнено успешно.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The difference is that <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> specifies permissions that will cause the stack walk to fail, but <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> specifies the only permissions that do not cause the stack walk to fail.</source>
          <target state="translated">Различие состоит в том <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> задает разрешения, которые стека терпит неудачу, но <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> указывает только разрешения, которые не приводят к сбою стека.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Call this method to ensure that your code can be used to access only the specified resources.</source>
          <target state="translated">Вызовите этот метод, чтобы убедиться, что код может использоваться для доступа к только к заданным ресурсам.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> is effective until the calling code returns to its caller.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> действует до возвращается вызывающему коду, вызвавшему его.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Only one <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> can be active on a frame.</source>
          <target state="translated">Только один <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> могут быть активными в каждом кадре.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> when an active <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> exists on the frame results in a <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</source>
          <target state="translated">Попытка вызвать <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> при наличии активного <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> существует на кадре приводит <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> to remove an active <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> удаление активной <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> учитывается для разрешения не предоставляются, так как запрос на это разрешение не будет успешным.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>However, if code lower on the call stack later calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for that permission, a <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the stack walk reaches the code that tried to call <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>.</source>
          <target state="translated">Тем не менее если код, расположенный ниже, при вызове стеке вызовов <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> этим разрешением, <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> возникает при проверке стека достигается код, который пытался вызвать <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>This is because the code that called <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> has not been granted the permission, even though it called <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> for that permission.</source>
          <target state="translated">Это так, как код, вызвавший <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> не предоставлено разрешение, несмотря на вызов <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> для этого разрешения.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">Стек вызовов обычно представляется как растет вниз, так что методы, расположенные выше в стеке вызовов вызывать методы, расположенные в стеке вызовов.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>There is already an active <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame.</source>
          <target state="translated">Уже имеется активное утверждение <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> для текущего кадра.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>You cannot override this method.</source>
          <target state="translated">Этот метод нельзя переопределить.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAll">
          <source>Causes all previous overrides for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Приводит к удалению и выводу из действия всех предыдущих переопределений для текущего кадра.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertAll">
          <source>If there are no overrides (<ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>) for the current frame, an <ph id="ph4">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">При наличии перекрытия не (<ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>) для текущего кадра <ph id="ph4">&lt;xref:System.ExecutionEngineException&gt;</ph> возникает исключение.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAll">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph>, or <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame.</source>
          <target state="translated">Для текущего кадра отсутствует предыдущий метод <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> или <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAssert">
          <source>Causes any previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Удаляет все предыдущие методы <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> для текущего кадра и прекращает их действие.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertAssert">
          <source>If there is no <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> for the current frame, an <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">При наличии не <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> для текущего кадра <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> возникает исключение.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAssert">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> for the current frame.</source>
          <target state="translated">Для текущего кадра отсутствует предыдущий метод <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertDeny">
          <source>Causes any previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Удаляет все предыдущие методы <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> для текущего кадра и прекращает их действие.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertDeny">
          <source>If there is no <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> for the current frame, an <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">При наличии не <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> для текущего кадра <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> возникает исключение.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertDeny">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> for the current frame.</source>
          <target state="translated">Для текущего кадра отсутствует предыдущий метод <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertPermitOnly">
          <source>Causes any previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Удаляет все предыдущие методы <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> для текущего кадра и прекращает их действие.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertPermitOnly">
          <source>If there is no <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> for the current frame, an <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">При наличии не <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> для текущего кадра <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> возникает исключение.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertPermitOnly">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame.</source>
          <target state="translated">Для текущего кадра отсутствует предыдущий метод <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToString">
          <source>Creates and returns a string representation of the current permission object.</source>
          <target state="translated">Создает и возвращает строковое представление текущего объекта разрешения.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToString">
          <source>A string representation of the current permission object.</source>
          <target state="translated">Строковое представление текущего объекта разрешения.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToString">
          <source>This method is useful in debugging when you need to display the permission as a string.</source>
          <target state="translated">Этот метод полезен при отладке, когда нужно отобразить разрешение в виде строки.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>When overridden in a derived class, creates an XML encoding of the security object and its current state.</source>
          <target state="translated">При переопределении в производном классе создает кодировку XML для объекта безопасности и его текущего состояния.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>An XML encoding of the security object, including any state information.</source>
          <target state="translated">Кодировка XML объекта безопасности, включающая сведения о состоянии.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>Custom code that extends security objects needs to implement the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> methods to make the objects security-encodable.</source>
          <target state="translated">Пользовательский код, который расширяет объекты безопасности необходимо реализовать <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> методов, чтобы объекты можно было кодировать безопасности.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере кода показано переопределение <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>You must override this method in a derived class.</source>
          <target state="translated">Необходимо переопределить этот метод в производном классе.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>A permission to combine with the current permission.</source>
          <target state="translated">Разрешение, которое требуется объединить с текущим разрешением.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">Его тип должен совпадать с типом текущего разрешения.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.</source>
          <target state="translated">При переопределении в производном классе создает разрешение, представляющее собой объединение текущего и указанного разрешений.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>A new permission that represents the union of the current permission and the specified permission.</source>
          <target state="translated">Новое разрешение, представляющее собой объединение текущего и указанного разрешений.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>The result of a call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> is a permission that represents all the operations represented by both the current permission and the specified permission.</source>
          <target state="translated">Результат вызова метода <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> является разрешение, представляющее все действия, представленные текущего разрешения и указанного разрешений.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>Any demand that passes either permission passes their union.</source>
          <target state="translated">Любой запрос, передающий любое разрешение, передает их объединение.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере кода показано переопределение <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>The <ph id="ph1">&lt;paramref name="other" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="other" /&gt;</ph> не равен <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>This method is only supported at this level when passed <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Этот метод поддерживается на данном уровне только при передаче значения <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">Необходимо переопределить этот метод в производном классе.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>You should return a copy of the permission if the value of the <ph id="ph1">&lt;paramref name="other" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Копия разрешение должно возвращаться, если значение <ph id="ph1">&lt;paramref name="other" /&gt;</ph> параметр <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>