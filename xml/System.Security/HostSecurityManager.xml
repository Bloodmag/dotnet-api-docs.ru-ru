<Type Name="HostSecurityManager" FullName="System.Security.HostSecurityManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ff48fa5df967caba5aed9ae2ba2fef1a119992f4" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30500648" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HostSecurityManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HostSecurityManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.HostSecurityManager" />
  <TypeSignature Language="VB.NET" Value="Public Class HostSecurityManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class HostSecurityManager" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Позволяет настраивать работу системы безопасности домена приложения и управлять ею.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При создании нового <xref:System.AppDomain>, общих запросов среды выполнения языка <xref:System.AppDomainManager> наличие <xref:System.Security.HostSecurityManager>, который участвует в принятии решений по безопасности <xref:System.AppDomain>.  Поставщики узла должен реализовывать диспетчер безопасности узла, который наследуется от <xref:System.Security.HostSecurityManager> класса.  
  
   
  
## Examples  
 Следующий пример показывает очень простая реализация <xref:System.Security.HostSecurityManager>.  
  
 [!code-csharp[System.Security.HostSecurityManager#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#1)]
 [!code-vb[System.Security.HostSecurityManager#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот класс не может использоваться частично доверенным или прозрачным кодом.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">для полного доверия для разработчиков производных классов. Этот класс не наследуется частично доверенным кодом.</permission>
    <block subset="none" type="overrides">
      <para>Некоторые члены <see cref="T:System.Security.HostSecurityManager" /> вызываются всякий раз, когда загружена сборка, явно или неявно. <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> И <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> методы не должны загрузить все сборки, так как это приведет к в членах <see cref="T:System.Security.HostSecurityManager" /> , вызывается рекурсивно. Чтобы избежать циклических ссылок, необходимо создать новые экземпляры классов, которые могут вызвать загрузку сборок, явно или неявно, в конструкторе класса, производного от <see cref="T:System.Security.HostSecurityManager" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HostSecurityManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HostSecurityManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Security.HostSecurityManager" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">для полного доверия для разработчиков производных классов. Этот член не может наследоваться частично доверенным кодом.</permission>
        <block subset="none" type="overrides">
          <para>Создайте экземпляры классов, которые могут вызвать загрузку, явно или неявно сборок в этом конструкторе.  Метод доступа get для <see cref="P:System.Security.HostSecurityManager.DomainPolicy" /> свойство и <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> и <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> методы вызываются всякий раз, когда сборка загружается и их последующей загрузке сборки будет вызывающая циклических ссылок.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DetermineApplicationTrust">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.ApplicationTrust DetermineApplicationTrust (System.Security.Policy.Evidence applicationEvidence, System.Security.Policy.Evidence activatorEvidence, System.Security.Policy.TrustManagerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.ApplicationTrust DetermineApplicationTrust(class System.Security.Policy.Evidence applicationEvidence, class System.Security.Policy.Evidence activatorEvidence, class System.Security.Policy.TrustManagerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.DetermineApplicationTrust(System.Security.Policy.Evidence,System.Security.Policy.Evidence,System.Security.Policy.TrustManagerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DetermineApplicationTrust (applicationEvidence As Evidence, activatorEvidence As Evidence, context As TrustManagerContext) As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::ApplicationTrust ^ DetermineApplicationTrust(System::Security::Policy::Evidence ^ applicationEvidence, System::Security::Policy::Evidence ^ activatorEvidence, System::Security::Policy::TrustManagerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="activatorEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="context" Type="System.Security.Policy.TrustManagerContext" />
      </Parameters>
      <Docs>
        <param name="applicationEvidence">Свидетельство для активируемого приложения.</param>
        <param name="activatorEvidence">Свидетельство для активирующего домена приложения (необязательное).</param>
        <param name="context">Контекст доверия.</param>
        <summary>Определяет, должно ли выполняться приложение.</summary>
        <returns>Объект, содержащий сведения о доверии в отношении приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен в производном классе. Базовая реализация вызывает диспетчер безопасности приложения, чтобы определить, если приложения должны быть выполнены.  
  
 Базовая реализация не используется свидетельство активатора. Однако переопределенная реализация может использовать свидетельство активатора для определения безопасности свидетельство для домена приложения, предпринимается попытка активировать приложение.  
  
   
  
## Examples  
 В следующем примере показан способ переопределения <xref:System.Security.HostSecurityManager.DetermineApplicationTrust%2A> метод для диспетчера безопасности пользовательского основного приложения. Данный пример является частью большего примера, приведенного для <xref:System.Security.HostSecurityManager> класса.  
  
 [!code-csharp[System.Security.HostSecurityManager#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#3)]
 [!code-vb[System.Security.HostSecurityManager#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="applicationEvidence" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Не удается найти в свидетельстве приложения объект <see cref="T:System.Runtime.Hosting.ActivationArguments" />.  
  
 - или -  
  
 Свойство <see cref="P:System.Runtime.Hosting.ActivationArguments.ActivationContext" /> в аргументах активации имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Набор разрешений <see cref="T:System.Security.Policy.ApplicationTrust" /> не содержит минимального набора запросов, определенного в объекте <see cref="T:System.ActivationContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainPolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.PolicyLevel DomainPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.PolicyLevel DomainPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.DomainPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DomainPolicy As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::PolicyLevel ^ DomainPolicy { System::Security::Policy::PolicyLevel ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает политику безопасности для текущего домена приложения.</summary>
        <value>Политика безопасности для текущего домена приложения. Значение по умолчанию: <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство может быть переопределено в производном классе. Базовая реализация всегда возвращает значение `null`.  
  
 Это свойство может вызываться в <xref:System.AppDomain> время создания. Это позволяет ведущему приложению задать политику для текущего <xref:System.AppDomain>.  Уровень политики состоит из следующих:  
  
-   Набор групп кода, организованных в одно дерево административным доступом.  
  
-   Набор именованных наборов разрешений, на которые ссылается группы кода, чтобы указать разрешения для предоставления кода, входящие в группу кода.  
  
-   Список сборок с полным доверием.  
  
> [!IMPORTANT]
>  См. примечания для наследующих объектов для <xref:System.Security.HostSecurityManager> класс для реализации критические сведения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод использует политику разграничения доступа кода (CAS), которая является устаревшей для [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Чтобы включить политику CAS для обеспечения совместимости с предыдущими версиями .NET Framework, используйте [элемент &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flags">
      <MemberSignature Language="C#" Value="public virtual System.Security.HostSecurityManagerOptions Flags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.HostSecurityManagerOptions Flags" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.Flags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Flags As HostSecurityManagerOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::HostSecurityManagerOptions Flags { System::Security::HostSecurityManagerOptions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.HostSecurityManagerOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает флаги, представляющие компоненты политики безопасности, необходимые сайту.</summary>
        <value>Одно из значений перечисления, указывающее компоненты политики безопасности. Значение по умолчанию: <see cref="F:System.Security.HostSecurityManagerOptions.AllFlags" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство может быть переопределено в производном классе. Базовая реализация всегда возвращает значение <xref:System.Security.HostSecurityManagerOptions.AllFlags>.  
  
 Унаследованный узел можно изменить значение этого свойства, если только подмножество <xref:System.Security.HostSecurityManagerOptions> представляет интерес.  Возможные подмножеств включают none, отклоненный набор, уровень политики и свидетельство сборки.  
  
   
  
## Examples  
 В следующем примере показан способ переопределения <xref:System.Security.HostSecurityManager.Flags%2A> свойств для диспетчера безопасности пользовательского основного приложения. Данный пример является частью большего примера, приведенного для <xref:System.Security.HostSecurityManager> класса.  
  
 [!code-csharp[System.Security.HostSecurityManager#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#2)]
 [!code-vb[System.Security.HostSecurityManager#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAppDomainEvidence (Type evidenceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAppDomainEvidence(class System.Type evidenceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAppDomainEvidence(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GenerateAppDomainEvidence (evidenceType As Type) As EvidenceBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAppDomainEvidence(Type ^ evidenceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Тип свидетельства.</param>
        <summary>Запрашивает определенный тип свидетельства для домена приложения.</summary>
        <returns>Запрошенное свидетельство домена приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен в производном классе. Возвращает базовую реализацию `null`.  
  
 Среда вызывает этот метод при необходимости свидетельства указанного типа для текущего <xref:System.AppDomain>. Возвращаемое значение используется в качестве узла предоставленное свидетельство и хранится в <xref:System.AppDomain.Evidence%2A> коллекцию <xref:System.AppDomain.CurrentDomain%2A> свойство. Можно использовать <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> метод, чтобы получить свидетельство, созданный из коллекции.  
  
 Чтобы получить обратный вызов этого метода, необходимо указать узлы <xref:System.Security.HostSecurityManagerOptions.HostAppDomainEvidence> флаг в <xref:System.Security.HostSecurityManager.Flags%2A> свойство.  
  
 Этот метод создания свидетельства позволяет хостам отложить создание свидетельство для <xref:System.AppDomain> пока потребуется свидетельство. В .NET Framework версии 3.5 и более ранних версиях необходимо было предоставить <xref:System.AppDomain> свидетельства во время загрузки, переопределив <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> метод. Мы рекомендуем использовать <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> свидетельство вместо переопределения <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A>.  
  
 <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> Метод вызывается в только для типов свидетельств, которые определены в переопределении <xref:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes%2A> метод.  
  
 Возвращаемое значение `null` указывает, что узел не может создать свидетельство указанного типа.  
  
   
  
## Examples  
 В следующем примере показан способ переопределения <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> метод для диспетчера безопасности пользовательского основного приложения. Данный пример является частью большего примера, приведенного для <xref:System.Security.HostSecurityManager> класса.  
  
 [!code-csharp[System.Security.HostSecurityManager#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#6)]
 [!code-vb[System.Security.HostSecurityManager#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAssemblyEvidence (Type evidenceType, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAssemblyEvidence(class System.Type evidenceType, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAssemblyEvidence(System.Type,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAssemblyEvidence(Type ^ evidenceType, System::Reflection::Assembly ^ assembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Тип свидетельства.</param>
        <param name="assembly">Целевая сборка.</param>
        <summary>Запрашивает определенный тип свидетельства для сборки.</summary>
        <returns>Запрошенное свидетельство сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен в производном классе. Возвращает базовую реализацию `null`.  
  
 Среда вызывает этот метод при необходимости свидетельства указанного типа для текущей сборки. Возвращаемое значение используется в качестве узла предоставленное свидетельство и хранится в <xref:System.Reflection.Assembly.Evidence%2A> свойство. Можно использовать <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> метод, чтобы получить свидетельство, созданный из <xref:System.Reflection.Assembly.Evidence%2A> свойство.  
  
 Чтобы получить обратный вызов этого метода, необходимо указать узлы <xref:System.Security.HostSecurityManagerOptions.HostAssemblyEvidence> флаг в <xref:System.Security.HostSecurityManager.Flags%2A> свойство.  
  
 Этот метод создания свидетельства позволяет хостам отложить создание свидетельство для <xref:System.AppDomain> пока потребуется свидетельство. В .NET Framework 3.5 и более ранних версиях необходимо было предоставить <xref:System.AppDomain> свидетельства во время загрузки, переопределив <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> метод. Мы рекомендуем использовать <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> свидетельство вместо переопределения <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A>.  
  
 <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> Метод вызывается в только для типов свидетельств, которые определены в переопределении <xref:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes%2A> метод.  
  
 Возвращаемое значение `null` указывает, что узел не может создать свидетельство указанного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAppDomainEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAppDomainEvidenceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAppDomainEvidenceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHostSuppliedAppDomainEvidenceTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAppDomainEvidenceTypes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Определяет, какие типы свидетельства узел может предоставить домену приложения при запросе.</summary>
        <returns>Массив типов свидетельства.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен в производном классе. Возвращает базовую реализацию `null`.  
  
 Типы, возвращаемый этим методом, определяют ли <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> метод вызывается обратно в. Присутствие этого типа в этом списке не означает узла необходимо сможет создать этот тип свидетельства, однако, он может быть установлено для. По этой причине лучше чрезмерно вместо в задавать типы в этом списке.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAssemblyEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAssemblyEvidenceTypes (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAssemblyEvidenceTypes(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAssemblyEvidenceTypes(System::Reflection::Assembly ^ assembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">Целевая сборка.</param>
        <summary>Определяет, какие типы свидетельства узел может предоставить сборке при запросе.</summary>
        <returns>Массив типов свидетельства.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен в производном классе. Возвращает базовую реализацию `null`.  
  
 Типы, возвращаемый этим методом, определяют ли <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> метод вызывается обратно в. Присутствие этого типа в этом списке не означает узла необходимо сможет создать этот тип свидетельства, однако, он может быть установлено для. По этой причине лучше чрезмерно вместо в задавать типы в этом списке.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAppDomainEvidence (System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAppDomainEvidence(class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAppDomainEvidence (inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAppDomainEvidence(System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="inputEvidence">Дополнительное свидетельство, добавляемое к свидетельству <see cref="T:System.AppDomain" />.</param>
        <summary>Содержит свидетельство домена приложения для загружаемой сборки.</summary>
        <returns>Свидетельство, используемое для класса <see cref="T:System.AppDomain" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен в производном классе.  
  
 Этот метод вызывается каждый раз, когда <xref:System.AppDomain> создан объект. `inputEvidence` Параметр является вычисленное свидетельство общеязыковая среда выполнения. Реализация узла можно расширить или сократить свидетельство. Возвращает значение, свидетельство для домена приложения.  Базовая реализация всегда возвращает объект свидетельства, переданных в качестве `inputEvidence` параметра.  
  
> [!IMPORTANT]
>  См. примечания для наследующих объектов для <xref:System.Security.HostSecurityManager> класс для реализации критические сведения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAssemblyEvidence (System.Reflection.Assembly loadedAssembly, System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAssemblyEvidence(class System.Reflection.Assembly loadedAssembly, class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAssemblyEvidence (loadedAssembly As Assembly, inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAssemblyEvidence(System::Reflection::Assembly ^ loadedAssembly, System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loadedAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="loadedAssembly">Загруженная сборка.</param>
        <param name="inputEvidence">Дополнительное свидетельство, добавляемое в свидетельство сборки.</param>
        <summary>Содержит свидетельство сборки для загружаемой сборки.</summary>
        <returns>Свидетельство, используемое для сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен в производном классе.  
  
 Этот метод вызывается каждый раз, когда загружена сборка, явно или неявно. В качестве параметров являются загружаемая сборка и вычисленное свидетельство общеязыковая среда выполнения. Реализация узла можно расширить или сократить свидетельство. Возвращает значение, свидетельство для сборки.  Базовая реализация всегда возвращает объект свидетельства, переданных в качестве `inputEvidence` параметра.  
  
> [!IMPORTANT]
>  См. примечания для наследующих объектов для <xref:System.Security.HostSecurityManager> класс для реализации критические сведения.  
  
   
  
## Examples  
 В следующем примере показан способ переопределения <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A> метод для диспетчера безопасности пользовательского основного приложения. Данный пример является частью большего примера, приведенного для <xref:System.Security.HostSecurityManager> класса.  
  
 [!code-csharp[System.Security.HostSecurityManager#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#5)]
 [!code-vb[System.Security.HostSecurityManager#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ResolvePolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Набор свидетельств, используемых для оценки политики.</param>
        <summary>Определяет разрешения, которые нужно предоставить коду, на основе определенного свидетельства.</summary>
        <returns>Набор разрешений, которые могут быть предоставлены системой безопасности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает обработчик политики безопасности, передавая ему указанное свидетельство. Результат определяется политикой безопасности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="evidence" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>