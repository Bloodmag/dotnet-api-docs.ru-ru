<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b37ff083eff27618aa07c0a744562f3f8a613708" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30499168" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Управляет проверкой стека, которая определяет, имеют ли все вызывающие объекты в стеке вызовов разрешения, необходимые для доступа к защищенному ресурсу.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Частично доверенный код всегда представляет угрозу безопасности. Иногда, ими можно управлять для выполнения действий от имени вредоносный код, который не имеет разрешения на доступ к ресурсу. Таким образом вредоносный код может получить высокий уровень доступа, чем следует разрешить.  
  
 Общеязыковая среда выполнения защищает управляемый код от подобных атак, выполнив проверку стека вызова. Обход стека требует, что весь код в стеке вызовов имеет разрешение на доступ к защищенному ресурсу. Поскольку коду, выполняющему атаки, всегда попадает в стек вызовов, он сможет превышать свои собственные разрешения безопасности.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Подтверждает, что вызывающий код может получить доступ к ресурсу, определяемому текущим объектом разрешения, даже если вызывающим объектам выше в стеке вызовов не предоставлено разрешение на доступ к ресурсу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Security.IStackWalk.Assert%2A> прекращает проверку наличия разрешений на вызывающим объектам выше в стеке вызовов. Таким образом даже если эти вызывающие объекты не имеют необходимых разрешений, они по-прежнему доступны ресурсы. Утверждение действует только в том случае, если код, вызывающий <xref:System.Security.IStackWalk.Assert%2A> проходит проверку безопасности на наличие утверждающего разрешения.  
  
 Вызов <xref:System.Security.IStackWalk.Assert%2A> действует только до возврата вызывающему коду, вызвавшему ее или до последующего вызова <xref:System.Security.IStackWalk.Assert%2A> сделает предыдущее утверждение неэффективным. Кроме того <xref:System.Security.CodeAccessPermission.RevertAssert%2A> или <xref:System.Security.CodeAccessPermission.RevertAll%2A> удаляет ожидающие <xref:System.Security.IStackWalk.Assert%2A>.  
  
 <xref:System.Security.IStackWalk.Assert%2A> учитывается для разрешения не предоставляются, так как запрос на это разрешение не будет успешным. Тем не менее если код, расположенный ниже в стеке вызовов вызывает <xref:System.Security.IStackWalk.Demand%2A> этим разрешением, <xref:System.Security.SecurityException> возникает при проверке стека достигается код, который пытался вызвать <xref:System.Security.IStackWalk.Assert%2A>. Это происходит потому, что код, вызвавший <xref:System.Security.IStackWalk.Assert%2A> не предоставлено разрешение, несмотря на то, что он пытался <xref:System.Security.IStackWalk.Assert%2A> его.  
  
> [!CAUTION]
>  Поскольку вызов <xref:System.Security.IStackWalk.Assert%2A> удаляет требование, что весь код в цепочке вызовов должно быть предоставлено разрешение на доступ к указанному ресурсу, может привести к возникновению уязвимости системы безопасности неправильное или неверно. Таким образом он должен использоваться с большой осторожностью.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего кода отсутствует <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Определяет во время выполнения, было ли разрешение, указанное текущим объектом разрешений, предоставлено всем вызывающим методам в стеке вызовов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обычно используется с защищенными библиотеками для обеспечения наличия у вызывающих объектов разрешений на доступ к ресурсу. Например, файл класса в безопасной библиотеке классов вызывает <xref:System.Security.IStackWalk.Demand%2A> для необходимого <xref:System.Security.Permissions.FileIOPermission> перед выполнением операции файл запрошенную вызывающим.  
  
 Разрешения для кода, который вызывает этот метод, не проверяется; Проверка начинается с непосредственный вызывающий объект кода и продолжается вверх по стеку. <xref:System.Security.IStackWalk.Demand%2A> выполняется успешно, только если не <xref:System.Security.SecurityException> возникает.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Вызывающий метод, расположенный выше в стеке вызовов, не имеет разрешения, указанного текущим объектом разрешений.  
  
 - или -  
  
 Вызывающий метод в стеке вызовов вызвал <see cref="M:System.Security.IStackWalk.Deny" /> в текущем объекте разрешений.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает ошибку каждого <see cref="M:System.Security.IStackWalk.Demand" /> для текущего объекта, проходящего через вызывающий код.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не позволяет вызывающим объектам выше в стеке вызовов доступ к защищенному ресурсу через код, вызывающий этот метод, даже если этим вызывающим предоставлено разрешение на доступ к нему. Стек вызовов обычно представляется как растет вниз, так что методы, расположенные выше в стеке вызовов вызывать методы, расположенные в стеке вызовов.  
  
 <xref:System.Security.IStackWalk.Deny%2A> можно ограничить ответственность программиста или предотвратить случайное уязвимостей, поскольку он не позволяет использовать метод, вызывающий <xref:System.Security.IStackWalk.Deny%2A> не могут использоваться для доступа к ресурсу, защищенному путем отказа в разрешении. Если метод вызывает метод <xref:System.Security.IStackWalk.Deny%2A> для разрешения и если <xref:System.Security.IStackWalk.Demand%2A> для этого разрешения вызывающий объект, расположенный ниже в стеке вызовов, то проверка безопасности завершится ошибкой при достижении <xref:System.Security.IStackWalk.Deny%2A>.  
  
 <xref:System.Security.IStackWalk.Deny%2A> учитывается для разрешения не предоставляются, так как запрос на это разрешение не будет успешным.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Этот метод нельзя переопределить.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Принудительно блокирует все проходящие через вызывающий код вызовы <see cref="M:System.Security.IStackWalk.Demand" /> для всех объектов, кроме текущего, даже если расположенный выше в стеке вызовов код обладает разрешениями на доступ к другим ресурсам.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.IStackWalk.PermitOnly%2A> Аналогично <xref:System.Security.IStackWalk.Deny%2A>, в том, что оба метода приводят стека возвращать ошибку, если они в противном случае будет выполнено успешно. Различие состоит в том <xref:System.Security.IStackWalk.Deny%2A> задает разрешения, которые стека терпит неудачу, но <xref:System.Security.IStackWalk.PermitOnly%2A> указывает только разрешения, которые не приводят к сбою стека. Вызовите этот метод, чтобы убедиться, что код может использоваться для доступа к только к заданным ресурсам.  
  
 <xref:System.Security.IStackWalk.PermitOnly%2A> учитывается для разрешения не предоставляются, так как запрос на это разрешение не будет успешным. Тем не менее если код, расположенный ниже, при вызове стеке вызовов <xref:System.Security.IStackWalk.Demand%2A> этим разрешением, <xref:System.Security.SecurityException> возникает при проверке стека достигается код, который пытался вызвать <xref:System.Security.IStackWalk.PermitOnly%2A>. Это так, как код, вызвавший <xref:System.Security.IStackWalk.PermitOnly%2A> не предоставлено разрешение, несмотря на вызов <xref:System.Security.IStackWalk.PermitOnly%2A> для этого разрешения. Стек вызовов обычно представляется как растет вниз, так что методы, расположенные выше в стеке вызовов вызывать методы, расположенные в стеке вызовов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>