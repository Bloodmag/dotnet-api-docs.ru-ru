<Type Name="RecognizedWordUnit" FullName="System.Speech.Recognition.RecognizedWordUnit">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="db8bbe70a61c7c005c717610d08e20178651bffc" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30529828" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RecognizedWordUnit" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit RecognizedWordUnit extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.RecognizedWordUnit" />
  <TypeSignature Language="VB.NET" Value="Public Class RecognizedWordUnit" />
  <TypeSignature Language="C++ CLI" Value="public ref class RecognizedWordUnit" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Text: {Text}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет атомарный блок распознанной речи.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все результаты, возвращенные механизма распознавания конструируются из <xref:System.Speech.Recognition.RecognizedWordUnit> объектов.  
  
 Массив <xref:System.Speech.Recognition.RecognizedWordUnit> объектов доступна для любой операции распознавания через <xref:System.Speech.Recognition.RecognizedPhrase.Words%2A> свойство <xref:System.Speech.Recognition.RecognizedPhrase> объекта.  
  
 Помимо предоставления мер точности распознавания (<xref:System.Speech.Recognition.RecognizedWordUnit.Confidence%2A>) <xref:System.Speech.Recognition.RecognizedWordUnit> предоставляет экземпляр:  
  
-   Нормализованный и точное (или лексической) текстовыми представлениями для распознанного слова. Дополнительные сведения см. в разделах <xref:System.Speech.Recognition.ReplacementText>, <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A> и <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A>.  
  
-   Сведения о произношения символов из поддерживаемых фонетического алфавита, например международного фонетического алфавита (IPA) или универсальных Phone набор (ИБП). Дополнительные сведения см. в разделе <xref:System.Speech.Recognition.RecognizedWordUnit.Pronunciation%2A>.  
  
-   Форматирование для печати. Дополнительные сведения см. <xref:System.Speech.Recognition.DisplayAttributes> класса и его <xref:System.Speech.Recognition.RecognizedWordUnit.DisplayAttributes%2A> свойство.  
  
   
  
## Examples  
 В следующем примере показано служебной процедуры (`stringFromWordArray`), приводит к возникновению ошибки строки. Строки содержат лексической выходные данные (с помощью <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A>), нормализованы текст (с помощью <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A>), или фонетический знаков из международного фонетического алфавита (с помощью <xref:System.Speech.Recognition.RecognizedWordUnit.Pronunciation%2A>). Форматирование строк с помощью <xref:System.Speech.Recognition.DisplayAttributes> получить объекты из <xref:System.Speech.Recognition.RecognizedWordUnit.DisplayAttributes%2A> свойство из <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> из <xref:System.Speech.Recognition.RecognizedWordUnit> объектов. <xref:System.Speech.Recognition.RecognizedWordUnit> Объекты извлекаются из <xref:System.Speech.Recognition.RecognizedPhrase.Words%2A> свойство <xref:System.Speech.Recognition.RecognizedPhrase> объекта.  
  
```csharp  
  
internal enum WordType   
{  
  Text,  
  Normalized = Text,  
  Lexical,  
  Pronunciation  
}  
```  
  
```csharp  
internal static string stringFromWordArray(ReadOnlyCollection<RecognizedWordUnit> words, WordType type)   
{  
  string text = "";  
  foreach (RecognizedWordUnit word in words)   
  {  
    string wordText = "";  
    if (type == WordType.Text || type == WordType.Normalized)   
    {  
      wordText = word.Text;  
    }   
    else if (type == WordType.Lexical)   
    {  
      wordText = word.LexicalForm;  
    }   
    else if (type == WordType.Pronunciation)   
    {  
      wordText = word.Pronunciation;  
    }   
    else   
    {  
      throw new InvalidEnumArgumentException(String.Format("[0}: is not a valid input", type));  
    }  
    // Use display attribute  
  
    if ((word.DisplayAttributes & DisplayAttributes.OneTrailingSpace) != 0)   
    {  
      wordText += " ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.TwoTrailingSpaces) != 0)  
    {  
      wordText += "  ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ConsumeLeadingSpaces) != 0)   
    {  
      wordText = wordText.TrimStart();  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ZeroTrailingSpaces) != 0)  
    {  
      wordText = wordText.TrimEnd();  
    }  
  
    text += wordText;  
  
  }  
  return text;  
}  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.DisplayAttributes" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RecognizedWordUnit (string text, float confidence, string pronunciation, string lexicalForm, System.Speech.Recognition.DisplayAttributes displayAttributes, TimeSpan audioPosition, TimeSpan audioDuration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, float32 confidence, string pronunciation, string lexicalForm, valuetype System.Speech.Recognition.DisplayAttributes displayAttributes, valuetype System.TimeSpan audioPosition, valuetype System.TimeSpan audioDuration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.RecognizedWordUnit.#ctor(System.String,System.Single,System.String,System.String,System.Speech.Recognition.DisplayAttributes,System.TimeSpan,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RecognizedWordUnit(System::String ^ text, float confidence, System::String ^ pronunciation, System::String ^ lexicalForm, System::Speech::Recognition::DisplayAttributes displayAttributes, TimeSpan audioPosition, TimeSpan audioDuration);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="confidence" Type="System.Single" />
        <Parameter Name="pronunciation" Type="System.String" />
        <Parameter Name="lexicalForm" Type="System.String" />
        <Parameter Name="displayAttributes" Type="System.Speech.Recognition.DisplayAttributes" />
        <Parameter Name="audioPosition" Type="System.TimeSpan" />
        <Parameter Name="audioDuration" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="text">Нормализованный текст для распознанного слова.  
  
 Возможные значения — <see langword="null" />, "" или <see cref="F:System.String.Empty" />.</param>
        <param name="confidence">Значение от 0,0 до 1.0 <see langword="float" />, указывающий определенность распознавания слова.</param>
        <param name="pronunciation">Фонетическое написание распознанного слова.  
  
 Возможные значения — <see langword="null" />, "" или <see cref="F:System.String.Empty" />.</param>
        <param name="lexicalForm">Ненормализованный текст для распознанного слова.  
  
 Этот аргумент обязателен и не может быть <see langword="null" />, "" или <see cref="F:System.String.Empty" />.</param>
        <param name="displayAttributes">Определяет использование пробелов для отображения распознанных слов.</param>
        <param name="audioPosition">Расположение распознанного слова во входном звуковом потоке.  
  
 Это значение может быть равно <see cref="F:System.TimeSpan.Zero" />.</param>
        <param name="audioDuration">Длина входных звуковых данных, которые соответствуют распознанному слову.  
  
 Это значение может быть равно <see cref="F:System.TimeSpan.Zero" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.RecognizedWordUnit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `text` или `pronunciation` , `null`, «», или <xref:System.String.Empty> и <xref:System.Speech.Recognition.RecognizedWordUnit> используется в операции распознавания, модуль распознавания создает соответствующие значения в выходных данных <xref:System.Speech.Recognition.RecognizedWordUnit> экземпляра.  
  
 Прямое построении <xref:System.Speech.Recognition.RecognizedWordUnit> экземпляры обычно используется только в том случае, если эмуляция операции распознавания, с помощью <xref:System.Speech.Recognition.SpeechRecognitionEngine.EmulateRecognize%2A> или <xref:System.Speech.Recognition.SpeechRecognitionEngine.EmulateRecognizeAsync%2A> методы <xref:System.Speech.Recognition.SpeechRecognitionEngine> класса и <xref:System.Speech.Recognition.SpeechRecognizer.EmulateRecognize%2A> или <xref:System.Speech.Recognition.SpeechRecognizer.EmulateRecognizeAsync%2A> методы <xref:System.Speech.Recognition.SpeechRecognizer> класса.  
  
 Для фактического приложений, не создавайте непосредственно <xref:System.Speech.Recognition.RecognizedWordUnit>, вместо получения его <xref:System.Speech.Recognition.RecognizedPhrase.Words%2A> свойство <xref:System.Speech.Recognition.RecognizedPhrase> объекта.  
  
   
  
## Examples  
 Следующий пример — это надуманный тест эмуляции, где создан из входных данных и передается в эмуляторе и затем проверяются новые слова.  
  
```csharp  
private void _emulateAndVerify_Click(object sender, EventArgs e)   
{  
  char[] delimiterChars = { ' ', ',', '.', ':', ';', '\t' };  
  string text = _emulateTextBox.Text;  
  string[] words = text.Split(delimiterChars);  
  
  RecognizedWordUnit[] InputWordUnits = new RecognizedWordUnit[words.Length];  
  for (int i = 0; i < words.Length; i++)   
  {  
    InputWordUnits[i] = new RecognizedWordUnit(  
        "",   
        0,   
        "",  
        words[i].ToLower(),   
        DisplayAttributes.OneTrailingSpace,   
        new TimeSpan(),   
        new TimeSpan());  
  }  
  
  RecognitionResult rec = _recognizer.EmulateRecognize(  
        InputWordUnits,   
        System.Globalization.CompareOptions.IgnoreCase);  
  if (rec == null)   
  {  
    MessageBox.Show(String.Format("Recognition emulation for {0} failed.\n", text));  
  }   
  else if (InputWordUnits.Length != rec.Words.Count)   
  {  
    MessageBox.Show(  
       String.Format("Length mismatch: Input was {0} words, Recognition has {1} words.\n}"));  
  }   
  else   
  {  
    for (int i = 0; i < InputWordUnits.Length; i++)   
    {  
  
      if (rec.Words[i].LexicalForm.ToLower() != InputWordUnits[i].LexicalForm.ToLower())   
      {  
        MessageBox.Show(  
          String.Format("Input word {0} \"{1}\" not found. Recognition output is {2}",  
          i, InputWordUnits[i].LexicalForm, rec.Words[i].LexicalForm));  
        continue;  
      }  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DisplayAttributes" />
      </Docs>
    </Member>
    <Member MemberName="Confidence">
      <MemberSignature Language="C#" Value="public float Confidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 Confidence" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.RecognizedWordUnit.Confidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Confidence As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float Confidence { float get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, присвоенное распознавателем, которое представляет вероятность того, что распознанное слово соответствует заданным входным данным.</summary>
        <value>Относительная меры точности для машинного правильного распознавания слов. Значение находится в диапазоне от 0,0 до 1,0 (низкая и высокая достоверность соответственно).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Достоверности не указывает абсолютный вероятность правильного распознавания слова. Вместо этого достоверности обеспечивают механизм для сравнения относительную точность нескольких альтернативных результатов распознавания для указанных введенных данных. Это облегчает, возвращая наиболее точный результат распознавания. Например если показатель достоверности 0,8 распознанного слова, это означает, что слово имеет 80% вероятность того, что совпадение точным для входных данных.  Он означает, что слово наиболее вероятные что совпадение точное, для ввода, чем другие результаты, имеющие достоверности оценки меньше, чем 0,8.  
  
 Показатель достоверности сам по себе не имеет смысла, если нет альтернативного результаты для сравнения, из одной и той же операции распознавания или из предыдущего отзывы одинаковыми входными данными.  
  
 Значения, возвращаемые методом <xref:System.Speech.Recognition.RecognizedWordUnit.Confidence%2A> : относительный и уникальным для каждого модуля распознавания. Отсутствует определение о сравнительных достоверность значения в диапазоне от двух разных распознавания, ни как <xref:System.Speech.Recognition.RecognizedWordUnit.Confidence%2A> отдельных <xref:System.Speech.Recognition.RecognizedWordUnit> объекты определяют <xref:System.Speech.Recognition.RecognizedPhrase.Confidence%2A> из <xref:System.Speech.Recognition.RecognizedPhrase>.  
  
 Распознавание речи может назначить низкий показатель достоверности ввода речи по различным причинам, включая фона помех, inarticulate речи или непредвиденных слова или word последовательностей. Если приложение использует <xref:System.Speech.Recognition.SpeechRecognitionEngine> экземпляр, можно изменить уровень достоверности какие речь приняты или отклонены с одним из входных данных <xref:System.Speech.Recognition.SpeechRecognitionEngine.UpdateRecognizerSetting%2A> методы. Пороговые значения достоверности для общего распознавателя, управляется <xref:System.Speech.Recognition.SpeechRecognizer>, связанные с профилем пользователя и хранится в реестре Windows. Приложения не следует записывать изменения в реестр для свойств общего распознавателя.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayAttributes">
      <MemberSignature Language="C#" Value="public System.Speech.Recognition.DisplayAttributes DisplayAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Speech.Recognition.DisplayAttributes DisplayAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.RecognizedWordUnit.DisplayAttributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayAttributes As DisplayAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Speech::Recognition::DisplayAttributes DisplayAttributes { System::Speech::Recognition::DisplayAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.DisplayAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает сведения о форматировании, используемые для создания текстового вывода из текущего экземпляра <see cref="T:System.Speech.Recognition.RecognizedWordUnit" />.</summary>
        <value>Указывает использование пробелов для отображения содержимого объекта <see cref="T:System.Speech.Recognition.RecognizedWordUnit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.DisplayAttributes> Объект, возвращаемый <xref:System.Speech.Recognition.RecognizedWordUnit.DisplayAttributes%2A> свойство задает начальные и конечные пробелы для использования с определенное слово, если таковые имеются.  
  
 Дополнительные сведения о том, как использовать эти сведения о форматировании см. в разделе <xref:System.Speech.Recognition.DisplayAttributes> перечисления.  
  
   
  
## Examples  
 В следующем примере показано служебной процедуры (`stringFromWordArray`), создает строку, которая форматируется в одном из трех способов: лексически (с помощью <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A>), нормализованную (с помощью <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A>), или произношении (с помощью <xref:System.Speech.Recognition.RecognizedWordUnit.Pronunciation%2A>). Текстовые выходные данные извлекаются из <xref:System.Speech.Recognition.RecognizedWordUnit.DisplayAttributes%2A> свойство <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> из <xref:System.Speech.Recognition.RecognizedWordUnit> объектов, которые извлекаются из <xref:System.Speech.Recognition.RecognizedPhrase.Words%2A> свойство <xref:System.Speech.Recognition.RecognizedPhrase> объекта.  
  
```csharp  
  
internal enum WordType   
{  
  Text,  
  Normalized = Text,  
  Lexical,  
  Pronunciation  
}  
```  
  
```csharp  
internal static string stringFromWordArray(  
        ReadOnlyCollection<RecognizedWordUnit> words,   
        WordType type)   
{  
  string text = "";  
  foreach (RecognizedWordUnit word in words)   
  {  
    string wordText = "";  
    if (type == WordType.Text || type == WordType.Normalized)   
    {  
      wordText = word.Text;  
    }   
    else if (type == WordType.Lexical)   
    {  
      wordText = word.LexicalForm;  
    }  
    else if (type == WordType.Pronunciation)   
    {  
       wordText = word.Pronunciation;  
    }   
    else   
    {  
      throw new InvalidEnumArgumentException(  
         String.Format("[0}: is not a valid input", type));  
    }  
  
    // Use display attribute  
    if ((word.DisplayAttributes & DisplayAttributes.OneTrailingSpace) != 0)   
    {  
      wordText += " ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.TwoTrailingSpaces) != 0)  
    {  
      wordText += "  ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ConsumeLeadingSpaces) != 0)   
    {  
      wordText = wordText.TrimStart();  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ZeroTrailingSpaces) != 0)  
    {  
      wordText = wordText.TrimEnd();  
    }  
  
    text += wordText;  
  
  }  
  return text;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DisplayAttributes" />
      </Docs>
    </Member>
    <Member MemberName="LexicalForm">
      <MemberSignature Language="C#" Value="public string LexicalForm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LexicalForm" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.RecognizedWordUnit.LexicalForm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LexicalForm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LexicalForm { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает ненормализованный текст распознанного слова.</summary>
        <value>Возвращает <see cref="T:System.String" />, содержащий текст распознанного слова, не выполняя нормализации.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев значения, возвращаемые методом <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A> и <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A> идентичны. Однако модули распознавания может использовать нормализацию речи для возврата более удобной для пользователей или colloquial текстовыми представлениями звукового ввода.  
  
 Нормализация речи используется одна специальная конструкция или символов, для выражения речи в записи. Например нормализация можно заменить произносимых слов «доллара и шестнадцать центов» «$1.16"в выходной текст.  
  
   
  
## Examples  
 В следующем примере показано программа подпрограмму, которая создает текст в одном из трех форматов: лексический (с помощью <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A>), нормализованную (с помощью <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A>) и фонетических (с помощью <xref:System.Speech.Recognition.RecognizedWordUnit.Pronunciation%2A>). Текстовые выходные данные извлекаются из <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> из <xref:System.Speech.Recognition.RecognizedWordUnit> объектов, которые извлекаются из <xref:System.Speech.Recognition.RecognizedPhrase.Words%2A> свойство <xref:System.Speech.Recognition.RecognizedPhrase> объекта.  
  
```csharp  
  
internal enum WordType   
{  
  Text,  
  Normalized = Text,  
  Lexical,  
  Pronunciation  
}  
```  
  
```csharp  
internal static string stringFromWordArray(  
         ReadOnlyCollection<RecognizedWordUnit> words,   
         WordType type)   
{  
  string text = "";  
  foreach (RecognizedWordUnit word in words)   
  {  
    string wordText = "";  
    if (type == WordType.Text || type == WordType.Normalized)   
    {  
      wordText = word.Text;  
    }   
    else if (type == WordType.Lexical)   
    {  
      wordText = word.LexicalForm;  
    }   
    else if (type == WordType.Pronunciation)   
    {  
      wordText = word.Pronunciation;  
    }   
    else   
    {  
      throw new InvalidEnumArgumentException(  
          String.Format("[0}: is not a valid input", type));  
    }  
  
    // Use display attribute  
    if ((word.DisplayAttributes & DisplayAttributes.OneTrailingSpace) != 0)   
    {  
      wordText += " ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.TwoTrailingSpaces) != 0)  
    {  
      wordText += "  ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ConsumeLeadingSpaces) != 0)   
    {  
      wordText = wordText.TrimStart();  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ZeroTrailingSpaces) != 0)  
    {  
    wordText = wordText.TrimEnd();  
    }  
  
    text += wordText;  
  
  }  
  return text;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DisplayAttributes" />
      </Docs>
    </Member>
    <Member MemberName="Pronunciation">
      <MemberSignature Language="C#" Value="public string Pronunciation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Pronunciation" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.RecognizedWordUnit.Pronunciation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Pronunciation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Pronunciation { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает фонетическое написание распознанного слова.</summary>
        <value>Строка символов из поддерживаемого фонетического алфавита, такого как международный фонетический алфавит (IPA) или универсальный набор звуков (UPS).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Содержимое <xref:System.Speech.Recognition.RecognizedWordUnit.Pronunciation%2A> указать, какие произношение распознавания речи, используемый для сопоставления входных данных речи для одного из его загруженного <xref:System.Speech.Recognition.Grammar> объектов. Произношение может быть определено в внутреннего лексикона механизма распознавания речи в документе лексики, связанного с Грамматика распознавания на загруженной <xref:System.Speech.Recognition.Grammar> объект или как встроенные в грамматику распознавания на загруженной <xref:System.Speech.Recognition.Grammar> объекта. Распознавание речи может также создавать произношения редко встречающиеся слова, чьи произношение не определены в лексики или грамматики, к которому распознавания речи в настоящее время имеет доступ.  
  
 Многие шрифты Юникода на основе Windows, например Courier New поддерживают отображение IPA строк. Дополнительные сведения см. в разделе [международного фонетического алфавита](http://go.microsoft.com/fwlink/?LinkId=58363).  
  
   
  
## Examples  
 В следующем примере показано программа подпрограмму, которая создает строку с одним из трех возможных форматов: лексический (с помощью <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A>), нормализованную (с помощью <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A>) и фонетических (с помощью <xref:System.Speech.Recognition.RecognizedWordUnit.Pronunciation%2A>). Текстовые выходные данные извлекаются из <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> из <xref:System.Speech.Recognition.RecognizedWordUnit> объектов, которые извлекаются из <xref:System.Speech.Recognition.RecognizedPhrase.Words%2A> свойство <xref:System.Speech.Recognition.RecognizedPhrase> объекта.  
  
```csharp  
  
internal enum WordType   
{  
  Text,  
  Normalized = Text,  
  Lexical,  
  Pronunciation  
}  
```  
  
```csharp  
internal static string stringFromWordArray(  
          ReadOnlyCollection<RecognizedWordUnit> words,   
          WordType type)   
{  
  string text = "";  
  foreach (RecognizedWordUnit word in words)   
  {  
    string wordText = "";  
    if (type == WordType.Text || type == WordType.Normalized)   
    {  
      wordText = word.Text;  
    }   
    else if (type == WordType.Lexical)   
    {  
      wordText = word.LexicalForm;  
    }   
    else if (type == WordType.Pronunciation)   
    {  
      wordText = word.Pronunciation;  
    }   
    else   
    {  
      throw new InvalidEnumArgumentException(  
          String.Format("[0}: is not a valid input", type));  
    }  
    // Use display attribute  
  
    if ((word.DisplayAttributes & DisplayAttributes.OneTrailingSpace) != 0)   
    {  
      wordText += " ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.TwoTrailingSpaces) != 0)   
    {  
      wordText += "  ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ConsumeLeadingSpaces) != 0)   
    {  
      wordText = wordText.TrimStart();  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ZeroTrailingSpaces) != 0)   
    {  
      wordText = wordText.TrimEnd();  
    }  
  
    text += wordText;  
  }  
  return text;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DisplayAttributes" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.RecognizedWordUnit.Text" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает нормализованный текст для распознанного слова.</summary>
        <value>Строка, содержащая нормализованный текстовый вывод для данного введенного слова.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев значения, возвращаемые методом <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A> и <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A> , будут идентичны. Однако модули распознавания может использовать нормализацию речи для возврата более удобной для пользователей или colloquial текстовыми представлениями звукового ввода.  
  
 Нормализация речи используется одна специальная конструкция или символов, для выражения речи в записи. Например нормализация можно заменить произносимых слов «доллара и шестнадцать центов» «$1.16"в выходной текст.  
  
   
  
## Examples  
 В следующем примере показано программа подпрограмму, которая создает строку в одном из трех форматов: лексический (с помощью <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A>), нормализованную (с помощью <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A>) и фонетических (с помощью <xref:System.Speech.Recognition.RecognizedWordUnit.Pronunciation%2A>). Текстовые выходные данные извлекаются из <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> из <xref:System.Speech.Recognition.RecognizedWordUnit> объектов, которые извлекаются из <xref:System.Speech.Recognition.RecognizedPhrase.Words%2A> свойство <xref:System.Speech.Recognition.RecognizedPhrase> объекта.  
  
```csharp  
  
internal enum WordType   
{  
  Text,  
  Normalized = Text,  
  Lexical,  
  Pronunciation  
}  
```  
  
```csharp  
internal static string stringFromWordArray(  
          ReadOnlyCollection<RecognizedWordUnit> words,   
          WordType type)   
{  
  string text = "";  
  foreach (RecognizedWordUnit word in words)   
  {  
    string wordText = "";  
    if (type == WordType.Text || type == WordType.Normalized)   
    {  
      wordText = word.Text;  
    }   
    else if (type == WordType.Lexical)   
    {  
      wordText = word.LexicalForm;  
    }   
    else if (type == WordType.Pronunciation)   
    {  
      wordText = word.Pronunciation;  
    }   
    else   
    {  
      throw new InvalidEnumArgumentException(  
           String.Format("[0}: is not a valid input", type));  
    }  
  
    // Use display attribute  
    if ((word.DisplayAttributes & DisplayAttributes.OneTrailingSpace) != 0)   
    {  
      wordText += " ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.TwoTrailingSpaces) != 0)   
    {  
      wordText += "  ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ConsumeLeadingSpaces) != 0)   
    {  
      wordText = wordText.TrimStart();  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ZeroTrailingSpaces) != 0)   
    {  
      wordText = wordText.TrimEnd();  
    }  
  
    text += wordText;  
  
  }  
  return text;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>