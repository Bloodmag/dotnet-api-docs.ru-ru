<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Match.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5fb63372e2192302c84aaf2b9879a89ead4000664.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fb63372e2192302c84aaf2b9879a89ead4000664</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Match">
          <source>Represents the results from a single regular expression match.</source>
          <target state="translated">Представляет результаты из отдельного совпадения регулярного выражения.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object is immutable and has no public constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> Является постоянным и не имеет открытого конструктора.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> class is returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> method and represents the first pattern match in a string.</source>
          <target state="translated">Экземпляр <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> класс возвращается посредством <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> метод и представляет первый шаблон соответствует в строке.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Subsequent matches are represented by <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Последующие соответствия, представляются <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объектов, возвращенных <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>In addition, a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object that consists of zero, one, or more <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects is returned by the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Кроме того <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> , состоящий из нуля, одного или нескольких <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> возвращенных объектов <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>If the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> method fails to match a regular expression pattern in an input string, it returns an empty <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> метод не соответствует шаблону регулярного выражения во входной строке, то возвращается пустая коллекция типа <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can then use a <ph id="ph1">`foreach`</ph> construct in C# or a <ph id="ph2">`For Each`</ph> construct in Visual Basic to iterate the collection.</source>
          <target state="translated">Затем можно использовать <ph id="ph1">`foreach`</ph> конструкции в C# или <ph id="ph2">`For Each`</ph> построения в Visual Basic для прохода по коллекции.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>If the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> method fails to match the regular expression pattern, it returns a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object that is equal to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.Empty%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> метод не соответствует шаблону регулярного выражения, он возвращает <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта, равное <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.Empty%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property to determine whether the match was successful.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> свойства, чтобы определить, успешно ли выполнено сопоставление.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The following example provides an illustration.</source>
          <target state="translated">Ниже приведен пример.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>If a pattern match is successful, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the matched substring, the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Index%2A&gt;</ph> property indicates the zero-based starting position of the matched substring in the input string, and the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Capture.Length%2A&gt;</ph> property indicates the length of matched substring in the input string.</source>
          <target state="translated">При успешном соответствия шаблону <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> свойство содержит совпадающую подстроку <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Index%2A&gt;</ph> свойство указывает отсчитываемый от нуля начальную позицию сопоставленной подстроки во входной строке и <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Capture.Length%2A&gt;</ph> указывает свойство Длина сопоставленной подстроки во входной строке.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Because a single match can involve multiple capturing groups, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> has a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> property that returns the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph>.</source>
          <target state="translated">Так как в одном сопоставлении может включать несколько групп захвата, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> имеет <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> свойство, которое возвращает <ph id="ph3">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> instance itself is equivalent to the first object in the collection, at <ph id="ph2">`Match.Groups[0]`</ph> (<ph id="ph3">`Match.Groups(0)`</ph> in Visual Basic), which represents the entire match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> Самого экземпляра эквивалентен первый объект в коллекции, в <ph id="ph2">`Match.Groups[0]`</ph> (<ph id="ph3">`Match.Groups(0)`</ph> в Visual Basic), который представляет все сопоставление.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can access the captured groups in a match in the following ways:</source>
          <target state="translated">Вы можете использовать захватываемые группы в соответствие следующим образом:</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can iterate the members of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object  by using a <ph id="ph2">`foreach`</ph> (C#) or <ph id="ph3">`For Each`</ph> (Visual Basic) construct.</source>
          <target state="translated">Можно выполнять итерацию по элементам <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> объектов с помощью <ph id="ph2">`foreach`</ph> (C#) или <ph id="ph3">`For Each`</ph> конструкции (Visual Basic).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%28System.Int32%29?displayProperty=nameWithType&gt;</ph> property to retrieve groups by the number of the capturing group.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%28System.Int32%29?displayProperty=nameWithType&gt;</ph> свойства, чтобы получить группы по номеру группы записи.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Note that you can determine which numbered groups are present in a regular expression by calling the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Обратите внимание, что можно определить, какие нумерованные группы в регулярном выражении путем вызова экземпляра <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%28System.String%29?displayProperty=nameWithType&gt;</ph> property to retrieve groups by the name of the capturing group.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%28System.String%29?displayProperty=nameWithType&gt;</ph> свойство для получения групп по имени захватываемой группы.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Note that you can determine which named groups are present in a regular expression by calling the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNames?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Обратите внимание, что можно определить, какие именованные группы присутствуют в регулярном выражении, вызвав экземпляр <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNames?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The following examples use the regular expression <ph id="ph1">`Console\.Write(Line)?`</ph>.</source>
          <target state="translated">В следующих примерах используется регулярное выражение <ph id="ph1">`Console\.Write(Line)?`</ph>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The regular expression is interpreted as follows:</source>
          <target state="translated">Регулярное выражение интерпретируется следующим образом:</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Console<ph id="ph1">\\</ph>.Write</source>
          <target state="translated">Консоль<ph id="ph1">\\</ph>. Записи</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Match the string "Console.Write".</source>
          <target state="translated">Совпадение со строкой "Console.Write".</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Note that the "." character is escaped so that it is interpreted as a literal period rather than as a wildcard that matches any character.</source>
          <target state="translated">Обратите внимание, что «.» экранируется, так что он интерпретируется как литерал период, а не как подстановочный знак, который соответствует любому символу.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>(Line)?</source>
          <target state="translated">(Строка)?</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Match zero or one occurrence of the string "Line".</source>
          <target state="translated">Совпадение с нулевым или единичным вхождением строки "Line".</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Пример 1.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method to retrieve all pattern matches in an input string.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> метод для извлечения всех совпадения во входной строке.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>It then iterates the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects in the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object to display information about each match.</source>
          <target state="translated">Затем выполняется итерация <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объектов в возвращаемом <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> объекта для отображения сведений о каждом.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Пример 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> methods to retrieve one match at a time.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> и <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> методы для получения одного совпадения одновременно.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Match.Empty">
          <source>Gets the empty group.</source>
          <target state="translated">Получает пустую группу.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Match.Empty">
          <source>All failed matches return this empty match.</source>
          <target state="translated">Все неудавшиеся совпадения возвращают это пустое совпадение.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Empty">
          <source>An empty match.</source>
          <target state="translated">Пустое совпадение.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Empty">
          <source>This property should not be used to determine if a match is successful.</source>
          <target state="translated">Это свойство не должно использоваться для определения, является ли совпадение успешно.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Empty">
          <source>Instead, use the <ph id="ph1">`Match.Success`</ph> property (which is inherited from <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Вместо этого используйте <ph id="ph1">`Match.Success`</ph> свойство (которое наследуется от <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>Gets a collection of groups matched by the regular expression.</source>
          <target state="translated">Получает коллекцию групп, соответствующих регулярному выражению.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The character groups matched by the pattern.</source>
          <target state="translated">Группы символов, соответствующие шаблону.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>A regular expression pattern can include subexpressions, which are defined by enclosing a portion of the regular expression pattern in parentheses.</source>
          <target state="translated">Шаблон регулярного выражения могут включать частями выражения, которые определяются путем заключения часть шаблона регулярного выражения в скобках.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>Every such subexpression forms a group.</source>
          <target state="translated">Каждое такое подвыражение образует группу.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> property provides access to information about those subexpression matches.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> Свойство предоставляет доступ к информации об этих подвыражений.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>For example, the regular expression pattern <ph id="ph1">`(\d{3})-(\d{3}-\d{4})`</ph>, which matches North American telephone numbers, has two subexpressions.</source>
          <target state="translated">Например, шаблон регулярного выражения <ph id="ph1">`(\d{3})-(\d{3}-\d{4})`</ph>, который сопоставляется с североамериканский телефонные номера, имеет две части выражения.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The first consists of the area code, which composes the first three digits of the telephone number.</source>
          <target state="translated">Первый состоит из кода города, составляющих первые три цифры номера телефона.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>This group is captured by the first portion of the regular expression, <ph id="ph1">`(\d{3})`</ph>.The second consists of the individual telephone number, which composes the last seven digits of the telephone number.</source>
          <target state="translated">Эта группа была зафиксирована первой частью регулярного выражения, <ph id="ph1">`(\d{3})`</ph>. Вторая состоит из отдельных телефонных номеров, которые включат последние семь цифр номера телефона.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>This group is captured by the second portion of the regular expression, <ph id="ph1">`(\d{3}-\d{4})`</ph>.</source>
          <target state="translated">Эта группа была захвачена во второй части регулярного выражения <ph id="ph1">`(\d{3}-\d{4})`</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>These two groups can then be retrieved from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object that is returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> property, as the following example shows.</source>
          <target state="translated">Эти две группы может быть извлечен из <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> объект, возвращаемый <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> свойства, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> property is a zero-based collection object that always has at least one member.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> Объект, возвращаемый <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> свойство является объектом коллекции (с нуля), всегда содержит по крайней мере один из элементов.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>If the regular expression engine cannot find any matches in a particular input string, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType&gt;</ph> property of the single <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object in the collection (the object at index 0) is set to <ph id="ph3">`false`</ph> and the <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object's <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property is set to <ph id="ph6">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если обработчик регулярных выражений не может найти совпадения в конкретной входной строке <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType&gt;</ph> свойства отдельного <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> объекта в коллекции (объект с индексом 0) задано значение <ph id="ph3">`false`</ph> и <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> объекта <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph>свойству <ph id="ph6">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>If the regular expression engine can find a match, the first element of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object (the element at index 0) returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> property contains a string that matches the entire regular expression pattern.</source>
          <target state="translated">Если обработчик регулярных выражений может найти совпадения, первый элемент <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> объект (элемент с индексом 0), возвращаемый <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> свойство содержит строку, которая соответствует шаблону всему регулярному выражению.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>Each subsequent element, from index one upward, represents a captured group, if the regular expression includes capturing groups.</source>
          <target state="translated">Каждый последующий элемент из одного индекса снизу вверх, представляет группу записи, если регулярное выражение содержит захватываемые группы.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>For more information, see the "Grouping Constructs and Regular Expression Objects" section of the <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept> article.</source>
          <target state="translated">Дополнительные сведения см. в разделе «Группирование создает и объекты регулярных выражений» из <bpt id="p1">[</bpt>конструкции группировки<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept> статьи.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The following example attempts to match a regular expression pattern against a sample string.</source>
          <target state="translated">В следующем примере предпринимается должно соответствовать шаблону регулярного выражения и образца строки.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> property to store information that is retrieved by the match for display to the console.</source>
          <target state="translated">В этом примере <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> свойство для хранения информации, возвращенной сопоставлением для отображения в консоли.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Returns a new <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> object with the results for the next match, starting at the position at which the last match ended (at the character after the last matched character).</source>
          <target state="translated">Возвращает новый объект <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> с результатами для следующего сопоставления, начиная с позиции, на которой завершилось последнее сопоставление (с символа после последнего сопоставленного символа).</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The next regular expression match.</source>
          <target state="translated">Следующее сопоставление регулярному выражению.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>This method is similar to calling <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> again and passing (<ph id="ph2">`Index+Length`</ph>) as the new starting position.</source>
          <target state="translated">Этот метод аналогичен вызову метода <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> снова и передача (<ph id="ph2">`Index+Length`</ph>) в качестве новой начальной позиции.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>This method does not modify the current instance.</source>
          <target state="translated">Этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Instead, it returns a new <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object that contains information about the next match.</source>
          <target state="translated">Вместо этого он возвращает новый <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объект, содержащий сведения о следующего совпадения.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Attempting to retrieve the next match may throw a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> if a time-out value for matching operations is in effect and the attempt to find the next match exceeds that time-out interval.</source>
          <target state="translated">Попытка получения следующего соответствия могут вызывать <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Если действует значение времени ожидания для операций поиска соответствий, и попытка найти следующее совпадение превышает заданный интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> method to capture regular expression matches beyond the first match.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> метод для захвата регулярного выражения соответствует после первого совпадения.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>When a match attempt is repeated by calling the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> method, the regular expression engine gives empty matches special treatment.</source>
          <target state="translated">При повторном попытки поиска совпадения, вызвав <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> , обработчик регулярных выражений дает пустые совпадения особым образом.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Usually, <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> begins the search for the next match exactly where the previous match left off.</source>
          <target state="translated">Как правило <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> начинает поиск следующего соответствия точно предыдущего совпадения места остановки.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>However, after an empty match, the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> method advances by one character before trying the next match.</source>
          <target state="translated">Однако после пустого совпадения <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> метод перемещает один символ перед попыткой следующего совпадения.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>This behavior guarantees that the regular expression engine will progress through the string.</source>
          <target state="translated">Это гарантирует, что обработчик регулярных выражений развивается по строке.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Otherwise, because an empty match does not result in any forward movement, the next match would start in exactly the same place as the previous match, and it would match the same empty string repeatedly.</source>
          <target state="translated">В противном случае — поскольку пустое совпадение не приведет к любой продвижение вперед, следующее соответствие начнется в той же позиции, что и предыдущий и многократно будет соответствовать же пустая строка.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The following example provides an illustration.</source>
          <target state="translated">Ниже приведен пример.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The regular expression pattern <bpt id="p1">&lt;c&gt;</bpt>a*<ept id="p1">&lt;/c&gt;</ept> searches for zero or more occurrences of the letter "a" in the string "abaabb".</source>
          <target state="translated">Шаблон регулярного выражения <bpt id="p1">&lt;c&gt;</bpt>*<ept id="p1">&lt;/c&gt;</ept> ищет ноль или более вхождений буквы «» в строке «abaabb».</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>As the output from the example shows, the search finds six matches.</source>
          <target state="translated">Как показывают выходные данные примера, поиск совпадения шесть.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The first match attempt finds the first "a".</source>
          <target state="translated">Первая попытка match находит первый «».</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The second match starts exactly where the first match ends, before the first b; it finds zero occurrences of "a" and returns an empty string.</source>
          <target state="translated">Второе соответствие начинается, где первый совпадать заканчивается перед первой b; он выполняет поиск вхождений «a» и возвращает пустую строку.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The third match does not begin exactly where the second match ended, because the second match returned an empty string.</source>
          <target state="translated">Третье соответствие не начинается точно там, где второе соответствие закончилось, так как второе соответствие возвратил пустую строку.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Instead, it begins one character later, after the first "b".</source>
          <target state="translated">Вместо этого оно начинается на один знак позже, после первой «b».</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The third match finds two occurrences of "a" and returns "aa".</source>
          <target state="translated">Третье соответствие находит два вхождения «a» и возвращает «aa».</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The fourth match attempt begins where the third match ended, before the second "b", and returns an empty string.</source>
          <target state="translated">Начинает четвертой попытки поиска совпадения, где закончилось третье, перед второй буквой «b» и возвращает пустую строку.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The fifth match attempt again advances one character so that it begins before the third "b" and returns an empty string.</source>
          <target state="translated">Пятый попытки поиска совпадения снова перемещает один символ, чтобы он начинается до третьей «b» и возвращает пустую строку.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The sixth match begins after the last "b" and returns an empty string again.</source>
          <target state="translated">Шестой поиск начинается после последнего «b» и снова возвращает пустую строку.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The replacement pattern to use.</source>
          <target state="translated">Шаблон замены для использования.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Returns the expansion of the specified replacement pattern.</source>
          <target state="translated">Возвращает расширение указанного шаблона замены.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The expanded version of the <ph id="ph1">&lt;paramref name="replacement" /&gt;</ph> parameter.</source>
          <target state="translated">Расширенная версия параметра <ph id="ph1">&lt;paramref name="replacement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Whereas the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType&gt;</ph> method replaces all matches in an input string with a specified replacement pattern, the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Result%2A&gt;</ph> method replaces a single match with a specified replacement pattern.</source>
          <target state="translated">В то время как <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType&gt;</ph> метод заменяет все совпадения во входной строке указанного шаблона замены, <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Result%2A&gt;</ph> метод заменяет совпадение указанного шаблона замены.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Because it operates on an individual match, it is also possible to perform processing on the matched string before you call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Result%2A&gt;</ph> method.</source>
          <target state="translated">Так как она работает с отдельными соответствия, можно также для обработки в сопоставленной строке перед вызовом метода <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Result%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The <ph id="ph1">`replacement`</ph> parameter is a standard regular expression replacement pattern.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> Параметр — это шаблон Стандартная регулярных выражений замены.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>It can consist of literal characters and regular expression substitutions.</source>
          <target state="translated">Он может включать литералы и знаки подстановки регулярного выражения.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>For more information, see <bpt id="p1">[</bpt>Substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Подстановки<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The following example replaces the hyphens that begin and end a parenthetical expression with parentheses.</source>
          <target state="translated">В следующем примере заменяется дефисы в начале и конце со скобками выражения со скобками.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The regular expression pattern <ph id="ph1">`--(.+?)--`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Возможные интерпретации шаблона регулярного выражения <ph id="ph1">`--(.+?)--`</ph> показаны в следующей таблице.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Match two hyphens.</source>
          <target state="translated">Поиск двух дефисов.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Match any character one or more times, but as few times as possible.</source>
          <target state="translated">Совпадение с любым символом один или несколько раз, но как можно меньшее число раз.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>This is the first capturing group.</source>
          <target state="translated">Это первая группа записи.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Match two hyphens.</source>
          <target state="translated">Поиск двух дефисов.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Note that the regular expression pattern <ph id="ph1">`--(.+?)--`</ph> uses the lazy quantifier <ph id="ph2">`+?`</ph>.</source>
          <target state="translated">Обратите внимание, что шаблон регулярного выражения <ph id="ph1">`--(.+?)--`</ph> использует ленивый квантификатор <ph id="ph2">`+?`</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>If the greedy quantifier <ph id="ph1">`+`</ph> were used instead, the regular expression engine would find only a single match in the input string.</source>
          <target state="translated">Если жадный квантификатор <ph id="ph1">`+`</ph> были использованы вместо этого обработчик регулярных выражений поиска только одно соответствие во входной строке.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The replacement string <ph id="ph1">`($1)`</ph> replaces the match with the first captured group, which is enclosed in parentheses.</source>
          <target state="translated">Строка замены <ph id="ph1">`($1)`</ph> заменяет совпадение первой захватываемой группы, которые заключены в круглые скобки.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source><ph id="ph1">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="replacement" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Expansion is not allowed for this pattern.</source>
          <target state="translated">Расширение для этого шаблона не разрешено.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)">
          <source>A regular expression match equivalent to the one expected.</source>
          <target state="translated">Сопоставление регулярному выражению, эквивалентное ожидаемому.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> instance equivalent to the one supplied that is suitable to share between multiple threads.</source>
          <target state="translated">Возвращает экземпляр <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph>, который эквивалентен одному из предоставленных экземпляров, пригодному для совместного использования несколькими потоками.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)">
          <source>A regular expression match that is suitable to share between multiple threads.</source>
          <target state="translated">Сопоставление регулярному выражению, пригодное для разделения между несколькими потоками.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)">
          <source><ph id="ph1">&lt;paramref name="inner" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="inner" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>