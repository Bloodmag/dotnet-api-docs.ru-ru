<Type Name="Match" FullName="System.Text.RegularExpressions.Match">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c886bcea5d17b2ba683b40687e65b1b31de9ad20" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36408141" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Match : System.Text.RegularExpressions.Group" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Match extends System.Text.RegularExpressions.Group" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Match" />
  <TypeSignature Language="VB.NET" Value="Public Class Match&#xA;Inherits Group" />
  <TypeSignature Language="C++ CLI" Value="public ref class Match : System::Text::RegularExpressions::Group" />
  <TypeSignature Language="F#" Value="type Match = class&#xA;    inherit Group" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.RegularExpressions.Group</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Представляет результаты из отдельного совпадения регулярного выражения.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Match> Является постоянным и не имеет открытого конструктора. Экземпляр <xref:System.Text.RegularExpressions.Match> класс возвращается посредством <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> метод и представляет первый шаблон соответствует в строке. Последующие соответствия, представляются <xref:System.Text.RegularExpressions.Match> объектов, возвращенных <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод. Кроме того <xref:System.Text.RegularExpressions.MatchCollection> , состоящий из нуля, одного или нескольких <xref:System.Text.RegularExpressions.Match> возвращенных объектов <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> метод.  
  
 Если <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> метод не соответствует шаблону регулярного выражения во входной строке, то возвращается пустая коллекция типа <xref:System.Text.RegularExpressions.MatchCollection> объекта. Затем можно использовать `foreach` конструкции в C# или `For Each` построения в Visual Basic для прохода по коллекции.  
  
 Если <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> метод не соответствует шаблону регулярного выражения, он возвращает <xref:System.Text.RegularExpressions.Match> объекта, равное <xref:System.Text.RegularExpressions.Match.Empty%2A?displayProperty=nameWithType>. Можно использовать <xref:System.Text.RegularExpressions.Group.Success%2A> свойства, чтобы определить, успешно ли выполнено сопоставление. Ниже приведен пример.  
  
 [!code-csharp[System.Text.RegularExpressions.Match.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/cs/Match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Match.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/vb/Match1.vb#1)]  
  
 При успешном соответствия шаблону <xref:System.Text.RegularExpressions.Capture.Value%2A> свойство содержит совпадающую подстроку <xref:System.Text.RegularExpressions.Capture.Index%2A> свойство указывает отсчитываемый от нуля начальную позицию сопоставленной подстроки во входной строке и <xref:System.Text.RegularExpressions.Capture.Length%2A> указывает свойство Длина сопоставленной подстроки во входной строке.  
  
 Так как в одном сопоставлении может включать несколько групп захвата, <xref:System.Text.RegularExpressions.Match> имеет <xref:System.Text.RegularExpressions.Match.Groups%2A> свойство, которое возвращает <xref:System.Text.RegularExpressions.GroupCollection>. <xref:System.Text.RegularExpressions.Match> Самого экземпляра эквивалентен первый объект в коллекции, в `Match.Groups[0]` (`Match.Groups(0)` в Visual Basic), который представляет все сопоставление. Вы можете использовать захватываемые группы в соответствие следующим образом:  
  
-   Можно выполнять итерацию по элементам <xref:System.Text.RegularExpressions.GroupCollection> объектов с помощью `foreach` (C#) или `For Each` конструкции (Visual Basic).  
  
-   Можно использовать <xref:System.Text.RegularExpressions.GroupCollection.Item%28System.Int32%29?displayProperty=nameWithType> свойства, чтобы получить группы по номеру группы записи. Обратите внимание, что можно определить, какие нумерованные группы в регулярном выражении путем вызова экземпляра <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A?displayProperty=nameWithType> метод.  
  
-   Можно использовать <xref:System.Text.RegularExpressions.GroupCollection.Item%28System.String%29?displayProperty=nameWithType> свойство для получения групп по имени захватываемой группы. Обратите внимание, что можно определить, какие именованные группы присутствуют в регулярном выражении, вызвав экземпляр <xref:System.Text.RegularExpressions.Regex.GetGroupNames?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующих примерах используется регулярное выражение `Console\.Write(Line)?`. Регулярное выражение интерпретируется следующим образом:  
  
|||  
|-|-|  
|Консоль\\. Записи|Совпадение со строкой "Console.Write". Обратите внимание, что «.» экранируется, так что он интерпретируется как литерал период, а не как подстановочный знак, который соответствует любому символу.|  
|(Строка)?|Совпадение с нулевым или единичным вхождением строки "Line".|  
  
 **Пример 1.**  
  
 В следующем примере вызывается <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> метод для извлечения всех совпадения во входной строке. Затем выполняется итерация <xref:System.Text.RegularExpressions.Match> объектов в возвращаемом <xref:System.Text.RegularExpressions.MatchCollection> объекта для отображения сведений о каждом.  
  
 [!code-csharp[System.Text.RegularExpressions.Match.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/cs/Match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Match.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/vb/Match2.vb#2)]  
  
 **Пример 2**  
  
 В следующем примере вызывается <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> и <xref:System.Text.RegularExpressions.Match.NextMatch%2A> методы для получения одного совпадения одновременно.  
  
 [!code-csharp[System.Text.RegularExpressions.Match.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/cs/Match3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Match.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/vb/Match3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.RegularExpressions.MatchCollection" />
    <altmember cref="T:System.Text.RegularExpressions.Regex" />
  </Docs>
  <Members>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.RegularExpressions.Match Empty" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Match.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::RegularExpressions::Match ^ Empty { System::Text::RegularExpressions::Match ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Empty : System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Match.Empty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает пустую группу. Все неудавшиеся совпадения возвращают это пустое совпадение.</summary>
        <value>Пустое совпадение.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство не должно использоваться для определения, является ли совпадение успешно. Вместо этого используйте `Match.Success` свойство (которое наследуется от <xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Groups">
      <MemberSignature Language="C#" Value="public virtual System.Text.RegularExpressions.GroupCollection Groups { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.RegularExpressions.GroupCollection Groups" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Match.Groups" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Groups As GroupCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Text::RegularExpressions::GroupCollection ^ Groups { System::Text::RegularExpressions::GroupCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Groups : System.Text.RegularExpressions.GroupCollection" Usage="System.Text.RegularExpressions.Match.Groups" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.GroupCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию групп, соответствующих регулярному выражению.</summary>
        <value>Группы символов, соответствующие шаблону.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шаблон регулярного выражения могут включать частями выражения, которые определяются путем заключения часть шаблона регулярного выражения в скобках. Каждое такое подвыражение образует группу. <xref:System.Text.RegularExpressions.Match.Groups%2A> Свойство предоставляет доступ к информации об этих подвыражений. Например, шаблон регулярного выражения `(\d{3})-(\d{3}-\d{4})`, который сопоставляется с североамериканский телефонные номера, имеет две части выражения. Первый состоит из кода города, составляющих первые три цифры номера телефона. Эта группа была зафиксирована первой частью регулярного выражения, `(\d{3})`. Вторая состоит из отдельных телефонных номеров, которые включат последние семь цифр номера телефона. Эта группа была захвачена во второй части регулярного выражения `(\d{3}-\d{4})`. Эти две группы может быть извлечен из <xref:System.Text.RegularExpressions.GroupCollection> объект, возвращаемый <xref:System.Text.RegularExpressions.Match.Groups%2A> свойства, как показано в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Match.Groups#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.match.groups/cs/groups1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Match.Groups#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.match.groups/vb/groups1.vb#1)]  
  
 <xref:System.Text.RegularExpressions.GroupCollection> Объект, возвращаемый <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> свойство является объектом коллекции (с нуля), всегда содержит по крайней мере один из элементов. Если обработчик регулярных выражений не может найти совпадения в конкретной входной строке <xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType> свойства отдельного <xref:System.Text.RegularExpressions.Group> объекта в коллекции (объект с индексом 0) задано значение `false` и <xref:System.Text.RegularExpressions.Group> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A>свойству <xref:System.String.Empty?displayProperty=nameWithType>. Если обработчик регулярных выражений может найти совпадения, первый элемент <xref:System.Text.RegularExpressions.GroupCollection> объект (элемент с индексом 0), возвращаемый <xref:System.Text.RegularExpressions.Match.Groups%2A> свойство содержит строку, которая соответствует шаблону всему регулярному выражению. Каждый последующий элемент из одного индекса снизу вверх, представляет группу записи, если регулярное выражение содержит захватываемые группы. Дополнительные сведения см. в разделе «Группирование создает и объекты регулярных выражений» из [конструкции группировки](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md) статьи.  
  
   
  
## Examples  
 В следующем примере предпринимается должно соответствовать шаблону регулярного выражения и образца строки. В этом примере <xref:System.Text.RegularExpressions.Match.Groups%2A> свойство для хранения информации, возвращенной сопоставлением для отображения в консоли.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextMatch">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match NextMatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match NextMatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Match.NextMatch" />
      <MemberSignature Language="VB.NET" Value="Public Function NextMatch () As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ NextMatch();" />
      <MemberSignature Language="F#" Value="member this.NextMatch : unit -&gt; System.Text.RegularExpressions.Match" Usage="match.NextMatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает новый объект <see cref="T:System.Text.RegularExpressions.Match" /> с результатами для следующего сопоставления, начиная с позиции, на которой завершилось последнее сопоставление (с символа после последнего сопоставленного символа).</summary>
        <returns>Следующее сопоставление регулярному выражению.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод аналогичен вызову метода <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> снова и передача (`Index+Length`) в качестве новой начальной позиции.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новый <xref:System.Text.RegularExpressions.Match> объект, содержащий сведения о следующего совпадения.  
  
 Попытка получения следующего соответствия могут вызывать <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Если действует значение времени ожидания для операций поиска соответствий, и попытка найти следующее совпадение превышает заданный интервал времени ожидания.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.RegularExpressions.Match.NextMatch%2A> метод для захвата регулярного выражения соответствует после первого совпадения.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло.</exception>
        <block subset="none" type="usage">
          <para>При повторном попытки поиска совпадения, вызвав <see cref="M:System.Text.RegularExpressions.Match.NextMatch" /> , обработчик регулярных выражений дает пустые совпадения особым образом. Как правило <see cref="M:System.Text.RegularExpressions.Match.NextMatch" /> начинает поиск следующего соответствия точно предыдущего совпадения места остановки. Однако после пустого совпадения <see cref="M:System.Text.RegularExpressions.Match.NextMatch" /> метод перемещает один символ перед попыткой следующего совпадения. Это гарантирует, что обработчик регулярных выражений развивается по строке. В противном случае — поскольку пустое совпадение не приведет к любой продвижение вперед, следующее соответствие начнется в той же позиции, что и предыдущий и многократно будет соответствовать же пустая строка.  Ниже приведен пример. Шаблон регулярного выражения <c>*</c> ищет ноль или более вхождений буквы «» в строке «abaabb». Как показывают выходные данные примера, поиск совпадения шесть. Первая попытка match находит первый «». Второе соответствие начинается, где первый совпадать заканчивается перед первой b; он выполняет поиск вхождений «a» и возвращает пустую строку. Третье соответствие не начинается точно там, где второе соответствие закончилось, так как второе соответствие возвратил пустую строку. Вместо этого оно начинается на один знак позже, после первой «b». Третье соответствие находит два вхождения «a» и возвращает «aa». Начинает четвертой попытки поиска совпадения, где закончилось третье, перед второй буквой «b» и возвращает пустую строку. Пятый попытки поиска совпадения снова перемещает один символ, чтобы он начинается до третьей «b» и возвращает пустую строку. Шестой поиск начинается после последнего «b» и снова возвращает пустую строку.  [! code-csharp[System.Text.RegularExpressions.Match.NextMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.match.nextmatch/cs/nextmatch1.cs#1)] [! code-vb[System.Text.RegularExpressions.Match.NextMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.match.nextmatch/vb/nextmatch1.vb#1)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Result">
      <MemberSignature Language="C#" Value="public virtual string Result (string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string Result(string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Match.Result(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Result (replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ Result(System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="abstract member Result : string -&gt; string&#xA;override this.Result : string -&gt; string" Usage="match.Result replacement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="replacement">Шаблон замены для использования.</param>
        <summary>Возвращает расширение указанного шаблона замены.</summary>
        <returns>Расширенная версия параметра <paramref name="replacement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В то время как <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> метод заменяет все совпадения во входной строке указанного шаблона замены, <xref:System.Text.RegularExpressions.Match.Result%2A> метод заменяет совпадение указанного шаблона замены. Так как она работает с отдельными соответствия, можно также для обработки в сопоставленной строке перед вызовом метода <xref:System.Text.RegularExpressions.Match.Result%2A> метод.  
  
 `replacement` Параметр — это шаблон Стандартная регулярных выражений замены. Он может включать литералы и знаки подстановки регулярного выражения. Дополнительные сведения см. в разделе [Подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md).  
  
   
  
## Examples  
 В следующем примере заменяется дефисы в начале и конце со скобками выражения со скобками.  
  
 [!code-csharp[System.Text.RegularExpressions.Match.Result#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.match.result/cs/result1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Match.Result#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.match.result/vb/result1.vb#1)]  
  
 Возможные интерпретации шаблона регулярного выражения `--(.+?)--` показаны в следующей таблице.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`--`|Поиск двух дефисов.|  
|`(.+?)`|Совпадение с любым символом один или несколько раз, но как можно меньшее число раз. Это первая группа записи.|  
|`--`|Поиск двух дефисов.|  
  
 Обратите внимание, что шаблон регулярного выражения `--(.+?)--` использует ленивый квантификатор `+?`. Если жадный квантификатор `+` были использованы вместо этого обработчик регулярных выражений поиска только одно соответствие во входной строке.  
  
 Строка замены `($1)` заменяет совпадение первой захватываемой группы, которые заключены в круглые скобки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="replacement" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Расширение для этого шаблона не разрешено.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Synchronized (System.Text.RegularExpressions.Match inner);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Synchronized(class System.Text.RegularExpressions.Match inner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (inner As Match) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Synchronized(System::Text::RegularExpressions::Match ^ inner);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Text.RegularExpressions.Match -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Match.Synchronized inner" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inner" Type="System.Text.RegularExpressions.Match" />
      </Parameters>
      <Docs>
        <param name="inner">Сопоставление регулярному выражению, эквивалентное ожидаемому.</param>
        <summary>Возвращает экземпляр <see cref="T:System.Text.RegularExpressions.Match" />, который эквивалентен одному из предоставленных экземпляров, пригодному для совместного использования несколькими потоками.</summary>
        <returns>Сопоставление регулярному выражению, пригодное для разделения между несколькими потоками.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="inner" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>