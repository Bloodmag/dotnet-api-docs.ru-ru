<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Regex.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e05b5b2-d481-4262-b7b7-7de7ac2afe07fd2ccb43296a43eb9c1de7114e0d688441835233.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fd2ccb43296a43eb9c1de7114e0d688441835233</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df6cf590aa3087f6c7c202712eee781c6a3c8f96</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/07/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Represents an immutable regular expression.</source>
          <target state="translated">Представляет постоянное регулярное выражение.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class represents the .NET Framework's regular expression engine.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> Класс представляет механизм регулярных выражений .NET Framework.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>It can be used to quickly parse large amounts of text to find specific character patterns; to extract, edit, replace, or delete text substrings; and to add the extracted strings to a collection to generate a report.</source>
          <target state="translated">Он позволяет быстро анализировать большие объемы текста для поиска определенных шаблонов символов; для извлечения, изменять, заменять или удалять текстовые подстроки, и добавлять извлеченные строки в коллекцию для создания отчета.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If your primary interest is to validate a string by determining whether it conforms to a particular pattern, you can use the <ph id="ph1">&lt;xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">Если ваш основной интерес для проверки строки, определяя их соответствие конкретному шаблону, можно использовать <ph id="ph1">&lt;xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To use regular expressions, you define the pattern that you want to identify in a text stream by using the syntax documented in <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Чтобы использовать регулярные выражения, необходимо определить шаблон, который нужно определить в текстовый поток, используя синтаксис, задокументированный в <bpt id="p1">[</bpt>языка регулярных выражений — краткий справочник<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Next, you can optionally instantiate a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">Затем при необходимости можно создать экземпляр <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Finally, you call a method that performs some operation, such as replacing text that matches the regular expression pattern, or identifying a pattern match.</source>
          <target state="translated">Наконец вызвать метод, который выполняет некоторые операции, например, заменив текст, соответствующий шаблону регулярного выражения или идентификация совпадения с шаблоном.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For some common regular expression patterns, see <bpt id="p1">[</bpt>Regular Expression Examples<ept id="p1">](~/docs/standard/base-types/regular-expression-examples.md)</ept>.</source>
          <target state="translated">Некоторые распространенные шаблоны регулярных выражений см. <bpt id="p1">[</bpt>Примеры регулярных выражений<ept id="p1">](~/docs/standard/base-types/regular-expression-examples.md)</ept>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>There are also a number of online libraries of regular expression patterns, such as the one at <bpt id="p1">[</bpt>Regular-Expressions.info<ept id="p1">](https://www.regular-expressions.info/examples.html)</ept>.</source>
          <target state="translated">Существует ряд документации библиотеки шаблонов регулярных выражений, например по одному <bpt id="p1">[</bpt>Regular Expressions.info<ept id="p1">](https://www.regular-expressions.info/examples.html)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">&lt;a name="remarks"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> For more information about using the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class, see the following sections in this topic:</source>
          <target state="translated"><bpt id="p1">&lt;a name="remarks"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Дополнительные сведения об использовании <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> класса, в следующих разделах этой статьи:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Regex vs. String Methods<ept id="p1">](#regex_vs_string)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Сравнение регулярных выражений. Методы строк<ept id="p1">](#regex_vs_string)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Static vs. Instance Methods<ept id="p1">](#static_vs_instance)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Статические vs. Методы экземпляра<ept id="p1">](#static_vs_instance)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Performing Regular Expression Operations<ept id="p1">](#regex_ops)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Выполнение операций регулярного выражения<ept id="p1">](#regex_ops)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Defining a Time-Out Value<ept id="p1">](#define_timeout)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Определение значения времени ожидания<ept id="p1">](#define_timeout)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information about the regular expression language, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> or download and print one of these brochures:</source>
          <target state="translated">Дополнительные сведения о языке регулярных выражений см. в <bpt id="p1">[</bpt>кратком справочнике по элементам языка регулярных выражений<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> или в одной из следующих брошюр, который вы можете скачать и распечатать:</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Quick Reference in Word (.docx) format<ept id="p1">](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Краткий справочник в формате Word (DOCX)<ept id="p1">](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)</ept>;</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Quick Reference in PDF (.pdf) format<ept id="p1">](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Краткий справочник в формате PDF (PDF)<ept id="p1">](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)</ept>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Regex vs. String Methods</source>
          <target state="translated">Сравнение регулярных выражений. Методы строк</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> class includes several search and comparison methods that you can use to perform pattern matching with text.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> Класс содержит несколько методов поиска и сравнения, которые можно использовать для выполнения сопоставления шаблона с текстом.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Contains%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> methods determine whether a string instance contains a specified substring; and the <ph id="ph4">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOfAny%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph7">&lt;xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType&gt;</ph> methods return the starting position of a specified substring in a string.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.String.Contains%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A?displayProperty=nameWithType&gt;</ph>, и <ph id="ph3">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> методы определить, содержит ли экземпляр string указанной подстроки и <ph id="ph4">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOfAny%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>, и <ph id="ph7">&lt;xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType&gt;</ph> методы возвращают начальную позицию указанной подстроки в строке.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Use the methods of the <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> class when you are searching for a specific string.</source>
          <target state="translated">Используйте методы класса <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> класс при поиске определенной строки.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class when you are searching for a specific pattern in a string.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> класс при поиске шаблона в строку.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information and examples, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</source>
          <target state="translated">Дополнительные сведения и примеры см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Примечания к<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Static vs. Instance Methods</source>
          <target state="translated">Статические vs. Методы экземпляра</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>After you define a regular expression pattern, you can provide it to the regular expression engine in either of two ways:</source>
          <target state="translated">После определения шаблона регулярного выражения, можно передать его обработчику регулярных выражений одним из двух способов:</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By instantiating a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object that represents the regular expression.</source>
          <target state="translated">Путем создания экземпляра <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> , представляющий регулярного выражения.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To do this, you pass the regular expression pattern to a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">Чтобы сделать это, передайте шаблон регулярного выражения для <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%2A&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable; when you instantiate a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with a regular expression, that object's regular expression cannot be changed.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> является неизменяемым; при создании экземпляра <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта регулярное выражение, не может изменяться объекта регулярного выражения.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By supplying both the regular expression and the text to search to a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> method.</source>
          <target state="translated">Указав регулярных выражений и текст для поиска для <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> в Visual Basic) <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This enables you to use a regular expression without explicitly creating a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">Это позволяет использовать регулярное выражение без явного создания <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>All <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> pattern identification methods include both static and instance overloads.</source>
          <target state="translated">Все <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> экземпляра перегрузки и включают как статические методы идентификации шаблона.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The regular expression engine must compile a particular pattern before the pattern can be used.</source>
          <target state="translated">Обработчик регулярных выражений необходимо скомпилировать определенный шаблон, прежде чем можно будет использовать шаблон.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Because <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objects are immutable, this is a one-time procedure that occurs when a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructor or a static method is called.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекты являются неизменяемыми, это одноразовую процедуру, которая возникает при <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> вызывается конструктор класса или статический метод.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To eliminate the need to repeatedly compile a single regular expression, the regular expression engine caches the compiled regular expressions used in static method calls.</source>
          <target state="translated">Чтобы избежать необходимости повторно компилировать одно регулярное выражение, обработчик регулярных выражений кэширует скомпилированные регулярные выражения, используемые в вызовах статичных методов.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>As a result, regular expression pattern-matching methods offer comparable performance for static and instance methods.</source>
          <target state="translated">Как следствие методы поиска совпадения с шаблоном регулярного выражения предлагают сравнимую производительность для статических методов и методов экземпляра.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In the .NET Framework versions 1.0 and 1.1, all compiled regular expressions, whether they were used in instance or static method calls, were cached.</source>
          <target state="translated">В версиях 1.0 и 1.1, все скомпилированные регулярные выражения .NET Framework используются ли они в экземпляре или статический метод вызывает, были кэшированы.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Starting with the .NET Framework 2.0, only regular expressions used in static method calls are cached.</source>
          <target state="translated">Начиная с .NET Framework 2.0, кэшируются только регулярные выражения, используемые в вызовах статичных методов.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>However, caching can adversely affect performance in the following two cases:</source>
          <target state="translated">Тем не менее кэширование может отрицательно сказаться на производительности в следующих двух случаях:</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>When you use static method calls with a large number of regular expressions.</source>
          <target state="translated">При использовании вызовов статических методов с большим числом регулярных выражений.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By default, the regular expression engine caches the 15 most recently used static regular expressions.</source>
          <target state="translated">По умолчанию обработчик регулярных выражений кэширует 15 последних использованных статических регулярных выражений.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If your application uses more than 15 static regular expressions, some regular expressions must be recompiled.</source>
          <target state="translated">Если приложение использует более 15 статических регулярных выражений, некоторые регулярные выражения должны быть перекомпилированы.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To prevent this recompilation, you can increase the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Чтобы предотвратить перекомпиляция, можно увеличить <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>When you instantiate new <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objects with regular expressions that have previously been compiled.</source>
          <target state="translated">При создании нового экземпляра <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объектов с помощью регулярных выражений, которые ранее были скомпилированы.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For example, the following code defines a regular expression to locate duplicated words in a text stream.</source>
          <target state="translated">Например следующий код определяет регулярное выражение для поиска повторяющихся слов в текстовый поток.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Although the example uses a single regular expression, it instantiates a new <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object to process each line of text.</source>
          <target state="translated">Несмотря на то, что в примере используется одним регулярным выражением, он создает новый <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объектов для обработки каждой строки текста.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This results in the recompilation of the regular expression with each iteration of the loop.</source>
          <target state="translated">Это приводит к повторной компиляции регулярного выражения с каждой итерацией цикла.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To prevent recompilation, you should instantiate a single <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object that is accessible to all code that requires it, as shown in the following rewritten example.</source>
          <target state="translated">Во избежание перекомпиляции, следует создать отдельный <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта, доступного ко всему коду, который требует, как показано в следующем примере перезаписанного.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Примечания к<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Performing Regular Expression Operations</source>
          <target state="translated">Выполнение операций регулярного выражения</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Whether you decide to instantiate a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object and call its methods or call static methods, the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class offers the following pattern-matching functionality:</source>
          <target state="translated">Вы решите создать <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> и вызывать его методы или вызывают статические методы <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> класс предлагает следующие функциональные возможности сопоставления шаблона:</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Validation of a match.</source>
          <target state="translated">Проверка соответствия.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method to determine whether a match is present.</source>
          <target state="translated">Вызывается <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> метод, чтобы определить, присутствует ли совпадение.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Retrieval of a single match.</source>
          <target state="translated">Извлечение одного совпадения.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object that represents the first match in a string or in part of a string.</source>
          <target state="translated">Можно вызвать <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> метод для извлечения <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> , представляющий первое совпадение в строке или их часть строки.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Subsequent matches can be retrieved by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Последующие соответствия можно получить, вызвав <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Retrieval of all matches.</source>
          <target state="translated">Извлечение всех совпадений.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType&gt;</ph> object that represents all the matches found in a string or in part of a string.</source>
          <target state="translated">Можно вызвать <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> метод для извлечения <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType&gt;</ph> , представляющий всех совпадений в строке или их часть строки.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Replacement of matched text.</source>
          <target state="translated">Замена совпадающего текста.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> method to replace matched text.</source>
          <target state="translated">Вызывается <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> метод для замены совпадающего текста.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The replacement text can also be defined by a regular expression.</source>
          <target state="translated">Текст замены можно также определить регулярным выражением.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In addition, some of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> methods include a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> parameter that enables you to programmatically define the replacement text.</source>
          <target state="translated">Кроме того, некоторые <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> методы включают <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> параметр, который позволяет программно определить текст замены.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Creation of a string array that is formed from parts of an input string.</source>
          <target state="translated">Создание массива строк, сформированный на основе части входной строки.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> method to split an input string at positions that are defined by the regular expression.</source>
          <target state="translated">Вызывается <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> метод разбиение входную строку в позициях, определенных с регулярным выражением.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In addition to its pattern-matching methods, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class includes several special-purpose methods:</source>
          <target state="translated">В дополнение к его методов поиска совпадения с шаблоном <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> класс включает несколько специализированных методов:</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method escapes any characters that may be interpreted as regular expression operators in a regular expression or input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> Метод экранирует все символы, которые могут быть интерпретированы как операторы регулярных выражений в входной строки или регулярного выражения.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method removes these escape characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> Метод удаляет escape-символы.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> method creates an assembly that contains predefined regular expressions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> Метод создает сборку, содержащую предварительно определенных регулярных выражений.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The .NET Framework contains examples of these special-purpose assemblies in the <ph id="ph1">&lt;xref:System.Web.RegularExpressions?displayProperty=nameWithType&gt;</ph> namespace.</source>
          <target state="translated">Платформа .NET Framework содержит примеры эти сборки специального назначения в <ph id="ph1">&lt;xref:System.Web.RegularExpressions?displayProperty=nameWithType&gt;</ph> пространства имен.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Примечания к<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Defining a Time-Out Value</source>
          <target state="translated">Определение значения времени ожидания</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The .NET Framework supports a full-featured regular expression language that provides substantial power and flexibility in pattern matching.</source>
          <target state="translated">Платформа .NET Framework поддерживает язык полнофункциональный регулярного выражения, предоставляет значительные возможности и гибкость в сопоставлениях с шаблоном.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>However, the power and flexibility come at a cost: the risk of poor performance.</source>
          <target state="translated">Тем не менее, мощность и гибкость есть своя Цена: риск снижения производительности.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Regular expressions that perform poorly are surprisingly easy to create.</source>
          <target state="translated">Регулярные выражения, которые завершаются неудачно удивительно легко создать.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In some cases, regular expression operations that rely on excessive backtracking can appear to stop responding when they process text that nearly matches the regular expression pattern.</source>
          <target state="translated">В некоторых случаях операции регулярного выражения, зависящие от избыточный поиск с возвратом может отображаться перестает отвечать при обработке текста, почти соответствующие шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information about the .NET Framework regular expression engine, see <bpt id="p1">[</bpt>Details of Regular Expression Behavior<ept id="p1">](~/docs/standard/base-types/details-of-regular-expression-behavior.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о обработчик регулярных выражений .NET Framework см. в разделе <bpt id="p1">[</bpt>подробные сведения о поведении регулярных выражений<ept id="p1">](~/docs/standard/base-types/details-of-regular-expression-behavior.md)</ept>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information about excessive backtracking, see <bpt id="p1">[</bpt>Backtracking<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о избыточный поиск с возвратом см. в разделе <bpt id="p1">[</bpt>поиск с возвратом<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, you can define a time-out interval for regular expression matches.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, можно определить интервал времени ожидания для совпадения с регулярными выражениями.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the regular expression engine cannot identify a match within this time interval, the matching operation throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Если обработчик регулярных выражений не может определить соответствие, в течение этого интервала времени, вызывает соответствующую операцию <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In most cases, this prevents the regular expression engine from wasting processing power by trying to match text that nearly matches the regular expression pattern.</source>
          <target state="translated">В большинстве случаев это не позволяет обработчику регулярных выражений тратить энергию обработки при попытке сопоставить текст, почти соответствующий шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>It also could indicate, however, that the timeout interval has been set too low, or that the current machine load has caused an overall degradation in performance.</source>
          <target state="translated">Также возможно, однако, что интервал времени ожидания было установлено слишком низкое, или что текущей нагрузки машины вызвала общего снижения производительности.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>How you handle the exception depends on the cause of the exception.</source>
          <target state="translated">Как обрабатывать исключение зависит от причины возникновения исключения.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the exception occurs because the time-out interval is set too low or because of excessive machine load, you can increase the time-out interval and retry the matching operation.</source>
          <target state="translated">При возникновении исключения, так как время ожидания задано слишком мало или из-за чрезмерного машины нагрузки можно увеличить интервал времени ожидания и повторите операцию сопоставления.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the exception occurs because the regular expression relies on excessive backtracking, you can assume that a match does not exist, and, optionally, you can log information that will help you modify the regular expression pattern.</source>
          <target state="translated">Если же исключение возникает, поскольку зависит избыточный поиск с возвратом в регулярных выражений, можно предположить, что соответствие не существует, и при необходимости можно записывать в журнал сведения, которые помогут вам изменить шаблон регулярного выражения.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You can set a time-out interval by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor when you instantiate a regular expression object.</source>
          <target state="translated">Можно задать интервал времени ожидания путем вызова <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> конструктор при создании экземпляра объекта регулярного выражения.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For static methods, you can set a time-out interval by calling an overload of a matching method that has a <ph id="ph1">`matchTimeout`</ph> parameter.</source>
          <target state="translated">Для статических методов можно задать интервал времени ожидания путем вызова перегрузки метода сопоставления, который имеет <ph id="ph1">`matchTimeout`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If you do not set a time-out value explicitly, the default time-out value  is determined as follows:</source>
          <target state="translated">Если значение времени ожидания не задано явно, по умолчанию значение времени ожидания определяется следующим образом:</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By using the application-wide time-out value, if one exists.</source>
          <target state="translated">С помощью тайм-аута приложения. значение, если он существует.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This can be any time-out value that applies to the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is instantiated or the static method call is made.</source>
          <target state="translated">Это может быть любое значение времени ожидания, в домен приложения, в котором применяется <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создать экземпляр объекта или вызов статического метода.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You can set the application-wide time-out value by calling the <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> method to assign the string representation of a <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> value to the "REGEX_DEFAULT_MATCH_TIMEOUT" property.</source>
          <target state="translated">Значение тайм-аута уровня приложения можно задать путем вызова <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> метод назначения строковое представление <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> значение свойства «REGEX_DEFAULT_MATCH_TIMEOUT».</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By using the value <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph>, if no application-wide time-out value has been set.</source>
          <target state="translated">С помощью значения <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph>, если значение времени ожидания уровня приложения не было задано.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>We recommend that you set a time-out value in all regular expression pattern-matching operations.</source>
          <target state="translated">Рекомендуется задавать значение времени ожидания во всех операциях поиска совпадения с шаблоном регулярного выражения.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>советы и рекомендации по использованию регулярных выражений<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Примечания к<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The following example uses a regular expression to check for repeated occurrences of words in a string.</source>
          <target state="translated">В следующем примере регулярное выражение для проверки повторяющихся вхождений слов в строке.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The regular expression <ph id="ph1">`\b(?&lt;word&gt;\w+)\s+(\k&lt;word&gt;)\b`</ph> can be interpreted as shown in the following table.</source>
          <target state="translated">Регулярное выражение <ph id="ph1">`\b(?&lt;word&gt;\w+)\s+(\k&lt;word&gt;)\b`</ph> можно интерпретировать как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Start the match at a word boundary.</source>
          <target state="translated">Начало соответствия на границе слова.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match one or more word characters up to a word boundary.</source>
          <target state="translated">Соответствует буквенным символам до границы слова.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Name this captured group <ph id="ph1">`word`</ph>.</source>
          <target state="translated">Имя данной группой записи <ph id="ph1">`word`</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match one or more white-space characters.</source>
          <target state="translated">Соответствует один или несколько символов пробела.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match the captured group that is named <ph id="ph1">`word`</ph>.</source>
          <target state="translated">Соответствует группе записи, которая называется <ph id="ph1">`word`</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match a word boundary.</source>
          <target state="translated">Соответствует границе слова.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The following example illustrates the use of a regular expression to check whether a string either represents a currency value or has the correct format to represent a currency value.</source>
          <target state="translated">Следующий пример иллюстрирует использование регулярного выражения для проверки, является ли строка представляет значение валюты или имеет правильный формат для представления денежного значения.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In this case, the regular expression is built dynamically from the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> properties for the user's current culture.</source>
          <target state="translated">В этом случае регулярного выражения оно строится динамически из <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph>, и <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> свойств для текущего языка и региональных параметров пользователя.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the system's current culture is en-US, the resulting regular expression is <ph id="ph1">`^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`</ph>.</source>
          <target state="translated">Если текущий язык и региональные параметры en US, результате регулярное выражение является <ph id="ph1">`^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This regular expression can be interpreted as shown in the following table.</source>
          <target state="translated">Это регулярное выражение может интерпретироваться, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Start at the beginning of the string.</source>
          <target state="translated">Начинаться в начале строки.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">Соответствует нулю или нескольким символам пробела.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one occurrence of either the positive sign or the negative sign.</source>
          <target state="translated">Совпадение с нулем или одним вхождением положительного или отрицательного знака.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one white-space character.</source>
          <target state="translated">Совпадение с нулем или одним символом пробела.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one occurrence of the dollar sign.</source>
          <target state="translated">Совпадение с нулем или одним вхождением знак доллара.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one white-space character.</source>
          <target state="translated">Совпадение с нулем или одним символом пробела.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or more decimal digits.</source>
          <target state="translated">Соответствует нулю или нескольким десятичным числам.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one decimal point symbol.</source>
          <target state="translated">Совпадает с нулем или одним символом десятичной запятой.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match two decimal digits zero or one time.</source>
          <target state="translated">Совпадение с двумя десятичными цифрами ноль или один раз.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match the pattern of integral and fractional digits separated by a decimal point symbol at least one time.</source>
          <target state="translated">Совпадение с шаблоном целой и дробной части, разделенные символа десятичного разделителя, по крайней мере один раз.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match the end of the string.</source>
          <target state="translated">Соответствует концу строки.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In this case, the regular expression assumes that a valid currency string does not contain group separator symbols, and that it has either no fractional digits or the number of fractional digits defined by the current culture's <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph> property.</source>
          <target state="translated">Таким образом, регулярное выражение предполагает, что строка допустимой валюты не содержит символы разделителя группы, и имеет дробных разрядов или количество цифр дробной части, определенные в текущих региональных параметрах <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Because the regular expression in this example is built dynamically, we do not know at design time whether the current culture's currency symbol, decimal sign, or positive and negative signs might be misinterpreted by the regular expression engine as regular expression language operators.</source>
          <target state="translated">Так как регулярное выражение в этом примере создается динамически, неизвестно во время разработки ли символ валюты для текущего языка и региональных параметров, десятичного разделителя или положительный и отрицательный знаки могут быть неправильно обработчиком регулярных выражений как операторы языка регулярных выражений.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To prevent any misinterpretation, the example passes each dynamically generated string to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method.</source>
          <target state="translated">Во избежание любой интерпретации в примере передается каждой строки динамически создаваемых <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class is immutable (read-only) and thread safe.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> Класса является неизменяемым (только для чтения) и потокобезопасным.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects can be created on any thread and shared between threads.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> объекты могут создаваться в любом потоке и совместно использоваться несколькими потоками.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information, see <bpt id="p1">[</bpt>Thread Safety<ept id="p1">](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>потокобезопасность<ept id="p1">](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor">
          <source>Note that this constructor is protected; it can only be called by classes derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Обратите внимание, что этот конструктор является защищенным; может вызываться только в классах, производных от <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class for the specified regular expression.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> для заданного регулярного выражения.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>For more information about regular expressions, see the <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> topics.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> разделы.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29&gt;</ph> constructor is equivalent to calling the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor with a value of <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.None&gt;</ph> for the <ph id="ph4">`options`</ph> argument.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29&gt;</ph> конструктор эквивалентно вызову <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> конструктор со значением <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.None&gt;</ph> для <ph id="ph4">`options`</ph> аргумент.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable, which means that it can be used only for the match pattern you define when you create it.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> является неизменяемым, это означает, что он может использоваться только для соответствия шаблону, определяется при ее создании.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>However, it can be used any number of times without being recompiled.</source>
          <target state="translated">Однако можно использовать любое количество раз без повторной компиляции.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>This constructor instantiates a regular expression object that attempts a case-sensitive match of any alphabetical characters defined in <ph id="ph1">`pattern`</ph>.</source>
          <target state="translated">Этот конструктор создает объект регулярного выражения, которую пытается выполнить регистра все буквенные символы, определенные в <ph id="ph1">`pattern`</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>For a case-insensitive match, use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Соответствие без учета регистра, используйте <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>The following example illustrates how to use this constructor to instantiate a regular expression that matches any word that begins with the letters "a" or "t".</source>
          <target state="translated">Следующий пример показывает, как использовать этот конструктор для создания экземпляра регулярное выражение, которое соответствует любому слову, начинающемуся с букв «a» или «t».</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>Note that the regular expression pattern cannot match the word "The" at the beginning of the text, because comparisons are case-sensitive by default.</source>
          <target state="translated">Обратите внимание, что шаблон регулярного выражения не может совпадать со словом «» в начале текста, так как сравнения выполняются с учетом регистра по умолчанию.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>For an example of case-insensitive comparison, see the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor.</source>
          <target state="translated">Пример сравнение без учета регистра см. в разделе <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>This constructor creates a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object that uses the default time-out value of the application domain in which it is created.</source>
          <target state="translated">Этот конструктор создает <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> объект, который использует значение времени ожидания по умолчанию домена приложения, в которой он создан.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>If a time-out value has not been defined for the application domain,  the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object uses the value <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the operation from timing out. The recommended constructor for creating a <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object is <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Если значение времени ожидания не был определен для домена приложения, <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> объект использует значение <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, что мешает выполнить операцию по истечении времени ожидания. Рекомендуемые конструктор для создания <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> объект <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, который позволяет установить интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object that contains a serialized pattern and <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> information.</source>
          <target state="translated">Объект, содержащий сериализованный шаблон и сведения <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The destination for this serialization.</source>
          <target state="translated">Целевой объект этой сериализации.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>(This parameter is not used; specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.)</source>
          <target state="translated">(Этот параметр не используется; задайте значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class by using serialized data.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>, используя сериализованные данные.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The pattern that <ph id="ph1">&lt;paramref name="info" /&gt;</ph> contains is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Шаблон, содержащий <ph id="ph1">&lt;paramref name="info" /&gt;</ph>, имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> contains an invalid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> flag.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> содержит недопустимый флаг <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that modify the regular expression.</source>
          <target state="translated">Побитовое сочетание значений перечисления, изменяющих регулярное выражение.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class for the specified regular expression, with options that modify the pattern.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> для указанного регулярного выражения с параметрами, изменяющими шаблон.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see the <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> topics.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> разделы.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable, which means that it can be used only for the match parameters you define when you create it.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> является неизменяемым, это означает, что он может использоваться только для параметров соответствия, определяется при ее создании.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>However, it can be used any number of times without being recompiled.</source>
          <target state="translated">Однако можно использовать любое количество раз без повторной компиляции.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example illustrates how to use this constructor to instantiate a regular expression that matches any word that begins with the letters "a" or "t".</source>
          <target state="translated">Следующий пример показывает, как использовать этот конструктор для создания экземпляра регулярное выражение, которое соответствует любому слову, начинающемуся с букв «a» или «t».</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Note that the match collection includes the word "The" that begins the text because the <ph id="ph1">`options`</ph> parameter has defined case-insensitive comparisons.</source>
          <target state="translated">Обратите внимание, что коллекция соответствий включает слово «», начинается текст, так как <ph id="ph1">`options`</ph> параметр определен сравнения без учета регистра.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> contains an invalid flag.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> содержит недопустимый флаг.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This constructor creates a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object that uses the default time-out value of the application domain in which it is created.</source>
          <target state="translated">Этот конструктор создает <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> объект, который использует значение времени ожидания по умолчанию домена приложения, в которой он создан.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object uses the value <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the operation from timing out. The recommended constructor for creating a <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object is <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Если значение времени ожидания не был определен для домена приложения, <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> объект использует значение <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, что мешает выполнить операцию по истечении времени ожидания. Рекомендуемые конструктор для создания <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> объект <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, который позволяет установить интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that modify the regular expression.</source>
          <target state="translated">Побитовое сочетание значений перечисления, изменяющих регулярное выражение.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Интервал времени ожидания или <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, чтобы указать, что метод не должен превышать время ожидания.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class for the specified regular expression, with options that modify the pattern and a value that specifies how long a pattern matching method should attempt a match before it times out.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> для указанного регулярного выражения с параметрами, которые изменяют шаблон, и значение, указывающее, как долго метод сравнения с шаблоном должен пытаться найти совпадение, прежде чем время ожидания истечет.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see the <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> topics.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> разделы.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable, which means that it can be used only for the match pattern that you define when you create it.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> является неизменяемым, это означает, что он может использоваться только для определения при создании шаблона соответствия.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, it can be used any number of times without being recompiled.</source>
          <target state="translated">Однако можно использовать любое количество раз без повторной компиляции.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern-matching method should try to find a match before it times out. If no match is found in that time interval, the pattern-matching method throws a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> Параметр указывает, сколько времени поиска совпадения с шаблоном метод должен пытаться найти совпадения, до истечения времени ожидания. Если совпадение не найдено в этого интервала времени, вызывает метод поиска совпадения с шаблоном <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в котором <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создан объект.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The instance pattern-matching methods that observe the <ph id="ph1">`matchTimeout`</ph> time-out interval include the following:</source>
          <target state="translated">Методы поиска совпадения с шаблоном экземпляра придерживаются <ph id="ph1">`matchTimeout`</ph> интервал времени ожидания включают следующее:</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated">Установка интервала времени ожидания предотвращает регулярные выражения, зависящие от избыточный поиск с возвратом отображение перестает отвечать при обработке входных данных, содержащий ближайшие совпадения.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>советы и рекомендации по использованию регулярных выражений<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> и <bpt id="p2">[</bpt>поиск с возвратом<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To set a reasonable time-out interval, consider the following factors:</source>
          <target state="translated">Чтобы задать интервал ожидания разумного, учитывайте следующие факторы:</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The length and complexity of the regular expression pattern.</source>
          <target state="translated">Длина и сложность шаблон регулярного выражения.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Longer and more complex regular expressions require more time than shorter and simpler ones.</source>
          <target state="translated">Длинные и более сложные регулярные выражения требуется больше времени, чем более короткий и простой из них.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The expected machine load.</source>
          <target state="translated">Нагрузка ожидаемый машины.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Processing takes more time on systems that have high CPU and memory utilization.</source>
          <target state="translated">Обработка занимает больше времени, в системах, имеющих высокий уровень использования ЦП и памяти.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with a time-out value of one second.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> конструктора для создания <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта со значением времени ожидания, равным одной секунде.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern <ph id="ph1">`(a+)+$`</ph>, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`(a+)+$`</ph>, который сопоставляется с последовательностью из одного или нескольких символов "a" в конце строки, относится к шаблонам с чрезмерным использованием поиска с возвратом.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> is thrown, the example increases the time-out value up to the maximum value of three seconds.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> является исключение, в примере увеличивается значение времени ожидания до достижения максимального значения, равного трем секундам.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Otherwise, it abandons the attempt to match the pattern.</source>
          <target state="translated">В противном случае не приостановит попытки найти соответствие шаблону.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является допустимым значением <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> отрицательно, равно нулю или больше приблизительно 24 дней.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Мы рекомендуем задавать <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> параметр соответствующее значение, например две секунды.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Если отключить время ожидания, указав <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, обработчик регулярных выражений, обеспечивает немного лучшую производительность.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Тем не менее следует отключить тайм-ауты только при следующих условиях:</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Если входных данных, обрабатываемых регулярное выражение является производным от известного и надежного источника или состоит из статического текста.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Это исключает текст, который был динамически ввода пользователями.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Если шаблон регулярного выражения тщательно протестирован для обеспечения эффективной обработки соответствует несовпадающие и ближайшем совпадает.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Если шаблон регулярного выражения содержит не языковые элементы, которые возникает избыточный поиск с возвратом при обработке почти совпадают.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Gets or sets the maximum number of entries in the current static cache of compiled regular expressions.</source>
          <target state="translated">Возвращает или задает максимальное количество записей в текущей статической кэш-памяти скомпилированных регулярных выражений.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>The maximum number of entries in the static cache.</source>
          <target state="translated">Максимальное количество записей в статической кэш-памяти.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class maintains an internal cache of compiled regular expressions used in static method calls.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> Класс поддерживает внутренний кэш скомпилированных регулярных выражений, используемых при вызове статического метода.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>If the value specified in a set operation is less than the current cache size, cache entries are discarded until the cache size is equal to the specified value.</source>
          <target state="translated">Если значение, указанное в операции задания меньше, чем текущий размер кэша, записей кэша будут удалены, пока размер кэша равен указанному значению.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>By default, the cache holds 15 compiled static regular expressions.</source>
          <target state="translated">По умолчанию кэш содержит 15 скомпилированных статических регулярных выражений.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Your application typically will not have to modify the size of the cache.</source>
          <target state="translated">Обычно приложение для изменения размера кэша не будет.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A&gt;</ph> property only when you want to turn off caching or when you have an unusually large cache.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A&gt;</ph> свойство только в том случае, если вы хотите отключить кэширование или при наличии большими наборами кэша.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>The value in a set operation is less than zero.</source>
          <target state="translated">Значение в операции задания меньше нуля.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>In the .NET Framework prior to the <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, regular expressions used in both static and instance method calls were cached.</source>
          <target state="translated">В платформе .NET Framework до версии <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, использовать регулярные выражения в как статическим, так и вызовов методов экземпляра были кэшированы.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, only regular expressions used in static method calls are cached.</source>
          <target state="translated">Начиная с версии <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, только регулярные выражения, используемые в вызовах статичных методов, кэшируются.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.capnames">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Используется объектом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>, который создан методом <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>Gets or sets a dictionary that maps named capturing groups to their index values.</source>
          <target state="translated">Получает или задает словарь, сопоставляющий именованные захватываемые группы со значениями их индексов.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>A dictionary that maps named capturing groups to their index values.</source>
          <target state="translated">Словарь, сопоставляющий именованные захватываемые группы со значениями их индексов.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>Note that this property is protected; it can only be accessed from a class derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Обратите внимание, что это свойство защищено; может осуществляться только из класса, производного от <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>A set operation attempts to convert the value assigned to the property to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object; if this conversion fails, it calls the <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Пытается преобразовать значение назначается свойству в операции задания <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> объекта; Если данное преобразование не удается, он вызывает метод <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>The value assigned to the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.CapNames" /&gt;</ph> property in a set operation is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение, присвоенное свойству <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.CapNames" /&gt;</ph> в операции задания, равно <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.caps">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Используется объектом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>, который создан методом <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>Gets or sets a dictionary that maps numbered capturing groups to their index values.</source>
          <target state="translated">Получает или задает словарь, сопоставляющий нумерованные захватываемые группы со значениями их индексов.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>A dictionary that maps numbered capturing groups to their index values.</source>
          <target state="translated">Словарь, сопоставляющий нумерованные захватываемые группы со значениями их индексов.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>Note that this property is protected; it can only be accessed from a class derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Обратите внимание, что это свойство защищено; может осуществляться только из класса, производного от <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>A set operation attempts to convert the value assigned to the property to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object; if this conversion fails, it calls the <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Пытается преобразовать значение назначается свойству в операции задания <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> объекта; Если данное преобразование не удается, он вызывает метод <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>The value assigned to the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Caps" /&gt;</ph> property in a set operation is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение, присвоенное свойству <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Caps" /&gt;</ph> в операции задания, равно <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.capsize">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Используется объектом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>, который создан методом <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.capslist">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Используется объектом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>, который создан методом <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Compiles regular expressions and saves them to disk in a single assembly.</source>
          <target state="translated">Компилирует регулярные выражения и сохраняет их на диск в единой сборке.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>An array that describes the regular expressions to compile.</source>
          <target state="translated">Массив, описывающий регулярные выражения для компилирования.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The file name of the assembly.</source>
          <target state="translated">Имя файла сборки.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Compiles one or more specified <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects to a named assembly.</source>
          <target state="translated">Компилирует один или несколько указанных объектов <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> в именованную сборку.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph2">`regexinfos`</ph> array is represented by a class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> Метод создает сборку платформы .NET Framework в какой каждого регулярного выражения, определенного в <ph id="ph2">`regexinfos`</ph> массива, представленный классом.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Typically, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> method is called from a separate application that generates an assembly of compiled regular expressions.</source>
          <target state="translated">Как правило <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> метод вызывается из отдельного приложения, создает сборку скомпилированных регулярных выражений.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Each regular expression included in the assembly has the following characteristics:</source>
          <target state="translated">Каждый регулярных выражений, включенных в сборке имеет следующие характеристики:</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>It is derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Он является производным от <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>It is assigned the fully qualified name that is defined by the <ph id="ph1">`fullnamespace`</ph> and <ph id="ph2">`name`</ph> parameters of its corresponding <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> object.</source>
          <target state="translated">Он назначен полное доменное имя, которое определяется <ph id="ph1">`fullnamespace`</ph> и <ph id="ph2">`name`</ph> параметров соответствующего <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>It has a default (or parameterless) constructor.</source>
          <target state="translated">По умолчанию (или без параметров) конструктора.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</source>
          <target state="translated">Обычно код, который создает и использует скомпилированное регулярное выражение находится в сборке или приложения, отдельном от кода, создающий сборку.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The following example creates an assembly named RegexLib.dll.</source>
          <target state="translated">В следующем примере создается сборка с именем RegexLib.dll.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The assembly includes two compiled regular expressions.</source>
          <target state="translated">Сборка включает два скомпилированных регулярных выражений.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The first, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, matches two identical contiguous words.</source>
          <target state="translated">Первый, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, соответствует два одинаковых смежных слов.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The second, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, checks whether a string has the correct format to be an email address.</source>
          <target state="translated">Второе, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, проверяет, является ли строка имеет правильный формат является адресом электронной почты.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The regular expression that checks a string for duplicate words is then instantiated and used by the following example.</source>
          <target state="translated">Затем регулярное выражение, которое проверяет строку на наличие повторяющихся слов создается и используется в следующем примере.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Successful compilation of this second example requires a reference to RegexLib.dll (the assembly created by the first example) to be added to the project.</source>
          <target state="translated">Для успешной компиляции во втором примере требуется ссылка на RegexLib.dll (сборка, созданная в первом примере) для добавления в проект.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The value of the <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> parameter's <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> property is an empty or null string.</source>
          <target state="translated">Значением свойства <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> параметра <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> является пустая или нулевая строка.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The regular expression pattern of one or more objects in <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated">Шаблон регулярного выражения одного или более объектов в <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> содержит недопустимый синтаксис.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> or <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> или <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>If you are developing on a system that has <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or its point releases installed, you target <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, and you use the <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> method to create an assembly that contains compiled regular expressions.</source>
          <target state="translated">При разработке в системе, где <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> или назначьте ее доработанные выпуски установлен <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, и использовать <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> метод, чтобы создать сборку, содержащую скомпилированные регулярные выражения.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Trying to use one of the regular expressions in that assembly on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> throws an exception.</source>
          <target state="translated">Попытка использовать одно из регулярных выражений в том, что сборке в системе с <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> приводит к возникновению исключения.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>To work around this problem, you can do either of the following:</source>
          <target state="translated">Чтобы обойти эту проблему, можно воспользоваться одним из следующих способов:</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Build the assembly that contains the compiled regular expressions on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> instead of later versions installed.</source>
          <target state="translated">Создать сборку, содержащую скомпилированные регулярные выражения в системе, которая имеет <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> вместо более поздних версий.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Instead of calling <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> and retrieving the compiled regular expression from an assembly, use either static or instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> methods with the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option when you instantiate a <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object or call a regular expression pattern matching method.</source>
          <target state="translated">Вместо вызова метода <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> и получение скомпилированного регулярного выражения из сборки, используйте статических или экземпляр <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> методы с <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> параметр при создании экземпляра <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> объекта или вызвать регулярного выражения методу сопоставления шаблона.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>An array that describes the regular expressions to compile.</source>
          <target state="translated">Массив, описывающий регулярные выражения для компилирования.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The file name of the assembly.</source>
          <target state="translated">Имя файла сборки.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>An array that defines the attributes to apply to the assembly.</source>
          <target state="translated">Массив, определяющий атрибуты, применяемые к сборке.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Compiles one or more specified <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects to a named assembly with the specified attributes.</source>
          <target state="translated">Компилирует один или несколько указанных объектов <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> в именованную сборку с заданными атрибутами.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph2">`regexinfos`</ph> array is represented by a class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> Метод создает сборку платформы .NET Framework в какой каждого регулярного выражения, определенного в <ph id="ph2">`regexinfos`</ph> массива, представленный классом.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Typically, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> method is called from a separate application that generates an assembly of compiled regular expressions.</source>
          <target state="translated">Как правило <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> метод вызывается из отдельного приложения, создает сборку скомпилированных регулярных выражений.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Each regular expression included in the assembly has the following characteristics:</source>
          <target state="translated">Каждый регулярных выражений, включенных в сборке имеет следующие характеристики:</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>It is derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Он является производным от <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>It is assigned the fully qualified name that is defined by the <ph id="ph1">`fullnamespace`</ph> and <ph id="ph2">`name`</ph> parameters of its corresponding <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> object.</source>
          <target state="translated">Он назначен полное доменное имя, которое определяется <ph id="ph1">`fullnamespace`</ph> и <ph id="ph2">`name`</ph> параметров соответствующего <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>It has a default (or parameterless) constructor.</source>
          <target state="translated">По умолчанию (или без параметров) конструктора.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</source>
          <target state="translated">Обычно код, который создает и использует скомпилированное регулярное выражение находится в сборке или приложения, отдельном от кода, создающий сборку.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> method generates a .NET Framework assembly from a method call instead of using a particular language's class definition keyword (such as <ph id="ph2">`class`</ph> in C# or <ph id="ph3">`Class`</ph>…<ph id="ph4">`End Class`</ph></source>
          <target state="translated">Так как <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> метод создает сборку платформы .NET Framework из вызова метода, вместо того чтобы использовать ключевое слово определение класса для конкретного языка (например, <ph id="ph2">`class`</ph> в C# или <ph id="ph3">`Class`</ph>...<ph id="ph4">`End Class`</ph></target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>in Visual Basic), it does not allow .NET Framework attributes to be assigned to the assembly by using the development language's standard attribute syntax.</source>
          <target state="translated">в Visual Basic) он не позволяет использовать .NET Framework атрибутов для назначения сборки с помощью языка разработки стандартный синтаксис атрибутов.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The <ph id="ph1">`attributes`</ph> parameter provides an alternative method for defining the attributes that apply to the assembly.</source>
          <target state="translated"><ph id="ph1">`attributes`</ph> Параметр предоставляет альтернативный метод для определения атрибутов, которые применяются к сборке.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>For each attribute that you want to apply to the assembly, do the following:</source>
          <target state="translated">Для каждого атрибута, который требуется применить к сборке выполните следующие действия.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Create an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects representing the parameter types of the attribute constructor that you want to call.</source>
          <target state="translated">Создайте массив <ph id="ph1">&lt;xref:System.Type&gt;</ph> объектов, представляющих типы параметров конструктора атрибута, который требуется вызвать.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Retrieve a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing the attribute class that you want to apply to the new assembly.</source>
          <target state="translated">Получить <ph id="ph1">&lt;xref:System.Type&gt;</ph> объект, представляющий класс атрибута, который вы хотите применить к новой сборке.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method of the attribute <ph id="ph2">&lt;xref:System.Type&gt;</ph> object to retrieve a <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object representing the attribute constructor that you want to call.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> метод атрибута <ph id="ph2">&lt;xref:System.Type&gt;</ph> извлекаемого объекта <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> объект, представляющий конструктор атрибута, который требуется вызвать.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Pass the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method the array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects that represents the constructor's parameter types.</source>
          <target state="translated">Передайте <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> метод массива из <ph id="ph2">&lt;xref:System.Type&gt;</ph> объектов, представляющих типы параметров конструктора.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Create a <ph id="ph1">&lt;xref:System.Object&gt;</ph> array that defines the parameters to pass to the attribute's constructor.</source>
          <target state="translated">Создание <ph id="ph1">&lt;xref:System.Object&gt;</ph> массив, который определяет параметры для передачи в конструктор атрибута.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Instantiate a <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> object by passing its constructor the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object retrieved in step 3 and the <ph id="ph3">&lt;xref:System.Object&gt;</ph> array created in step 4.</source>
          <target state="translated">Создать экземпляр <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> объекта путем передачи его конструктору <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> объекта, полученное на шаге 3 и <ph id="ph3">&lt;xref:System.Object&gt;</ph> массив, созданный на шаге 4.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>You can then pass an array of these <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objects instead of the <ph id="ph2">`attributes`</ph> parameter to the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Затем можно передать массив этих <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> объектов вместо <ph id="ph2">`attributes`</ph> параметр <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The following example creates an assembly named RegexLib.dll and applies the <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribute to it.</source>
          <target state="translated">В следующем примере создается сборка с именем RegexLib.dll и применяет <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> к нему атрибут.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The assembly includes two compiled regular expressions.</source>
          <target state="translated">Сборка включает два скомпилированных регулярных выражений.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The first, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, matches two identical contiguous words.</source>
          <target state="translated">Первый, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, соответствует два одинаковых смежных слов.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The second, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, checks whether a string has the correct format to be an email address.</source>
          <target state="translated">Второе, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, проверяет, является ли строка имеет правильный формат является адресом электронной почты.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>You can verify that the <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribute has been applied to the assembly by examining its manifest with a reflection utility such as ILDasm.</source>
          <target state="translated">Можно убедиться, что <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> был применен атрибут к сборке с помощью проверки его манифест с помощью отражения программы, например ILDasm.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The regular expression that checks a string for duplicate words is then instantiated and used by the following example.</source>
          <target state="translated">Затем регулярное выражение, которое проверяет строку на наличие повторяющихся слов создается и используется в следующем примере.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Successful compilation of this second example requires a reference to RegexLib.dll (the assembly created by the first example) to be added to the project.</source>
          <target state="translated">Для успешной компиляции во втором примере требуется ссылка на RegexLib.dll (сборка, созданная в первом примере) для добавления в проект.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The value of the <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> parameter's <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> property is an empty or null string.</source>
          <target state="translated">Значением свойства <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> параметра <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> является пустая или нулевая строка.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The regular expression pattern of one or more objects in <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated">Шаблон регулярного выражения одного или более объектов в <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> содержит недопустимый синтаксис.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> or <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> или <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>If you are developing on a system that has <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or its point releases installed, you target <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, and you use the <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> method to create an assembly that contains compiled regular expressions.</source>
          <target state="translated">При разработке в системе, где <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> или назначьте ее доработанные выпуски установлен <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, и использовать <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> метод, чтобы создать сборку, содержащую скомпилированные регулярные выражения.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Trying to use one of the regular expressions in that assembly on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> throws an exception.</source>
          <target state="translated">Попытка использовать одно из регулярных выражений в том, что сборке в системе с <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> приводит к возникновению исключения.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>To work around this problem, you can do either of the following:</source>
          <target state="translated">Чтобы обойти эту проблему, можно воспользоваться одним из следующих способов:</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Build the assembly that contains the compiled regular expressions on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> instead of later versions installed.</source>
          <target state="translated">Создать сборку, содержащую скомпилированные регулярные выражения в системе, которая имеет <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> вместо более поздних версий.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Instead of calling <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> and retrieving the compiled regular expression from an assembly, use either static or instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> methods with the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option when you instantiate a <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object or call a regular expression pattern matching method.</source>
          <target state="translated">Вместо вызова метода <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> и получение скомпилированного регулярного выражения из сборки, используйте статических или экземпляр <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> методы с <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> параметр при создании экземпляра <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> объекта или вызвать регулярного выражения методу сопоставления шаблона.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>An array that describes the regular expressions to compile.</source>
          <target state="translated">Массив, описывающий регулярные выражения для компилирования.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The file name of the assembly.</source>
          <target state="translated">Имя файла сборки.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>An array that defines the attributes to apply to the assembly.</source>
          <target state="translated">Массив, определяющий атрибуты, применяемые к сборке.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The name of the Win32 resource file to include in the assembly.</source>
          <target state="translated">Имя файла ресурса Win32 для включения в сборку.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Compiles one or more specified <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects and a specified resource file to a named assembly with the specified attributes.</source>
          <target state="translated">Компилирует один или несколько указанных объектов <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> и указанный файл ресурсов в именованную сборку с заданными атрибутами.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph3">`regexinfos`</ph> array is represented by a class.</source>
          <target state="translated">[<ph id="ph1">\]</ph>, Имя сборки, CustomAttributeBuilder с передачей<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName% 2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 &gt; метод создает сборку платформы .NET Framework в какой каждого регулярного выражения, определенного в <ph id="ph3">`regexinfos`</ph> массива, представленный классом.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Typically, the [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method is called from a separate application that generates an assembly of compiled regular expressions.</source>
          <target state="translated">Как правило [<ph id="ph1">\]</ph>, имя сборки, CustomAttributeBuilder с передачей<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D% 2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 &gt; метод вызывается из отдельного приложения, создает сборку скомпилированных регулярных выражений.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Each regular expression included in the assembly has the following characteristics:</source>
          <target state="translated">Каждый регулярных выражений, включенных в сборке имеет следующие характеристики:</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>It is derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Он является производным от <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>It is assigned the fully qualified name that is defined by the <ph id="ph1">`fullnamespace`</ph> and <ph id="ph2">`name`</ph> parameters of its corresponding <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> object.</source>
          <target state="translated">Он назначен полное доменное имя, которое определяется <ph id="ph1">`fullnamespace`</ph> и <ph id="ph2">`name`</ph> параметров соответствующего <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>It has a default (or parameterless) constructor.</source>
          <target state="translated">По умолчанию (или без параметров) конструктора.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</source>
          <target state="translated">Обычно код, который создает и использует скомпилированное регулярное выражение находится в сборке или приложения, отдельном от кода, создающий сборку.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> method generates a .NET Framework assembly from a method call instead of using a particular language's class definition keyword (such as <ph id="ph2">`class`</ph> in C# or <ph id="ph3">`Class`</ph>…<ph id="ph4">`End Class`</ph></source>
          <target state="translated">Так как <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> метод создает сборку платформы .NET Framework из вызова метода, вместо того чтобы использовать ключевое слово определение класса для конкретного языка (например, <ph id="ph2">`class`</ph> в C# или <ph id="ph3">`Class`</ph>...<ph id="ph4">`End Class`</ph></target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>in Visual Basic), it does not allow .NET Framework attributes to be assigned to the assembly by using the development language's standard attribute syntax.</source>
          <target state="translated">в Visual Basic) он не позволяет использовать .NET Framework атрибутов для назначения сборки с помощью языка разработки стандартный синтаксис атрибутов.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The <ph id="ph1">`attributes`</ph> parameter provides an alternative method for defining the attributes that apply to the assembly.</source>
          <target state="translated"><ph id="ph1">`attributes`</ph> Параметр предоставляет альтернативный метод для определения атрибутов, которые применяются к сборке.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>For each attribute that you want to apply to the assembly, do the following:</source>
          <target state="translated">Для каждого атрибута, который требуется применить к сборке выполните следующие действия.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Create an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects representing the parameter types of the attribute constructor that you want to call.</source>
          <target state="translated">Создайте массив <ph id="ph1">&lt;xref:System.Type&gt;</ph> объектов, представляющих типы параметров конструктора атрибута, который требуется вызвать.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Retrieve a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing the attribute class that you want to apply to the new assembly.</source>
          <target state="translated">Получить <ph id="ph1">&lt;xref:System.Type&gt;</ph> объект, представляющий класс атрибута, который вы хотите применить к новой сборке.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method of the attribute <ph id="ph2">&lt;xref:System.Type&gt;</ph> object to retrieve a <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object representing the attribute constructor that you want to call.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> метод атрибута <ph id="ph2">&lt;xref:System.Type&gt;</ph> извлекаемого объекта <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> объект, представляющий конструктор атрибута, который требуется вызвать.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Pass the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method the array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects that represents the constructor's parameter types</source>
          <target state="translated">Передайте <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> метод массива из <ph id="ph2">&lt;xref:System.Type&gt;</ph> объектов, представляющих типы параметров конструктора</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Create a <ph id="ph1">&lt;xref:System.Object&gt;</ph> array that defines the parameters to pass to the attribute's constructor.</source>
          <target state="translated">Создание <ph id="ph1">&lt;xref:System.Object&gt;</ph> массив, который определяет параметры для передачи в конструктор атрибута.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Instantiate a <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> object by passing its constructor the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object retrieved in step 3 and the <ph id="ph3">&lt;xref:System.Object&gt;</ph> array created in step 4.</source>
          <target state="translated">Создать экземпляр <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> объекта путем передачи его конструктору <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> объекта, полученное на шаге 3 и <ph id="ph3">&lt;xref:System.Object&gt;</ph> массив, созданный на шаге 4.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>You can then pass an array of these <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objects instead of the <ph id="ph2">`attributes`</ph> parameter to the [<ph id="ph3">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph4">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method.</source>
          <target state="translated">Затем можно передать массив этих <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> объектов вместо <ph id="ph2">`attributes`</ph> параметра [<ph id="ph3">\]</ph>, имя сборки, CustomAttributeBuilder с передачей<ph id="ph4">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly% 28System.Text.RegularExpressions.RegexCompilationInfo%5b%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 &gt; метод.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The value of the <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> parameter's <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> property is an empty or null string.</source>
          <target state="translated">Значением свойства <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> параметра <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> является пустая или нулевая строка.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The regular expression pattern of one or more objects in <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated">Шаблон регулярного выражения одного или более объектов в <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> содержит недопустимый синтаксис.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> or <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> или <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> parameter designates an invalid Win32 resource file.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> назначает недопустимый файл ресурсов Win32.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The file designated by the <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> parameter cannot be found.</source>
          <target state="translated">Не удается найти файл, заданный свойством <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>If you are developing on a system that has <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or its point releases installed, you target <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, and you use the <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> method to create an assembly that contains compiled regular expressions.</source>
          <target state="translated">При разработке в системе, где <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> или назначьте ее доработанные выпуски установлен <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, и использовать <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> метод, чтобы создать сборку, содержащую скомпилированные регулярные выражения.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Trying to use one of the regular expressions in that assembly on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> throws an exception.</source>
          <target state="translated">Попытка использовать одно из регулярных выражений в том, что сборке в системе с <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> приводит к возникновению исключения.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>To work around this problem, you can do either of the following:</source>
          <target state="translated">Чтобы обойти эту проблему, можно воспользоваться одним из следующих способов:</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Build the assembly that contains the compiled regular expressions on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> instead of later versions installed.</source>
          <target state="translated">Создать сборку, содержащую скомпилированные регулярные выражения в системе, которая имеет <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> вместо более поздних версий.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Instead of calling <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> and retrieving the compiled regular expression from an assembly, use either static or instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> methods with the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option when you instantiate a <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object or call a regular expression pattern matching method.</source>
          <target state="translated">Вместо вызова метода <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> и получение скомпилированного регулярного выражения из сборки, используйте статических или экземпляр <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> методы с <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> параметр при создании экземпляра <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> объекта или вызвать регулярного выражения методу сопоставления шаблона.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>The input string that contains the text to convert.</source>
          <target state="translated">Входная строка, содержащая преобразуемый текст.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Escapes a minimal set of characters (<ph id="ph1">\\</ph>, *, +, ?, |, {, [, (,), ^, $,., #, and white space) by replacing them with their escape codes.</source>
          <target state="translated">Преобразует минимальный набор символов (<ph id="ph1">\\</ph>, *, +, ?, |, {, [, (,), ^, $,., # и пробел), заменяя их escape-кодами.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>This instructs the regular expression engine to interpret these characters literally rather than as metacharacters.</source>
          <target state="translated">При этом обработчику регулярных выражений дается команда интерпретировать эти символы буквально, а не как метасимволы.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>A string of characters with metacharacters converted to their escaped form.</source>
          <target state="translated">Строка символов с метасимволами, приведенными в преобразованную форму.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> converts a string so that the regular expression engine will interpret any metacharacters that it may contain as character literals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> Преобразует строку, чтобы обработчик регулярных выражений интерпретирует метасимволами, он может содержать как символьные литералы.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>For example, consider a regular expression that is designed to extract comments that are delimited by straight opening and closing brackets ([ and ]) from text.</source>
          <target state="translated">Например рассмотрим регулярное выражение, предназначенное для извлечения комментариев, которые разделены открывающей и закрывающей квадратных скобок ([и]) из текста.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In the following example, the regular expression "[(.*?)]" is interpreted as a character class.</source>
          <target state="translated">В следующем примере регулярное выражение «[(.*?)]» интерпретируется как класс символов.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Rather than matching comments embedded in the input text, the regular expression matches each opening or closing parenthesis, period, asterisk, or question mark.</source>
          <target state="translated">Вместо сопоставления комментариев внедренных в входной текст, регулярное выражение сопоставляет каждый открывающей или закрывающей круглой, период, звездочку или вопросительный знак.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>However, if the opening bracket is escaped by passing it to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method, the regular expression succeeds in matching comments that are embedded in the input string.</source>
          <target state="translated">Однако если открывающую квадратную скобку, экранируется путем ее передачи <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> метода регулярное выражение успешно сопоставления комментариев, которые внедряются во входной строке.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>The following example illustrates this.</source>
          <target state="translated">Это показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In a regular expression that is defined by using static text, characters that are to be interpreted literally rather than as metacharacters can be escaped by preceding them with a backslash symbol (<ph id="ph1">\\</ph>) as well as by calling the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method.</source>
          <target state="translated">В регулярном выражении, которое определяется с помощью статического текста, можно экранировать символы, которые должны интерпретироваться буквально, а не как метасимволы предварять символ обратной косой черты (<ph id="ph1">\\</ph>) также путем вызова <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In a regular expression that is defined dynamically using characters that are not known at design time, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method is particularly important to ensure that the regular expression engine interprets individual characters as literals rather than as metacharacters.</source>
          <target state="translated">В регулярном выражении, которое определяется динамически с помощью символов, которые не известны во время разработки вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> метод особенно важно, чтобы убедиться, что обработчик регулярных выражений распознает отдельные символы как литералы вместо чем как метасимволы.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If a regular expression pattern includes either the number sign (#) or literal white-space characters, they must be escaped if input text is parsed with the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option enabled.</source>
          <target state="translated">Если шаблон регулярного выражения включает литеральные символы пробела или знак номера (#), то их необходимо экранировать Если входной текст анализируется с <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> параметр включен.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>While the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method escapes the straight opening bracket ([) and opening brace ({) characters, it does not escape their corresponding closing characters (] and }).</source>
          <target state="translated">Хотя <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> метод экранирует прямой Открытие квадратная скобка ([) и открыв скобки ({}), он не экранирует их соответствующий закрывающий символов (] и}).</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In most cases, escaping these is not necessary.</source>
          <target state="translated">В большинстве случаев эти экранирование не требуется.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If a closing bracket or brace is not preceded by its corresponding opening character, the regular expression engine interprets it literally.</source>
          <target state="translated">Закрывающая скобка или фигурной скобки не предшествует соответствующего открывающего символа, обработчик регулярных выражений интерпретирует буквально.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If an opening braket or brace is interpreted as a metacharacter, the regular expression engine interprets the first corresponding closing character as a metacharacter.</source>
          <target state="translated">Если открытая круглая или квадратная скобка интерпретируется как метасимвол, обработчик регулярных выражений интерпретирует первый соответствующий закрывающий знак как метасимвол.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If this is not the desired behavior, the closing bracket or brace should be escaped by explicitly prepending the backslash (<ph id="ph1">\\</ph>) character.</source>
          <target state="translated">Если это не желательно, добавляя перед обратной косой чертой следует экранировать закрывающих или фигурных скобок (<ph id="ph1">\\</ph>) символов.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>For an illustration, see the Example section.</source>
          <target state="translated">Иллюстрация см. в разделе.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>The following example extracts comments from text.</source>
          <target state="translated">Следующий пример извлекает комментарии из текста.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>It assumes that the comments are delimited by a begin comment symbol and an end comment symbol that is selected by the user.</source>
          <target state="translated">В примере предполагается, что комментарии разделяются символом начала комментария и символом окончания комментария, выбранных пользователем.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Because the comment symbols are to be interpreted literally, they are passed to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method to ensure that they cannot be misinterpreted as metacharacters.</source>
          <target state="translated">Поскольку символы начала комментария следует интерпретировать буквально, они передаются в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> метод, чтобы гарантировать, что они не может быть ошибочно интерпретирована как метасимволы.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In addition, the example explicitly checks whether the end comment symbol entered by the user is a closing bracket (]) or brace (}).</source>
          <target state="translated">Кроме того пример явно проверяет, является ли введенный пользователем символ окончания комментария закрывающая скобка (]) или фигурной скобкой (}).</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If it is, a backslash character (<ph id="ph1">\\</ph>) is prepended to the bracket or brace so that it is interpreted literally.</source>
          <target state="translated">Если это так, символ обратной косой черты (<ph id="ph1">\\</ph>) добавляется в скобки или фигурные скобки, чтобы интерпретировать буквально.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Note that the example also uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> collection to display the comment only, rather than the comment together with its opening and closing comment symbols.</source>
          <target state="translated">Обратите внимание, что в примере также используется <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> коллекции для отображения комментариев, вместо того чтобы комментарий вместе с ее открывающих и закрывающих символов комментария.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="str" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.factory">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Используется объектом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>, который создан методом <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Returns an array of capturing group names for the regular expression.</source>
          <target state="translated">Возвращает массив имен группы записи для регулярного выражения.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>A string array of group names.</source>
          <target state="translated">Строковый массив имен группы.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The collection of group names contains the set of strings used to name capturing groups in the expression.</source>
          <target state="translated">Коллекция имен групп содержит набор строк, используемых для имени захватываемых групп в выражении.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Even if capturing groups are not explicitly named, they are automatically assigned numerical names ("0", "1", "2", "3", and so on).</source>
          <target state="translated">Даже если группы захвата не названы явным образом, они автоматически назначаются числовые имена («0», «1», «2», «3» и т. д).</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The "0" named group represents all text matched by the regular expression pattern.</source>
          <target state="translated">«0» с именем группы представляет все текст, соответствующий шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Numbered groups precede explicitly named groups in the collection, and named groups appear in the order in which they are defined in the regular expression pattern.</source>
          <target state="translated">Нумерованные группы перед явно именованные группы в коллекции, а именованные группы отображаются в том порядке, в котором они определены в шаблоне регулярного выражения.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>You can use the <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> property on the array returned by this method to determine the number of groups in a regular expression.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> свойства в массиве, возвращенное этим методом, чтобы определить количество групп в регулярном выражении.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The following example defines a general-purpose <ph id="ph1">`ShowMatches`</ph> method that displays the names of regular expression groups and their matched text.</source>
          <target state="translated">В следующем примере определяется универсальный <ph id="ph1">`ShowMatches`</ph> метод, который отображает имена групп регулярных выражений и их совпадающего текста.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>In this case, the regular expression pattern <ph id="ph1">`\b(?&lt;FirstWord&gt;\w+)\s?((\w+)\s)*(?&lt;LastWord&gt;\w+)?(?&lt;Punctuation&gt;\p{Po})`</ph> is intended to parse a simple sentence, and to identify its first word, last word, and ending punctuation mark.</source>
          <target state="translated">В данном случае шаблон регулярного выражения <ph id="ph1">`\b(?&lt;FirstWord&gt;\w+)\s?((\w+)\s)*(?&lt;LastWord&gt;\w+)?(?&lt;Punctuation&gt;\p{Po})`</ph> предназначен для синтаксического анализа simple предложения, а также для определения его первого слова, последнее слово и конечным знаком пунктуации.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The following table shows how the regular expression pattern is interpreted:</source>
          <target state="translated">Следующая таблица показывает, как интерпретируется шаблон регулярного выражения:</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Совпадение должно начинаться на границе слова.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match one or more word characters.</source>
          <target state="translated">Совпадение с одним или несколькими символами слова.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the <ph id="ph1">`FirstWord`</ph> named group.</source>
          <target state="translated">Это <ph id="ph1">`FirstWord`</ph> с именем группы.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>\s?</source>
          <target state="translated">\s?</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match zero or one white-space characters.</source>
          <target state="translated">Совпадение с нулем или одним символом пробела.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>(\w+)</source>
          <target state="translated">(\w+)</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match one or more word characters.</source>
          <target state="translated">Совпадение с одним или несколькими символами слова.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the second capturing group.</source>
          <target state="translated">Это вторая группа записи.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>\s</source>
          <target state="translated">\s</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match a white-space character.</source>
          <target state="translated">Соответствует пробелу.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>((\w+)\s)*</source>
          <target state="translated">((\w+)\s)*</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match zero or more occurrences of one or more word characters followed by a white space.</source>
          <target state="translated">Сопоставление нуля или более вхождений одной или несколькими символами слова, с пробелом.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the first capturing group.</source>
          <target state="translated">Это первая группа записи.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>(?<ph id="ph1">\&lt;</ph>LastWord&gt;\w+)?</source>
          <target state="translated">(? <ph id="ph1">\&lt;</ph>LastWord &gt; \w+)?</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match zero or one occurrence of one or more word characters.</source>
          <target state="translated">Сопоставление нулевого или единичного вхождения одной или несколькими символами слова.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the <ph id="ph1">`LastWord`</ph> named group.</source>
          <target state="translated">Это <ph id="ph1">`LastWord`</ph> с именем группы.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>(?<ph id="ph1">\&lt;</ph>Punctuation&gt;\p{Po})</source>
          <target state="translated">(? <ph id="ph1">\&lt;</ph>Пунктуации &gt; \p{Po})</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match a character whose Unicode category is Punctuation, Other.</source>
          <target state="translated">Соответствует символу, которого категории Юникода является знаком пунктуации, другими.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the <ph id="ph1">`Punctuation`</ph> named group.</source>
          <target state="translated">Это <ph id="ph1">`Punctuation`</ph> с именем группы.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Returns an array of capturing group numbers that correspond to group names in an array.</source>
          <target state="translated">Возвращает массив номеров групп записи, что соответствует именам групп в массиве.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>An integer array of group numbers.</source>
          <target state="translated">Целочисленный массив номеров групп.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Both unnamed and named capturing groups can be accessed by number.</source>
          <target state="translated">Неименованные и именованные группы захвата может осуществляться по номеру.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Unnamed groups are numbered from left to right starting with 1.</source>
          <target state="translated">Неименованные группы нумеруются слева направо, начиная с 1.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>(The capturing group in index 0 (zero) represents the match as a whole.)  Named groups are then numbered from left to right starting with a number that is one greater than the number of unnamed capturing groups.</source>
          <target state="translated">(Группе записи в индексе 0 (ноль) представляет сопоставление в целом).  Именованные группы, затем нумеруются слева направо, начиная с число, которое на единицу больше, чем число неименованных захватываемых групп.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Referencing a group by its number instead of by string name can provide faster access.</source>
          <target state="translated">Ссылки на группы по номеру ее, а не по имени строки может обеспечить более быстрый доступ.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The following example defines a regular expression, <ph id="ph1">`\b((?&lt;word&gt;\w+)\s*)+(?&lt;end&gt;[.?!])`</ph>, that matches a sentence.</source>
          <target state="translated">В следующем примере определяется регулярное выражение, <ph id="ph1">`\b((?&lt;word&gt;\w+)\s*)+(?&lt;end&gt;[.?!])`</ph>, которая сопоставляет предложение.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The regular expression includes three capturing groups: an unnamed group that captures an individual word along with a space character that may follow it; a group named <ph id="ph1">`word`</ph> that captures the individual words in the sentence; and a group named <ph id="ph2">`end`</ph> that captures the punctuation that ends the sentence.</source>
          <target state="translated">Регулярное выражение содержит три группы захвата: неименованные группы, отражающая отдельного слова вместе с символ пробела, может следовать за его; Группа с именем <ph id="ph1">`word`</ph> , собирающий отдельные слова в операторе; и группа с именем <ph id="ph2">`end`</ph> , собирающий знаки препинания, который заканчивается предложения.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A&gt;</ph> method to get the numbers of all capturing groups, and then displays their captured string.</source>
          <target state="translated">В примере вызывается <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A&gt;</ph> метод для получения номера записи всех групп, а затем отображает их захватываемой строки.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> method is used to indicate whether a particular numbered group corresponds to a named group.</source>
          <target state="translated">Кроме того <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> метод используется для указания того, соответствует ли определенный нумерованной группе именованную группу.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">Возможные интерпретации шаблона регулярного выражения показаны в следующей таблице.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Совпадение должно начинаться на границе слова.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match one or more word characters and assign the matched strings to a group named <ph id="ph1">`word`</ph>.</source>
          <target state="translated">Сопоставление одного или нескольких символов слов и назначить соответствующие строки в группу с именем <ph id="ph1">`word`</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">Соответствует нулю или нескольким символам пробела.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Assign the <ph id="ph1">`word`</ph> captured group followed by any captured white-space characters to the first captured group.</source>
          <target state="translated">Назначьте <ph id="ph1">`word`</ph> захватываемой группе, все записанные символы-разделители для первой захватываемой группы.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match the pattern of one or more word characters followed by any white-space characters one or more times.</source>
          <target state="translated">Совпадение с шаблоном символов слов, за которым следует любой пробельные символы один или несколько раз.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match a period, question mark, or exclamation point.</source>
          <target state="translated">Совпадение с точкой, вопросительным знаком или восклицательным знаком.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Assign the matched character to the <ph id="ph1">`end`</ph> capturing group.</source>
          <target state="translated">Сопоставленная символа, который необходимо назначить <ph id="ph1">`end`</ph> захватываемой группой.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The group number to convert to the corresponding group name.</source>
          <target state="translated">Номер группы для преобразования в соответствующее имя группы.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Gets the group name that corresponds to the specified group number.</source>
          <target state="translated">Получает имя группы, соответствующее указанному номеру группы.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>A string that contains the group name associated with the specified group number.</source>
          <target state="translated">Строка, содержащая имя группы, связанное с указанным номером группы.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If there is no group name that corresponds to <ph id="ph1">&lt;paramref name="i" /&gt;</ph>, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">При отсутствии имени группы, соответствующей параметру <ph id="ph1">&lt;paramref name="i" /&gt;</ph>, метод возвращает значение <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>A regular expression pattern may contain either named or numbered capturing groups, which delineate subexpressions within a pattern match.</source>
          <target state="translated">Шаблон регулярного выражения может содержать либо именованной или нумерованной группы записи, которые отображают части выражений в пределах соответствия шаблону.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Numbered groups are delimited by the syntax (<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>) and are assigned numbers based on their order in the regular expression.</source>
          <target state="translated">Нумерованные группы разделены с помощью синтаксиса (<bpt id="p1">*</bpt>часть выражения<ept id="p1">*</ept>) и им назначается чисел в зависимости от их порядка в регулярном выражении.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Named groups are delimited by the syntax (?<ph id="ph1">`&lt;`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) or (?'<bpt id="p3">*</bpt>name<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>), where <bpt id="p5">*</bpt>name<ept id="p5">*</ept> is the name by which the subexpression will be identified.</source>
          <target state="translated">Именованные группы разделяются с помощью синтаксиса (?<ph id="ph1">`&lt;`</ph> <bpt id="p1">*</bpt>имя<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>часть выражения<ept id="p2">*</ept>) или (? " <bpt id="p3">*</bpt>имя<ept id="p3">*</ept>"<bpt id="p4">*</bpt>часть выражения<ept id="p4">*</ept>), где <bpt id="p5">*</bpt>имя<ept id="p5">*</ept> имя, по которому будет определяться вложенное выражение.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>(For more information, see <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.) The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> method identifies both named groups and numbered groups by their ordinal positions in the regular expression.</source>
          <target state="translated">(Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Конструкции группировки<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.) <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> Метод идентифицирует именованные группы и нумерованные группы по их позициям порядковый номер в регулярном выражении.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Ordinal position zero always represents the entire regular expression.</source>
          <target state="translated">Порядковый номер ноль всегда представляет полное регулярное выражение.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>All numbered groups are then counted before named groups, regardless of their actual position in the regular expression pattern.</source>
          <target state="translated">Все пронумерованные группы, затем учитываются перед именем группы, независимо от их фактического расположения в шаблоне регулярного выражения.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If <ph id="ph1">`i`</ph> is the number of a named group, the method returns the name of the group.</source>
          <target state="translated">Если <ph id="ph1">`i`</ph> номер именованные группы, метод возвращает имя группы.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If <ph id="ph1">`i`</ph> is the number of an unnamed group, the method returns the string representation of the number.</source>
          <target state="translated">Если <ph id="ph1">`i`</ph> номер неименованной группы, метод возвращает строковое представление числа.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>For example, if <ph id="ph1">`i`</ph> is 1, the method returns "1".</source>
          <target state="translated">Например если <ph id="ph1">`i`</ph> -1, метод возвращает «1».</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If <ph id="ph1">`i`</ph> is not the number of a capturing group, the method returns <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">`i`</ph> не — номер захватываемой группы, метод возвращает <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If a pattern match is found, the value returned by this method can then be used to retrieve the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object that represents the captured group from the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Если обнаруживается соответствие шаблону, значение, возвращенное этим методом затем может использоваться для получения <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> , представляющий захватываемой группы из <ph id="ph2">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object is returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> Возвращенный объект <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The following example defines a regular expression pattern that matches an address line containing a U.S. city name, state name, and zip code.</source>
          <target state="translated">В следующем примере определяется шаблон регулярного выражения, который соответствует строке адреса, содержащей название города США, имя состояния и почтовый индекс.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> method to retrieve the names of capturing groups.</source>
          <target state="translated">В этом примере <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> метод для извлечения имен группы записи.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>It then uses these names to retrieve the corresponding captured groups for matches.</source>
          <target state="translated">Затем эти имена используются для получения соответствующие захватываемой группы совпадений.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">Шаблон регулярного выражения определяется следующее выражение:</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">В следующей таблице показано, как интерпретируется шаблон регулярного выражения.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match one or more alphabetic or white-space character.</source>
          <target state="translated">Выделяет один или несколько символ буквы или символы разделители.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Assign this captured group the name <ph id="ph1">`city`</ph>.</source>
          <target state="translated">Назначьте этой группе записи имя <ph id="ph1">`city`</ph>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match a comma (,) followed by a white-space character.</source>
          <target state="translated">Соответствует запятой (,), за которым следует символ пробела.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match two alphabetic characters.</source>
          <target state="translated">Соответствует двух букв.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Assign this captured group the name <ph id="ph1">`state`</ph>.</source>
          <target state="translated">Назначьте этой группе записи имя <ph id="ph1">`state`</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>This group should be followed by a white-space character.</source>
          <target state="translated">Эта группа должен следовать символ пробела.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match five numeric digits followed by either zero or one occurrence of a hyphen followed by four digits.</source>
          <target state="translated">Соответствует пяти цифр, за которыми следует ноль или один экземпляров дефис и еще четыре цифры.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Assign this captured group the name <ph id="ph1">`zip`</ph>.</source>
          <target state="translated">Назначьте этой группе записи имя <ph id="ph1">`zip`</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>The group name to convert to the corresponding group number.</source>
          <target state="translated">Имя группы для преобразования в соответствующий номер группы.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Returns the group number that corresponds to the specified group name.</source>
          <target state="translated">Возвращает номер группы, соответствующий указанному имени группы.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>The group number that corresponds to the specified group name, or -1 if <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid group name.</source>
          <target state="translated">Номер группы, соответствующий указанному имени группы, или -1, если <ph id="ph1">&lt;paramref name="name" /&gt;</ph> является недопустимым именем группы.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>A regular expression pattern may contain either named or numbered capturing groups, which delineate subexpressions within a pattern match.</source>
          <target state="translated">Шаблон регулярного выражения может содержать либо именованной или нумерованной группы записи, которые отображают части выражений в пределах соответствия шаблону.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Numbered groups are delimited by the syntax (<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>) and are assigned numbers based on their order in the regular expression.</source>
          <target state="translated">Нумерованные группы разделены с помощью синтаксиса (<bpt id="p1">*</bpt>часть выражения<ept id="p1">*</ept>) и им назначается чисел в зависимости от их порядка в регулярном выражении.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Named groups are delimited by the syntax (?<ph id="ph1">`&lt;`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) or (?'<bpt id="p3">*</bpt>name<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>), where <bpt id="p5">*</bpt>name<ept id="p5">*</ept> is the name by which the subexpression will be identified.</source>
          <target state="translated">Именованные группы разделяются с помощью синтаксиса (?<ph id="ph1">`&lt;`</ph> <bpt id="p1">*</bpt>имя<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>часть выражения<ept id="p2">*</ept>) или (? " <bpt id="p3">*</bpt>имя<ept id="p3">*</ept>"<bpt id="p4">*</bpt>часть выражения<ept id="p4">*</ept>), где <bpt id="p5">*</bpt>имя<ept id="p5">*</ept> имя, по которому будет определяться вложенное выражение.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>(For more information, see <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.) The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A&gt;</ph> method identifies both named groups and numbered groups by their ordinal positions in the regular expression.</source>
          <target state="translated">(Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Конструкции группировки<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.) <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A&gt;</ph> Метод идентифицирует именованные группы и нумерованные группы по их позициям порядковый номер в регулярном выражении.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Ordinal position zero always represents the entire regular expression.</source>
          <target state="translated">Порядковый номер ноль всегда представляет полное регулярное выражение.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>All numbered groups are then counted before named groups, regardless of their actual position in the regular expression pattern.</source>
          <target state="translated">Все пронумерованные группы, затем учитываются перед именем группы, независимо от их фактического расположения в шаблоне регулярного выражения.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>If <ph id="ph1">`name`</ph> is the string representation of a group number that is present in the regular expression pattern, the method returns that number.</source>
          <target state="translated">Если <ph id="ph1">`name`</ph> является строковым представлением номер группы, который присутствует в шаблоне регулярного выражения, этот метод возвращает, число.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>If <ph id="ph1">`name`</ph> corresponds to a named capturing group that is present in the regular expression pattern, the method returns its corresponding number.</source>
          <target state="translated">Если <ph id="ph1">`name`</ph> соответствует именованного захватываемой группой, который присутствует в шаблоне регулярного выражения, метод возвращает его соответствующий номер.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>The comparison of <ph id="ph1">`name`</ph> with the group name is case-sensitive.</source>
          <target state="translated">Сравнение <ph id="ph1">`name`</ph> с группой имени учитывается регистр.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>If <ph id="ph1">`name`</ph> does not correspond to the name of a capturing group or to the string representation of the number of a capturing group, the method returns -1.</source>
          <target state="translated">Если <ph id="ph1">`name`</ph> не соответствует имени захватываемой группы, или строковое представление числа захватываемой группы, метод возвращает значение-1.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>Specifies that a pattern-matching operation should not time out.</source>
          <target state="translated">Указывает, что для операции сравнения с шаблоном не используется конечное время ожидания.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> class constructor and a number of static matching methods use the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> constant to indicate that the attempt to find a pattern match should not time out.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> Класса конструктор и количество статического сопоставления методы использования <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> константу, чтобы указать, не удается найти соответствие шаблону должен неограниченное время ожидания.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>Setting the regular expression engine's time-out value to <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> can cause regular expressions that rely on excessive backtracking to appear to stop responding when processing text that nearly matches the regular expression pattern.</source>
          <target state="translated">Установка значения времени ожидания обработчика регулярных выражений в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> может привести к регулярные выражения, зависящие от избыточный поиск с возвратом к перестает отвечать на запросы при обработке текста, почти соответствующие шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>If you disable time-outs, you should ensure that your regular expression does not rely on excessive backtracking and that it handles text that nearly matches the regular expression pattern.</source>
          <target state="translated">Если отключить время ожидания, следует убедиться, что регулярное выражение не зависит от избыточный поиск с возвратом и обработки текста, почти соответствующие шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>For more information about handling backtracking, see <bpt id="p1">[</bpt>Backtracking<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об обработке поиск с возвратом см. в разделе <bpt id="p1">[</bpt>поиск с возвратом<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> constant can be supplied as the value of the <ph id="ph2">`matchTimeout`</ph> argument of the following members:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> Константа может быть передано в качестве значение <ph id="ph2">`matchTimeout`</ph> аргумент из следующих элементов:</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.InitializeReferences">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Используется объектом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>, который создан методом <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.InitializeReferences">
          <source>References have already been initialized.</source>
          <target state="translated">Ссылки уже инициализированы.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.internalMatchTimeout">
          <source>The maximum amount of time that can elapse in a pattern-matching operation before the operation times out.</source>
          <target state="translated">Максимальное время, которое может пройти в операции сравнения с шаблоном перед истечением срока ожидания операции.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Indicates whether the regular expression finds a match in the input string.</source>
          <target state="translated">Указывает на то, обнаруживает ли регулярное выражение соответствие во входной строке.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Indicates whether the regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor finds a match in a specified input string.</source>
          <target state="translated">Указывает, обнаружено ли в указанной входной строке соответствие регулярному выражению, заданному в конструкторе <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если регулярное выражение обнаруживает соответствие; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> Метод обычно используется для проверки строки или чтобы обеспечить соответствие строка определенному шаблону без получения этой строки для последующей обработки.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">Если вы хотите определить ли одну или несколько строк, соответствующих шаблону регулярного выражения и затем извлечение их для последующей обработки, вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, определяемое <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создан объект.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если время ожидания не определен в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> вызов конструктора или в свойствах домена приложения, или если значение интервала <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">Следующий пример иллюстрирует использование <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> метод, чтобы определить, является ли строка допустимым артикулом.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов знаков, разделенных дефисами.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Первый набор, который содержит четыре знака, должен состоять из буквенно-цифровой символ, и два цифровые символы, за которыми следует буквенно-цифровой символ.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">Второй набор, состоящий из трех символов, должен быть числовым.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Третий набор, состоящий из четырех символов, должен иметь три цифровые символы, за которыми следует буквенно-цифровой символ.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The regular expression pattern is:</source>
          <target state="translated">Шаблон регулярного выражения выглядит следующим образом:</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">В следующей таблице показано, как интерпретируется шаблон регулярного выражения.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Begin the match at the beginning of the line.</source>
          <target state="translated">Соответствие должно обнаруживаться в начале строки.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Соответствует один буквенный символ (<ph id="ph1">`a`</ph> через <ph id="ph2">`z`</ph> или <ph id="ph3">`A`</ph> через <ph id="ph4">`Z`</ph>) или цифре.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match two numeric characters.</source>
          <target state="translated">Соответствует двум цифрам.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Соответствует один буквенный символ (<ph id="ph1">`a`</ph> через <ph id="ph2">`z`</ph> или <ph id="ph3">`A`</ph> через <ph id="ph4">`Z`</ph>) или цифре.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a hyphen.</source>
          <target state="translated">Выделение дефиса.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">Соответствует ровно трем цифрам.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">Найти дефис и еще по три цифры, а два совпадений в этом шаблоне.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Соответствует один буквенный символ (<ph id="ph1">`a`</ph> через <ph id="ph2">`z`</ph> или <ph id="ph3">`A`</ph> через <ph id="ph4">`Z`</ph>) или цифре.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>End the match at the end of the line.</source>
          <target state="translated">Совпадение должно заканчиваться в конце строки.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="input" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The character position at which to start the search.</source>
          <target state="translated">Расположение символа, с которого необходимо начать поиск.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Indicates whether the regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor finds a match in the specified input string, beginning at the specified starting position in the string.</source>
          <target state="translated">Указывает, обнаружено ли в указанной входной строке соответствие (начинающееся с указанной позиции в этой строке) регулярному выражению, заданному в конструкторе <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если регулярное выражение обнаруживает соответствие; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> Метод обычно используется для проверки строки или чтобы обеспечить соответствие строка определенному шаблону без получения этой строки для последующей обработки.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">Если вы хотите определить ли одну или несколько строк, соответствующих шаблону регулярного выражения и затем извлечение их для последующей обработки, вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, определяемое <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создан объект.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если время ожидания не определен в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> вызов конструктора или в свойствах домена приложения, или если значение интервала <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">Следующий пример иллюстрирует использование <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> метод, чтобы определить, является ли строка допустимым артикулом.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>It searches for a part number that follows a colon (:) character in a string.</source>
          <target state="translated">Он выполняет поиск номер части, следует двоеточие (:) в строке.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> method is used to determine the position of the colon character, which is then passed to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> Метод используется для определения положения символа двоеточия, который затем передается <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов знаков, разделенных дефисами.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Первый набор, который содержит четыре знака, должен состоять из буквенно-цифровой символ, и два цифровые символы, за которыми следует буквенно-цифровой символ.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">Второй набор, состоящий из трех символов, должен быть числовым.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Третий набор, состоящий из четырех символов, должен иметь три цифровые символы, за которыми следует буквенно-цифровой символ.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The regular expression pattern is:</source>
          <target state="translated">Шаблон регулярного выражения выглядит следующим образом:</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">В следующей таблице показано, как интерпретируется шаблон регулярного выражения.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Соответствует один буквенный символ (<ph id="ph1">`a`</ph> через <ph id="ph2">`z`</ph> или <ph id="ph3">`A`</ph> через <ph id="ph4">`Z`</ph>) или цифре.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match two numeric characters.</source>
          <target state="translated">Соответствует двум цифрам.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Соответствует один буквенный символ (<ph id="ph1">`a`</ph> через <ph id="ph2">`z`</ph> или <ph id="ph3">`A`</ph> через <ph id="ph4">`Z`</ph>) или цифре.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a hyphen.</source>
          <target state="translated">Выделение дефиса.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">Соответствует ровно трем цифрам.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">Найти дефис и еще по три цифры, а два совпадений в этом шаблоне.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Соответствует один буквенный символ (<ph id="ph1">`a`</ph> через <ph id="ph2">`z`</ph> или <ph id="ph3">`A`</ph> через <ph id="ph4">`Z`</ph>) или цифре.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>End the match at the end of the line.</source>
          <target state="translated">Совпадение должно заканчиваться в конце строки.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="input" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="startat" /&gt;</ph> имеет значение меньше нуля или больше длины <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Indicates whether the specified regular expression finds a match in the specified input string.</source>
          <target state="translated">Указывает, обнаружено ли в указанной входной строке соответствие заданному регулярному выражению.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если регулярное выражение обнаруживает соответствие; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> Метод обычно используется для проверки строки или чтобы обеспечить соответствие строка определенному шаблону без получения этой строки для последующей обработки.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">Если вы хотите определить ли одну или несколько строк, соответствующих шаблону регулярного выражения и затем извлечение их для последующей обработки, вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the regular expression pattern specified by <ph id="ph3">`pattern`</ph> and calling the <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance method.</source>
          <target state="translated">Статический <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> метода эквивалентно созданию <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта с шаблоном регулярного выражения, заданные <ph id="ph3">`pattern`</ph> и вызов <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> метод экземпляра.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>This regular expression pattern is cached for rapid retrieval by the regular expression engine.</source>
          <target state="translated">Этот шаблон регулярного выражения кэшируется для быстрого извлечения обработчиком регулярных выражений.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если время ожидания не определяется в свойствах домена приложения или если значение интервала <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">Следующий пример иллюстрирует использование <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> метод, чтобы определить, является ли строка допустимым артикулом.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов знаков, разделенных дефисами.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Первый набор, который содержит четыре знака, должен состоять из буквенно-цифровой символ, и два цифровые символы, за которыми следует буквенно-цифровой символ.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">Второй набор, состоящий из трех символов, должен быть числовым.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Третий набор, состоящий из четырех символов, должен иметь три цифровые символы, за которыми следует буквенно-цифровой символ.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The regular expression pattern is:</source>
          <target state="translated">Шаблон регулярного выражения выглядит следующим образом:</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">В следующей таблице показано, как интерпретируется шаблон регулярного выражения.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Begin the match at the beginning of the line.</source>
          <target state="translated">Соответствие должно обнаруживаться в начале строки.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Соответствует один буквенный символ (<ph id="ph1">`a`</ph> через <ph id="ph2">`z`</ph> или <ph id="ph3">`A`</ph> через <ph id="ph4">`Z`</ph>) или цифре.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match two numeric characters.</source>
          <target state="translated">Соответствует двум цифрам.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Соответствует один буквенный символ (<ph id="ph1">`a`</ph> через <ph id="ph2">`z`</ph> или <ph id="ph3">`A`</ph> через <ph id="ph4">`Z`</ph>) или цифре.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a hyphen.</source>
          <target state="translated">Выделение дефиса.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">Соответствует ровно трем цифрам.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">Найти дефис и еще по три цифры, а два совпадений в этом шаблоне.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Соответствует один буквенный символ (<ph id="ph1">`a`</ph> через <ph id="ph2">`z`</ph> или <ph id="ph3">`A`</ph> через <ph id="ph4">`Z`</ph>) или цифре.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>End the match at the end of the line.</source>
          <target state="translated">Совпадение должно заканчиваться в конце строки.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called.</source>
          <target state="translated">Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором был вызван метод.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Если значение времени ожидания не был определен для домена приложения, а значение <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, что предотвращает истечения времени ожидания, метод используется.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The recommended static method for verifying a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Рекомендуемые статический метод для проверки соответствия шаблону является <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, который позволяет установить интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options.</source>
          <target state="translated">Указывает, обнаружено ли в указанной входной строке соответствие заданному регулярному выражению, используя указанные параметры сопоставления.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если регулярное выражение обнаруживает соответствие; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> Метод обычно используется для проверки строки или чтобы обеспечить соответствие строка определенному шаблону без получения этой строки для последующей обработки.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">Если вы хотите определить ли одну или несколько строк, соответствующих шаблону регулярного выражения и затем извлечение их для последующей обработки, вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the regular expression pattern specified by <ph id="ph3">`pattern`</ph> and the regular expression options specified by <ph id="ph4">`options`</ph> and calling the <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance method.</source>
          <target state="translated">Статический <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> метода эквивалентно созданию <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта с шаблоном регулярного выражения, заданные <ph id="ph3">`pattern`</ph> и параметры регулярного выражения, заданные <ph id="ph4">`options`</ph> и вызов <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> экземпляра метод.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This regular expression pattern is cached for rapid retrieval by the regular expression engine.</source>
          <target state="translated">Этот шаблон регулярного выражения кэшируется для быстрого извлечения обработчиком регулярных выражений.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если время ожидания не определяется в свойствах домена приложения или если значение интервала <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">Следующий пример иллюстрирует использование <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> метод, чтобы определить, является ли строка допустимым артикулом.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов знаков, разделенных дефисами.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Первый набор, который содержит четыре знака, должен состоять из буквенно-цифровой символ, и два цифровые символы, за которыми следует буквенно-цифровой символ.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">Второй набор, состоящий из трех символов, должен быть числовым.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Третий набор, состоящий из четырех символов, должен иметь три цифровые символы, за которыми следует буквенно-цифровой символ.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern is:</source>
          <target state="translated">Шаблон регулярного выражения выглядит следующим образом:</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">В следующей таблице показано, как интерпретируется шаблон регулярного выражения.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Begin the match at the beginning of the string.</source>
          <target state="translated">Начало совпадения в начале строки.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Соответствует любому одиночному знаку алфавита от <ph id="ph1">`A`</ph> через <ph id="ph2">`Z`</ph>, или любой цифре.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match two numeric characters.</source>
          <target state="translated">Соответствует двум цифрам.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Соответствует любому одиночному знаку алфавита от <ph id="ph1">`A`</ph> через <ph id="ph2">`Z`</ph>, или любой цифре.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match a hyphen.</source>
          <target state="translated">Выделение дефиса.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">Соответствует ровно трем цифрам.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern..</source>
          <target state="translated">Найти дефис и еще по три цифры и соответствует двум вхождениям этого шаблона...</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Соответствует любому одиночному знаку алфавита от <ph id="ph1">`A`</ph> через <ph id="ph2">`Z`</ph>, или любой цифре.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>End the match at the end of the string.</source>
          <target state="translated">Совпадение должно заканчиваться в конце строки.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method with the <ph id="ph2">`options`</ph> parameter set to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> is equivalent to defining the following regular expression:</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> метод с <ph id="ph2">`options`</ph> равным <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> эквивалентное определение следующее регулярное выражение:</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For comparison, see the example for the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">Для сравнения, см. пример для <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является допустимым значением <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Если значение времени ожидания не был определен для домена приложения, а значение <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, что предотвращает истечения времени ожидания, метод используется.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for verifying a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Рекомендуемые статический метод для проверки соответствия шаблону является <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, который позволяет установить интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Интервал времени ожидания или <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, чтобы указать, что метод не должен превышать время ожидания.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options and time-out interval.</source>
          <target state="translated">Указывает, обнаружено ли в указанной входной строке соответствие заданному регулярному выражению, с помощью указанных параметров сопоставления и интервала времени ожидания.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если регулярное выражение обнаруживает соответствие; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> Метод обычно используется для проверки строки или чтобы обеспечить соответствие строка определенному шаблону без получения этой строки для последующей обработки.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">Если вы хотите определить ли одну или несколько строк, соответствующих шаблону регулярного выражения и затем извлечение их для последующей обработки, вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the regular expression pattern specified by <ph id="ph3">`pattern`</ph> and the regular expression options specified by <ph id="ph4">`options`</ph> and calling the <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance method.</source>
          <target state="translated">Статический <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> метода эквивалентно созданию <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта с шаблоном регулярного выражения, заданные <ph id="ph3">`pattern`</ph> и параметры регулярного выражения, заданные <ph id="ph4">`options`</ph> и вызов <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> экземпляра метод.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This regular expression pattern is cached for rapid retrieval by the regular expression engine.</source>
          <target state="translated">Этот шаблон регулярного выражения кэшируется для быстрого извлечения обработчиком регулярных выражений.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> Указывает о том, как долго шаблон соответствующий метод должен пытаться найти совпадения, до истечения времени ожидания. Установка интервала времени ожидания предотвращает регулярные выражения, зависящие от избыточный поиск с возвратом отображение перестает отвечать при обработке входных данных, содержащий ближайшие совпадения.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>советы и рекомендации по использованию регулярных выражений<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> и <bpt id="p2">[</bpt>поиск с возвратом<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Если совпадение не найдено в этого интервала времени, метод вызывает <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в которой выполняется метод.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">Следующий пример иллюстрирует использование <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> метод, чтобы определить, является ли строка допустимым артикулом.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов знаков, разделенных дефисами.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Первый набор, который содержит четыре знака, должен состоять из буквенно-цифровой символ, и два цифровые символы, за которыми следует буквенно-цифровой символ.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">Второй набор, состоящий из трех символов, должен быть числовым.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Третий набор, состоящий из четырех символов, должен иметь три цифровые символы, за которыми следует буквенно-цифровой символ.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Matching the regular expression pattern should involve minimal searching through the input string, so the method sets a time-out interval of 500 milliseconds.</source>
          <target state="translated">Сопоставление шаблона регулярного выражения привлечь минимальной поиска по входной строке, поэтому метод устанавливает интервал ожидания 500 миллисекунд.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern is:</source>
          <target state="translated">Шаблон регулярного выражения выглядит следующим образом:</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">В следующей таблице показано, как интерпретируется шаблон регулярного выражения.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Begin the match at the beginning of the string.</source>
          <target state="translated">Начало совпадения в начале строки.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Соответствует любому одиночному знаку алфавита от <ph id="ph1">`A`</ph> через <ph id="ph2">`Z`</ph>, или любой цифре.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match two numeric characters.</source>
          <target state="translated">Соответствует двум цифрам.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Соответствует любому одиночному знаку алфавита от <ph id="ph1">`A`</ph> через <ph id="ph2">`Z`</ph>, или любой цифре.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match a hyphen.</source>
          <target state="translated">Выделение дефиса.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">Соответствует ровно трем цифрам.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">Найти дефис и еще по три цифры, а два совпадений в этом шаблоне.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Соответствует любому одиночному знаку алфавита от <ph id="ph1">`A`</ph> через <ph id="ph2">`Z`</ph>, или любой цифре.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>End the match at the end of the string.</source>
          <target state="translated">Совпадение должно заканчиваться в конце строки.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method with the <ph id="ph2">`options`</ph> parameter set to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> is equivalent to defining the following regular expression:</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> метод с <ph id="ph2">`options`</ph> равным <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> эквивалентное определение следующее регулярное выражение:</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For comparison, see the example for the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">Для сравнения, см. пример для <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является допустимым значением <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> отрицательно, равно нулю или больше приблизительно 24 дней.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Мы рекомендуем задавать <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> параметр соответствующее значение, например две секунды.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Если отключить время ожидания, указав <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, обработчик регулярных выражений, обеспечивает немного лучшую производительность.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Тем не менее следует отключить тайм-ауты только при следующих условиях:</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Если входных данных, обрабатываемых регулярное выражение является производным от известного и надежного источника или состоит из статического текста.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Это исключает текст, который был динамически ввода пользователями.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Если шаблон регулярного выражения тщательно протестирован для обеспечения эффективной обработки соответствует несовпадающие и ближайшем совпадает.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Если шаблон регулярного выражения содержит не языковые элементы, которые возникает избыточный поиск с возвратом при обработке почти совпадают.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Searches an input string for a substring that matches a regular expression pattern and returns the first occurrence as a single <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> object.</source>
          <target state="translated">Находит во входной строке подстроку, совпадающую с шаблоном регулярного выражения, и возвращает первое вхождение в качестве единого объекта <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Searches the specified input string for the first occurrence of the regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Ищет в указанной входной строке первое вхождение регулярного выражения, указанного в конструкторе <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Объект, содержащий сведения о совпадении.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения во входной строке.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Сведения об элементах языка, можно создать шаблон регулярного выражения см. в разделе <bpt id="p1">[</bpt>языка регулярных выражений — краткий справочник<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Если соответствие найдено, возвращенный <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> содержит подстроку из <ph id="ph3">`input`</ph> , соответствующий шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если совпадение не найдено, его значение равно <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>This method returns the first substring in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Этот метод возвращает первую подстроку в <ph id="ph1">`input`</ph> , соответствующий шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Можно получить последующие соответствия, повторно вызвав возвращаемый <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Кроме того, все совпадения в одном вызове метода можно получить, вызвав <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, определяемое <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создан объект.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если время ожидания не определен в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> вызов конструктора или в свойствах домена приложения, или если значение интервала <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The following example finds regular expression pattern matches in a string, then lists the matched groups, captures, and capture positions.</source>
          <target state="translated">В следующем примере вычисляется шаблон регулярного выражения сопоставляет строки, а затем перечисляется список соответствующих групп, записей и позиций записи.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The regular expression pattern <ph id="ph1">`(\w+)\s+(car)`</ph> matches occurrences of the word "car" along with the word that precedes it.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`(\w+)\s+(car)`</ph> совпадает с числом вхождений слова «машина» вместе с Microsoft word, предшествующего ему.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>It is interpreted as shown in the following table.</source>
          <target state="translated">Интерпретируется, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Match one or more word characters.</source>
          <target state="translated">Совпадение с одним или несколькими символами слова.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>This is the first capturing group.</source>
          <target state="translated">Это первая группа записи.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Match one or more white-space characters.</source>
          <target state="translated">Соответствует один или несколько символов пробела.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>(car)</source>
          <target state="translated">(car)</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Match the literal string "car".</source>
          <target state="translated">Соответствует строковый литерал «машина».</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>This is the second capturing group.</source>
          <target state="translated">Это вторая группа записи.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="input" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The zero-based character position at which to start the search.</source>
          <target state="translated">Отсчитываемая от нуля позиция символа, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position in the string.</source>
          <target state="translated">Ищет во входной строке первое вхождение регулярного выражения, начиная с указанной начальной позиции.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Объект, содержащий сведения о совпадении.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> method returns the first substring that matches a regular expression pattern, starting at or after the <ph id="ph2">`startat`</ph> character position, in an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения, начиная с или после <ph id="ph2">`startat`</ph> позиции во входной строке знака.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Сведения об элементах языка, можно создать шаблон регулярного выражения см. в разделе <bpt id="p1">[</bpt>языка регулярных выражений — краткий справочник<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">Шаблон регулярного выражения, для которого <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> выполняет метод определяется путем вызова одного из <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> конструкторы класса.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об элементах, образующих шаблон регулярного выражения см. в разделе <bpt id="p1">[</bpt>языка регулярных выражений — краткий справочник<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can optionally specify a starting position in the string by using the <ph id="ph1">`startat`</ph> parameter.</source>
          <target state="translated">При необходимости можно указать начальную позицию в строке с помощью <ph id="ph1">`startat`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>When the regular expression engine parses from left to right (the default), the match and the scan move rightward, starting at the character specified in <ph id="ph1">`startat`</ph>.</source>
          <target state="translated">Когда обработчик регулярных выражений выполняет синтаксический анализ слева направо (по умолчанию), сопоставление и сканирование переместить правом направлении, начиная с символа, указанного в <ph id="ph1">`startat`</ph>.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>When the regular expression engine parses from right to left (when the regular expression pattern is constructed with the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> option), the match and scan move in the opposite direction and begin with the character at <ph id="ph2">`startat`</ph> -1.</source>
          <target state="translated">Когда обработчик регулярных выражений выполняет синтаксический анализ справа налево (если создается шаблон регулярного выражения со <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> параметр), сопоставление и просмотр перемещения в обратном направлении и начинаются с символа в <ph id="ph2">`startat`</ph> -1.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If you do not specify a starting position, the search begins at the default <ph id="ph1">`startat`</ph> position.</source>
          <target state="translated">Если начальная позиция не указан, поиск начинается в режиме по умолчанию <ph id="ph1">`startat`</ph> позиции.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If the regular expression searches from left to right, the default <ph id="ph1">`startat`</ph> position is at the left end of <ph id="ph2">`input`</ph>; if it searches from right to left, the default <ph id="ph3">`startat`</ph> position is at the right end of <ph id="ph4">`input`</ph>.</source>
          <target state="translated">Если регулярное выражение выполняет поиск слева направо, значение по умолчанию <ph id="ph1">`startat`</ph> расположено в левый конец <ph id="ph2">`input`</ph>; Если поиск выполняется от право слева, по умолчанию <ph id="ph3">`startat`</ph> расположено в правом конце <ph id="ph4">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If you want to restrict a match so that it begins at a particular character position in the string and the regular expression engine does not scan the remainder of the string for a match, anchor the regular expression with a <ph id="ph1">`\G`</ph> (at the left for a left-to-right pattern, or at the right for a right-to-left pattern).</source>
          <target state="translated">Если вы хотите ограничить соответствие, таким образом, чтобы он начинается с определенной позиции в строке и обработчик регулярных выражений не проверяет остаток строки на соответствие, закрепите регулярное выражение с <ph id="ph1">`\G`</ph> (слева для слева направо шаблон, или справа для шаблона справа налево).</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>This restricts the match so it must start exactly at <ph id="ph1">`startat`</ph>.</source>
          <target state="translated">Это ограничивает совпадение, поэтому он должен начинаться точно в <ph id="ph1">`startat`</ph>.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Если соответствие найдено, возвращенный <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> содержит подстроку из <ph id="ph3">`input`</ph> , соответствующий шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если совпадение не найдено, его значение равно <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>This method returns the first substring found at or after the <ph id="ph1">`startat`</ph> character position in <ph id="ph2">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Этот метод возвращает первую подстроку, найденную в или после <ph id="ph1">`startat`</ph> позиция знака в <ph id="ph2">`input`</ph> , соответствующий шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Можно получить последующие соответствия, повторно вызвав возвращаемый <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Кроме того, все совпадения в одном вызове метода можно получить, вызвав <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, определяемое <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exeeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Если вы не задает интервал времени ожидания при вызове конструктора, исключение вызывается, если любое значение времени ожидания операции превышает, установленного для домена приложения, в котором <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создан объект.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если время ожидания не определен в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> вызов конструктора или в свойствах домена приложения, или если значение интервала <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="input" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="startat" /&gt;</ph> имеет значение меньше нуля или больше длины <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Searches the specified input string for the first occurrence of the specified regular expression.</source>
          <target state="translated">Ищет в указанной входной строке первое вхождение заданного регулярного выражения.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Объект, содержащий сведения о совпадении.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения во входной строке.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Сведения об элементах языка, можно создать шаблон регулярного выражения см. в разделе <bpt id="p1">[</bpt>языка регулярных выражений — краткий справочник<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Статический <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> метода эквивалентно созданию <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> с указанным шаблоном регулярного выражения и вызов экземпляра <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>In this case, the regular expression engine caches the regular expression pattern.</source>
          <target state="translated">В этом случае обработчик регулярных выражений кэширует шаблон регулярного выражения.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Если соответствие найдено, возвращенный <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> содержит подстроку из <ph id="ph3">`input`</ph> , соответствующий шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если совпадение не найдено, его значение равно <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>This method returns the first substring in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Этот метод возвращает первую подстроку в <ph id="ph1">`input`</ph> , соответствующий шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Можно получить последующие соответствия, повторно вызвав возвращаемый <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Кроме того, все совпадения в одном вызове метода можно получить, вызвав <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если время ожидания не определяется в свойствах домена приложения или если значение интервала <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method to find the first word that contains at least one <ph id="ph2">`z`</ph> character, and then calls the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method to find any additional matches.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> метод, чтобы найти первое слово, содержит по крайней мере один <ph id="ph2">`z`</ph> символов, а затем вызывает <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> метод для поиска дополнительных совпадений.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The regular expression pattern <ph id="ph1">`\b\w*z+\w*\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Возможные интерпретации шаблона регулярного выражения <ph id="ph1">`\b\w*z+\w*\b`</ph> показаны в следующей таблице.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Совпадение должно начинаться на границе слова.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Match zero, one, or more word characters.</source>
          <target state="translated">Соответствует ноль, один или несколько символов слова.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Match one or more occurrences of the <ph id="ph1">`z`</ph> character.</source>
          <target state="translated">Сопоставление одного или нескольких вхождений <ph id="ph1">`z`</ph> символов.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Match zero, one, or more word characters.</source>
          <target state="translated">Соответствует ноль, один или несколько символов слова.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Совпадение должно заканчиваться на границе слова.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Если значение времени ожидания не был определен для домена приложения, а значение <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, что предотвращает истечения времени ожидания, метод используется.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The recommended static method for retrieving a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Статические рекомендуется для получения соответствия шаблону <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, который позволяет установить интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The zero-based character position in the input string that defines the leftmost position to be searched.</source>
          <target state="translated">Отсчитываемая от нуля позиция символа во входной строке, определяющая самую левую позицию диапазона поиска.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The number of characters in the substring to include in the search.</source>
          <target state="translated">Количество символов в подстроке для включения в поиск.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position and searching only the specified number of characters.</source>
          <target state="translated">Ищет во входной строке первое вхождение регулярного выражения, начиная с указанной начальной позиции и выполняя поиск только по указанному количеству символов.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Объект, содержащий сведения о совпадении.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method returns the first substring that matches a regular expression pattern in a portion of an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения в части во входной строке.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Сведения об элементах языка, можно создать шаблон регулярного выражения см. в разделе <bpt id="p1">[</bpt>языка регулярных выражений — краткий справочник<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">Шаблон регулярного выражения, для которого <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> выполняет метод определяется путем вызова одного из <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> конструкторы класса.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об элементах, образующих шаблон регулярного выражения см. в разделе <bpt id="p1">[</bpt>языка регулярных выражений — краткий справочник<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method searches the portion of <ph id="ph2">`input`</ph> defined by the <ph id="ph3">`beginning`</ph> and <ph id="ph4">`length`</ph> parameters for the regular expression pattern.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Метод выполняет поиск часть <ph id="ph2">`input`</ph> определяется <ph id="ph3">`beginning`</ph> и <ph id="ph4">`length`</ph> параметры шаблона регулярного выражения.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">`beginning`</ph> always defines the index of the leftmost character to include in the search, and <ph id="ph2">`length`</ph> defines the maximum number of characters to search.</source>
          <target state="translated"><ph id="ph1">`beginning`</ph> всегда определяет индекс первого символа, чтобы включить в поиск, и <ph id="ph2">`length`</ph> определяет максимальное число символов для поиска.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>Together, they define the range of the search.</source>
          <target state="translated">Вместе они определяют диапазон поиска.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If the search proceeds from left to right (the default), the regular expression engine searches from the character at index <ph id="ph1">`beginning`</ph> to the character at index <ph id="ph2">`beginning`</ph><ph id="ph3"> + </ph><ph id="ph4">`length`</ph> – 1.</source>
          <target state="translated">Если поиск выполняется слева направо (по умолчанию), обработчик регулярных выражений ищет из знак с индексом <ph id="ph1">`beginning`</ph> знак с индексом <ph id="ph2">`beginning`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`length`</ph> – 1.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If the regular expression engine was instantiated by using the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> option so that the search proceeds from right to left, the regular expression engine searches from the character at index <ph id="ph2">`beginning`</ph><ph id="ph3"> + </ph><ph id="ph4">`length`</ph> – 1 to the character at index <ph id="ph5">`beginning`</ph>.</source>
          <target state="translated">Если обработчик регулярных выражений был создан с помощью <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> , что поиск продолжается справа слева, поиск обработчика регулярных выражений в знак с индексом <ph id="ph2">`beginning`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`length`</ph> – 1 для знак с индексом <ph id="ph5">`beginning`</ph>.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>This method returns the first match that it finds within this range.</source>
          <target state="translated">Этот метод возвращает первое совпадение, найденное в этот диапазон.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Можно получить последующие соответствия, повторно вызвав возвращаемый <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Если соответствие найдено, возвращенный <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> содержит подстроку из <ph id="ph3">`input`</ph> , соответствующий шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если совпадение не найдено, его значение равно <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, определяемое <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If you do not set a time-out value when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Если не задано значение времени ожидания, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создан объект.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если время ожидания не определен в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> вызов конструктора или в свойствах домена приложения, или если значение интервала <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="input" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="beginning" /&gt;</ph> имеет значение меньше нуля или больше длины <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="length" /&gt;</ph> имеет значение меньше нуля или больше длины <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph><ph id="ph2">&lt;see langword="+" /&gt;</ph><ph id="ph3">&lt;paramref name="length" /&gt;</ph><ph id="ph4">&lt;see langword="–1" /&gt;</ph> identifies a position that is outside the range of <ph id="ph5">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph><ph id="ph2">&lt;see langword="+" /&gt;</ph><ph id="ph3">&lt;paramref name="length" /&gt;</ph><ph id="ph4">&lt;see langword="–1" /&gt;</ph> определяет позицию, которая находится вне диапазона <ph id="ph5">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Searches the input string for the first occurrence of the specified regular expression, using the specified matching options.</source>
          <target state="translated">Ищет во входной строке первое вхождение заданного регулярного выражения, используя указанные параметры сопоставления.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Объект, содержащий сведения о совпадении.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения во входной строке.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Сведения об элементах языка, можно создать шаблон регулярного выражения см. в разделе <bpt id="p1">[</bpt>языка регулярных выражений — краткий справочник<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor and calling the instance <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Статический <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> метода эквивалентно созданию <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта с <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> конструктор и вызов экземпляра <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Если соответствие найдено, возвращенный <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> содержит подстроку из <ph id="ph3">`input`</ph> , соответствующий шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если совпадение не найдено, его значение равно <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method returns the first substring found in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Этот метод возвращает первую подстроку, найденную в <ph id="ph1">`input`</ph> , соответствующий шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> method.</source>
          <target state="translated">Можно получить последующие соответствия, повторно вызвав возвращаемый <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Кроме того, все совпадения в одном вызове метода можно получить, вызвав <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если время ожидания не определяется в свойствах домена приложения или если значение интервала <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example defines a regular expression that matches words beginning with the letter "a".</source>
          <target state="translated">В следующем примере определяется регулярное выражение, которое сопоставляет слова, начинающиеся с буквы «».</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>It uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> option to ensure that the regular expression locates words beginning with both an uppercase "a" and a lowercase "a".</source>
          <target state="translated">Она использует <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> параметр, чтобы убедиться, что регулярное выражение находит слова, начинающиеся на обоих заглавных букв нижнего регистра «» и «».</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern <ph id="ph1">`\ba\w*\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Возможные интерпретации шаблона регулярного выражения <ph id="ph1">`\ba\w*\b`</ph> показаны в следующей таблице.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Совпадение должно начинаться на границе слова.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the character "a".</source>
          <target state="translated">Соответствует символу «».</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match zero, one, or more word characters.</source>
          <target state="translated">Соответствует ноль, один или несколько символов слова.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Совпадение должно заканчиваться на границе слова.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является допустимой битовой комбинацией значений <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Если значение времени ожидания не был определен для домена приложения, а значение <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, что предотвращает истечения времени ожидания, метод используется.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for retrieving a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Статические рекомендуется для получения соответствия шаблону <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, который позволяет установить интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Интервал времени ожидания или <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, чтобы указать, что метод не должен превышать время ожидания.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Searches the input string for the first occurrence of the specified regular expression, using the specified matching options and time-out interval.</source>
          <target state="translated">Ищет во входной строке первое вхождение заданного регулярного выражения, используя указанные параметры сопоставления и интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Объект, содержащий сведения о совпадении.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения во входной строке.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Сведения об элементах языка, можно создать шаблон регулярного выражения см. в разделе <bpt id="p1">[</bpt>языка регулярных выражений — краткий справочник<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor and calling the instance <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Статический <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> метода эквивалентно созданию <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта с <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> конструктор и вызов экземпляра <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Если соответствие найдено, возвращенный <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> содержит подстроку из <ph id="ph3">`input`</ph> , соответствующий шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если совпадение не найдено, его значение равно <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This method returns the first substring found in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Этот метод возвращает первую подстроку, найденную в <ph id="ph1">`input`</ph> , соответствующий шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> method.</source>
          <target state="translated">Можно получить последующие соответствия, повторно вызвав возвращаемый <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Кроме того, все совпадения в одном вызове метода можно получить, вызвав <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> Указывает о том, как долго шаблон соответствующий метод должен пытаться найти совпадения, до истечения времени ожидания. Установка интервала времени ожидания предотвращает регулярные выражения, зависящие от избыточный поиск с возвратом отображение перестает отвечать при обработке входных данных, содержащий ближайшие совпадения.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>советы и рекомендации по использованию регулярных выражений<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> и <bpt id="p2">[</bpt>поиск с возвратом<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Если совпадение не найдено в этого интервала времени, метод вызывает <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в которой выполняется метод.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является допустимой битовой комбинацией значений <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> отрицательно, равно нулю или больше приблизительно 24 дней.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Мы рекомендуем задавать <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> параметр соответствующее значение, например две секунды.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Если отключить время ожидания, указав <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, обработчик регулярных выражений, обеспечивает немного лучшую производительность.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Тем не менее следует отключить тайм-ауты только при следующих условиях:</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Если входных данных, обрабатываемых регулярное выражение является производным от известного и надежного источника или состоит из статического текста.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Это исключает текст, который был динамически ввода пользователями.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Если шаблон регулярного выражения тщательно протестирован для обеспечения эффективной обработки соответствует несовпадающие и ближайшем совпадает.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Если шаблон регулярного выражения содержит не языковые элементы, которые возникает избыточный поиск с возвратом при обработке почти совпадают.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Searches an input string for all occurrences of a regular expression and returns all the matches.</source>
          <target state="translated">Ищет во входной строке все вхождения регулярного выражения и возвращает все соответствия.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>When a match attempt is repeated by calling the <ph id="ph1">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /&gt;</ph> method, the regular expression engine gives empty matches special treatment.</source>
          <target state="translated">При повторном попытки поиска совпадения, вызвав <ph id="ph1">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /&gt;</ph> , обработчик регулярных выражений дает пустые совпадения особым образом.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Usually, the regular expression engine begins the search for the next match exactly where the previous match left off.</source>
          <target state="translated">Обычно обработчик регулярных выражений начинает поиск следующего соответствия точно предыдущего совпадения места остановки.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>However, after an empty match, the regular expression engine advances by one character before trying the next match.</source>
          <target state="translated">Однако после пустого совпадения, обработчик регулярных выражений перемещает один символ перед попыткой.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This behavior guarantees that the regular expression engine will progress through the string.</source>
          <target state="translated">Это гарантирует, что обработчик регулярных выражений развивается по строке.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Otherwise, because an empty match does not result in any forward movement, the next match would start in exactly the same place as the previous match, and it would match the same empty string repeatedly.</source>
          <target state="translated">В противном случае — поскольку пустое совпадение не приведет к любой продвижение вперед, следующее соответствие начнется в той же позиции, что и предыдущий и многократно будет соответствовать же пустая строка.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In the following example, the regular expression pattern <bpt id="p1">&lt;c&gt;</bpt>a*<ept id="p1">&lt;/c&gt;</ept> searches for zero or more occurrences of the letter "a" in the string "abaabb".</source>
          <target state="translated">В следующем примере шаблон регулярного выражения <bpt id="p1">&lt;c&gt;</bpt>*<ept id="p1">&lt;/c&gt;</ept> ищет ноль или более вхождений буквы «» в строке «abaabb».</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>As the output from the example shows, the resulting <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchCollection" /&gt;</ph> object contains six <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects.</source>
          <target state="translated">Как видно в результатах показано в примере, итоговый <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchCollection" /&gt;</ph> объект содержит шесть <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> объектов.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The first match attempt finds the first "a".</source>
          <target state="translated">Первая попытка match находит первый «».</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The second match starts exactly where the first match ends, before the first b; it finds zero occurrences of "a" and returns an empty string.</source>
          <target state="translated">Второе соответствие начинается, где первый совпадать заканчивается перед первой b; он выполняет поиск вхождений «a» и возвращает пустую строку.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The third match does not begin exactly where the second match ended, because the second match returned an empty string.</source>
          <target state="translated">Третье соответствие не начинается точно там, где второе соответствие закончилось, так как второе соответствие возвратил пустую строку.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Instead, it begins one character later, after the first "b".</source>
          <target state="translated">Вместо этого оно начинается на один знак позже, после первой «b».</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The third match finds two occurrences of "a" and returns "aa".</source>
          <target state="translated">Третье соответствие находит два вхождения «a» и возвращает «aa».</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The fourth match attempt begins where the third match ended, before the second "b", and returns an empty string.</source>
          <target state="translated">Начинает четвертой попытки поиска совпадения, где закончилось третье, перед второй буквой «b» и возвращает пустую строку.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The fifth match attempt again advances one character so that it begins before the third "b" and returns an empty string.</source>
          <target state="translated">Пятый попытки поиска совпадения снова перемещает один символ, чтобы он начинается до третьей «b» и возвращает пустую строку.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The sixth match begins after the last "b" and returns an empty string again.</source>
          <target state="translated">Шестой поиск начинается после последнего «b» и снова возвращает пустую строку.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Searches the specified input string for all occurrences of a regular expression.</source>
          <target state="translated">Ищет в указанной входной строке все вхождения регулярного выражения.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">Коллекция объектов <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph>, найденных при поиске.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> Аналогичен методу <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> за исключением того, что он возвращает сведения о всех сопоставлениях найден во входной строке, а не одного совпадения.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Это эквивалентно следующему коду:</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The collection includes only matches and terminates at the first non-match.</source>
          <target state="translated">Коллекция содержит только соответствие и заканчивается на первом не соответствует.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">Шаблон регулярного выражения, для которого <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> выполняет метод определяется путем вызова одного из <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> конструкторы класса.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об элементах, образующих шаблон регулярного выражения см. в разделе <bpt id="p1">[</bpt>языка регулярных выражений — краткий справочник<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> Метод использует отложенное вычисление для заполнения возвращаемый <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">Доступ к членам этой коллекции, такие как <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> вызывает коллекции устанавливаться немедленно.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Чтобы воспользоваться преимуществами отложенного вычисления, следует итерацию коллекции, с помощью конструкции, такие как <ph id="ph1">`foreach`</ph> в C# и <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>in Visual Basic.</source>
          <target state="translated">в Visual Basic.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Из-за его отложенное вычисление вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> метод не выдает <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> property is not <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> and a matching operation exceeds the time-out interval.</source>
          <target state="translated">Однако исключение вызывается при выполнении операции <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> объект, возвращаемый этим методом, если <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> свойство не <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> и операции сопоставления до истечения времени ожидания.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method to identify any words in a sentence that end in "es".</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> метода, чтобы идентифицировать слов в предложении, заканчивающиеся на «es».</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`\b\w+es\b`</ph> определяется, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Совпадение должно начинаться на границе слова.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Match one or more word characters.</source>
          <target state="translated">Совпадение с одним или несколькими символами слова.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Match the literal string "es".</source>
          <target state="translated">Соответствует строковый литерал «es».</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Совпадение должно заканчиваться на границе слова.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="input" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The character position in the input string at which to start the search.</source>
          <target state="translated">Позиция символа во входной строке, с которой необходимо начать поиск.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Searches the specified input string for all occurrences of a regular expression, beginning at the specified starting position in the string.</source>
          <target state="translated">Ищет в указанной входной строке все вхождения регулярного выражения, начиная с указанной начальной позиции.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">Коллекция объектов <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph>, найденных при поиске.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The  <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method is similar to the  <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> Аналогичен методу <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> за исключением того, что он возвращает сведения о всех сопоставлениях найден во входной строке, а не одного совпадения.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Это эквивалентно следующему коду:</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">Шаблон регулярного выражения, для которого <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> выполняет метод определяется путем вызова одного из <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> конструкторы класса.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об элементах, образующих шаблон регулярного выражения см. в разделе <bpt id="p1">[</bpt>языка регулярных выражений — краткий справочник<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> Метод использует отложенное вычисление для заполнения возвращаемый <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">Доступ к членам этой коллекции, такие как <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> вызывает коллекции устанавливаться немедленно.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Чтобы воспользоваться преимуществами отложенного вычисления, следует итерацию коллекции, с помощью конструкции, такие как <ph id="ph1">`foreach`</ph> в C# и <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>in Visual Basic.</source>
          <target state="translated">в Visual Basic.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Из-за его отложенное вычисление вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> метод не выдает <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> property is not <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> and a matching operation exceeds the time-out interval..</source>
          <target state="translated">Однако исключение вызывается при выполнении операции <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> объект, возвращаемый этим методом, если <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> свойство не <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> и операции сопоставления до истечения времени ожидания...</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method to find the first word in a sentence that ends in "es", and then calls the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method to identify any additional words that end in "es".</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> метода для обнаружения первого слова в предложение, которое заканчивается на «es», а затем вызывает <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> метода, чтобы идентифицировать другие слова, которые заканчиваются на «es».</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`\b\w+es\b`</ph> определяется, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Совпадение должно начинаться на границе слова.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Match one or more word characters.</source>
          <target state="translated">Совпадение с одним или несколькими символами слова.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Match the literal string "es".</source>
          <target state="translated">Соответствует строковый литерал «es».</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Совпадение должно заканчиваться на границе слова.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="input" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="startat" /&gt;</ph> имеет значение меньше нуля или больше длины <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Searches the specified input string for all occurrences of a specified regular expression.</source>
          <target state="translated">Ищет в указанной входной строке все вхождения заданного регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">Коллекция объектов <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph>, найденных при поиске.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> Аналогичен методу <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> за исключением того, что он возвращает сведения о всех сопоставлениях найден во входной строке, а не одного совпадения.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Это эквивалентно следующему коду:</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The static <ph id="ph1">`Matches`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Matches`</ph>.</source>
          <target state="translated">Статический <ph id="ph1">`Matches`</ph> методы эквивалентны созданию <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> с указанным шаблоном регулярного выражения и вызова метода <ph id="ph3">`Matches`</ph>.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> Метод использует отложенное вычисление для заполнения возвращаемый <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">Доступ к членам этой коллекции, такие как <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> вызывает коллекции устанавливаться немедленно.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Чтобы воспользоваться преимуществами отложенного вычисления, следует итерацию коллекции, с помощью конструкции, такие как <ph id="ph1">`foreach`</ph> в C# и <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>in Visual Basic.</source>
          <target state="translated">в Visual Basic.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Из-за его отложенное вычисление вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> метод не выдает <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if a time-out interval is defined by the "REGEX_DEFAULT_MATCH_TIMEOUT" property of the current application domain and a matching operation exceeds this time-out interval.</source>
          <target state="translated">Однако исключение вызывается при выполнении операции на <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> объект, возвращаемый этим методом, если интервал времени ожидания определяется свойством «REGEX_DEFAULT_MATCH_TIMEOUT» из текущего домена приложения и операции сопоставления превысит этот интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method to identify any word in a sentence that ends in "es".</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> метод выявления любых слов в предложение, которое заканчивается на «es».</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`\b\w+es\b`</ph> определяется, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Совпадение должно начинаться на границе слова.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Match one or more word characters.</source>
          <target state="translated">Совпадение с одним или несколькими символами слова.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Match the literal string "es".</source>
          <target state="translated">Соответствует строковый литерал «es».</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Совпадение должно заканчиваться на границе слова.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Если значение времени ожидания не был определен для домена приложения, а значение <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, что предотвращает истечения времени ожидания, метод используется.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The recommended static method for retrieving multiple pattern matches is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you specify the time-out interval.</source>
          <target state="translated">Рекомендуемые статический метод для извлечения нескольких шаблон соответствует является <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, которая позволяет задать интервал ожидания.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that specify options for matching.</source>
          <target state="translated">Побитовая комбинация значений перечисления, задающая параметры для сопоставления.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options.</source>
          <target state="translated">Ищет в указанной входной строке все вхождения заданного регулярного выражения, используя указанные параметры сопоставления.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">Коллекция объектов <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph>, найденных при поиске.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> Аналогичен методу <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> за исключением того, что он возвращает сведения о всех сопоставлениях найден во входной строке, а не одного совпадения.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Это эквивалентно следующему коду:</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">`Matches`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Matches`</ph>.</source>
          <target state="translated">Статический <ph id="ph1">`Matches`</ph> методы эквивалентны созданию <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> с указанным шаблоном регулярного выражения и вызова метода <ph id="ph3">`Matches`</ph>.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> Метод использует отложенное вычисление для заполнения возвращаемый <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">Доступ к членам этой коллекции, такие как <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> вызывает коллекции устанавливаться немедленно.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Чтобы воспользоваться преимуществами отложенного вычисления, следует итерацию коллекции, с помощью конструкции, такие как <ph id="ph1">`foreach`</ph> в C# и <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>in Visual Basic.</source>
          <target state="translated">в Visual Basic.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Из-за его отложенное вычисление вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> метод не выдает <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if a time-out interval is defined by the "REGEX_DEFAULT_MATCH_TIMEOUT" property of the current application domain and a matching operation exceeds this time-out interval.</source>
          <target state="translated">Однако исключение вызывается при выполнении операции на <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> объект, возвращаемый этим методом, если интервал времени ожидания определяется свойством «REGEX_DEFAULT_MATCH_TIMEOUT» из текущего домена приложения и операции сопоставления превысит этот интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method to identify any word in a sentence that ends in "es", and then calls the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method to perform a case-insensitive comparison of the pattern with the input string.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> метод выявления любых слов в предложение, которое заканчивается на «es», а затем вызывает <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> метод, чтобы выполнить сравнение без учета регистра шаблона со входной строкой.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>As the output shows, the two methods return different results.</source>
          <target state="translated">Как показывают выходные данные, эти два метода возвращать разные результаты.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`\b\w+es\b`</ph> определяется, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Совпадение должно начинаться на границе слова.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match one or more word characters.</source>
          <target state="translated">Совпадение с одним или несколькими символами слова.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the literal string "es".</source>
          <target state="translated">Соответствует строковый литерал «es».</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Совпадение должно заканчиваться на границе слова.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является допустимой битовой комбинацией значений <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Если значение времени ожидания не был определен для домена приложения, а значение <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, что предотвращает истечения времени ожидания, метод используется.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for retrieving multiple pattern matches is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Рекомендуемые статический метод для извлечения нескольких шаблон соответствует является <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, который позволяет установить интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that specify options for matching.</source>
          <target state="translated">Побитовая комбинация значений перечисления, задающая параметры для сопоставления.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Интервал времени ожидания или <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, чтобы указать, что метод не должен превышать время ожидания.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options and time-out interval.</source>
          <target state="translated">Ищет в указанной входной строке все вхождения заданного регулярного выражения, используя указанные параметры сопоставления и интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">Коллекция объектов <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph>, найденных при поиске.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> Аналогичен методу <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> за исключением того, что он возвращает сведения о всех сопоставлениях найден во входной строке, а не одного совпадения.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Это эквивалентно следующему коду:</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">`Matches`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Matches`</ph>.</source>
          <target state="translated">Статический <ph id="ph1">`Matches`</ph> методы эквивалентны созданию <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> с указанным шаблоном регулярного выражения и вызова метода <ph id="ph3">`Matches`</ph>.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> Метод использует отложенное вычисление для заполнения возвращаемый <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">Доступ к членам этой коллекции, такие как <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> вызывает коллекции устанавливаться немедленно.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Чтобы воспользоваться преимуществами отложенного вычисления, следует итерацию коллекции, с помощью конструкции, такие как <ph id="ph1">`foreach`</ph> в C# и <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>in Visual Basic.</source>
          <target state="translated">в Visual Basic.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Из-за его отложенное вычисление вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> метод не выдает <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, an exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if a matching operation exceeds this time-out interval specified by the<ph id="ph2">`matchTimeout`</ph> parameter.</source>
          <target state="translated">Однако исключение при выполнении операции <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> объект, возвращаемый этим методом, если операции сопоставления превысит этот интервал времени ожидания, заданные<ph id="ph2">`matchTimeout`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to perform a case-sensitive comparison that matches any word in a sentence that ends in "es".</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> метод, чтобы выполнить сравнение с учетом регистра, которая соответствует любому слову предложения, который заканчивается на «es».</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to perform a case-insensitive comparison of the pattern with the input string.</source>
          <target state="translated">Затем он вызывает <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> метод, чтобы выполнить сравнение без учета регистра шаблона со входной строкой.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In both cases, the time-out interval is set to one second.</source>
          <target state="translated">В обоих случаях время ожидания равно одной секунде.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>As the output shows, the two methods return different results.</source>
          <target state="translated">Как показывают выходные данные, эти два метода возвращать разные результаты.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`\b\w+es\b`</ph> определяется, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Совпадение должно начинаться на границе слова.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match one or more word characters.</source>
          <target state="translated">Совпадение с одним или несколькими символами слова.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the literal string "es".</source>
          <target state="translated">Соответствует строковый литерал «es».</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Совпадение должно заканчиваться на границе слова.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является допустимой битовой комбинацией значений <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> отрицательно, равно нулю или больше приблизительно 24 дней.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Мы рекомендуем задавать <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> параметр соответствующее значение, например две секунды.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Если отключить время ожидания, указав <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, обработчик регулярных выражений, обеспечивает немного лучшую производительность.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Тем не менее следует отключить тайм-ауты только при следующих условиях:</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Если входных данных, обрабатываемых регулярное выражение является производным от известного и надежного источника или состоит из статического текста.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Это исключает текст, который был динамически ввода пользователями.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Если шаблон регулярного выражения тщательно протестирован для обеспечения эффективной обработки соответствует несовпадающие и ближайшем совпадает.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Если шаблон регулярного выражения содержит не языковые элементы, которые возникает избыточный поиск с возвратом при обработке почти совпадают.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>Gets the time-out interval of the current instance.</source>
          <target state="translated">Получает интервал времени ожидания текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>The maximum time interval that can elapse in a pattern-matching operation before a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /&gt;</ph> is thrown, or <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> if time-outs are disabled.</source>
          <target state="translated">Максимальный интервал времени, который может пройти в операции сравнения с шаблоном, прежде чем возникнет исключение <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /&gt;</ph>, или <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, если контроль времени ожидания отключен.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> property defines the approximate maximum time interval for a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instance to execute a single matching operation before the operation times out. The regular expression engine throws a <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception during its next timing check after the time-out interval has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> Свойство определяет приблизительное максимальный интервал времени для <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> экземпляра для выполнения одной операции сопоставления до истечения времени ожидания операции. Обработчик регулярных выражений создает исключение <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> исключение во время его следующей проверки времени, после истечения интервала времени ожидания.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>This prevents the regular expression engine from processing input strings that require excessive backtracking.</source>
          <target state="translated">Это предотвращает обработки входных строк, которые требуют избыточный поиск с возвратом обработчик регулярных выражений.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>For more information, see <bpt id="p1">[</bpt>Backtracking<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Best Practices for Regular Expressions<ept id="p2">](~/docs/standard/base-types/best-practices.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>поиск с возвратом<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept> и <bpt id="p2">[</bpt>советы и рекомендации по использованию регулярных выражений<ept id="p2">](~/docs/standard/base-types/best-practices.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>This property is read-only.</source>
          <target state="translated">Это свойство доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>You can set its value explicitly for an individual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object by calling the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor; and you can set its value for all <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> matching operations in an application domain by calling the <ph id="ph4">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> method and providing a <ph id="ph5">&lt;xref:System.TimeSpan&gt;</ph> value for the "REGEX_DEFAULT_MATCH_TIMEOUT" property, as the following example illustrates.</source>
          <target state="translated">Его значение можно задать явным образом для отдельного <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> путем вызова метода <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> конструктора; и вы можете задать его значение для всех <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> сопоставления операций в домене приложения с помощью вызова <ph id="ph4">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> метод и предоставляя <ph id="ph5">&lt;xref:System.TimeSpan&gt;</ph> значение для свойства «REGEX_DEFAULT_MATCH_TIMEOUT», как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>If you do not explicitly set a time-out interval, the default value <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> is used, and matching operations do not time out.</source>
          <target state="translated">Если вы не задает явно интервал времени ожидания, значение по умолчанию <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> используется и сопоставления операции имеют неограниченное время ожидания.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>Gets the options that were passed into the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Получает параметр, которые были переданы в конструктор <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>One or more members of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> enumeration that represent options that were passed to the <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor</source>
          <target state="translated">Один или несколько членов перечисления <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>, представляющих параметры, переданные в конструктор <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>The value of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> property consists of one or more members of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions&gt;</ph> enumeration.</source>
          <target state="translated">Значение <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> свойство состоит из одного или нескольких членов <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>If no options were defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructor, its value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если параметры не были определены в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> конструктора класса, его значением является <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>The available options are discussed in detail in the <bpt id="p1">[</bpt>Regular Expression Options<ept id="p1">](~/docs/standard/base-types/regular-expression-options.md)</ept> topic.</source>
          <target state="translated">Доступные параметры подробно обсуждаются в <bpt id="p1">[</bpt>параметры регулярных выражений<ept id="p1">](~/docs/standard/base-types/regular-expression-options.md)</ept> раздела.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> property does not reflect inline options defined in the regular expression pattern itself.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> свойство не отражает встроенные параметры, определенные в регулярном выражении шаблона сам.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> is the base class of regular expressions created by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> является базовым классом регулярных выражений, созданные <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>These compiled regular expressions use the base class implementation of the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property.</source>
          <target state="translated">Эти скомпилированные регулярные выражения использовать реализацию базового класса <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>If called from a derived class, the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property returns the options that were passed to the <ph id="ph2">&lt;paramref name="options" /&gt;</ph> parameter of the <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> class constructor that was used to define the regular expression.</source>
          <target state="translated">При вызове из производного класса, <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> свойство возвращает параметры, которые были переданы <ph id="ph2">&lt;paramref name="options" /&gt;</ph> параметр <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> конструктора класса, который использовался для определения регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.pattern">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Используется объектом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>, который создан методом <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>In a specified input string, replaces strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">В указанной входной строке заменяет строки, соответствующие шаблону регулярного выражения, указанной строкой замены.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The replacement string.</source>
          <target state="translated">Строка замены.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>In a specified input string, replaces all strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">В указанной входной строке заменяет все строки, соответствующие шаблону регулярного выражения, указанной строкой замены.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The search for matches starts at the beginning of the <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">Поиск соответствий начинается в начале <ph id="ph1">`input`</ph> строки.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">Регулярное выражение — это шаблон, определенный конструктором для текущего <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> Указывает строку, которая является для замены каждого соответствия во <ph id="ph2">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> может содержать любое сочетание текста и <bpt id="p1">[</bpt>подстановки<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Например, шаблон замены <ph id="ph1">`a*${test}b`</ph> вставляет строку «*» следуют подстроку, сопоставленную с <ph id="ph2">`test`</ph> захватываемой группой, в том случае, если таковые имеются, за которым следует строка «b».</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* Символ не воспринимается как метасимвол в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Подстановки – это языковые элементы только регулярных выражений, которые распознаются в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Все другие регулярных выражений элементов языка, включая <bpt id="p1">[</bpt>escape-последовательности символов<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, допускаются в только в шаблонах регулярных выражений и не распознаются в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции замены превышает интервал времени ожидания, определяемое <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создан объект.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Если время ожидания не определен в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> вызов конструктора или в свойствах домена приложения, или если значение интервала <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не создается</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Поскольку этот метод возвращает <ph id="ph1">`input`</ph> без изменений, если нет соответствия, можно использовать <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы определить, ли метод внесены замены входной строкой.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The following example defines a regular expression, <ph id="ph1">`\s+`</ph>, that matches one or more white-space characters.</source>
          <target state="translated">В следующем примере определяется регулярное выражение, <ph id="ph1">`\s+`</ph>, который соответствует один или несколько символов пробела.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The replacement string, " ", replaces them with a single space character.</source>
          <target state="translated">Строка замены "», заменяется одним пробелом.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The following example defines a regular expression, <ph id="ph1">`(\p{Sc}\s?)?(\d+\.?((?&lt;=\.)\d+)?)(?(1)|\s?\p{Sc})?`</ph>, and a replacement pattern, <ph id="ph2">`$2`</ph>, that removes either a leading or a trailing currency symbol from a numeric value.</source>
          <target state="translated">В следующем примере определяется регулярное выражение, <ph id="ph1">`(\p{Sc}\s?)?(\d+\.?((?&lt;=\.)\d+)?)(?(1)|\s?\p{Sc})?`</ph>и шаблон замены <ph id="ph2">`$2`</ph>, который удаляет начальный или конечный символ валюты из числового значения.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The regular expression is interpreted as shown in the following table.</source>
          <target state="translated">Возможные интерпретации регулярного выражения показаны в следующей таблице.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match a currency symbol.</source>
          <target state="translated">Совпадает с символом валюты.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source><ph id="ph1">`{Sc}`</ph> denotes any character that is a member of the Unicode Symbol, Currency category.</source>
          <target state="translated"><ph id="ph1">`{Sc}`</ph> Обозначает любой символ, который является членом Юникода категории символов и валют.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match zero or one white-space character.</source>
          <target state="translated">Совпадение с нулем или одним символом пробела.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match zero or one occurrence of the combination of a currency symbol followed by zero or one white-space character.</source>
          <target state="translated">Совпадение с нулем или одним вхождением сочетание обозначение денежной единицы, за которым следует ноль или один символ пробела.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>This is the first capturing group.</source>
          <target state="translated">Это первая группа записи.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Совпадение с одной или несколькими десятичными цифрами.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match zero or one occurrence of a period (used as a decimal separator character).</source>
          <target state="translated">Совпадение с нулем или одним вхождением точки (используется как символ десятичного разделителя).</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If a period is the previous character, match one or more decimal digits.</source>
          <target state="translated">Если точку предыдущего символа, соответствует один или несколько десятичных цифр.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>This pattern can be matched either zero or one time.</source>
          <target state="translated">Этот шаблон может быть установлен как ноль или один раз.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match the pattern of one or more decimal digits followed by an optional period and additional decimal digits.</source>
          <target state="translated">Совпадение с шаблоном один или несколько десятичных цифр, за которым следует необязательная точка и десятичными цифрами.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>This is the second capturing group.</source>
          <target state="translated">Это вторая группа записи.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29&gt;</ph> method replaces the entire match with the value of this captured group.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29&gt;</ph> метод заменяет все совпадения со значением данной группой записи.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If the first captured group exists, match an empty string.</source>
          <target state="translated">Если существует первой захватываемой группы, соответствует пустая строка.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Otherwise, match zero or one white-space character followed by a currency symbol.</source>
          <target state="translated">В противном случае соответствует ноль или один символ пробела, за которым следует символ валюты.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> Метод может использоваться для замены совпадения регулярного выражения, если выполняется хотя бы одно из следующих условий:</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">Строка замены нельзя легко указать замены шаблоном регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">Строка замены получается из некоторой обработки, выполненной на совпадающую строку.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">Строка замены получается из условной обработки.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">Метод эквивалентен вызову <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> метода и передачи каждого <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта в возвращаемом <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> коллекции <ph id="ph4">`evaluator`</ph> делегата.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">Регулярное выражение — это шаблон, определенный конструктором для текущего <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph> Параметр является делегатом для пользовательского метода, который определяется пользователем и проверяет каждое совпадение.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">Пользовательский метод должен иметь следующую сигнатуру для сопоставления <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> делегата.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">Пользовательский метод возвращает строку, которая заменяет совпадающую входные данные.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции замены превышает интервал времени ожидания, определяемое <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создан объект.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Если время ожидания не определен в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> вызов конструктора или в свойствах домена приложения, или если значение интервала <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не создается</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Поскольку этот метод возвращает <ph id="ph1">`input`</ph> без изменений, если нет соответствия, можно использовать <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы определить, ли метод внесены замены входной строкой.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The following code example displays an original string, matches each word in the original string, converts the first character of each match to uppercase, then displays the converted string.</source>
          <target state="translated">В следующем примере кода демонстрируется исходная строка, сопоставляет каждое слово в исходной строке, преобразует первый символ каждого соответствия преобразуется в верхний регистр, а затем отображает преобразованную строку.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The replacement string.</source>
          <target state="translated">Строка замены.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The maximum number of times the replacement can occur.</source>
          <target state="translated">Максимальное количество возможных случаев замены.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">В указанной входной строке заменяет указанное максимальное количество строк, соответствующих шаблону регулярного выражения, указанной строкой замены.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The search for matches starts at the beginning of the <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">Поиск соответствий начинается в начале <ph id="ph1">`input`</ph> строки.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The regular expression is the pattern that is defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">Регулярное выражение — это шаблон, который определен с помощью конструктора для текущего <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is negative, replacements continue to the end of the string.</source>
          <target state="translated">Если <ph id="ph1">`count`</ph> является отрицательным, замена продолжается до конца строки.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> exceeds the number of matches, all matches are replaced.</source>
          <target state="translated">Если <ph id="ph1">`count`</ph> превышает количество совпадений, все совпадения заменяются.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace the first <ph id="ph2">`count`</ph> matches in <ph id="ph3">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> Указывает строку, которая является для замены первый <ph id="ph2">`count`</ph> совпадения в <ph id="ph3">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> может содержать любое сочетание текста и <bpt id="p1">[</bpt>подстановки<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Например, шаблон замены <ph id="ph1">`a*${test}b`</ph> вставляет строку «*» следуют подстроку, сопоставленную с <ph id="ph2">`test`</ph> захватываемой группой, в том случае, если таковые имеются, за которым следует строка «b».</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* Символ не воспринимается как метасимвол в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Подстановки – это языковые элементы только регулярных выражений, которые распознаются в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Все другие регулярных выражений элементов языка, включая <bpt id="p1">[</bpt>escape-последовательности символов<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, допускаются в только в шаблонах регулярных выражений и не распознаются в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции замены превышает интервал времени ожидания, определяемое <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создан объект.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Если время ожидания не определен в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> вызов конструктора или в свойствах домена приложения, или если значение интервала <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не создается</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Поскольку этот метод возвращает <ph id="ph1">`input`</ph> без изменений, если нет соответствия, можно использовать <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы определить, ли метод внесены замены входной строкой.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The following example replaces the first five occurrences of duplicated characters with a single character.</source>
          <target state="translated">В следующем примере заменяется первые пять вхождений повторяющихся символов в виде одного символа.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`(\w)\1`</ph> matches consecutive occurrences of a single character and assigns the first occurrence to the first capturing group.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`(\w)\1`</ph> сопоставляет последовательные вхождения одного символа и присваивает его первого вхождения первая группа записи.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured group.</source>
          <target state="translated">Шаблон замены <ph id="ph1">`$1`</ph> заменяет все совпадения первой группой записи.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The replacement string.</source>
          <target state="translated">Строка замены.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</source>
          <target state="translated">В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, указанной строкой замены.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если для <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The static <ph id="ph1">`Replace`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Replace`</ph>.</source>
          <target state="translated">Статический <ph id="ph1">`Replace`</ph> методы эквивалентны созданию <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> с указанным шаблоном регулярного выражения и вызова метода <ph id="ph3">`Replace`</ph>.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The search for matches starts at the beginning of the <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">Поиск соответствий начинается в начале <ph id="ph1">`input`</ph> строки.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> Указывает строку, которая является для замены каждого соответствия во <ph id="ph2">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> может содержать любое сочетание текста и <bpt id="p1">[</bpt>подстановки<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Например, шаблон замены <ph id="ph1">`a*${test}b`</ph> вставляет строку «*» следуют подстроку, сопоставленную с <ph id="ph2">`test`</ph> захватываемой группой, в том случае, если таковые имеются, за которым следует строка «b».</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* Символ не воспринимается как метасимвол в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Подстановки – это языковые элементы только регулярных выражений, которые распознаются в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Все другие регулярных выражений элементов языка, включая <bpt id="p1">[</bpt>escape-последовательности символов<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, допускаются в только в шаблонах регулярных выражений и не распознаются в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции замены превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если время ожидания не определяется в свойствах домена приложения или если значение интервала <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Поскольку этот метод возвращает <ph id="ph1">`input`</ph> без изменений, если нет соответствия, можно использовать <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы определить, ли метод внесены замены входной строкой.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The following example defines a regular expression, <ph id="ph1">`\s+`</ph>, that matches one or more white-space characters.</source>
          <target state="translated">В следующем примере определяется регулярное выражение, <ph id="ph1">`\s+`</ph>, который соответствует один или несколько символов пробела.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The replacement string, " ", replaces them with a single space character.</source>
          <target state="translated">Строка замены "», заменяется одним пробелом.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> method to replace the local machine and drive names in a UNC path with a local file path.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> метод для замены локальные имена компьютера и диск в формате UNC путь к локальному файлу.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The regular expression uses the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property to include the name of the local computer, and the <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> method to include the names of the logical drives.</source>
          <target state="translated">В регулярном выражении используется <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> свойство имя локального компьютера и <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы включить имена логических дисков.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</source>
          <target state="translated">Для успешного выполнения в примере строковый литерал «MyMachine» следует заменить имя локального компьютера.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">Шаблон регулярного выражения определяется следующее выражение:</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">В следующей таблице показано, как интерпретируется шаблон регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match two consecutive backslash (<ph id="ph1">`\`</ph>) characters.</source>
          <target state="translated">Соответствует двум обратной косой черты подряд (<ph id="ph1">`\`</ph>) символов.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</source>
          <target state="translated">Так как символ обратной косой черты интерпретируется как escape-символ, косую черту необходимо экранировать с дополнительную обратную косую черту.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Perform a case-insensitive match of the string that is returned by the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Выполнение сравнения без учета регистра строки, который возвращается методом <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match the period (<ph id="ph1">`.`</ph>) character followed by one or more word characters.</source>
          <target state="translated">Совпадение точкой (<ph id="ph1">`.`</ph>) за которым одной или несколькими символами слова.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>This match can occur zero or more times.</source>
          <target state="translated">Это совпадение может произойти ноль или более раз.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The matched subexpression is not captured.</source>
          <target state="translated">Сопоставленная часть выражения не выделяется.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match a backslash (<ph id="ph1">`\`</ph>) character.</source>
          <target state="translated">Соответствует обратной косой черты (<ph id="ph1">`\`</ph>) символов.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Perform a case-insensitive match of the character class that consists of the individual drive lettters.</source>
          <target state="translated">Выполнение сравнения без учета регистра класса символов, который состоит из отдельно взятых.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>This match is the first captured subexpression.</source>
          <target state="translated">Это сопоставление выполняется первое полученное вложенное выражение.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match the literal dollar sign (<ph id="ph1">`$`</ph>) character.</source>
          <target state="translated">Соответствует знак доллара (<ph id="ph1">`$`</ph>) символов.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured subexpression.</source>
          <target state="translated">Шаблон замены <ph id="ph1">`$1`</ph> заменяет все совпадения с первое полученное вложенное выражение.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>That is, it replaces the UNC machine and drive name with the drive letter.</source>
          <target state="translated">То есть он заменяет UNC-имя компьютера и диск с буквой диска.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> или <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> равно <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Если значение времени ожидания не был определен для домена приложения, а значение <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, что предотвращает истечения времени ожидания, метод используется.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The recommended static method for replacing a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Рекомендуемые статический метод для замены сопоставления шаблона является <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, который позволяет установить интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если для <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> Метод может использоваться для замены совпадения регулярного выражения, если выполняется хотя бы одно из следующих условий:</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">Строка замены нельзя легко указать замены шаблоном регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">Строка замены получается из некоторой обработки, выполненной на совпадающую строку.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">Строка замены получается из условной обработки.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">Метод эквивалентен вызову <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> метода и передачи каждого <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта в возвращаемом <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> коллекции <ph id="ph4">`evaluator`</ph> делегата.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph> Параметр является делегатом для пользовательского метода, который определяется пользователем и проверяет каждое совпадение.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">Пользовательский метод должен иметь следующую сигнатуру для сопоставления <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> делегата.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">Пользовательский метод возвращает строку, которая заменяет совпадающую входные данные.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции замены превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если время ожидания не определяется в свойствах домена приложения или если значение интервала <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Поскольку этот метод возвращает <ph id="ph1">`input`</ph> без изменений, если нет соответствия, можно использовать <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы определить, ли метод внесены замены входной строкой.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The following example uses a regular expression to extract the individual words from a string, and then uses a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate to call a method named <ph id="ph2">`WordScramble`</ph> that scrambles the individual letters in the word.</source>
          <target state="translated">Следующий пример использует регулярное выражение для извлечения отдельные слова из строки, а затем использует <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> делегат, вызываемый метод с именем <ph id="ph2">`WordScramble`</ph> , шифруется отдельных букв в слове.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>To do this, the <ph id="ph1">`WordScramble`</ph> method creates an array that contains the characters in the match.</source>
          <target state="translated">Чтобы сделать это, <ph id="ph1">`WordScramble`</ph> метод создает массив, содержащий символы в соответствие.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>It also creates a parallel array that it populates with random floating-point numbers.</source>
          <target state="translated">Он также создает параллельный массив, который он заполняет случайными числами с плавающей запятой.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The arrays are sorted by calling the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method, and the sorted array is provided as an argument to a <ph id="ph2">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">Массивы сортируются путем вызова <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> метод и упорядоченный массив предоставляется как аргумент для <ph id="ph2">&lt;xref:System.String&gt;</ph> конструктора класса.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>This newly created string is then returned by the <ph id="ph1">`WordScramble`</ph> method.</source>
          <target state="translated">Эта созданная строка возвращается <ph id="ph1">`WordScramble`</ph> метод.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The regular expression pattern <ph id="ph1">`\w+`</ph> matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`\w+`</ph> соответствует одной или несколькими символами слова; обработчик регулярных выражений будет продолжать добавлять символы для сопоставления, пока встретится несловообразующий символ, например символ пробела.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> или <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> равно <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Если значение времени ожидания не был определен для домена приложения, а значение <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, что предотвращает истечения времени ожидания, метод используется.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The recommended static method for evaluating and replacing a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Статические рекомендуется для оценки и замена соответствия шаблону <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, который позволяет установить интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The maximum number of times the replacement will occur.</source>
          <target state="translated">Максимальное количество возможных случаев замены.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">В указанной входной строке заменяется указанное максимальное количество строк, соответствующих шаблону регулярного выражения, строкой, возвращенной делегатом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> Метод может использоваться для замены совпадения регулярного выражения, если выполняется хотя бы одно из следующих условий:</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">Строка замены нельзя легко указать замены шаблоном регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">Строка замены получается из некоторой обработки, выполненной на совпадающую строку.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">Строка замены получается из условной обработки.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> method and passing the first <ph id="ph2">`count`</ph><ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects in the returned <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph5">`evaluator`</ph> delegate.</source>
          <target state="translated">Метод эквивалентен вызову <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> метода и передачи первый <ph id="ph2">`count`</ph> <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объектов в возвращаемом <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> коллекции <ph id="ph5">`evaluator`</ph> делегата.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">Регулярное выражение — это шаблон, определенный конструктором для текущего <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph> Параметр является делегатом для пользовательского метода, который определяется пользователем и проверяет каждое совпадение.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">Пользовательский метод должен иметь следующую сигнатуру для сопоставления <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> делегата.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">Пользовательский метод возвращает строку, которая заменяет совпадающую входные данные.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции замены превышает интервал времени ожидания, определяемое <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создан объект.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Если время ожидания не определен в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> вызов конструктора или в свойствах домена приложения, или если значение интервала <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не создается</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Поскольку этот метод возвращает <ph id="ph1">`input`</ph> без изменений, если нет соответствия, можно использовать <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы определить, ли метод внесены замены входной строкой.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The following example uses a regular expression to deliberately misspell half of the words in a list.</source>
          <target state="translated">В следующем примере регулярное выражение намеренно опечатка половины слов в списке.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>It uses the regular expression <ph id="ph1">`\w*(ie|ei)\w*`</ph> to match words that include the characters "ie" or "ei".</source>
          <target state="translated">Она использует регулярное выражение <ph id="ph1">`\w*(ie|ei)\w*`</ph> для сопоставления слов, содержащих символы «ie» или «ei».</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>It passes the first half of the matching words to the <ph id="ph1">`ReverseLetter`</ph> method, which, in turn, uses the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method to reverse "i" and "e" in the matched string.</source>
          <target state="translated">Передает Первая половина совпадающих слов <ph id="ph1">`ReverseLetter`</ph> метод, который в свою очередь, использует <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> метода для отмены «i» и «e» в совпадающую строку.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The remaining words remain unchanged.</source>
          <target state="translated">Остальные слова остаются без изменений.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The regular expression <ph id="ph1">`\w*(ie|ei)\w*`</ph> is defined as shown in the following table.</source>
          <target state="translated">Определение регулярного выражения <ph id="ph1">`\w*(ie|ei)\w*`</ph> показано в таблице ниже.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Match zero or more word characters.</source>
          <target state="translated">Совпадение с нулем или большим числом буквенных символов.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Match either "ie" or "ei".</source>
          <target state="translated">Соответствует «ie» или «ei».</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Match zero or more word characters.</source>
          <target state="translated">Совпадение с нулем или большим числом буквенных символов.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`([ie])([ie])`</ph> in the <ph id="ph2">`ReverseLetter`</ph> method matches the first "i" or "e" in the diphthong "ie" or "ei" and assigns the letter to the first capturing group.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`([ie])([ie])`</ph> в <ph id="ph2">`ReverseLetter`</ph> метод соответствует первой «i» или «e» в diphthong «ie» или «ei» и назначается буква первая группа записи.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>It matches the second "i" or "e" and assigns the letter to the second capturing group.</source>
          <target state="translated">Он соответствует второй «i» или «e» и назначает букву вторая группа записи.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The two characters are then reversed by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> method with the replacement pattern <ph id="ph2">`$2$1`</ph>.</source>
          <target state="translated">Затем два знака отменяются путем вызова <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> метод с шаблон замены <ph id="ph2">`$2$1`</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The replacement string.</source>
          <target state="translated">Строка замены.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Maximum number of times the replacement can occur.</source>
          <target state="translated">Максимальное возможное количество случаев замены.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The character position in the input string where the search begins.</source>
          <target state="translated">Позиция символа во входной строке, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">В указанной входной подстроке заменяет указанное максимальное количество строк, соответствующих шаблону регулярного выражения, указанной строкой замены.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The search for matches starts in the <ph id="ph1">`input`</ph> string at the position specified by the <ph id="ph2">`startat`</ph> parameter.</source>
          <target state="translated">Поиск соответствий начинается <ph id="ph1">`input`</ph> строка в позиции, указанной параметром <ph id="ph2">`startat`</ph> параметр.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">Регулярное выражение — это шаблон, определенный конструктором для текущего <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is negative, replacements continue to the end of the string.</source>
          <target state="translated">Если <ph id="ph1">`count`</ph> является отрицательным, замена продолжается до конца строки.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> exceeds the number of matches, all matches are replaced.</source>
          <target state="translated">Если <ph id="ph1">`count`</ph> превышает количество совпадений, все совпадения заменяются.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> Указывает строку, которая является для замены каждого соответствия во <ph id="ph2">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> может содержать любое сочетание текста и <bpt id="p1">[</bpt>подстановки<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Например, шаблон замены <ph id="ph1">`a*${test}b`</ph> вставляет строку «*» следуют подстроку, сопоставленную с <ph id="ph2">`test`</ph> захватываемой группой, в том случае, если таковые имеются, за которым следует строка «b».</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* Символ не воспринимается как метасимвол в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Подстановки – это языковые элементы только регулярных выражений, которые распознаются в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Все другие регулярных выражений элементов языка, включая <bpt id="p1">[</bpt>escape-последовательности символов<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, допускаются в только в шаблонах регулярных выражений и не распознаются в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции замены превышает интервал времени ожидания, определяемое <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создан объект.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Если время ожидания не определен в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> вызов конструктора или в свойствах домена приложения, или если значение интервала <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не создается</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Поскольку этот метод возвращает <ph id="ph1">`input`</ph> без изменений, если нет соответствия, можно использовать <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы определить, ли метод внесены замены входной строкой.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The following example double-spaces all but the first line of a string.</source>
          <target state="translated">Следующий пример двойные пробелы содержатся все, кроме первой строки в строке.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>It defines a regular expression pattern, <ph id="ph1">`^.*$`</ph>, that matches a line of text, calls the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method to match the first line of the string, and uses the <ph id="ph3">`Match.Index`</ph> and <ph id="ph4">`Match.Count`</ph> properties to determine the starting position of the second line.</source>
          <target state="translated">Он определяет шаблон регулярного выражения, <ph id="ph1">`^.*$`</ph>, выделяющий строки текста, вызовы <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> метода в соответствии с первой строки, строки и использует <ph id="ph3">`Match.Index`</ph> и <ph id="ph4">`Match.Count`</ph> свойства, чтобы определить начальную позицию второго Строка.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`^.*$`</ph> is defined as shown in the following table.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`^.*$`</ph> определяется, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Match the start of a line.</source>
          <target state="translated">Поиск начала строки.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>(Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object was instantiated by using the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option; otherwise, this character class would only match the beginning of the input string.)</source>
          <target state="translated">(Обратите внимание, что <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объект был создан с помощью <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> параметр; в противном случае этот класс символов будет соответствовать только начало строки ввода.)</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Match any character zero or more times.</source>
          <target state="translated">Совпадение с любым символом ноль или более раз.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Match the end of a line.</source>
          <target state="translated">Соответствует концу строки.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>(Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object was instantiated by using the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option; otherwise, this character class would only match the beginning of the input string.)</source>
          <target state="translated">(Обратите внимание, что <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объект был создан с помощью <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> параметр; в противном случае этот класс символов будет соответствовать только начало строки ввода.)</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The replacement string (<ph id="ph1">`vbCrLf + "$&amp;"`</ph> in Visual Basic, <ph id="ph2">`"\n$&amp;"`</ph> in C#) adds a new line before the matched string.</source>
          <target state="translated">Строка замены (<ph id="ph1">`vbCrLf + "$&amp;"`</ph> в Visual Basic, <ph id="ph2">`"\n$&amp;"`</ph> в C#) добавляет новую строку перед совпадающую строку.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Note that <ph id="ph1">`\n`</ph> in the C# example is interpreted as the newline character by the C# compiler; it does not represent a regular expression character escape.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">`\n`</ph> в C# пример интерпретируется как символ перевода строки для компилятора C#; он не представляет escape-символ регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="startat" /&gt;</ph> имеет значение меньше нуля или больше длины <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string.</source>
          <target state="translated">Строка замены.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</source>
          <target state="translated">В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, указанной строкой замены.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Specified options modify the matching operation.</source>
          <target state="translated">Указанные параметры изменяют операцию сопоставления.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если для <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">`Replace`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Replace`</ph>.</source>
          <target state="translated">Статический <ph id="ph1">`Replace`</ph> методы эквивалентны созданию <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> с указанным шаблоном регулярного выражения и вызова метода <ph id="ph3">`Replace`</ph>.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">При указании <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> для <ph id="ph2">`options`</ph> параметра, поиск соответствий начинается в конце входной строки и перемещается влево ";" в противном случае поиск начинается в начале входной строки и сдвиг вправо.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> Указывает строку, которая является для замены каждого соответствия во <ph id="ph2">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> может содержать любое сочетание текста и <bpt id="p1">[</bpt>подстановки<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Например, шаблон замены <ph id="ph1">`a*${test}b`</ph> вставляет строку «*» следуют подстроку, сопоставленную с <ph id="ph2">`test`</ph> захватываемой группой, в том случае, если таковые имеются, за которым следует строка «b».</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* Символ не воспринимается как метасимвол в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Подстановки – это языковые элементы только регулярных выражений, которые распознаются в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Все другие регулярных выражений элементов языка, включая <bpt id="p1">[</bpt>escape-последовательности символов<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, допускаются в только в шаблонах регулярных выражений и не распознаются в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции замены превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если время ожидания не определяется в свойствах домена приложения или если значение интервала <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Поскольку этот метод возвращает <ph id="ph1">`input`</ph> без изменений, если нет соответствия, можно использовать <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы определить, ли метод внесены замены входной строкой.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method to replace the local machine and drive names in a UNC path with a local file path.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> метод для замены локальные имена компьютера и диск в формате UNC путь к локальному файлу.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression uses the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property to include the name of the local computer, and the <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> method to include the names of the logical drives.</source>
          <target state="translated">В регулярном выражении используется <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> свойство имя локального компьютера и <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы включить имена логических дисков.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>All regular expression string comparisons are case-insensitive.</source>
          <target state="translated">Все Регулярное выражение сравнения строк без учета регистра.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</source>
          <target state="translated">Для успешного выполнения в примере строковый литерал «MyMachine» следует заменить имя локального компьютера.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">Шаблон регулярного выражения определяется следующее выражение:</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">В следующей таблице показано, как интерпретируется шаблон регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match two consecutive backslash (<ph id="ph1">`\`</ph>) characters.</source>
          <target state="translated">Соответствует двум обратной косой черты подряд (<ph id="ph1">`\`</ph>) символов.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</source>
          <target state="translated">Так как символ обратной косой черты интерпретируется как escape-символ, косую черту необходимо экранировать с дополнительную обратную косую черту.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the string that is returned by the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Совпадает со строкой, которая возвращается <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the period (<ph id="ph1">`.`</ph>) character followed by one or more word characters.</source>
          <target state="translated">Совпадение точкой (<ph id="ph1">`.`</ph>) за которым одной или несколькими символами слова.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This match can occur zero or more times.</source>
          <target state="translated">Это совпадение может произойти ноль или более раз.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The matched subexpression is not captured.</source>
          <target state="translated">Сопоставленная часть выражения не выделяется.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match a backslash (<ph id="ph1">`\`</ph>) character.</source>
          <target state="translated">Соответствует обратной косой черты (<ph id="ph1">`\`</ph>) символов.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the character class that consists of the individual drive letters.</source>
          <target state="translated">Соответствует класс символов, состоящий из отдельных букв диска.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This match is the first captured subexpression.</source>
          <target state="translated">Это сопоставление выполняется первое полученное вложенное выражение.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the literal dollar sign (<ph id="ph1">`$`</ph>) character.</source>
          <target state="translated">Соответствует знак доллара (<ph id="ph1">`$`</ph>) символов.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured subexpression.</source>
          <target state="translated">Шаблон замены <ph id="ph1">`$1`</ph> заменяет все совпадения с первое полученное вложенное выражение.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>That is, it replaces the UNC machine and drive name with the drive letter.</source>
          <target state="translated">То есть он заменяет UNC-имя компьютера и диск с буквой диска.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> или <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> равно <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является допустимой битовой комбинацией значений <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Если значение времени ожидания не был определен для домена приложения, а значение <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, что предотвращает истечения времени ожидания, метод используется.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for replacing a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Рекомендуемые статический метод для замены сопоставления шаблона является <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, который позволяет установить интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>Specified options modify the matching operation.</source>
          <target state="translated">Указанные параметры изменяют операцию сопоставления.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если для <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match in if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> Метод может использоваться для замены соответствует регулярному выражению в, если выполняется хотя бы одно из следующих условий:</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">Строка замены нельзя легко указать замены шаблоном регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">Строка замены получается из некоторой обработки, выполненной на совпадающую строку.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">Строка замены получается из условной обработки.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">Метод эквивалентен вызову <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> метода и передачи каждого <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта в возвращаемом <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> коллекции <ph id="ph4">`evaluator`</ph> делегата.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph> Параметр является делегатом для пользовательского метода, который определяется пользователем и проверяет каждое совпадение.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">Пользовательский метод должен иметь следующую сигнатуру для сопоставления <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> делегата.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">Пользовательский метод возвращает строку, которая заменяет совпадающую входные данные.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">При указании <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> для <ph id="ph2">`options`</ph> параметра, поиск соответствий начинается в конце входной строки и перемещается влево ";" в противном случае поиск начинается в начале входной строки и сдвиг вправо.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции замены превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если время ожидания не определяется в свойствах домена приложения или если значение интервала <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Поскольку этот метод возвращает <ph id="ph1">`input`</ph> без изменений, если нет соответствия, можно использовать <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы определить, ли метод внесены замены входной строкой.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example uses a regular expression to extract the individual words from a string, and then uses a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate to call a method named <ph id="ph2">`WordScramble`</ph> that scrambles the individual letters in the word.</source>
          <target state="translated">Следующий пример использует регулярное выражение для извлечения отдельные слова из строки, а затем использует <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> делегат, вызываемый метод с именем <ph id="ph2">`WordScramble`</ph> , шифруется отдельных букв в слове.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>To do this, the <ph id="ph1">`WordScramble`</ph> method creates an array that contains the characters in the match.</source>
          <target state="translated">Чтобы сделать это, <ph id="ph1">`WordScramble`</ph> метод создает массив, содержащий символы в соответствие.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>It also creates a parallel array that it populates with random floating-point numbers.</source>
          <target state="translated">Он также создает параллельный массив, который он заполняет случайными числами с плавающей запятой.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The arrays are sorted by calling the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method, and the sorted array is provided as an argument to a <ph id="ph2">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">Массивы сортируются путем вызова <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> метод и упорядоченный массив предоставляется как аргумент для <ph id="ph2">&lt;xref:System.String&gt;</ph> конструктора класса.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>This newly created string is then returned by the <ph id="ph1">`WordScramble`</ph> method.</source>
          <target state="translated">Эта созданная строка возвращается <ph id="ph1">`WordScramble`</ph> метод.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern <ph id="ph1">`\w+`</ph> matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`\w+`</ph> соответствует одной или несколькими символами слова; обработчик регулярных выражений будет продолжать добавлять символы для сопоставления, пока встретится несловообразующий символ, например символ пробела.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method includes the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option so that the comment in the regular expression pattern <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> is ignored by the regular expression engine.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> метод включает <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> параметр, чтобы комментарий в шаблоне регулярного выражения <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> обрабатывается обработчиком регулярных выражений.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> или <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> равно <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является допустимой битовой комбинацией значений <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The maximum number of times the replacement will occur.</source>
          <target state="translated">Максимальное количество возможных случаев замены.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The character position in the input string where the search begins.</source>
          <target state="translated">Позиция символа во входной строке, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">В указанной входной подстроке заменяется указанное максимальное количество строк, соответствующих шаблону регулярного выражения, строкой, возвращенной делегатом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> Метод может использоваться для замены совпадения регулярного выражения, если выполняется хотя бы одно из следующих условий:</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">Строка замены нельзя легко указать замены шаблоном регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">Строка замены получается из некоторой обработки, выполненной на совпадающую строку.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">Строка замены получается из условной обработки.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method and passing the first <ph id="ph2">`count`</ph><ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects in the returned <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph5">`evaluator`</ph> delegate.</source>
          <target state="translated">Метод эквивалентен вызову <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> метода и передачи первый <ph id="ph2">`count`</ph> <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объектов в возвращаемом <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> коллекции <ph id="ph5">`evaluator`</ph> делегата.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">Регулярное выражение — это шаблон, определенный конструктором для текущего <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph> Параметр является делегатом для пользовательского метода, который определяется пользователем и проверяет каждое совпадение.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">Пользовательский метод должен иметь следующую сигнатуру для сопоставления <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> делегата.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">Пользовательский метод возвращает строку, которая заменяет совпадающую входные данные.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции замены превышает интервал времени ожидания, определяемое <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создан объект.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Если время ожидания не определен в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> вызов конструктора или в свойствах домена приложения, или если значение интервала <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не создается</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Поскольку этот метод возвращает <ph id="ph1">`input`</ph> без изменений, если нет соответствия, можно использовать <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы определить, ли метод внесены замены входной строкой.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="startat" /&gt;</ph> имеет значение меньше нуля или больше длины <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The replacement string.</source>
          <target state="translated">Строка замены.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Интервал времени ожидания или <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, чтобы указать, что метод не должен превышать время ожидания.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</source>
          <target state="translated">В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, указанной строкой замены.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</source>
          <target state="translated">Дополнительные параметры определяют параметры, которые изменяют соответствующую операцию и интервал времени ожидания, если совпадение не найдено.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если для <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">`Replace`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Replace`</ph>.</source>
          <target state="translated">Статический <ph id="ph1">`Replace`</ph> методы эквивалентны созданию <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> с указанным шаблоном регулярного выражения и вызова метода <ph id="ph3">`Replace`</ph>.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">При указании <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> для <ph id="ph2">`options`</ph> параметра, поиск соответствий начинается в конце входной строки и перемещается влево ";" в противном случае поиск начинается в начале входной строки и сдвиг вправо.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> Указывает строку, которая является для замены каждого соответствия во <ph id="ph2">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> может содержать любое сочетание текста и <bpt id="p1">[</bpt>подстановки<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Например, шаблон замены <ph id="ph1">`a*${test}b`</ph> вставляет строку «*» следуют подстроку, сопоставленную с <ph id="ph2">`test`</ph> захватываемой группой, в том случае, если таковые имеются, за которым следует строка «b».</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* Символ не воспринимается как метасимвол в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Подстановки – это языковые элементы только регулярных выражений, которые распознаются в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Все другие регулярных выражений элементов языка, включая <bpt id="p1">[</bpt>escape-последовательности символов<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, допускаются в только в шаблонах регулярных выражений и не распознаются в шаблонах замены.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> Указывает о том, как долго шаблон соответствующий метод должен пытаться найти совпадения, до истечения времени ожидания. Установка интервала времени ожидания предотвращает регулярные выражения, зависящие от избыточный поиск с возвратом отображение перестает отвечать при обработке входных данных, содержащий ближайшие совпадения.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>советы и рекомендации по использованию регулярных выражений<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> и <bpt id="p2">[</bpt>поиск с возвратом<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Если совпадение не найдено в этого интервала времени, метод вызывает <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в которой выполняется метод.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Поскольку этот метод возвращает <ph id="ph1">`input`</ph> без изменений, если нет соответствия, можно использовать <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы определить, ли метод внесены замены входной строкой.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to replace the local machine and drive names in a UNC path with a local file path.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> метод для замены локальные имена компьютера и диск в формате UNC путь к локальному файлу.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression uses the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property to include the name of the local computer and the <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> method to include the names of the logical drives.</source>
          <target state="translated">В регулярном выражении используется <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> свойство имя локального компьютера и <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы включить имена логических дисков.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>All regular expression string comparisons are case-insensitive, and any single replacement operation times out if a match cannot be found in 0.5 second.</source>
          <target state="translated">Все Регулярное выражение сравнения строк без учета регистра, и любые операции замены одного времени ожидания, если совпадение не найдено в 0,5 секунды.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</source>
          <target state="translated">Для успешного выполнения в примере строковый литерал «MyMachine» следует заменить имя локального компьютера.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">Шаблон регулярного выражения определяется следующее выражение:</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">В следующей таблице показано, как интерпретируется шаблон регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match two consecutive backslash (<ph id="ph1">`\`</ph>) characters.</source>
          <target state="translated">Соответствует двум обратной косой черты подряд (<ph id="ph1">`\`</ph>) символов.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</source>
          <target state="translated">Так как символ обратной косой черты интерпретируется как escape-символ, косую черту необходимо экранировать с дополнительную обратную косую черту.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the string that is returned by the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Совпадает со строкой, которая возвращается <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the period (<ph id="ph1">`.`</ph>) character followed by one or more word characters.</source>
          <target state="translated">Совпадение точкой (<ph id="ph1">`.`</ph>) за которым одной или несколькими символами слова.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This match can occur zero or more times.</source>
          <target state="translated">Это совпадение может произойти ноль или более раз.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The matched subexpression is not captured.</source>
          <target state="translated">Сопоставленная часть выражения не выделяется.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match a backslash (<ph id="ph1">`\`</ph>) character.</source>
          <target state="translated">Соответствует обратной косой черты (<ph id="ph1">`\`</ph>) символов.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the character class that consists of the individual drive letters.</source>
          <target state="translated">Соответствует класс символов, состоящий из отдельных букв диска.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This match is the first captured subexpression.</source>
          <target state="translated">Это сопоставление выполняется первое полученное вложенное выражение.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the literal dollar sign (<ph id="ph1">`$`</ph>) character.</source>
          <target state="translated">Соответствует знак доллара (<ph id="ph1">`$`</ph>) символов.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured subexpression.</source>
          <target state="translated">Шаблон замены <ph id="ph1">`$1`</ph> заменяет все совпадения с первое полученное вложенное выражение.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>That is, it replaces the UNC machine and drive name with the drive letter.</source>
          <target state="translated">То есть он заменяет UNC-имя компьютера и диск с буквой диска.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> или <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> равно <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является допустимой битовой комбинацией значений <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> отрицательно, равно нулю или больше приблизительно 24 дней.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Мы рекомендуем задавать <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> параметр соответствующее значение, например две секунды.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Если отключить время ожидания, указав <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, обработчик регулярных выражений, обеспечивает немного лучшую производительность.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Тем не менее следует отключить тайм-ауты только при следующих условиях:</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Если входных данных, обрабатываемых регулярное выражение является производным от известного и надежного источника или состоит из статического текста.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Это исключает текст, который был динамически ввода пользователями.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Если шаблон регулярного выражения тщательно протестирован для обеспечения эффективной обработки соответствует несовпадающие и ближайшем совпадает.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Если шаблон регулярного выражения содержит не языковые элементы, которые возникает избыточный поиск с возвратом при обработке почти совпадают.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">Строка для поиска соответствия.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of enumeration values that provide options for matching.</source>
          <target state="translated">Побитовая комбинация значений перечисления, предоставляющих параметры для сопоставления.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Интервал времени ожидания или <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, чтобы указать, что метод не должен превышать время ожидания.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In a specified input string, replaces all substrings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">В указанной входной строке заменяет все подстроки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</source>
          <target state="translated">Дополнительные параметры определяют параметры, которые изменяют соответствующую операцию и интервал времени ожидания, если совпадение не найдено.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если для <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> Метод может использоваться для замены совпадения регулярного выражения, если выполняется хотя бы одно из следующих условий:</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">Если строка замены нельзя легко указать замены шаблоном регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the replacement string results from some processing performed on the matched string.</source>
          <target state="translated">Если строка замены получается из некоторой обработки выполняется над совпадающую строку.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the replacement string results from conditional processing.</source>
          <target state="translated">Если строка замены получается из условной обработки.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">Метод эквивалентен вызову <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> метода и передачи каждого <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> объекта в возвращаемом <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> коллекции <ph id="ph4">`evaluator`</ph> делегата.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph> Параметр является делегатом для пользовательского метода, который определяется пользователем и проверяет каждое совпадение.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">Пользовательский метод должен иметь следующую сигнатуру для сопоставления <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> делегата.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">Пользовательский метод возвращает строку, которая заменяет совпадающую входные данные.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">При указании <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> для <ph id="ph2">`options`</ph> параметра, поиск соответствий начинается в конце входной строки и перемещается влево ";" в противном случае поиск начинается в начале входной строки и сдвиг вправо.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to "stop responding when they process input that contains near matches.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> Указывает о том, как долго шаблон соответствующий метод должен пытаться найти совпадения, до истечения времени ожидания. Установка интервала времени ожидания предотвращает регулярные выражения, зависящие от избыточный поиск с возвратом из кажется» перестает отвечать при обработке ввода, содержащий ближайшие совпадения.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>советы и рекомендации по использованию регулярных выражений<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> и <bpt id="p2">[</bpt>поиск с возвратом<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Если совпадение не найдено в этого интервала времени, метод вызывает <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в которой выполняется метод.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Поскольку этот метод возвращает <ph id="ph1">`input`</ph> без изменений, если нет соответствия, можно использовать <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы определить, ли метод внесены замены входной строкой.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example uses a regular expression to extract the individual words from a string, and then uses a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate to call a method named <ph id="ph2">`WordScramble`</ph> that scrambles the individual letters in the word.</source>
          <target state="translated">Следующий пример использует регулярное выражение для извлечения отдельные слова из строки, а затем использует <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> делегат, вызываемый метод с именем <ph id="ph2">`WordScramble`</ph> , шифруется отдельных букв в слове.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To do this, the <ph id="ph1">`WordScramble`</ph> method creates an array that contains the characters in the match.</source>
          <target state="translated">Чтобы сделать это, <ph id="ph1">`WordScramble`</ph> метод создает массив, содержащий символы в соответствие.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>It also creates a parallel array that it populates with random floating-point numbers.</source>
          <target state="translated">Он также создает параллельный массив, который он заполняет случайными числами с плавающей запятой.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The arrays are sorted by calling the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method, and the sorted array is provided as an argument to a <ph id="ph2">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">Массивы сортируются путем вызова <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> метод и упорядоченный массив предоставляется как аргумент для <ph id="ph2">&lt;xref:System.String&gt;</ph> конструктора класса.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This newly created string is then returned by the <ph id="ph1">`WordScramble`</ph> method.</source>
          <target state="translated">Эта созданная строка возвращается <ph id="ph1">`WordScramble`</ph> метод.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern <ph id="ph1">`\w+`</ph> matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`\w+`</ph> соответствует одной или несколькими символами слова; обработчик регулярных выражений будет продолжать добавлять символы для сопоставления, пока встретится несловообразующий символ, например символ пробела.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method includes the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option so that the comment in the regular expression pattern <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> is ignored by the regular expression engine.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> метод включает <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> параметр, чтобы комментарий в шаблоне регулярного выражения <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> обрабатывается обработчиком регулярных выражений.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> или <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> равно <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является допустимой битовой комбинацией значений <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> отрицательно, равно нулю или больше приблизительно 24 дней.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Мы рекомендуем задавать <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> параметр соответствующее значение, например две секунды.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Если отключить время ожидания, указав <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, обработчик регулярных выражений, обеспечивает немного лучшую производительность.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Тем не менее следует отключить тайм-ауты только при следующих условиях:</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Если входных данных, обрабатываемых регулярное выражение является производным от известного и надежного источника или состоит из статического текста.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Это исключает текст, который был динамически ввода пользователями.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Если шаблон регулярного выражения тщательно протестирован для обеспечения эффективной обработки соответствует несовпадающие и ближайшем совпадает.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Если шаблон регулярного выражения содержит не языковые элементы, которые возникает избыточный поиск с возвратом при обработке почти совпадают.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.RightToLeft">
          <source>Gets a value that indicates whether the regular expression searches from right to left.</source>
          <target state="translated">Получает значение, указывающее на то, выполняется ли регулярным выражением поиск справа налево.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.RightToLeft">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression searches from right to left; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если регулярное выражение выполняет поиск справа налево; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.RightToLeft">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.RightToLeft%2A&gt;</ph> is <ph id="ph2">`true`</ph> if the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instance was created with the <ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> option.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.RightToLeft%2A&gt;</ph> — <ph id="ph2">`true`</ph> Если <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создавался экземпляр <ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> параметр.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.roptions">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Используется объектом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>, который создан методом <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Splits an input string into an array of substrings at the positions defined by a regular expression match.</source>
          <target state="translated">Разделяет входную строку в массив подстрок в позициях, определенных соответствием регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The string to split.</source>
          <target state="translated">Строка для разделения.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Splits an input string into an array of substrings at the positions defined by a regular expression pattern specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Разделяет входную строку в массив подстрок в позициях, определенных шаблоном регулярного выражения, указанным в конструкторе <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>An array of strings.</source>
          <target state="translated">Массив строк.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> Методы аналогичны <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> метода, за исключением того, что <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> разделяет строку по разделителям регулярным выражением, вместо набора символов.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The string is split as many times as possible.</source>
          <target state="translated">Строка разделяется столько раз, сколько возможно.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If no delimiter is found, the return value contains one element whose value is the original input string.</source>
          <target state="translated">Если разделитель не найден, возвращаемое значение содержит один элемент, значение которого является исходной входной строкой.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">Если несколько соответствий являются смежными, пустая строка вставляется в массив.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found, as the following code shows.</source>
          <target state="translated">Например разделение строки одиночным дефисом вызывает возвращаемый массив для включения пустую строку в позицию, где находятся два смежных дефиса, как показано в следующем коде.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">При обнаружении совпадения в начале или в конце входной строки, пустая строка входит в начале или конце возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`\d+`</ph> to split an input string on numeric characters.</source>
          <target state="translated">В следующем примере шаблон регулярного выражения <ph id="ph1">`\d+`</ph> для разбиения входной строки на цифровые символы.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Because the string begins and ends with matching numeric characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Так как строка начинается и заканчивается сопоставления числовых символов, оно первый и последний элемент возвращаемого массива <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">Если используются скобки записи в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> выражения, любой записанный текст включается в результирующий строковый массив.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">Например если разделить строку «plum Груши» дефисами находиться внутри круглых скобок, возвращаемый массив включает элемент строки, содержащий дефис.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Тем не менее если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии платформы .NET Framework.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">В .NET Framework 1.0 и 1.1 Если соответствие не найдено в первый набор круглых скобок, записанный текст из дополнительных скобок записи не включается в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">Начиная с .NET Framework 2.0, весь записанный текст также добавляется в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">Например следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">Первый набор скобок записи записывает дефис, а второй набор записывает косую черту.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">Если код примера скомпилирован и запущен под управлением платформы .NET Framework версии 1.0 или 1.1, в нем исключаются символы косых черт. Если он компилируется и выполняется в .NET Framework 2.0 или более поздней версии, то они включаются.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%29&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Если регулярное выражение может совпасть с пустой строкой, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%29&gt;</ph> разобьет строку на массив строк для одного символа, потому что разделитель пустой строки можно найти в любом месте.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example:</source>
          <target state="translated">Пример:</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Note that the returned array also includes an empty string at the beginning and end of the array.</source>
          <target state="translated">Обратите внимание, что возвращаемый массив также включает пустую строку в начале и в конец массива.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции split превышает интервал времени ожидания, определяемое <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создан объект.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Если время ожидания не определен в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> вызов конструктора или в свойствах домена приложения, или если значение интервала <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не создается</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="input" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The string to be split.</source>
          <target state="translated">Строка для разделения.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The maximum number of times the split can occur.</source>
          <target state="translated">Максимальное количество возможных случаев разделения.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Разделяет входную строку указанное максимальное количество раз в массив подстрок в позициях, определенных регулярным выражением, указанным в конструкторе <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>An array of strings.</source>
          <target state="translated">Массив строк.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> Методы аналогичны <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> метода, за исключением того, что <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> разделяет строку по разделителям регулярным выражением, вместо набора символов.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The <ph id="ph1">`count`</ph> parameter specifies the maximum number of substrings into which the <ph id="ph2">`input`</ph> string can be split; the last string contains the unsplit remainder of the string.</source>
          <target state="translated"><ph id="ph1">`count`</ph> Указывает максимальное количество подстрок, в который <ph id="ph2">`input`</ph> можно разделить строку; последняя строка содержит неразделенный остаток строки.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>A <ph id="ph1">`count`</ph> value of zero provides the default behavior of splitting as many times as possible.</source>
          <target state="translated">Объект <ph id="ph1">`count`</ph> нулевое значение обеспечивает стандартное поведение разбивки столько раз, сколько возможно.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If multiple matches are adjacent to one another or if a match is found at the beginning or end of <ph id="ph1">`input`</ph>, and the number of matches found is at least two less than <ph id="ph2">`count`</ph>, an empty string is inserted into the array.</source>
          <target state="translated">Если несколько соответствий, располагаются рядом друг с другом или если найдено совпадение в начале или конце <ph id="ph1">`input`</ph>, и количество найденных совпадений по крайней мере два меньше, чем <ph id="ph2">`count`</ph>, пустая строка вставляется в массив.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>That is, empty strings that result from adjacent matches or from matches at the beginning or end of the input string are counted in determining whether the number of matched substrings equals <ph id="ph1">`count`</ph>.</source>
          <target state="translated">То есть пустые строки, которые произойти из смежных соответствий или совпадений в начале или в конце входной строки учитываются при определении ли число соответствующих подстрок равно <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>In the following example, the regular expression <ph id="ph1">`/d+`</ph> is used to split an input string that includes one or more decimal digits into a maximum of three substrings.</source>
          <target state="translated">В следующем примере регулярное выражение <ph id="ph1">`/d+`</ph> используется для разбиения входной строки, содержащей один или несколько десятичных цифр, в максимум три подстроки.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Because the beginning of the input string matches the regular expression pattern, the first array element contains <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, the second contains the first set of alphabetic characters in the input string, and the third contains the remainder of the string that follows the third match.</source>
          <target state="translated">Так как в начале входной строки соответствует шаблону регулярного выражения, первый элемент массива содержит <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, второй содержит первый набор буквенные символы во входной строке, а третий содержит остаток строки который следует за Третье соответствие.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If capturing parentheses are used in a regular expression, any captured text is included in the array of split strings.</source>
          <target state="translated">Если в регулярном выражении используются скобки записи, любой записанный текст включается в массив разделенных строк.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>However, any array elements that contain captured text are not counted in determining whether the number of matches has reached <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Тем не менее, все элементы массива, содержащие записанный текст, не учитываются при определении ли достигнуто число совпадений <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>For example, splitting the string "apple-apricot-plum-pear-banana" into a maximum of four substrings results in a seven-element array, as the following code shows.</source>
          <target state="translated">Например разделение строки «apple яблоко слива Груши банана» на максимально возможные четыре подстроки, дает в 7 элементный массив, как следующий код показывает.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Тем не менее если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии платформы .NET Framework.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>In the .NET Framework 1.0 and 1.1, only captured text from the first set of capturing parentheses is included in the returned array.</source>
          <target state="translated">В .NET Framework 1.0 и 1.1 только записанный текст из первого набора скобок записи включен в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Starting with the .NET Framework 2.0, all captured text is added to the returned array.</source>
          <target state="translated">Начиная с .NET Framework 2.0, весь записанный текст добавляется в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>However, elements in the returned array that contain captured text are not counted in determining whether the number of matched substrings equals <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Тем не менее, элементы в возвращенном массиве, содержащие записанный текст, не учитываются при определении ли число соответствующих подстрок равно <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>For example, in the following code, a regular expression uses two sets of capturing parentheses to extract the elements of a date from a date string.</source>
          <target state="translated">Например в следующем коде регулярное выражение использует два набора скобок записи для извлечения элементов даты из строки даты.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">Первый набор скобок записи записывает дефис, а второй набор записывает косую черту.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> method then specifies a maximum of two elements in the returned array.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> метод затем указывает более двух элементов в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, the method returns a two-element string array.</source>
          <target state="translated">Если код примера скомпилирован и запущен под управлением платформы .NET Framework версии 1.0 или 1.1, метод возвращает массив строк двух элементов.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If it is compiled and run under the .NET Framework 2.0 or later versions, the method returns a three-element string array.</source>
          <target state="translated">Если он компилируется и выполняется в .NET Framework 2.0 или более поздней версии, метод возвращает массив строк с тремя элементами.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Если регулярное выражение может совпасть с пустой строкой, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> разобьет строку на массив строк для одного символа, потому что разделитель пустой строки можно найти в любом месте.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The following example splits the string "characters" into as many elements as there are in the input string.</source>
          <target state="translated">Следующий пример разделяет строку «символы» в, как много элементов, сколько их во входной строке.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Because the null string matches the beginning of the input string, a null string is inserted at the beginning of the returned array.</source>
          <target state="translated">Так как пустая строка соответствует началу входной строки, нулевые строки вставлены в начале возвращаемого массива.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>This causes the tenth element to consist of the two characters at the end of the input string.</source>
          <target state="translated">В результате десятый элемент состоит из двух символов в конце входной строки.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции split превышает интервал времени ожидания, определяемое <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создан объект.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Если время ожидания не определен в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> вызов конструктора или в свойствах домена приложения, или если значение интервала <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не создается</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="input" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The string to split.</source>
          <target state="translated">Строка для разделения.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Splits an input string into an array of substrings at the positions defined by a regular expression pattern.</source>
          <target state="translated">Разделяет входную строку в массив подстрок в позициях, определенных шаблоном регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>An array of strings.</source>
          <target state="translated">Массив строк.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> Методы аналогичны <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> метода, за исключением того, что <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> разделяет строку по разделителям регулярным выражением, вместо набора символов.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">`input`</ph> string is split as many times as possible.</source>
          <target state="translated"><ph id="ph1">`input`</ph> Строка разделяется столько раз, сколько возможно.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If <ph id="ph1">`pattern`</ph> is not found in the <ph id="ph2">`input`</ph> string, the return value contains one element whose value is the original <ph id="ph3">`input`</ph> string.</source>
          <target state="translated">Если <ph id="ph1">`pattern`</ph> не найден в <ph id="ph2">`input`</ph> строка, возвращаемое значение содержит один элемент, значение которого является исходный <ph id="ph3">`input`</ph> строки.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Compiled regular expressions used in calls to static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods are automatically cached.</source>
          <target state="translated">Скомпилированные регулярные выражения, используемые в вызовах статическому <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> методы автоматически сохраняются в кэше.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>To manage the lifetime of compiled regular expressions yourself, use the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods.</source>
          <target state="translated">Чтобы самостоятельно управлять временем жизни скомпилированные регулярные выражения, используйте экземпляр <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">Если несколько соответствий являются смежными, пустая строка вставляется в массив.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found, as the following code shows.</source>
          <target state="translated">Например разделение строки одиночным дефисом вызывает возвращаемый массив для включения пустую строку в позицию, где находятся два смежных дефиса, как показано в следующем коде.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">При обнаружении совпадения в начале или в конце входной строки, пустая строка входит в начале или конце возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`\d+`</ph> to split an input string on numeric characters.</source>
          <target state="translated">В следующем примере шаблон регулярного выражения <ph id="ph1">`\d+`</ph> для разбиения входной строки на цифровые символы.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Because the string begins and ends with matching numeric characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Так как строка начинается и заканчивается сопоставления числовых символов, оно первый и последний элемент возвращаемого массива <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">Если используются скобки записи в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> выражения, любой записанный текст включается в результирующий строковый массив.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">Например если разделить строку «plum Груши» дефисами находиться внутри круглых скобок, возвращаемый массив включает элемент строки, содержащий дефис.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Тем не менее если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии платформы .NET Framework.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">В .NET Framework 1.0 и 1.1 Если соответствие не найдено в первый набор круглых скобок, записанный текст из дополнительных скобок записи не включается в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">Начиная с .NET Framework 2.0, весь записанный текст также добавляется в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">Например следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">Первый набор скобок записи записывает дефис, а второй набор записывает косую черту.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">Если код примера скомпилирован и запущен под управлением платформы .NET Framework версии 1.0 или 1.1, в нем исключаются символы косых черт. Если он компилируется и выполняется в .NET Framework 2.0 или более поздней версии, то они включаются.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Если регулярное выражение может совпасть с пустой строкой, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> разобьет строку на массив строк для одного символа, потому что разделитель пустой строки можно найти в любом месте.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example:</source>
          <target state="translated">Пример:</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Note that the returned array also includes an empty string at the beginning and end of the array.</source>
          <target state="translated">Обратите внимание, что возвращаемый массив также включает пустую строку в начале и в конец массива.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции split превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если время ожидания не определяется в свойствах домена приложения или если значение интервала <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called.</source>
          <target state="translated">Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором был вызван метод.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Если значение времени ожидания не был определен для домена приложения, а значение <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, что предотвращает истечения времени ожидания, метод используется.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The recommended static method for splitting text on a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Статические рекомендуется для разбиения текста на соответствие шаблону <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, который позволяет установить интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The string to be split.</source>
          <target state="translated">Строка для разделения.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The maximum number of times the split can occur.</source>
          <target state="translated">Максимальное количество возможных случаев разделения.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The character position in the input string where the search will begin.</source>
          <target state="translated">Позиция символа во входной строке, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Разделяет входную строку указанное максимальное количество раз в массив подстрок в позициях, определенных регулярным выражением, указанным в конструкторе <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The search for the regular expression pattern starts at a specified character position in the input string.</source>
          <target state="translated">Поиск шаблона регулярного выражения начинается с указанной позиции элемента во входной строке.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>An array of strings.</source>
          <target state="translated">Массив строк.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> Методы аналогичны <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> метода, за исключением того, что <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> разделяет строку по разделителям регулярным выражением, вместо набора символов.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`count`</ph> parameter specifies the maximum number of substrings into which the <ph id="ph2">`input`</ph> string is split; the last string contains the unsplit remainder of the string.</source>
          <target state="translated"><ph id="ph1">`count`</ph> Указывает максимальное количество подстрок, в который <ph id="ph2">`input`</ph> разбиения строк; последняя строка содержит неразделенный остаток строки.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>A <ph id="ph1">`count`</ph> value of zero provides the default behavior of splitting as many times as possible.</source>
          <target state="translated">Объект <ph id="ph1">`count`</ph> нулевое значение обеспечивает стандартное поведение разбивки столько раз, сколько возможно.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startat`</ph> parameter defines the point at which the search for the first delimiter begins (this can be used for skipping leading white space).</source>
          <target state="translated"><ph id="ph1">`startat`</ph> Параметр определяет точку, с которой начинается поиск первого разделителя (это может использоваться для пропуска начальных пробелов).</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If no matches are found from the <ph id="ph1">`count`</ph>+1 position in the string, the method returns a one-element array that contains the <ph id="ph2">`input`</ph> string.</source>
          <target state="translated">Если совпадений не обнаружено из <ph id="ph1">`count`</ph>+ 1 позиции в строке, то метод возвращает массив одного элемента, который содержит <ph id="ph2">`input`</ph> строки.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If one or more matches are found, the first element of the returned array contains the first portion of the string from the first character up to one character before the match.</source>
          <target state="translated">Если один или несколько совпадений, первый элемент возвращаемого массива содержит первую часть строки с первого символа до одного символа до соответствия.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If multiple matches are adjacent to one another and the number of matches found is at least two less than <ph id="ph1">`count`</ph>, an empty string is inserted into the array.</source>
          <target state="translated">Если несколько соответствий являются смежными и количество найденных совпадений по крайней мере два меньше, чем <ph id="ph1">`count`</ph>, пустая строка вставляется в массив.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Similarly, if a match is found at <ph id="ph1">`startat`</ph>, which is the first character in the string, the first element of the returned array is an empty string.</source>
          <target state="translated">Аналогично Если соответствие найдено в <ph id="ph1">`startat`</ph>, который является первым символом в строке, первый элемент возвращаемого массива является пустая строка.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>That is, empty strings that result from adjacent matches are counted in determining whether the number of matched substrings equals <ph id="ph1">`count`</ph>.</source>
          <target state="translated">То есть пустые строки, которые являются результатом смежных соответствий учитываются при определении ли число соответствующих подстрок равно <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>In the following example, the regular expression <ph id="ph1">`\d+`</ph> is used to find the starting position of the first substring of numeric characters in a string, and then to split the string a maximum of three times starting at that position.</source>
          <target state="translated">В следующем примере регулярное выражение <ph id="ph1">`\d+`</ph> используется для поиска начальную позицию первой подстроки числовых символов в строке, а затем для разбиения строки более три раза, начиная с этой позиции.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Because the regular expression pattern matches the beginning of the input string, the returned string array consists of an empty string, a five-character alphabetic string, and the remainder of the string,</source>
          <target state="translated">Так как шаблон регулярного выражения соответствует началу входной строки, возвращаемой строки массива состоит из пустая строка, Строка букв пяти символов и остаток строки,</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If capturing parentheses are used in a regular expression, any captured text is included in the array of split strings.</source>
          <target state="translated">Если в регулярном выражении используются скобки записи, любой записанный текст включается в массив разделенных строк.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>However, any array elements that contain captured text are not counted in determining whether the number of matches has reached <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Тем не менее, все элементы массива, содержащие записанный текст, не учитываются при определении ли достигнуто число совпадений <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>For example, splitting the string '"apple-apricot-plum-pear-pomegranate-pineapple-peach" into a maximum of four substrings beginning at character 15 in the string results in a seven-element array, as the following code shows.</source>
          <target state="translated">Например, разделение строки "«яблоко-абрикос-слива-груша-гранат-ананас-персик» на максимально возможные четыре подстроки, начиная с символа 15 в строку результатов в 7 элементный массив, как показано в следующем коде.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Тем не менее если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии платформы .NET Framework.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>In .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">В .NET Framework 1.0 и 1.1 Если соответствие не найдено в первый набор круглых скобок, записанный текст из дополнительных скобок записи не включается в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">Начиная с .NET Framework 2.0, весь записанный текст также добавляется в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the individual words in a string.</source>
          <target state="translated">Например следующий код использует два набора скобок записи для извлечения отдельных слов в строке.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the vertical bar.</source>
          <target state="translated">Первый набор скобок записи записывает дефис, а второй набор записывает вертикальную черту.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the vertical bar characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">Если код примера скомпилирован и запущен под управлением платформы .NET Framework версии 1.0 или 1.1, исключаются вертикальную панель символов; Если он компилируется и выполняется в .NET Framework 2.0 или более поздней версии, то они включаются.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Если регулярное выражение может совпасть с пустой строкой, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> разобьет строку на массив строк для одного символа, потому что разделитель пустой строки можно найти в любом месте.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The following example splits the string "characters" into as many elements as the input string contains, starting with the character "a".</source>
          <target state="translated">Следующий пример разделяется на строку «символы» столько же элементов содержит входной строки, начиная с символа «».</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Because the null string matches the end of the input string, a null string is inserted at the end of the returned array.</source>
          <target state="translated">Так как пустая строка соответствует концу входной строки, нулевые строки вставлены в конце возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции split превышает интервал времени ожидания, определяемое <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> создан объект.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Если время ожидания не определен в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> вызов конструктора или в свойствах домена приложения, или если значение интервала <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не создается</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="input" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="startat" /&gt;</ph> имеет значение меньше нуля или больше длины <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to split.</source>
          <target state="translated">Строка для разделения.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern.</source>
          <target state="translated">Разделяет входную строку в массив подстрок в позициях, определенных указанным шаблоном регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Specified options modify the matching operation.</source>
          <target state="translated">Указанные параметры изменяют операцию сопоставления.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>An array of strings.</source>
          <target state="translated">Массив строк.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> Методы аналогичны <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> метода, за исключением того, что <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> разделяет строку по разделителям регулярным выражением, вместо набора символов.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string is split as many times as possible.</source>
          <target state="translated">Строка разделяется столько раз, сколько возможно.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no delimiter is found, the return value contains one element whose value is the original <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">Если разделитель не найден, возвращаемое значение содержит один элемент, значение которого является исходный <ph id="ph1">`input`</ph> строки.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Compiled regular expressions used in calls to static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods are automatically cached.</source>
          <target state="translated">Скомпилированные регулярные выражения, используемые в вызовах статическому <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> методы автоматически сохраняются в кэше.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>To manage the lifetime of compiled regular expressions yourself, use the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods.</source>
          <target state="translated">Чтобы самостоятельно управлять временем жизни скомпилированные регулярные выражения, используйте экземпляр <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">Если несколько соответствий являются смежными, пустая строка вставляется в массив.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found.</source>
          <target state="translated">Например разделение строки одиночным дефисом вызывает возвращаемый массив для включения пустую строку в позицию, где находятся два смежных дефиса.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">При обнаружении совпадения в начале или в конце входной строки, пустая строка входит в начале или конце возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`[a-z]+`</ph> to split an input string on any uppercase or lowercase alphabetic character.</source>
          <target state="translated">В следующем примере шаблон регулярного выражения <ph id="ph1">`[a-z]+`</ph> для разбиения входной строки на любой прописные или строчные буквы.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the string begins and ends with matching alphabetic characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Так как строка начинается и заканчивается с соответствующим буквенные символы, первый и последний элемент возвращаемого массива равен <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">Если используются скобки записи в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> выражения, любой записанный текст включается в результирующий строковый массив.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">Например если разделить строку «plum Груши» дефисами находиться внутри круглых скобок, возвращаемый массив включает элемент строки, содержащий дефис.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Тем не менее если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии платформы .NET Framework.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">В .NET Framework 1.0 и 1.1 Если соответствие не найдено в первый набор круглых скобок, записанный текст из дополнительных скобок записи не включается в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">Начиная с .NET Framework 2.0, весь записанный текст также добавляется в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">Например следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">Первый набор скобок записи записывает дефис, а второй набор записывает косую черту.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">Если код примера скомпилирован и запущен под управлением платформы .NET Framework версии 1.0 или 1.1, в нем исключаются символы косых черт. Если он компилируется и выполняется в .NET Framework 2.0 или более поздней версии, то они включаются.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Если регулярное выражение может совпасть с пустой строкой, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> разобьет строку на массив строк для одного символа, потому что разделитель пустой строки можно найти в любом месте.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> Исключение, если время выполнения операции split превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если время ожидания не определяется в свойствах домена приложения или если значение интервала <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является допустимой битовой комбинацией значений <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called.</source>
          <target state="translated">Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором был вызван метод.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Если значение времени ожидания не был определен для домена приложения, а значение <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, что предотвращает истечения времени ожидания, метод используется.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for splitting text on a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Статические рекомендуется для разбиения текста на соответствие шаблону <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, который позволяет установить интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to split.</source>
          <target state="translated">Строка для разделения.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Шаблон регулярного выражения для сопоставления.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Интервал времени ожидания или <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, чтобы указать, что метод не должен превышать время ожидания.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern.</source>
          <target state="translated">Разделяет входную строку в массив подстрок в позициях, определенных указанным шаблоном регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</source>
          <target state="translated">Дополнительные параметры определяют параметры, которые изменяют соответствующую операцию и интервал времени ожидания, если совпадение не найдено.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A string array.</source>
          <target state="translated">Массив строк.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> Методы аналогичны <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> метода, за исключением того, что <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> разделяет строку по разделителям регулярным выражением, вместо набора символов.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string is split as many times as possible.</source>
          <target state="translated">Строка разделяется столько раз, сколько возможно.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no delimiter is found, the return value contains one element whose value is the original <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">Если разделитель не найден, возвращаемое значение содержит один элемент, значение которого является исходный <ph id="ph1">`input`</ph> строки.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Compiled regular expressions used in calls to static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods are automatically cached.</source>
          <target state="translated">Скомпилированные регулярные выражения, используемые в вызовах статическому <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> методы автоматически сохраняются в кэше.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To manage the lifetime of compiled regular expressions yourself, use the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods.</source>
          <target state="translated">Чтобы самостоятельно управлять временем жизни скомпилированные регулярные выражения, используйте экземпляр <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">Если несколько соответствий являются смежными, пустая строка вставляется в массив.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found.</source>
          <target state="translated">Например разделение строки одиночным дефисом вызывает возвращаемый массив для включения пустую строку в позицию, где находятся два смежных дефиса.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">При обнаружении совпадения в начале или в конце входной строки, пустая строка входит в начале или конце возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`[a-z]+`</ph> to split an input string on any uppercase or lowercase alphabetic character.</source>
          <target state="translated">В следующем примере шаблон регулярного выражения <ph id="ph1">`[a-z]+`</ph> для разбиения входной строки на любой прописные или строчные буквы.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the string begins and ends with matching alphabetic characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Так как строка начинается и заканчивается с соответствующим буквенные символы, первый и последний элемент возвращаемого массива равен <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">Если используются скобки записи в <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> выражения, любой записанный текст включается в результирующий строковый массив.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">Например если разделить строку «plum Груши» дефисами находиться внутри круглых скобок, возвращаемый массив включает элемент строки, содержащий дефис.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Тем не менее если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии платформы .NET Framework.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">В .NET Framework 1.0 и 1.1 Если соответствие не найдено в первый набор круглых скобок, записанный текст из дополнительных скобок записи не включается в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">Начиная с .NET Framework 2.0, весь записанный текст также добавляется в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">Например следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">Первый набор скобок записи записывает дефис, а второй набор записывает косую черту.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">Если код примера скомпилирован и запущен под управлением платформы .NET Framework версии 1.0 или 1.1, в нем исключаются символы косых черт. Если он компилируется и выполняется в .NET Framework 2.0 или более поздней версии, то они включаются.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Если регулярное выражение может совпасть с пустой строкой, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> разобьет строку на массив строк для одного символа, потому что разделитель пустой строки можно найти в любом месте.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> Указывает о том, как долго шаблон соответствующий метод должен пытаться найти совпадения, до истечения времени ожидания. Установка интервала времени ожидания предотвращает регулярные выражения, зависящие от избыточный поиск с возвратом отображение перестает отвечать при обработке входных данных, содержащий ближайшие совпадения.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>советы и рекомендации по использованию регулярных выражений<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> и <bpt id="p2">[</bpt>поиск с возвратом<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Если совпадение не найдено в этого интервала времени, метод вызывает <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в которой выполняется метод.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Произошла ошибка анализа регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="input" /&gt;</ph> или <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является допустимой битовой комбинацией значений <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> отрицательно, равно нулю или больше приблизительно 24 дней.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">Время ожидания истекло.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения о времени ожидания см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Мы рекомендуем задавать <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> параметр соответствующее значение, например две секунды.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Если отключить время ожидания, указав <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, обработчик регулярных выражений, обеспечивает немного лучшую производительность.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Тем не менее следует отключить тайм-ауты только при следующих условиях:</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Если входных данных, обрабатываемых регулярное выражение является производным от известного и надежного источника или состоит из статического текста.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Это исключает текст, который был динамически ввода пользователями.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Если шаблон регулярного выражения тщательно протестирован для обеспечения эффективной обработки соответствует несовпадающие и ближайшем совпадает.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Если шаблон регулярного выражения содержит не языковые элементы, которые возникает избыточный поиск с возвратом при обработке почти совпадают.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object to populate with serialization information.</source>
          <target state="translated">Объект, который требуется заполнить информацией о сериализации.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The place to store and retrieve serialized data.</source>
          <target state="translated">Место для хранения и извлечения сериализованных данных.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This parameter is reserved for future use.</source>
          <target state="translated">Этот параметр зарезервирован для использования в будущем.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Populates a <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object with the data necessary to deserialize the current <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object.</source>
          <target state="translated">Заполняет объект <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> данными даты, необходимыми для десериализации текущего объекта <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>Returns the regular expression pattern that was passed into the <ph id="ph1">&lt;see langword="Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Возвращает шаблон регулярного выражения, который был передан в конструктор <ph id="ph1">&lt;see langword="Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>The <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> parameter that was passed into the <ph id="ph2">&lt;see langword="Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph>, который был передан в конструктор <ph id="ph2">&lt;see langword="Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о регулярных выражениях см. в разделе <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> и <bpt id="p2">[</bpt>языка регулярных выражений — краткий справочник<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> is the base class of regular expressions created by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> является базовым классом регулярных выражений, созданные <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>These compiled regular expressions use the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> implementation of the base class.</source>
          <target state="translated">Эти скомпилированные регулярные выражения используйте <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> реализацию базового класса.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>If called from a derived class, the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> method returns the string that was passed to the <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> parameter of the <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> class constructor that was used to define the regular expression.</source>
          <target state="translated">При вызове из производного класса, <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> метод возвращает строку, который был передан в <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> параметр <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> конструктора класса, который использовался для определения регулярного выражения.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>The input string containing the text to convert.</source>
          <target state="translated">Входная строка, содержащая текст для преобразования.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>Converts any escaped characters in the input string.</source>
          <target state="translated">Преобразует все escape-символы во входной строке обратно в символы.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>A string of characters with any escaped characters converted to their unescaped form.</source>
          <target state="translated">Строка символов с любыми преобразованными символами, приведенными в их непреобразованную форму.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method performs one of the following two transformations:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> Метод выполняет одно из следующих двух преобразований:</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>It reverses the transformation performed by the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method by removing the escape character ("<ph id="ph2">\\</ph>") from each character escaped by the method.</source>
          <target state="translated">Он обращает преобразования, выполняемые <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> метод путем удаления escape-символ (»<ph id="ph2">\\</ph>«) из каждого символа, с помощью метода в escape-последовательность.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>These include the <ph id="ph1">\\</ph>, *, +, ?, &amp;#124;, {, [, (,), ^, $,., #, and white space characters.</source>
          <target state="translated">К ним относятся <ph id="ph1">\\</ph>, *, +,?, &amp;#124;, {, [, (,), ^, $,., # и пробелы.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method unescapes the closing bracket (]) and closing brace (}) characters.</source>
          <target state="translated">Кроме того <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> метод отменяет преобразование преобразованных закрывающая скобка (]) и закрывающие скобки (}).</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> cannot reverse an escaped string perfectly because it cannot deduce precisely which characters were escaped,</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> Невозможно обратить строки, в которой полностью, так как он не может вывести точно были escape-символов,</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>It replaces the representation of unprintable characters with the characters themselves.</source>
          <target state="translated">Она заменяет представление непечатаемых символов сами символы.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>For example, it replaces \a with \x07.</source>
          <target state="translated">Например он заменяет \a \x07.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>The character representations it replaces are \a, \b, \e, \n, \r, \f, \t, and \v.</source>
          <target state="translated">Представлений символов, которое оно заменяет являются \a, \b, \e, \n, \r, \f \t и \v.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>If the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method encounters other escape sequences that it cannot convert, such as \w or \s, it throws an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> метод обнаруживает других escape-последовательности, преобразование невозможно, например \w или \s, он выдает <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> includes an unrecognized escape sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> включает нераспознанную escape-последовательность.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="str" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionC">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Используется объектом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>, который создан методом <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionC">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property contains the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если свойство <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> содержит параметр <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph>; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionR">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">Используется объектом <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>, который создан методом <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionR">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property contains the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /&gt;</ph> option; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если свойство <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> содержит параметр <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /&gt;</ph>; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)">
          <source>The time-out interval to check.</source>
          <target state="translated">Время ожидания, которое требуется проверить.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)">
          <source>Checks whether a time-out interval is within an acceptable range.</source>
          <target state="translated">Проверяет, попадает ли интервал времени ожидания в допустимый диапазон.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>