<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f5b1b16e45086d2dbf7c8f1afa213b88dfe4f122" />
    <Meta Name="ms.sourcegitcommit" Value="9f18ecaf63382fa565dfaeb7274bc1a9e81c35e9" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/19/2018" />
    <Meta Name="ms.locfileid" Value="36208852" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет постоянное регулярное выражение.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> Класс представляет механизм регулярных выражений .NET Framework. Он позволяет быстро анализировать большие объемы текста для поиска определенных шаблонов символов; для извлечения, изменять, заменять или удалять текстовые подстроки, и добавлять извлеченные строки в коллекцию для создания отчета.  
  
> [!NOTE]
>  Если ваш основной интерес для проверки строки, определяя их соответствие конкретному шаблону, можно использовать <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> класса.  
  
 Чтобы использовать регулярные выражения, необходимо определить шаблон, который нужно определить в текстовый поток, используя синтаксис, задокументированный в [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Затем при необходимости можно создать экземпляр <xref:System.Text.RegularExpressions.Regex> объекта. Наконец вызвать метод, который выполняет некоторые операции, например, заменив текст, соответствующий шаблону регулярного выражения или идентификация совпадения с шаблоном.  
  
> [!NOTE]
>  Некоторые распространенные шаблоны регулярных выражений см. [Примеры регулярных выражений](~/docs/standard/base-types/regular-expression-examples.md). Существует ряд документации библиотеки шаблонов регулярных выражений, например по одному [Regular Expressions.info](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a> Дополнительные сведения об использовании <xref:System.Text.RegularExpressions.Regex> класса, в следующих разделах этой статьи:  
  
-   [Сравнение регулярных выражений. Методы строк](#regex_vs_string)  
  
-   [Статические vs. Методы экземпляра](#static_vs_instance)  
  
-   [Выполнение операций регулярного выражения](#regex_ops)  
  
-   [Определение значения времени ожидания](#define_timeout)  
  
 Дополнительные сведения о языке регулярных выражений см. в [кратком справочнике по элементам языка регулярных выражений](~/docs/standard/base-types/regular-expression-language-quick-reference.md) или в одной из следующих брошюр, который вы можете скачать и распечатать:  
  
 [Краткий справочник в формате Word (DOCX)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx);  
 [Краткий справочник в формате PDF (PDF)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf).  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Сравнение регулярных выражений. Методы строк  
 <xref:System.String?displayProperty=nameWithType> Класс содержит несколько методов поиска и сравнения, которые можно использовать для выполнения сопоставления шаблона с текстом. Например <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, и <xref:System.String.StartsWith%2A?displayProperty=nameWithType> методы определить, содержит ли экземпляр string указанной подстроки и <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, и <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> методы возвращают начальную позицию указанной подстроки в строке. Используйте методы класса <xref:System.String?displayProperty=nameWithType> класс при поиске определенной строки. Используйте <xref:System.Text.RegularExpressions.Regex> класс при поиске шаблона в строку. Дополнительные сведения и примеры см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
 [Примечания к](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Статические vs. Методы экземпляра  
 После определения шаблона регулярного выражения, можно передать его обработчику регулярных выражений одним из двух способов:  
  
-   Путем создания экземпляра <xref:System.Text.RegularExpressions.Regex> , представляющий регулярного выражения. Чтобы сделать это, передайте шаблон регулярного выражения для <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> конструктор. Объект <xref:System.Text.RegularExpressions.Regex> является неизменяемым; при создании экземпляра <xref:System.Text.RegularExpressions.Regex> объекта регулярное выражение, не может изменяться объекта регулярного выражения.  
  
-   Указав регулярных выражений и текст для поиска для `static` (`Shared` в Visual Basic) <xref:System.Text.RegularExpressions.Regex> метод. Это позволяет использовать регулярное выражение без явного создания <xref:System.Text.RegularExpressions.Regex> объекта.  
  
 Все <xref:System.Text.RegularExpressions.Regex> экземпляра перегрузки и включают как статические методы идентификации шаблона.  
  
 Обработчик регулярных выражений необходимо скомпилировать определенный шаблон, прежде чем можно будет использовать шаблон. Поскольку <xref:System.Text.RegularExpressions.Regex> объекты являются неизменяемыми, это одноразовую процедуру, которая возникает при <xref:System.Text.RegularExpressions.Regex> вызывается конструктор класса или статический метод. Чтобы избежать необходимости повторно компилировать одно регулярное выражение, обработчик регулярных выражений кэширует скомпилированные регулярные выражения, используемые в вызовах статичных методов. Как следствие методы поиска совпадения с шаблоном регулярного выражения предлагают сравнимую производительность для статических методов и методов экземпляра.  
  
> [!IMPORTANT]
>  В версиях 1.0 и 1.1, все скомпилированные регулярные выражения .NET Framework используются ли они в экземпляре или статический метод вызывает, были кэшированы. Начиная с .NET Framework 2.0, кэшируются только регулярные выражения, используемые в вызовах статичных методов.  
  
 Тем не менее кэширование может отрицательно сказаться на производительности в следующих двух случаях:  
  
-   При использовании вызовов статических методов с большим числом регулярных выражений. По умолчанию обработчик регулярных выражений кэширует 15 последних использованных статических регулярных выражений. Если приложение использует более 15 статических регулярных выражений, некоторые регулярные выражения должны быть перекомпилированы. Чтобы предотвратить перекомпиляция, можно увеличить <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> свойство.  
  
-   При создании нового экземпляра <xref:System.Text.RegularExpressions.Regex> объектов с помощью регулярных выражений, которые ранее были скомпилированы. Например следующий код определяет регулярное выражение для поиска повторяющихся слов в текстовый поток. Несмотря на то, что в примере используется одним регулярным выражением, он создает новый <xref:System.Text.RegularExpressions.Regex> объектов для обработки каждой строки текста. Это приводит к повторной компиляции регулярного выражения с каждой итерацией цикла.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Во избежание перекомпиляции, следует создать отдельный <xref:System.Text.RegularExpressions.Regex> объекта, доступного ко всему коду, который требует, как показано в следующем примере перезаписанного.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [Примечания к](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Выполнение операций регулярного выражения  
 Вы решите создать <xref:System.Text.RegularExpressions.Regex> и вызывать его методы или вызывают статические методы <xref:System.Text.RegularExpressions.Regex> класс предлагает следующие функциональные возможности сопоставления шаблона:  
  
-   Проверка соответствия. Вызывается <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> метод, чтобы определить, присутствует ли совпадение.  
  
-   Извлечение одного совпадения. Можно вызвать <xref:System.Text.RegularExpressions.Regex.Match%2A> метод для извлечения <xref:System.Text.RegularExpressions.Match> , представляющий первое совпадение в строке или их часть строки. Последующие соответствия можно получить, вызвав <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод.  
  
-   Извлечение всех совпадений. Можно вызвать <xref:System.Text.RegularExpressions.Regex.Matches%2A> метод для извлечения <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> , представляющий всех совпадений в строке или их часть строки.  
  
-   Замена совпадающего текста. Вызывается <xref:System.Text.RegularExpressions.Regex.Replace%2A> метод для замены совпадающего текста. Текст замены можно также определить регулярным выражением. Кроме того, некоторые <xref:System.Text.RegularExpressions.Regex.Replace%2A> методы включают <xref:System.Text.RegularExpressions.MatchEvaluator> параметр, который позволяет программно определить текст замены.  
  
-   Создание массива строк, сформированный на основе части входной строки. Вызывается <xref:System.Text.RegularExpressions.Regex.Split%2A> метод разбиение входную строку в позициях, определенных с регулярным выражением.  
  
 В дополнение к его методов поиска совпадения с шаблоном <xref:System.Text.RegularExpressions.Regex> класс включает несколько специализированных методов:  
  
-   <xref:System.Text.RegularExpressions.Regex.Escape%2A> Метод экранирует все символы, которые могут быть интерпретированы как операторы регулярных выражений в входной строки или регулярного выражения.  
  
-   <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Метод удаляет escape-символы.  
  
-   <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Метод создает сборку, содержащую предварительно определенных регулярных выражений. Платформа .NET Framework содержит примеры эти сборки специального назначения в <xref:System.Web.RegularExpressions?displayProperty=nameWithType> пространства имен.  
  
 [Примечания к](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Определение значения времени ожидания  
 Платформа .NET Framework поддерживает язык полнофункциональный регулярного выражения, предоставляет значительные возможности и гибкость в сопоставлениях с шаблоном. Тем не менее, мощность и гибкость есть своя Цена: риск снижения производительности. Регулярные выражения, которые завершаются неудачно удивительно легко создать. В некоторых случаях операции регулярного выражения, зависящие от избыточный поиск с возвратом может отображаться перестает отвечать при обработке текста, почти соответствующие шаблону регулярного выражения. Дополнительные сведения о обработчик регулярных выражений .NET Framework см. в разделе [подробные сведения о поведении регулярных выражений](~/docs/standard/base-types/details-of-regular-expression-behavior.md). Дополнительные сведения о избыточный поиск с возвратом см. в разделе [поиск с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], можно определить интервал времени ожидания для совпадения с регулярными выражениями. Если обработчик регулярных выражений не может определить соответствие, в течение этого интервала времени, вызывает соответствующую операцию <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. В большинстве случаев это не позволяет обработчику регулярных выражений тратить энергию обработки при попытке сопоставить текст, почти соответствующий шаблону регулярного выражения. Также возможно, однако, что интервал времени ожидания было установлено слишком низкое, или что текущей нагрузки машины вызвала общего снижения производительности.  
  
 Как обрабатывать исключение зависит от причины возникновения исключения. При возникновении исключения, так как время ожидания задано слишком мало или из-за чрезмерного машины нагрузки можно увеличить интервал времени ожидания и повторите операцию сопоставления. Если же исключение возникает, поскольку зависит избыточный поиск с возвратом в регулярных выражений, можно предположить, что соответствие не существует, и при необходимости можно записывать в журнал сведения, которые помогут вам изменить шаблон регулярного выражения.  
  
 Можно задать интервал времени ожидания путем вызова <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> конструктор при создании экземпляра объекта регулярного выражения. Для статических методов можно задать интервал времени ожидания путем вызова перегрузки метода сопоставления, который имеет `matchTimeout` параметра. Если значение времени ожидания не задано явно, по умолчанию значение времени ожидания определяется следующим образом:  
  
-   С помощью тайм-аута приложения. значение, если он существует. Это может быть любое значение времени ожидания, в домен приложения, в котором применяется <xref:System.Text.RegularExpressions.Regex> создать экземпляр объекта или вызов статического метода. Значение тайм-аута уровня приложения можно задать путем вызова <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> метод назначения строковое представление <xref:System.TimeSpan> значение свойства «REGEX_DEFAULT_MATCH_TIMEOUT».  
  
-   С помощью значения <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, если значение времени ожидания уровня приложения не было задано.  
  
> [!IMPORTANT]
>  Рекомендуется задавать значение времени ожидания во всех операциях поиска совпадения с шаблоном регулярного выражения. Дополнительные сведения см. в разделе [советы и рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md).  
  
 [Примечания к](#remarks)  
  
   
  
## Examples  
 В следующем примере регулярное выражение для проверки повторяющихся вхождений слов в строке. Регулярное выражение `\b(?<word>\w+)\s+(\k<word>)\b` можно интерпретировать как показано в следующей таблице.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`\b`|Начало соответствия на границе слова.|  
|`(?<word>\w+)`|Соответствует буквенным символам до границы слова. Имя данной группой записи `word`.|  
|`\s+`|Соответствует один или несколько символов пробела.|  
|`(\k<word>)`|Соответствует группе записи, которая называется `word`.|  
|`\b`|Соответствует границе слова.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 Следующий пример иллюстрирует использование регулярного выражения для проверки, является ли строка представляет значение валюты или имеет правильный формат для представления денежного значения. В этом случае регулярного выражения оно строится динамически из <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, и <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> свойств для текущего языка и региональных параметров пользователя. Если текущий язык и региональные параметры en US, результате регулярное выражение является `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`. Это регулярное выражение может интерпретироваться, как показано в следующей таблице.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`^`|Начинаться в начале строки.|  
|`\s*`|Соответствует нулю или нескольким символам пробела.|  
|`[\+-]?`|Совпадение с нулем или одним вхождением положительного или отрицательного знака.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`\$?`|Совпадение с нулем или одним вхождением знак доллара.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`\d*`|Соответствует нулю или нескольким десятичным числам.|  
|`\.?`|Совпадает с нулем или одним символом десятичной запятой.|  
|`\d{2}?`|Совпадение с двумя десятичными цифрами ноль или один раз.|  
|`(\d*\.?\d{2}?){1}`|Совпадение с шаблоном целой и дробной части, разделенные символа десятичного разделителя, по крайней мере один раз.|  
|`$`|Соответствует концу строки.|  
  
 Таким образом, регулярное выражение предполагает, что строка допустимой валюты не содержит символы разделителя группы, и имеет дробных разрядов или количество цифр дробной части, определенные в текущих региональных параметрах <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> свойство.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 Так как регулярное выражение в этом примере создается динамически, неизвестно во время разработки ли символ валюты для текущего языка и региональных параметров, десятичного разделителя или положительный и отрицательный знаки могут быть неправильно обработчиком регулярных выражений как операторы языка регулярных выражений. Во избежание любой интерпретации в примере передается каждой строки динамически создаваемых <xref:System.Text.RegularExpressions.Regex.Escape%2A> метод.  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <see cref="T:System.Text.RegularExpressions.Regex" /> Класса является неизменяемым (только для чтения) и потокобезопасным. <see cref="T:System.Text.RegularExpressions.Regex" /> объекты могут создаваться в любом потоке и совместно использоваться несколькими потоками. Дополнительные сведения см. в разделе [Safety](~/docs/standard/base-types/thread-safety-in-regular-expressions.md) потока.</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что этот конструктор является защищенным; может вызываться только в классах, производных от <xref:System.Text.RegularExpressions.Regex> класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" /> для заданного регулярного выражения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md) разделы.  
  
 Вызов <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> конструктор эквивалентно вызову <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> конструктор со значением <xref:System.Text.RegularExpressions.RegexOptions.None> для `options` аргумент.  
  
 Объект <xref:System.Text.RegularExpressions.Regex> является неизменяемым, это означает, что он может использоваться только для соответствия шаблону, определяется при ее создании. Однако можно использовать любое количество раз без повторной компиляции.  
  
 Этот конструктор создает объект регулярного выражения, которую пытается выполнить регистра все буквенные символы, определенные в `pattern`. Соответствие без учета регистра, используйте <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> конструктор.  
  
   
  
## Examples  
 Следующий пример показывает, как использовать этот конструктор для создания экземпляра регулярное выражение, которое соответствует любому слову, начинающемуся с букв «a» или «t».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 Обратите внимание, что шаблон регулярного выражения не может совпадать со словом «» в начале текста, так как сравнения выполняются с учетом регистра по умолчанию. Пример сравнение без учета регистра см. в разделе <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Этот конструктор создает <see cref="T:System.Text.RegularExpressions.Regex" /> объект, который использует значение времени ожидания по умолчанию домена приложения, в которой он создан. Если значение времени ожидания не был определен для домена приложения, <see cref="T:System.Text.RegularExpressions.Regex" /> объект использует значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что мешает выполнить операцию по истечении времени ожидания. Рекомендуемые конструктор для создания <see cref="T:System.Text.RegularExpressions.Regex" /> объект <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Объект, содержащий сериализованный шаблон и сведения <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</param>
        <param name="context">Целевой объект этой сериализации. (Этот параметр не используется; задайте значение <see langword="null" />.)</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" />, используя сериализованные данные.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Шаблон, содержащий <paramref name="info" />, имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="info" /> содержит недопустимый флаг <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовое сочетание значений перечисления, изменяющих регулярное выражение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" /> для указанного регулярного выражения с параметрами, изменяющими шаблон.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md) разделы.  
  
 Объект <xref:System.Text.RegularExpressions.Regex> является неизменяемым, это означает, что он может использоваться только для параметров соответствия, определяется при ее создании. Однако можно использовать любое количество раз без повторной компиляции.  
  
   
  
## Examples  
 Следующий пример показывает, как использовать этот конструктор для создания экземпляра регулярное выражение, которое соответствует любому слову, начинающемуся с букв «a» или «t».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Обратите внимание, что коллекция соответствий включает слово «», начинается текст, так как `options` параметр определен сравнения без учета регистра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> содержит недопустимый флаг.</exception>
        <block subset="none" type="usage">
          <para>Этот конструктор создает <see cref="T:System.Text.RegularExpressions.Regex" /> объект, который использует значение времени ожидания по умолчанию домена приложения, в которой он создан. Если значение времени ожидания не был определен для домена приложения, <see cref="T:System.Text.RegularExpressions.Regex" /> объект использует значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что мешает выполнить операцию по истечении времени ожидания. Рекомендуемые конструктор для создания <see cref="T:System.Text.RegularExpressions.Regex" /> объект <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовое сочетание значений перечисления, изменяющих регулярное выражение.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" /> для указанного регулярного выражения с параметрами, которые изменяют шаблон, и значение, указывающее, как долго метод сравнения с шаблоном должен пытаться найти совпадение, прежде чем время ожидания истечет.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md) разделы.  
  
 Объект <xref:System.Text.RegularExpressions.Regex> является неизменяемым, это означает, что он может использоваться только для определения при создании шаблона соответствия. Однако можно использовать любое количество раз без повторной компиляции.  
  
 `matchTimeout` Параметр указывает, сколько времени поиска совпадения с шаблоном метод должен пытаться найти совпадения, до истечения времени ожидания. Если совпадение не найдено в этого интервала времени, вызывает метод поиска совпадения с шаблоном <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Методы поиска совпадения с шаблоном экземпляра придерживаются `matchTimeout` интервал времени ожидания включают следующее:  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 Установка интервала времени ожидания предотвращает регулярные выражения, зависящие от избыточный поиск с возвратом отображение перестает отвечать при обработке входных данных, содержащий ближайшие совпадения. Дополнительные сведения см. в разделе [советы и рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиск с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Чтобы задать интервал ожидания разумного, учитывайте следующие факторы:  
  
-   Длина и сложность шаблон регулярного выражения. Длинные и более сложные регулярные выражения требуется больше времени, чем более короткий и простой из них.  
  
-   Нагрузка ожидаемый машины. Обработка занимает больше времени, в системах, имеющих высокий уровень использования ЦП и памяти.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> конструктора для создания <xref:System.Text.RegularExpressions.Regex> объекта со значением времени ожидания, равным одной секунде. Шаблон регулярного выражения `(a+)+$`, который сопоставляется с последовательностью из одного или нескольких символов "a" в конце строки, относится к шаблонам с чрезмерным использованием поиска с возвратом. Если <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> является исключение, в примере увеличивается значение времени ожидания до достижения максимального значения, равного трем секундам. В противном случае не приостановит попытки найти соответствие шаблону.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> не является допустимым значением <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  -или-  Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <block subset="none" type="usage">
          <para>Мы рекомендуем задавать <paramref name="matchTimeout" /> параметр соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений, обеспечивает немного лучшую производительность. Тем не менее, следует отключить тайм-ауты только при следующих условиях: — когда входные данные, обрабатываемые регулярного выражения определяется из известного и надежного источника или состоит из статического текста. Это исключает текст, который был динамически ввода пользователями.  — Если для обеспечения эффективной обработки тщательно протестирован шаблон регулярного выражения соответствует, несовпадающие, а ближайшем.  -Если шаблон регулярного выражения содержит не языковые элементы, которые возникает избыточный поиск с возвратом при обработке почти совпадают.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное количество записей в текущей статической кэш-памяти скомпилированных регулярных выражений.</summary>
        <value>Максимальное количество записей в статической кэш-памяти.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> Класс поддерживает внутренний кэш скомпилированных регулярных выражений, используемых при вызове статического метода. Если значение, указанное в операции задания меньше, чем текущий размер кэша, записей кэша будут удалены, пока размер кэша равен указанному значению.  
  
 По умолчанию кэш содержит 15 скомпилированных статических регулярных выражений. Обычно приложение для изменения размера кэша не будет. Используйте <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> свойство только в том случае, если вы хотите отключить кэширование или при наличии большими наборами кэша.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше нуля.</exception>
        <block subset="none" type="usage">
          <para>В платформе .NET Framework до версии [! INCLUDE[net_v20SP1_short](~/includes/NET-v20sp1-Short-MD.MD)], регулярные выражения, используемые в как статическим, так и вызовов методов экземпляра были кэшированы. Начиная с [! INCLUDE[net_v20SP1_short](~/includes/NET-v20sp1-Short-MD.MD)], только регулярные выражения, используемые в статический метод кэшируется вызовов.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает словарь, сопоставляющий именованные захватываемые группы со значениями их индексов.</summary>
        <value>Словарь, сопоставляющий именованные захватываемые группы со значениями их индексов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что это свойство защищено; может осуществляться только из класса, производного от <xref:System.Text.RegularExpressions.Regex> класса.  
  
 Пытается преобразовать значение назначается свойству в операции задания <xref:System.Collections.Hashtable> объекта; Если данное преобразование не удается, он вызывает метод <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение, присвоенное свойству <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> в операции задания, равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает словарь, сопоставляющий нумерованные захватываемые группы со значениями их индексов.</summary>
        <value>Словарь, сопоставляющий нумерованные захватываемые группы со значениями их индексов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что это свойство защищено; может осуществляться только из класса, производного от <xref:System.Text.RegularExpressions.Regex> класса.  
  
 Пытается преобразовать значение назначается свойству в операции задания <xref:System.Collections.Hashtable> объекта; Если данное преобразование не удается, он вызывает метод <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение, присвоенное свойству <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> в операции задания, равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Компилирует регулярные выражения и сохраняет их на диск в единой сборке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

На основе .NET Core вызовы `Regex.CompileToAssembly` throw метод <xref:System.PlatformNotSupportedException>; выписке сборки не поддерживается.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Массив, описывающий регулярные выражения для компилирования.</param>
        <param name="assemblyname">Имя файла сборки.</param>
        <summary>Компилирует один или несколько указанных объектов <see cref="T:System.Text.RegularExpressions.Regex" /> в именованную сборку.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> Метод создает сборку платформы .NET Framework в какой каждого регулярного выражения, определенного в `regexinfos` массива, представленный классом. Как правило <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> метод вызывается из отдельного приложения, создает сборку скомпилированных регулярных выражений. Каждый регулярных выражений, включенных в сборке имеет следующие характеристики:  
  
-   Он является производным от <xref:System.Text.RegularExpressions.Regex> класса.  
  
-   Он назначен полное доменное имя, которое определяется `fullnamespace` и `name` параметров соответствующего <xref:System.Text.RegularExpressions.RegexCompilationInfo> объекта.  
  
-   По умолчанию (или без параметров) конструктора.  
  
 Обычно код, который создает и использует скомпилированное регулярное выражение находится в сборке или приложения, отдельном от кода, создающий сборку.  
  
   
  
## Examples  
 В следующем примере создается сборка с именем RegexLib.dll. Сборка включает два скомпилированных регулярных выражений. Первый, `Utilities.RegularExpressions.DuplicatedString`, соответствует два одинаковых смежных слов. Второе, `Utilities.RegularExpressions.EmailAddress`, проверяет, является ли строка имеет правильный формат является адресом электронной почты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 Затем регулярное выражение, которое проверяет строку на наличие повторяющихся слов создается и используется в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Для успешной компиляции во втором примере требуется ссылка на RegexLib.dll (сборка, созданная в первом примере) для добавления в проект.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением свойства <see cref="P:System.Reflection.AssemblyName.Name" /> параметра <paramref name="assemblyname" /> является пустая или нулевая строка.  -или-  Шаблон регулярного выражения одного или нескольких объектов в <paramref name="regexinfos" /> содержит недопустимый синтаксис.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyname" /> или <paramref name="regexinfos" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Только .NET Core: создание сборки скомпилированных регулярных выражений не поддерживается.</exception>
        <block subset="none" type="usage">
          <para>При разработке в системе, где [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)] или назначьте ее доработанные выпуски установлен [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и использовании <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> метод, чтобы создать сборку, содержащую скомпилированные регулярные выражения. Попытка использовать одно из регулярных выражений в том, что сборке в системе с [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] возникло исключение. Чтобы обойти эту проблему, можно выполнить одно из следующих:-создать сборку, содержащую скомпилированные регулярные выражения в системе, которая имеет [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] вместо более поздних версиях установлены.  -Вместо из вызова метода <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> и получение скомпилированного регулярного выражения из сборки, используйте статических или экземпляр <see cref="T:System.Text.RegularExpressions.Regex" /> методы с <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> параметр при создании экземпляра <see cref="T:System.Text.RegularExpressions.Regex" /> объекта или вызвать регулярного выражения методу сопоставления шаблона.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Массив, описывающий регулярные выражения для компилирования.</param>
        <param name="assemblyname">Имя файла сборки.</param>
        <param name="attributes">Массив, определяющий атрибуты, применяемые к сборке.</param>
        <summary>Компилирует один или несколько указанных объектов <see cref="T:System.Text.RegularExpressions.Regex" /> в именованную сборку с заданными атрибутами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> Метод создает сборку платформы .NET Framework в какой каждого регулярного выражения, определенного в `regexinfos` массива, представленный классом. Как правило <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> метод вызывается из отдельного приложения, создает сборку скомпилированных регулярных выражений. Каждый регулярных выражений, включенных в сборке имеет следующие характеристики:  
  
-   Он является производным от <xref:System.Text.RegularExpressions.Regex> класса.  
  
-   Он назначен полное доменное имя, которое определяется `fullnamespace` и `name` параметров соответствующего <xref:System.Text.RegularExpressions.RegexCompilationInfo> объекта.  
  
-   По умолчанию (или без параметров) конструктора.  
  
 Обычно код, который создает и использует скомпилированное регулярное выражение находится в сборке или приложения, отдельном от кода, создающий сборку.  
  
 Так как <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> метод создает сборку платформы .NET Framework из вызова метода, вместо того чтобы использовать ключевое слово определение класса для конкретного языка (например, `class` в C# или `Class`...`End Class` в Visual Basic) он не позволяет использовать .NET Framework атрибутов для назначения сборки с помощью языка разработки стандартный синтаксис атрибутов. `attributes` Параметр предоставляет альтернативный метод для определения атрибутов, которые применяются к сборке. Для каждого атрибута, который требуется применить к сборке выполните следующие действия.  
  
1.  Создайте массив <xref:System.Type> объектов, представляющих типы параметров конструктора атрибута, который требуется вызвать.  
  
2.  Получить <xref:System.Type> объект, представляющий класс атрибута, который вы хотите применить к новой сборке.  
  
3.  Вызовите <xref:System.Type.GetConstructor%2A> метод атрибута <xref:System.Type> извлекаемого объекта <xref:System.Reflection.ConstructorInfo> объект, представляющий конструктор атрибута, который требуется вызвать. Передайте <xref:System.Type.GetConstructor%2A> метод массива из <xref:System.Type> объектов, представляющих типы параметров конструктора.  
  
4.  Создание <xref:System.Object> массив, который определяет параметры для передачи в конструктор атрибута.  
  
5.  Создать экземпляр <xref:System.Reflection.Emit.CustomAttributeBuilder> объекта путем передачи его конструктору <xref:System.Reflection.ConstructorInfo> объекта, полученное на шаге 3 и <xref:System.Object> массив, созданный на шаге 4.  
  
 Затем можно передать массив этих <xref:System.Reflection.Emit.CustomAttributeBuilder> объектов вместо `attributes` параметр <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> метода.  
  
   
  
## Examples  
 В следующем примере создается сборка с именем RegexLib.dll и применяет <xref:System.Reflection.AssemblyTitleAttribute> к нему атрибут. Сборка включает два скомпилированных регулярных выражений. Первый, `Utilities.RegularExpressions.DuplicatedString`, соответствует два одинаковых смежных слов. Второе, `Utilities.RegularExpressions.EmailAddress`, проверяет, является ли строка имеет правильный формат является адресом электронной почты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 Можно убедиться, что <xref:System.Reflection.AssemblyTitleAttribute> был применен атрибут к сборке с помощью проверки его манифест с помощью отражения программы, например ILDasm.  
  
 Затем регулярное выражение, которое проверяет строку на наличие повторяющихся слов создается и используется в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Для успешной компиляции во втором примере требуется ссылка на RegexLib.dll (сборка, созданная в первом примере) для добавления в проект.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением свойства <see cref="P:System.Reflection.AssemblyName.Name" /> параметра <paramref name="assemblyname" /> является пустая или нулевая строка.  -или-  Шаблон регулярного выражения одного или нескольких объектов в <paramref name="regexinfos" /> содержит недопустимый синтаксис.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyname" /> или <paramref name="regexinfos" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Только .NET Core: создание сборки скомпилированных регулярных выражений не поддерживается.</exception>
        <block subset="none" type="usage">
          <para>При разработке в системе, где [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)] или назначьте ее доработанные выпуски установлен [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и использовании <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> метод, чтобы создать сборку, содержащую скомпилированные регулярные выражения. Попытка использовать одно из регулярных выражений в том, что сборке в системе с [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] возникло исключение. Чтобы обойти эту проблему, можно выполнить одно из следующих:-создать сборку, содержащую скомпилированные регулярные выражения в системе, которая имеет [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] вместо более поздних версиях установлены.  -Вместо из вызова метода <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> и получение скомпилированного регулярного выражения из сборки, используйте статических или экземпляр <see cref="T:System.Text.RegularExpressions.Regex" /> методы с <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> параметр при создании экземпляра <see cref="T:System.Text.RegularExpressions.Regex" /> объекта или вызвать регулярного выражения методу сопоставления шаблона.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
        <Parameter Name="resourceFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Массив, описывающий регулярные выражения для компилирования.</param>
        <param name="assemblyname">Имя файла сборки.</param>
        <param name="attributes">Массив, определяющий атрибуты, применяемые к сборке.</param>
        <param name="resourceFile">Имя файла ресурса Win32 для включения в сборку.</param>
        <summary>Компилирует один или несколько указанных объектов <see cref="T:System.Text.RegularExpressions.Regex" /> и указанный файл ресурсов в именованную сборку с заданными атрибутами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [\], Имя сборки, CustomAttributeBuilder с передачей\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName% 2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 > метод создает сборку платформы .NET Framework в какой каждого регулярного выражения, определенного в `regexinfos` массива, представленный классом. Как правило [\], имя сборки, CustomAttributeBuilder с передачей\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D% 2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 > метод вызывается из отдельного приложения, создает сборку скомпилированных регулярных выражений. Каждый регулярных выражений, включенных в сборке имеет следующие характеристики:  
  
-   Он является производным от <xref:System.Text.RegularExpressions.Regex> класса.  
  
-   Он назначен полное доменное имя, которое определяется `fullnamespace` и `name` параметров соответствующего <xref:System.Text.RegularExpressions.RegexCompilationInfo> объекта.  
  
-   По умолчанию (или без параметров) конструктора.  
  
 Обычно код, который создает и использует скомпилированное регулярное выражение находится в сборке или приложения, отдельном от кода, создающий сборку.  
  
 Так как <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> метод создает сборку платформы .NET Framework из вызова метода, вместо того чтобы использовать ключевое слово определение класса для конкретного языка (например, `class` в C# или `Class`...`End Class` в Visual Basic) он не позволяет использовать .NET Framework атрибутов для назначения сборки с помощью языка разработки стандартный синтаксис атрибутов. `attributes` Параметр предоставляет альтернативный метод для определения атрибутов, которые применяются к сборке. Для каждого атрибута, который требуется применить к сборке выполните следующие действия.  
  
1.  Создайте массив <xref:System.Type> объектов, представляющих типы параметров конструктора атрибута, который требуется вызвать.  
  
2.  Получить <xref:System.Type> объект, представляющий класс атрибута, который вы хотите применить к новой сборке.  
  
3.  Вызовите <xref:System.Type.GetConstructor%2A> метод атрибута <xref:System.Type> извлекаемого объекта <xref:System.Reflection.ConstructorInfo> объект, представляющий конструктор атрибута, который требуется вызвать. Передайте <xref:System.Type.GetConstructor%2A> метод массива из <xref:System.Type> объектов, представляющих типы параметров конструктора  
  
4.  Создание <xref:System.Object> массив, который определяет параметры для передачи в конструктор атрибута.  
  
5.  Создать экземпляр <xref:System.Reflection.Emit.CustomAttributeBuilder> объекта путем передачи его конструктору <xref:System.Reflection.ConstructorInfo> объекта, полученное на шаге 3 и <xref:System.Object> массив, созданный на шаге 4.  
  
 Затем можно передать массив этих <xref:System.Reflection.Emit.CustomAttributeBuilder> объектов вместо `attributes` параметра [\], имя сборки, CustomAttributeBuilder с передачей\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly% 28System.Text.RegularExpressions.RegexCompilationInfo%5b%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 > метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением свойства <see cref="P:System.Reflection.AssemblyName.Name" /> параметра <paramref name="assemblyname" /> является пустая или нулевая строка.  -или-  Шаблон регулярного выражения одного или нескольких объектов в <paramref name="regexinfos" /> содержит недопустимый синтаксис.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyname" /> или <paramref name="regexinfos" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Параметр <paramref name="resourceFile" /> назначает недопустимый файл ресурсов Win32.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл, заданный свойством <paramref name="resourceFile" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Только .NET Core: создание сборки скомпилированных регулярных выражений не поддерживается.</exception>
        <block subset="none" type="usage">
          <para>При разработке в системе, где [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)] или назначьте ее доработанные выпуски установлен [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и использовании <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> метод, чтобы создать сборку, содержащую скомпилированные регулярные выражения. Попытка использовать одно из регулярных выражений в том, что сборке в системе с [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] возникло исключение. Чтобы обойти эту проблему, можно выполнить одно из следующих:-создать сборку, содержащую скомпилированные регулярные выражения в системе, которая имеет [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] вместо более поздних версиях установлены.  -Вместо из вызова метода <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> и получение скомпилированного регулярного выражения из сборки, используйте статических или экземпляр <see cref="T:System.Text.RegularExpressions.Regex" /> методы с <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> параметр при создании экземпляра <see cref="T:System.Text.RegularExpressions.Regex" /> объекта или вызвать регулярного выражения методу сопоставления шаблона.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Входная строка, содержащая преобразуемый текст.</param>
        <summary>Преобразует минимальный набор символов (\\, *, +, ?, |, {, [, (,), ^, $,., # и пробел), заменяя их escape-кодами. При этом обработчику регулярных выражений дается команда интерпретировать эти символы буквально, а не как метасимволы.</summary>
        <returns>Строка символов с метасимволами, приведенными в преобразованную форму.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> Преобразует строку, чтобы обработчик регулярных выражений интерпретирует метасимволами, он может содержать как символьные литералы. Например рассмотрим регулярное выражение, предназначенное для извлечения комментариев, которые разделены открывающей и закрывающей квадратных скобок ([и]) из текста. В следующем примере регулярное выражение «[(.*?)]» интерпретируется как класс символов. Вместо сопоставления комментариев внедренных в входной текст, регулярное выражение сопоставляет каждый открывающей или закрывающей круглой, период, звездочку или вопросительный знак.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 Однако если открывающую квадратную скобку, экранируется путем ее передачи <xref:System.Text.RegularExpressions.Regex.Escape%2A> метода регулярное выражение успешно сопоставления комментариев, которые внедряются во входной строке. Это показано в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 В регулярном выражении, которое определяется с помощью статического текста, можно экранировать символы, которые должны интерпретироваться буквально, а не как метасимволы предварять символ обратной косой черты (\\) также путем вызова <xref:System.Text.RegularExpressions.Regex.Escape%2A> метод. В регулярном выражении, которое определяется динамически с помощью символов, которые не известны во время разработки вызов <xref:System.Text.RegularExpressions.Regex.Escape%2A> метод особенно важно, чтобы убедиться, что обработчик регулярных выражений распознает отдельные символы как литералы вместо чем как метасимволы.  
  
> [!NOTE]
>  Если шаблон регулярного выражения включает литеральные символы пробела или знак номера (#), то их необходимо экранировать Если входной текст анализируется с <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> параметр включен.  
  
 Хотя <xref:System.Text.RegularExpressions.Regex.Escape%2A> метод экранирует прямой Открытие квадратная скобка ([) и открыв скобки ({}), он не экранирует их соответствующий закрывающий символов (] и}). В большинстве случаев эти экранирование не требуется. Закрывающая скобка или фигурной скобки не предшествует соответствующего открывающего символа, обработчик регулярных выражений интерпретирует буквально. Если открытая круглая или квадратная скобка интерпретируется как метасимвол, обработчик регулярных выражений интерпретирует первый соответствующий закрывающий знак как метасимвол. Если это не желательно, добавляя перед обратной косой чертой следует экранировать закрывающих или фигурных скобок (\\) символов. Иллюстрация см. в разделе.  
  
   
  
## Examples  
 Следующий пример извлекает комментарии из текста. В примере предполагается, что комментарии разделяются символом начала комментария и символом окончания комментария, выбранных пользователем. Поскольку символы начала комментария следует интерпретировать буквально, они передаются в <xref:System.Text.RegularExpressions.Regex.Escape%2A> метод, чтобы гарантировать, что они не может быть ошибочно интерпретирована как метасимволы. Кроме того пример явно проверяет, является ли введенный пользователем символ окончания комментария закрывающая скобка (]) или фигурной скобкой (}). Если это так, символ обратной косой черты (\\) добавляется в скобки или фигурные скобки, чтобы интерпретировать буквально. Обратите внимание, что в примере также используется <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> коллекции для отображения комментариев, вместо того чтобы комментарий вместе с ее открывающих и закрывающих символов комментария.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="str" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив имен группы записи для регулярного выражения.</summary>
        <returns>Строковый массив имен группы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Коллекция имен групп содержит набор строк, используемых для имени захватываемых групп в выражении. Даже если группы захвата не названы явным образом, они автоматически назначаются числовые имена («0», «1», «2», «3» и т. д). «0» с именем группы представляет все текст, соответствующий шаблону регулярного выражения. Нумерованные группы перед явно именованные группы в коллекции, а именованные группы отображаются в том порядке, в котором они определены в шаблоне регулярного выражения.  
  
 Можно использовать <xref:System.Array.Length%2A> свойства в массиве, возвращенное этим методом, чтобы определить количество групп в регулярном выражении.  
  
   
  
## Examples  
 В следующем примере определяется универсальный `ShowMatches` метод, который отображает имена групп регулярных выражений и их совпадающего текста.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 В данном случае шаблон регулярного выражения `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` предназначен для синтаксического анализа simple предложения, а также для определения его первого слова, последнее слово и конечным знаком пунктуации. Следующая таблица показывает, как интерпретируется шаблон регулярного выражения:  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`(?<FirstWord>\w+)`|Совпадение с одним или несколькими символами слова. Это `FirstWord` с именем группы.|  
|\s?|Совпадение с нулем или одним символом пробела.|  
|(\w+)|Совпадение с одним или несколькими символами слова. Это вторая группа записи.|  
|\s|Соответствует пробелу.|  
|((\w+)\s)*|Сопоставление нуля или более вхождений одной или несколькими символами слова, с пробелом. Это первая группа записи.|  
|(? \<LastWord > \w+)?|Сопоставление нулевого или единичного вхождения одной или несколькими символами слова. Это `LastWord` с именем группы.|  
|(? \<Пунктуации > \p{Po})|Соответствует символу, которого категории Юникода является знаком пунктуации, другими. Это `Punctuation` с именем группы.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив номеров групп записи, что соответствует именам групп в массиве.</summary>
        <returns>Целочисленный массив номеров групп.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неименованные и именованные группы захвата может осуществляться по номеру. Неименованные группы нумеруются слева направо, начиная с 1. (Группе записи в индексе 0 (ноль) представляет сопоставление в целом).  Именованные группы, затем нумеруются слева направо, начиная с число, которое на единицу больше, чем число неименованных захватываемых групп.  
  
 Ссылки на группы по номеру ее, а не по имени строки может обеспечить более быстрый доступ.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение, `\b((?<word>\w+)\s*)+(?<end>[.?!])`, которая сопоставляет предложение. Регулярное выражение содержит три группы захвата: неименованные группы, отражающая отдельного слова вместе с символ пробела, может следовать за его; Группа с именем `word` , собирающий отдельные слова в операторе; и группа с именем `end` , собирающий знаки препинания, который заканчивается предложения. В примере вызывается <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> метод для получения номера записи всех групп, а затем отображает их захватываемой строки. Кроме того <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> метод используется для указания того, соответствует ли определенный нумерованной группе именованную группу.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 Возможные интерпретации шаблона регулярного выражения показаны в следующей таблице.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`(?<word>\w+)`|Сопоставление одного или нескольких символов слов и назначить соответствующие строки в группу с именем `word`.|  
|`\s*`|Соответствует нулю или нескольким символам пробела.|  
|`((?<word>\w+)\s*)`|Назначьте `word` захватываемой группе, все записанные символы-разделители для первой захватываемой группы.|  
|`((?<word>\w+)\s*)+`|Совпадение с шаблоном символов слов, за которым следует любой пробельные символы один или несколько раз.|  
|`(?<end>[.?!])`|Совпадение с точкой, вопросительным знаком или восклицательным знаком. Сопоставленная символа, который необходимо назначить `end` захватываемой группой.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Номер группы для преобразования в соответствующее имя группы.</param>
        <summary>Получает имя группы, соответствующее указанному номеру группы.</summary>
        <returns>Строка, содержащая имя группы, связанное с указанным номером группы. При отсутствии имени группы, соответствующей параметру <paramref name="i" />, метод возвращает значение <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шаблон регулярного выражения может содержать либо именованной или нумерованной группы записи, которые отображают части выражений в пределах соответствия шаблону. Нумерованные группы разделены с помощью синтаксиса (*часть выражения*) и им назначается чисел в зависимости от их порядка в регулярном выражении. Именованные группы разделяются с помощью синтаксиса (?`<` *имя*`>`*часть выражения*) или (? " *имя*"*часть выражения*), где *имя* имя, по которому будет определяться вложенное выражение. (Дополнительные сведения см. в разделе [Конструкции группировки](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> Метод идентифицирует именованные группы и нумерованные группы по их позициям порядковый номер в регулярном выражении. Порядковый номер ноль всегда представляет полное регулярное выражение. Все пронумерованные группы, затем учитываются перед именем группы, независимо от их фактического расположения в шаблоне регулярного выражения.  
  
 Если `i` номер именованные группы, метод возвращает имя группы. Если `i` номер неименованной группы, метод возвращает строковое представление числа. Например если `i` -1, метод возвращает «1». Если `i` не — номер захватываемой группы, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Если обнаруживается соответствие шаблону, значение, возвращенное этим методом затем может использоваться для получения <xref:System.Text.RegularExpressions.Group> , представляющий захватываемой группы из <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> свойство. <xref:System.Text.RegularExpressions.GroupCollection> Возвращенный объект <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> свойство.  
  
   
  
## Examples  
 В следующем примере определяется шаблон регулярного выражения, который соответствует строке адреса, содержащей название города США, имя состояния и почтовый индекс. В этом примере <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> метод для извлечения имен группы записи. Затем эти имена используются для получения соответствующие захватываемой группы совпадений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 Шаблон регулярного выражения определяется следующее выражение:  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Выделяет один или несколько символ буквы или символы разделители. Назначьте этой группе записи имя `city`.|  
|`,`|Соответствует запятой (,), за которым следует символ пробела.|  
|`(?<state>[A-Za-z]{2})`|Соответствует двух букв. Назначьте этой группе записи имя `state`. Эта группа должен следовать символ пробела.|  
|`(?<zip>\d{5}(-\d{4})?)`|Соответствует пяти цифр, за которыми следует ноль или один экземпляров дефис и еще четыре цифры. Назначьте этой группе записи имя `zip`.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя группы для преобразования в соответствующий номер группы.</param>
        <summary>Возвращает номер группы, соответствующий указанному имени группы.</summary>
        <returns>Номер группы, соответствующий указанному имени группы, или -1, если <paramref name="name" /> является недопустимым именем группы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шаблон регулярного выражения может содержать либо именованной или нумерованной группы записи, которые отображают части выражений в пределах соответствия шаблону. Нумерованные группы разделены с помощью синтаксиса (*часть выражения*) и им назначается чисел в зависимости от их порядка в регулярном выражении. Именованные группы разделяются с помощью синтаксиса (?`<` *имя*`>`*часть выражения*) или (? " *имя*"*часть выражения*), где *имя* имя, по которому будет определяться вложенное выражение. (Дополнительные сведения см. в разделе [Конструкции группировки](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> Метод идентифицирует именованные группы и нумерованные группы по их позициям порядковый номер в регулярном выражении. Порядковый номер ноль всегда представляет полное регулярное выражение. Все пронумерованные группы, затем учитываются перед именем группы, независимо от их фактического расположения в шаблоне регулярного выражения.  
  
 Если `name` является строковым представлением номер группы, который присутствует в шаблоне регулярного выражения, этот метод возвращает, число. Если `name` соответствует именованного захватываемой группой, который присутствует в шаблоне регулярного выражения, метод возвращает его соответствующий номер. Сравнение `name` с группой имени учитывается регистр. Если `name` не соответствует имени захватываемой группы, или строковое представление числа захватываемой группы, метод возвращает значение-1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что для операции сравнения с шаблоном не используется конечное время ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Класса конструктор и количество статического сопоставления методы использования <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> константу, чтобы указать, не удается найти соответствие шаблону должен неограниченное время ожидания.  
  
> [!WARNING]
>  Установка значения времени ожидания обработчика регулярных выражений в <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> может привести к регулярные выражения, зависящие от избыточный поиск с возвратом к перестает отвечать на запросы при обработке текста, почти соответствующие шаблону регулярного выражения. Если отключить время ожидания, следует убедиться, что регулярное выражение не зависит от избыточный поиск с возвратом и обработки текста, почти соответствующие шаблону регулярного выражения.  
>   
>  Дополнительные сведения об обработке поиск с возвратом см. в разделе [поиск с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> Константа может быть передано в качестве значение `matchTimeout` аргумент из следующих элементов:  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ссылки уже инициализированы.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Максимальное время, которое может пройти в операции сравнения с шаблоном перед истечением срока ожидания операции.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Указывает на то, обнаруживает ли регулярное выражение соответствие во входной строке.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие регулярному выражению, заданному в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Значение <see langword="true" />, если регулярное выражение обнаруживает соответствие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Метод обычно используется для проверки строки или чтобы обеспечить соответствие строка определенному шаблону без получения этой строки для последующей обработки. Если вы хотите определить ли одну или несколько строк, соответствующих шаблону регулярного выражения и затем извлечение их для последующей обработки, вызов <xref:System.Text.RegularExpressions.Regex.Match%2A> или <xref:System.Text.RegularExpressions.Regex.Matches%2A> метод.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, определяемое <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не возникает.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> метод, чтобы определить, является ли строка допустимым артикулом. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов знаков, разделенных дефисами. Первый набор, который содержит четыре знака, должен состоять из буквенно-цифровой символ, и два цифровые символы, за которыми следует буквенно-цифровой символ. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен иметь три цифровые символы, за которыми следует буквенно-цифровой символ.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`^`|Соответствие должно обнаруживаться в начале строки.|  
|`[a-zA-Z0-9]`|Соответствует один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`\d{2}`|Соответствует двум цифрам.|  
|`[a-zA-Z0-9]`|Соответствует один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Соответствует ровно трем цифрам.|  
|`(-\d{3}){2}`|Найти дефис и еще по три цифры, а два совпадений в этом шаблоне.|  
|`[a-zA-Z0-9]`|Соответствует один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`$`|Совпадение должно заканчиваться в конце строки.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="startat">Расположение символа, с которого необходимо начать поиск.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие (начинающееся с указанной позиции в этой строке) регулярному выражению, заданному в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Значение <see langword="true" />, если регулярное выражение обнаруживает соответствие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Метод обычно используется для проверки строки или чтобы обеспечить соответствие строка определенному шаблону без получения этой строки для последующей обработки. Если вы хотите определить ли одну или несколько строк, соответствующих шаблону регулярного выражения и затем извлечение их для последующей обработки, вызов <xref:System.Text.RegularExpressions.Regex.Match%2A> или <xref:System.Text.RegularExpressions.Regex.Matches%2A> метод.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, определяемое <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не возникает.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> метод, чтобы определить, является ли строка допустимым артикулом. Он выполняет поиск номер части, следует двоеточие (:) в строке. <xref:System.String.IndexOf%28System.Char%29> Метод используется для определения положения символа двоеточия, который затем передается <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> метод. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов знаков, разделенных дефисами. Первый набор, который содержит четыре знака, должен состоять из буквенно-цифровой символ, и два цифровые символы, за которыми следует буквенно-цифровой символ. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен иметь три цифровые символы, за которыми следует буквенно-цифровой символ.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Соответствует один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`\d{2}`|Соответствует двум цифрам.|  
|`[a-zA-Z0-9]`|Соответствует один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Соответствует ровно трем цифрам.|  
|`(-\d{3}){2}`|Найти дефис и еще по три цифры, а два совпадений в этом шаблоне.|  
|`[a-zA-Z0-9]`|Соответствует один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`$`|Совпадение должно заканчиваться в конце строки.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие заданному регулярному выражению.</summary>
        <returns>Значение <see langword="true" />, если регулярное выражение обнаруживает соответствие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Метод обычно используется для проверки строки или чтобы обеспечить соответствие строка определенному шаблону без получения этой строки для последующей обработки. Если вы хотите определить ли одну или несколько строк, соответствующих шаблону регулярного выражения и затем извлечение их для последующей обработки, вызов <xref:System.Text.RegularExpressions.Regex.Match%2A> или <xref:System.Text.RegularExpressions.Regex.Matches%2A> метод.  
  
 Статический <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метода эквивалентно созданию <xref:System.Text.RegularExpressions.Regex> объекта с шаблоном регулярного выражения, заданные `pattern` и вызов <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> метод экземпляра. Этот шаблон регулярного выражения кэшируется для быстрого извлечения обработчиком регулярных выражений.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод. Если время ожидания не определяется в свойствах домена приложения или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не возникает.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метод, чтобы определить, является ли строка допустимым артикулом. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов знаков, разделенных дефисами. Первый набор, который содержит четыре знака, должен состоять из буквенно-цифровой символ, и два цифровые символы, за которыми следует буквенно-цифровой символ. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен иметь три цифровые символы, за которыми следует буквенно-цифровой символ.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`^`|Соответствие должно обнаруживаться в начале строки.|  
|`[a-zA-Z0-9]`|Соответствует один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`\d{2}`|Соответствует двум цифрам.|  
|`[a-zA-Z0-9]`|Соответствует один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Соответствует ровно трем цифрам.|  
|`(-\d{3}){2}`|Найти дефис и еще по три цифры, а два совпадений в этом шаблоне.|  
|`[a-zA-Z0-9]`|Соответствует один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`$`|Совпадение должно заканчиваться в конце строки.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage">
          <para>Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором был вызван метод. Если значение времени ожидания не был определен для домена приложения, а значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Рекомендуемые статический метод для проверки соответствия шаблону является <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие заданному регулярному выражению, используя указанные параметры сопоставления.</summary>
        <returns>Значение <see langword="true" />, если регулярное выражение обнаруживает соответствие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Метод обычно используется для проверки строки или чтобы обеспечить соответствие строка определенному шаблону без получения этой строки для последующей обработки. Если вы хотите определить ли одну или несколько строк, соответствующих шаблону регулярного выражения и затем извлечение их для последующей обработки, вызов <xref:System.Text.RegularExpressions.Regex.Match%2A> или <xref:System.Text.RegularExpressions.Regex.Matches%2A> метод.  
  
 Статический <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метода эквивалентно созданию <xref:System.Text.RegularExpressions.Regex> объекта с шаблоном регулярного выражения, заданные `pattern` и параметры регулярного выражения, заданные `options` и вызов <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> экземпляра метод. Этот шаблон регулярного выражения кэшируется для быстрого извлечения обработчиком регулярных выражений.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод. Если время ожидания не определяется в свойствах домена приложения или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не возникает.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метод, чтобы определить, является ли строка допустимым артикулом. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов знаков, разделенных дефисами. Первый набор, который содержит четыре знака, должен состоять из буквенно-цифровой символ, и два цифровые символы, за которыми следует буквенно-цифровой символ. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен иметь три цифровые символы, за которыми следует буквенно-цифровой символ.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале строки.|  
|`[A-Z0-9]`|Соответствует любому одиночному знаку алфавита от `A` через `Z`, или любой цифре.|  
|`\d{2}`|Соответствует двум цифрам.|  
|`[A-Z0-9]`|Соответствует любому одиночному знаку алфавита от `A` через `Z`, или любой цифре.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Соответствует ровно трем цифрам.|  
|`(-\d{3}){2}`|Найти дефис и еще по три цифры и соответствует двум вхождениям этого шаблона...|  
|`[A-Z0-9]`|Соответствует любому одиночному знаку алфавита от `A` через `Z`, или любой цифре.|  
|`$`|Совпадение должно заканчиваться в конце строки.|  
  
 Вызов <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метод с `options` равным <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> эквивалентное определение следующее регулярное выражение:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Для сравнения, см. пример для <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> не является допустимым значением <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage">
          <para>Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван. Если значение времени ожидания не был определен для домена приложения, а значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Рекомендуемые статический метод для проверки соответствия шаблону является <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие заданному регулярному выражению, с помощью указанных параметров сопоставления и интервала времени ожидания.</summary>
        <returns>Значение <see langword="true" />, если регулярное выражение обнаруживает соответствие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Метод обычно используется для проверки строки или чтобы обеспечить соответствие строка определенному шаблону без получения этой строки для последующей обработки. Если вы хотите определить ли одну или несколько строк, соответствующих шаблону регулярного выражения и затем извлечение их для последующей обработки, вызов <xref:System.Text.RegularExpressions.Regex.Match%2A> или <xref:System.Text.RegularExpressions.Regex.Matches%2A> метод.  
  
 Статический <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метода эквивалентно созданию <xref:System.Text.RegularExpressions.Regex> объекта с шаблоном регулярного выражения, заданные `pattern` и параметры регулярного выражения, заданные `options` и вызов <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> экземпляра метод. Этот шаблон регулярного выражения кэшируется для быстрого извлечения обработчиком регулярных выражений.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `matchTimeout` Указывает о том, как долго шаблон соответствующий метод должен пытаться найти совпадения, до истечения времени ожидания. Установка интервала времени ожидания предотвращает регулярные выражения, зависящие от избыточный поиск с возвратом отображение перестает отвечать при обработке входных данных, содержащий ближайшие совпадения. Дополнительные сведения см. в разделе [советы и рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиск с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если совпадение не найдено в этого интервала времени, метод вызывает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в которой выполняется метод.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод, чтобы определить, является ли строка допустимым артикулом. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов знаков, разделенных дефисами. Первый набор, который содержит четыре знака, должен состоять из буквенно-цифровой символ, и два цифровые символы, за которыми следует буквенно-цифровой символ. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен иметь три цифровые символы, за которыми следует буквенно-цифровой символ. Сопоставление шаблона регулярного выражения привлечь минимальной поиска по входной строке, поэтому метод устанавливает интервал ожидания 500 миллисекунд.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале строки.|  
|`[A-Z0-9]`|Соответствует любому одиночному знаку алфавита от `A` через `Z`, или любой цифре.|  
|`\d{2}`|Соответствует двум цифрам.|  
|`[A-Z0-9]`|Соответствует любому одиночному знаку алфавита от `A` через `Z`, или любой цифре.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Соответствует ровно трем цифрам.|  
|`(-\d{3}){2}`|Найти дефис и еще по три цифры, а два совпадений в этом шаблоне.|  
|`[A-Z0-9]`|Соответствует любому одиночному знаку алфавита от `A` через `Z`, или любой цифре.|  
|`$`|Совпадение должно заканчиваться в конце строки.|  
  
 Вызов <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод с `options` равным <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> эквивалентное определение следующее регулярное выражение:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Для сравнения, см. пример для <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> не является допустимым значением <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  -или-  Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло.</exception>
        <block subset="none" type="usage">
          <para>Мы рекомендуем задавать <paramref name="matchTimeout" /> параметр соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений, обеспечивает немного лучшую производительность. Тем не менее, следует отключить тайм-ауты только при следующих условиях: — когда входные данные, обрабатываемые регулярного выражения определяется из известного и надежного источника или состоит из статического текста. Это исключает текст, который был динамически ввода пользователями.  — Если для обеспечения эффективной обработки тщательно протестирован шаблон регулярного выражения соответствует, несовпадающие, а ближайшем.  -Если шаблон регулярного выражения содержит не языковые элементы, которые возникает избыточный поиск с возвратом при обработке почти совпадают.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Находит во входной строке подстроку, совпадающую с шаблоном регулярного выражения, и возвращает первое вхождение в качестве единого объекта <see cref="T:System.Text.RegularExpressions.Match" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <summary>Ищет в указанной входной строке первое вхождение регулярного выражения, указанного в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения во входной строке. Сведения об элементах языка, можно создать шаблон регулярного выражения см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Group.Success%2A> свойство. Если соответствие найдено, возвращенный <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> содержит подстроку из `input` , соответствующий шаблону регулярного выражения. Если совпадение не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку в `input` , соответствующий шаблону регулярного выражения. Можно получить последующие соответствия, повторно вызвав возвращаемый <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод. Кроме того, все совпадения в одном вызове метода можно получить, вызвав <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> метод.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, определяемое <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не возникает.  
  
   
  
## Examples  
 В следующем примере вычисляется шаблон регулярного выражения сопоставляет строки, а затем перечисляется список соответствующих групп, записей и позиций записи.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 Шаблон регулярного выражения `(\w+)\s+(car)` совпадает с числом вхождений слова «машина» вместе с Microsoft word, предшествующего ему. Интерпретируется, как показано в следующей таблице.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`(\w+)`|Совпадение с одним или несколькими символами слова. Это первая группа записи.|  
|`\s+`|Соответствует один или несколько символов пробела.|  
|(car)|Соответствует строковый литерал «машина». Это вторая группа записи.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="startat">Отсчитываемая от нуля позиция символа, с которой начинается поиск.</param>
        <summary>Ищет во входной строке первое вхождение регулярного выражения, начиная с указанной начальной позиции.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения, начиная с или после `startat` позиции во входной строке знака. Сведения об элементах языка, можно создать шаблон регулярного выражения см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Шаблон регулярного выражения, для которого <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> выполняет метод определяется путем вызова одного из <xref:System.Text.RegularExpressions.Regex> конструкторы класса. Дополнительные сведения об элементах, образующих шаблон регулярного выражения см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 При необходимости можно указать начальную позицию в строке с помощью `startat` параметра. Когда обработчик регулярных выражений выполняет синтаксический анализ слева направо (по умолчанию), сопоставление и сканирование переместить правом направлении, начиная с символа, указанного в `startat`. Когда обработчик регулярных выражений выполняет синтаксический анализ справа налево (если создается шаблон регулярного выражения со <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> параметр), сопоставление и просмотр перемещения в обратном направлении и начинаются с символа в `startat` -1. Если начальная позиция не указан, поиск начинается в режиме по умолчанию `startat` позиции. Если регулярное выражение выполняет поиск слева направо, значение по умолчанию `startat` расположено в левый конец `input`; Если поиск выполняется от право слева, по умолчанию `startat` расположено в правом конце `input`.  
  
 Если вы хотите ограничить соответствие, таким образом, чтобы он начинается с определенной позиции в строке и обработчик регулярных выражений не проверяет остаток строки на соответствие, закрепите регулярное выражение с `\G` (слева для слева направо шаблон, или справа для шаблона справа налево). Это ограничивает совпадение, поэтому он должен начинаться точно в `startat`.  
  
 Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Group.Success%2A> свойство. Если соответствие найдено, возвращенный <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> содержит подстроку из `input` , соответствующий шаблону регулярного выражения. Если совпадение не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку, найденную в или после `startat` позиция знака в `input` , соответствующий шаблону регулярного выражения. Можно получить последующие соответствия, повторно вызвав возвращаемый <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод. Кроме того, все совпадения в одном вызове метода можно получить, вызвав <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> метод.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, определяемое <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если вы не задает интервал времени ожидания при вызове конструктора, исключение вызывается, если любое значение времени ожидания операции превышает, установленного для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не возникает.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Ищет в указанной входной строке первое вхождение заданного регулярного выражения.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения во входной строке. Сведения об элементах языка, можно создать шаблон регулярного выражения см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Статический <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> метода эквивалентно созданию <xref:System.Text.RegularExpressions.Regex> с указанным шаблоном регулярного выражения и вызов экземпляра <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> метод. В этом случае обработчик регулярных выражений кэширует шаблон регулярного выражения.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Group.Success%2A> свойство. Если соответствие найдено, возвращенный <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> содержит подстроку из `input` , соответствующий шаблону регулярного выражения. Если совпадение не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку в `input` , соответствующий шаблону регулярного выражения. Можно получить последующие соответствия, повторно вызвав возвращаемый <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод. Кроме того, все совпадения в одном вызове метода можно получить, вызвав <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> метод.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод. Если время ожидания не определяется в свойствах домена приложения или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не возникает.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> метод, чтобы найти первое слово, содержит по крайней мере один `z` символов, а затем вызывает <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод для поиска дополнительных совпадений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 Возможные интерпретации шаблона регулярного выражения `\b\w*z+\w*\b` показаны в следующей таблице.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w*`|Соответствует ноль, один или несколько символов слова.|  
|`z+`|Сопоставление одного или нескольких вхождений `z` символов.|  
|`\w*`|Соответствует ноль, один или несколько символов слова.|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage">
          <para>Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван. Если значение времени ожидания не был определен для домена приложения, а значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Статические рекомендуется для получения соответствия шаблону <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, который позволяет установить интервал времени ожидания.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="beginning">Отсчитываемая от нуля позиция символа во входной строке, определяющая самую левую позицию диапазона поиска.</param>
        <param name="length">Количество символов в подстроке для включения в поиск.</param>
        <summary>Ищет во входной строке первое вхождение регулярного выражения, начиная с указанной начальной позиции и выполняя поиск только по указанному количеству символов.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения в части во входной строке. Сведения об элементах языка, можно создать шаблон регулярного выражения см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Шаблон регулярного выражения, для которого <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> выполняет метод определяется путем вызова одного из <xref:System.Text.RegularExpressions.Regex> конструкторы класса. Дополнительные сведения об элементах, образующих шаблон регулярного выражения см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Метод выполняет поиск часть `input` определяется `beginning` и `length` параметры шаблона регулярного выражения. `beginning` всегда определяет индекс первого символа, чтобы включить в поиск, и `length` определяет максимальное число символов для поиска. Вместе они определяют диапазон поиска. Если поиск выполняется слева направо (по умолчанию), обработчик регулярных выражений ищет из знак с индексом `beginning` знак с индексом `beginning`  +  `length` – 1. Если обработчик регулярных выражений был создан с помощью <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> , что поиск продолжается справа слева, поиск обработчика регулярных выражений в знак с индексом `beginning`  +  `length` – 1 для знак с индексом `beginning`. Этот метод возвращает первое совпадение, найденное в этот диапазон. Можно получить последующие соответствия, повторно вызвав возвращаемый <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод.  
  
 Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Group.Success%2A> свойство. Если соответствие найдено, возвращенный <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> содержит подстроку из `input` , соответствующий шаблону регулярного выражения. Если совпадение не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, определяемое <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если не задано значение времени ожидания, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не возникает.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="beginning" /> имеет значение меньше нуля или больше длины <paramref name="input" />.  -или-  Параметр <paramref name="length" /> имеет значение меньше нуля или больше длины <paramref name="input" />.  -или-  <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="–1" /> определяет позицию, которая находится вне диапазона <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>Ищет во входной строке первое вхождение заданного регулярного выражения, используя указанные параметры сопоставления.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения во входной строке. Сведения об элементах языка, можно создать шаблон регулярного выражения см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Статический <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метода эквивалентно созданию <xref:System.Text.RegularExpressions.Regex> объекта с <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> конструктор и вызов экземпляра <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> метод.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Group.Success%2A> свойство. Если соответствие найдено, возвращенный <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> содержит подстроку из `input` , соответствующий шаблону регулярного выражения. Если совпадение не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку, найденную в `input` , соответствующий шаблону регулярного выражения. Можно получить последующие соответствия, повторно вызвав возвращаемый <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Match.NextMatch%2A> метод. Кроме того, все совпадения в одном вызове метода можно получить, вызвав <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> метод.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции сопоставления превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод. Если время ожидания не определяется в свойствах домена приложения или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не возникает.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение, которое сопоставляет слова, начинающиеся с буквы «». Она использует <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> параметр, чтобы убедиться, что регулярное выражение находит слова, начинающиеся на обоих заглавных букв нижнего регистра «» и «».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 Возможные интерпретации шаблона регулярного выражения `\ba\w*\b` показаны в следующей таблице.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`a`|Соответствует символу «».|  
|`\w*`|Соответствует ноль, один или несколько символов слова.|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage">
          <para>Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван. Если значение времени ожидания не был определен для домена приложения, а значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Статические рекомендуется для получения соответствия шаблону <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, который позволяет установить интервал времени ожидания.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Ищет во входной строке первое вхождение заданного регулярного выражения, используя указанные параметры сопоставления и интервал времени ожидания.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения во входной строке. Сведения об элементах языка, можно создать шаблон регулярного выражения см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Статический <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метода эквивалентно созданию <xref:System.Text.RegularExpressions.Regex> объекта с <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> конструктор и вызов экземпляра <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> метод.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Group.Success%2A> свойство. Если соответствие найдено, возвращенный <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> содержит подстроку из `input` , соответствующий шаблону регулярного выражения. Если совпадение не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку, найденную в `input` , соответствующий шаблону регулярного выражения. Можно получить последующие соответствия, повторно вызвав возвращаемый <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Match.NextMatch%2A> метод. Кроме того, все совпадения в одном вызове метода можно получить, вызвав <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> метод.  
  
 `matchTimeout` Указывает о том, как долго шаблон соответствующий метод должен пытаться найти совпадения, до истечения времени ожидания. Установка интервала времени ожидания предотвращает регулярные выражения, зависящие от избыточный поиск с возвратом отображение перестает отвечать при обработке входных данных, содержащий ближайшие совпадения. Дополнительные сведения см. в разделе [советы и рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиск с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если совпадение не найдено в этого интервала времени, метод вызывает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в которой выполняется метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  -или-  Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage">
          <para>Мы рекомендуем задавать <paramref name="matchTimeout" /> параметр соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений, обеспечивает немного лучшую производительность. Тем не менее, следует отключить тайм-ауты только при следующих условиях: — когда входные данные, обрабатываемые регулярного выражения определяется из известного и надежного источника или состоит из статического текста. Это исключает текст, который был динамически ввода пользователями.  — Если для обеспечения эффективной обработки тщательно протестирован шаблон регулярного выражения соответствует, несовпадающие, а ближайшем.  -Если шаблон регулярного выражения содержит не языковые элементы, которые возникает избыточный поиск с возвратом при обработке почти совпадают.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ищет во входной строке все вхождения регулярного выражения и возвращает все соответствия.</summary>
        <block subset="none" type="usage">
          <para>При повторном попытки поиска совпадения, вызвав <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> , обработчик регулярных выражений дает пустые совпадения особым образом. Обычно обработчик регулярных выражений начинает поиск следующего соответствия точно предыдущего совпадения места остановки. Однако после пустого совпадения, обработчик регулярных выражений перемещает один символ перед попыткой. Это гарантирует, что обработчик регулярных выражений развивается по строке. В противном случае — поскольку пустое совпадение не приведет к любой продвижение вперед, следующее соответствие начнется в той же позиции, что и предыдущий и многократно будет соответствовать же пустая строка.  В следующем примере шаблон регулярного выражения <c>*</c> ищет ноль или более вхождений буквы «» в строке «abaabb». Как видно в результатах показано в примере, итоговый <see cref="T:System.Text.RegularExpressions.MatchCollection" /> объект содержит шесть <see cref="T:System.Text.RegularExpressions.Match" /> объектов. Первая попытка match находит первый «». Второе соответствие начинается, где первый совпадать заканчивается перед первой b; он выполняет поиск вхождений «a» и возвращает пустую строку. Третье соответствие не начинается точно там, где второе соответствие закончилось, так как второе соответствие возвратил пустую строку. Вместо этого оно начинается на один знак позже, после первой «b». Третье соответствие находит два вхождения «a» и возвращает «aa». Начинает четвертой попытки поиска совпадения, где закончилось третье, перед второй буквой «b» и возвращает пустую строку. Пятый попытки поиска совпадения снова перемещает один символ, чтобы он начинается до третьей «b» и возвращает пустую строку. Шестой поиск начинается после последнего «b» и снова возвращает пустую строку.  [! code-csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [! code-vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <summary>Ищет в указанной входной строке все вхождения регулярного выражения.</summary>
        <returns>Коллекция объектов <see cref="T:System.Text.RegularExpressions.Match" />, найденных при поиске. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> Аналогичен методу <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> за исключением того, что он возвращает сведения о всех сопоставлениях найден во входной строке, а не одного совпадения. Это эквивалентно следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 Коллекция содержит только соответствие и заканчивается на первом не соответствует.  
  
 Шаблон регулярного выражения, для которого <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> выполняет метод определяется путем вызова одного из <xref:System.Text.RegularExpressions.Regex> конструкторы класса. Дополнительные сведения об элементах, образующих шаблон регулярного выражения см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Метод использует отложенное вычисление для заполнения возвращаемый <xref:System.Text.RegularExpressions.MatchCollection> объекта. Доступ к членам этой коллекции, такие как <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> вызывает коллекции устанавливаться немедленно. Чтобы воспользоваться преимуществами отложенного вычисления, следует итерацию коллекции, с помощью конструкции, такие как `foreach` в C# и `For Each`...`Next` в Visual Basic.  
  
 Из-за его отложенное вычисление вызов <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> метод не выдает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. Однако исключение вызывается при выполнении операции <xref:System.Text.RegularExpressions.MatchCollection> объект, возвращаемый этим методом, если <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> свойство не <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> и операции сопоставления до истечения времени ожидания.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> метода, чтобы идентифицировать слов в предложении, заканчивающиеся на «es».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Соответствует строковый литерал «es».|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="startat">Позиция символа во входной строке, с которой необходимо начать поиск.</param>
        <summary>Ищет в указанной входной строке все вхождения регулярного выражения, начиная с указанной начальной позиции.</summary>
        <returns>Коллекция объектов <see cref="T:System.Text.RegularExpressions.Match" />, найденных при поиске. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> Аналогичен методу <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> за исключением того, что он возвращает сведения о всех сопоставлениях найден во входной строке, а не одного совпадения. Это эквивалентно следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 Шаблон регулярного выражения, для которого <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> выполняет метод определяется путем вызова одного из <xref:System.Text.RegularExpressions.Regex> конструкторы класса. Дополнительные сведения об элементах, образующих шаблон регулярного выражения см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Метод использует отложенное вычисление для заполнения возвращаемый <xref:System.Text.RegularExpressions.MatchCollection> объекта. Доступ к членам этой коллекции, такие как <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> вызывает коллекции устанавливаться немедленно. Чтобы воспользоваться преимуществами отложенного вычисления, следует итерацию коллекции, с помощью конструкции, такие как `foreach` в C# и `For Each`...`Next` в Visual Basic.  
  
 Из-за его отложенное вычисление вызов <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> метод не выдает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. Однако исключение вызывается при выполнении операции <xref:System.Text.RegularExpressions.MatchCollection> объект, возвращаемый этим методом, если <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> свойство не <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> и операции сопоставления до истечения времени ожидания...  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> метода для обнаружения первого слова в предложение, которое заканчивается на «es», а затем вызывает <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> метода, чтобы идентифицировать другие слова, которые заканчиваются на «es».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Соответствует строковый литерал «es».|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Ищет в указанной входной строке все вхождения заданного регулярного выражения.</summary>
        <returns>Коллекция объектов <see cref="T:System.Text.RegularExpressions.Match" />, найденных при поиске. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Аналогичен методу <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> за исключением того, что он возвращает сведения о всех сопоставлениях найден во входной строке, а не одного совпадения. Это эквивалентно следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 Статический `Matches` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> с указанным шаблоном регулярного выражения и вызова метода `Matches`.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Метод использует отложенное вычисление для заполнения возвращаемый <xref:System.Text.RegularExpressions.MatchCollection> объекта. Доступ к членам этой коллекции, такие как <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> вызывает коллекции устанавливаться немедленно. Чтобы воспользоваться преимуществами отложенного вычисления, следует итерацию коллекции, с помощью конструкции, такие как `foreach` в C# и `For Each`...`Next` в Visual Basic.  
  
 Из-за его отложенное вычисление вызов <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> метод не выдает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. Однако исключение вызывается при выполнении операции на <xref:System.Text.RegularExpressions.MatchCollection> объект, возвращаемый этим методом, если интервал времени ожидания определяется свойством «REGEX_DEFAULT_MATCH_TIMEOUT» из текущего домена приложения и операции сопоставления превысит этот интервал времени ожидания.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> метод выявления любых слов в предложение, которое заканчивается на «es».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Соответствует строковый литерал «es».|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван. Если значение времени ожидания не был определен для домена приложения, а значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Рекомендуемые статический метод для извлечения нескольких шаблон соответствует является <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, которая позволяет задать интервал ожидания.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, задающая параметры для сопоставления.</param>
        <summary>Ищет в указанной входной строке все вхождения заданного регулярного выражения, используя указанные параметры сопоставления.</summary>
        <returns>Коллекция объектов <see cref="T:System.Text.RegularExpressions.Match" />, найденных при поиске. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Аналогичен методу <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> за исключением того, что он возвращает сведения о всех сопоставлениях найден во входной строке, а не одного совпадения. Это эквивалентно следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 Статический `Matches` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> с указанным шаблоном регулярного выражения и вызова метода `Matches`.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Метод использует отложенное вычисление для заполнения возвращаемый <xref:System.Text.RegularExpressions.MatchCollection> объекта. Доступ к членам этой коллекции, такие как <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> вызывает коллекции устанавливаться немедленно. Чтобы воспользоваться преимуществами отложенного вычисления, следует итерацию коллекции, с помощью конструкции, такие как `foreach` в C# и `For Each`...`Next` в Visual Basic.  
  
 Из-за его отложенное вычисление вызов <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> метод не выдает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. Однако исключение вызывается при выполнении операции на <xref:System.Text.RegularExpressions.MatchCollection> объект, возвращаемый этим методом, если интервал времени ожидания определяется свойством «REGEX_DEFAULT_MATCH_TIMEOUT» из текущего домена приложения и операции сопоставления превысит этот интервал времени ожидания.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> метод выявления любых слов в предложение, которое заканчивается на «es», а затем вызывает <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метод, чтобы выполнить сравнение без учета регистра шаблона со входной строкой. Как показывают выходные данные, эти два метода возвращать разные результаты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Соответствует строковый литерал «es».|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван. Если значение времени ожидания не был определен для домена приложения, а значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Рекомендуемые статический метод для извлечения нескольких шаблон соответствует является <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, задающая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Ищет в указанной входной строке все вхождения заданного регулярного выражения, используя указанные параметры сопоставления и интервал времени ожидания.</summary>
        <returns>Коллекция объектов <see cref="T:System.Text.RegularExpressions.Match" />, найденных при поиске. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Аналогичен методу <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> за исключением того, что он возвращает сведения о всех сопоставлениях найден во входной строке, а не одного совпадения. Это эквивалентно следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 Статический `Matches` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> с указанным шаблоном регулярного выражения и вызова метода `Matches`.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Метод использует отложенное вычисление для заполнения возвращаемый <xref:System.Text.RegularExpressions.MatchCollection> объекта. Доступ к членам этой коллекции, такие как <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> вызывает коллекции устанавливаться немедленно. Чтобы воспользоваться преимуществами отложенного вычисления, следует итерацию коллекции, с помощью конструкции, такие как `foreach` в C# и `For Each`...`Next` в Visual Basic.  
  
 Из-за его отложенное вычисление вызов <xref:System.Text.RegularExpressions.Regex.Matches%2A> метод не выдает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. Однако исключение при выполнении операции <xref:System.Text.RegularExpressions.MatchCollection> объект, возвращаемый этим методом, если операции сопоставления превысит этот интервал времени ожидания, заданные`matchTimeout` параметра.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод, чтобы выполнить сравнение с учетом регистра, которая соответствует любому слову предложения, который заканчивается на «es». Затем он вызывает <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод, чтобы выполнить сравнение без учета регистра шаблона со входной строкой. В обоих случаях время ожидания равно одной секунде. Как показывают выходные данные, эти два метода возвращать разные результаты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Соответствует строковый литерал «es».|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  -или-  Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <block subset="none" type="usage">
          <para>Мы рекомендуем задавать <paramref name="matchTimeout" /> параметр соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений, обеспечивает немного лучшую производительность. Тем не менее, следует отключить тайм-ауты только при следующих условиях: — когда входные данные, обрабатываемые регулярного выражения определяется из известного и надежного источника или состоит из статического текста. Это исключает текст, который был динамически ввода пользователями.  — Если для обеспечения эффективной обработки тщательно протестирован шаблон регулярного выражения соответствует, несовпадающие, а ближайшем.  -Если шаблон регулярного выражения содержит не языковые элементы, которые возникает избыточный поиск с возвратом при обработке почти совпадают.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает интервал времени ожидания текущего экземпляра.</summary>
        <value>Максимальный интервал времени, который может пройти в операции сравнения с шаблоном, прежде чем возникнет исключение <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" />, или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, если контроль времени ожидания отключен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> Свойство определяет приблизительное максимальный интервал времени для <xref:System.Text.RegularExpressions.Regex> экземпляра для выполнения одной операции сопоставления до истечения времени ожидания операции. Обработчик регулярных выражений создает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение во время его следующей проверки времени, после истечения интервала времени ожидания. Это предотвращает обработки входных строк, которые требуют избыточный поиск с возвратом обработчик регулярных выражений. Дополнительные сведения см. в разделе [поиск с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md) и [советы и рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md).  
  
 Это свойство доступно только для чтения. Его значение можно задать явным образом для отдельного <xref:System.Text.RegularExpressions.Regex> путем вызова метода <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктора; и вы можете задать его значение для всех <xref:System.Text.RegularExpressions.Regex> сопоставления операций в домене приложения с помощью вызова <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> метод и предоставляя <xref:System.TimeSpan> значение для свойства «REGEX_DEFAULT_MATCH_TIMEOUT», как показано в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 Если вы не задает явно интервал времени ожидания, значение по умолчанию <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> используется и сопоставления операции имеют неограниченное время ожидания.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает параметр, которые были переданы в конструктор <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <value>Один или несколько членов перечисления <see cref="T:System.Text.RegularExpressions.RegexOptions" />, представляющих параметры, переданные в конструктор <see cref="T:System.Text.RegularExpressions.Regex" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение <xref:System.Text.RegularExpressions.Regex.Options%2A> свойство состоит из одного или нескольких членов <xref:System.Text.RegularExpressions.RegexOptions> перечисления. Если параметры не были определены в <xref:System.Text.RegularExpressions.Regex> конструктора класса, его значением является <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>. Доступные параметры подробно обсуждаются в [параметры регулярных выражений](~/docs/standard/base-types/regular-expression-options.md) раздела.  
  
 Обратите внимание, что <xref:System.Text.RegularExpressions.Regex.Options%2A> свойство не отражает встроенные параметры, определенные в регулярном выражении шаблона сам.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> является базовым классом регулярных выражений, созданные <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> метод. Эти скомпилированные регулярные выражения использовать реализацию базового класса <see cref="P:System.Text.RegularExpressions.Regex.Options" /> свойство. При вызове из производного класса, <see cref="P:System.Text.RegularExpressions.Regex.Options" /> свойство возвращает параметры, которые были переданы <paramref name="options" /> параметр <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> конструктора класса, который использовался для определения регулярного выражения.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>В указанной входной строке заменяет строки, соответствующие шаблону регулярного выражения, указанной строкой замены.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="replacement">Строка замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие шаблону регулярного выражения, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск соответствий начинается в начале `input` строки. Регулярное выражение — это шаблон, определенный конструктором для текущего <xref:System.Text.RegularExpressions.Regex> объекта.  
  
 `replacement` Указывает строку, которая является для замены каждого соответствия во `input`. `replacement` может содержать любое сочетание текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку «*» следуют подстроку, сопоставленную с `test` захватываемой группой, в том случае, если таковые имеются, за которым следует строка «b». * Символ не воспринимается как метасимвол в шаблонах замены.  
  
> [!NOTE]
>  Подстановки – это языковые элементы только регулярных выражений, которые распознаются в шаблонах замены. Все другие регулярных выражений элементов языка, включая [escape-последовательности символов](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются в только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции замены превышает интервал времени ожидания, определяемое <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку этот метод возвращает `input` без изменений, если нет соответствия, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод внесены замены входной строкой.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение, `\s+`, который соответствует один или несколько символов пробела. Строка замены "», заменяется одним пробелом.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 В следующем примере определяется регулярное выражение, `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`и шаблон замены `$2`, который удаляет начальный или конечный символ валюты из числового значения.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 Возможные интерпретации регулярного выражения показаны в следующей таблице.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`\p{Sc}`|Совпадает с символом валюты. `{Sc}` Обозначает любой символ, который является членом Юникода категории символов и валют.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`(\p{Sc}\s?)?`|Совпадение с нулем или одним вхождением сочетание обозначение денежной единицы, за которым следует ноль или один символ пробела. Это первая группа записи.|  
|`\d+`|Совпадение с одной или несколькими десятичными цифрами.|  
|`\.?`|Совпадение с нулем или одним вхождением точки (используется как символ десятичного разделителя).|  
|`((?<=\.)\d+)?`|Если точку предыдущего символа, соответствует один или несколько десятичных цифр. Этот шаблон может быть установлен как ноль или один раз.|  
|`(\d+\.?((?<=\.)\d+)?)`|Совпадение с шаблоном один или несколько десятичных цифр, за которым следует необязательная точка и десятичными цифрами. Это вторая группа записи. Вызов <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> метод заменяет все совпадения со значением данной группой записи.|  
|`(?(1)&#124;\s?\p{Sc})?`|Если существует первой захватываемой группы, соответствует пустая строка. В противном случае соответствует ноль или один символ пробела, за которым следует символ валюты.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="replacement" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Метод может использоваться для замены совпадения регулярного выражения, если выполняется хотя бы одно из следующих условий:  
  
-   Строка замены нельзя легко указать замены шаблоном регулярного выражения.  
  
-   Строка замены получается из некоторой обработки, выполненной на совпадающую строку.  
  
-   Строка замены получается из условной обработки.  
  
 Метод эквивалентен вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> метода и передачи каждого <xref:System.Text.RegularExpressions.Match> объекта в возвращаемом <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегата.  
  
 Регулярное выражение — это шаблон, определенный конструктором для текущего <xref:System.Text.RegularExpressions.Regex> объекта.  
  
 `evaluator` Параметр является делегатом для пользовательского метода, который определяется пользователем и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления <xref:System.Text.RegularExpressions.MatchEvaluator> делегата.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет совпадающую входные данные.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции замены превышает интервал времени ожидания, определяемое <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку этот метод возвращает `input` без изменений, если нет соответствия, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод внесены замены входной строкой.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется исходная строка, сопоставляет каждое слово в исходной строке, преобразует первый символ каждого соответствия преобразуется в верхний регистр, а затем отображает преобразованную строку.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="evaluator" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="replacement">Строка замены.</param>
        <param name="count">Максимальное количество возможных случаев замены.</param>
        <summary>В указанной входной строке заменяет указанное максимальное количество строк, соответствующих шаблону регулярного выражения, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск соответствий начинается в начале `input` строки. Регулярное выражение — это шаблон, который определен с помощью конструктора для текущего <xref:System.Text.RegularExpressions.Regex> объекта. Если `count` является отрицательным, замена продолжается до конца строки. Если `count` превышает количество совпадений, все совпадения заменяются.  
  
 `replacement` Указывает строку, которая является для замены первый `count` совпадения в `input`. `replacement` может содержать любое сочетание текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку «*» следуют подстроку, сопоставленную с `test` захватываемой группой, в том случае, если таковые имеются, за которым следует строка «b». * Символ не воспринимается как метасимвол в шаблонах замены.  
  
> [!NOTE]
>  Подстановки – это языковые элементы только регулярных выражений, которые распознаются в шаблонах замены. Все другие регулярных выражений элементов языка, включая [escape-последовательности символов](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются в только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции замены превышает интервал времени ожидания, определяемое <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку этот метод возвращает `input` без изменений, если нет соответствия, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод внесены замены входной строкой.  
  
   
  
## Examples  
 В следующем примере заменяется первые пять вхождений повторяющихся символов в виде одного символа. Шаблон регулярного выражения `(\w)\1` сопоставляет последовательные вхождения одного символа и присваивает его первого вхождения первая группа записи. Шаблон замены `$1` заменяет все совпадения первой группой записи.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="replacement" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="replacement">Строка замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статический `Replace` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> с указанным шаблоном регулярного выражения и вызова метода `Replace`.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Поиск соответствий начинается в начале `input` строки.  
  
 `replacement` Указывает строку, которая является для замены каждого соответствия во `input`. `replacement` может содержать любое сочетание текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку «*» следуют подстроку, сопоставленную с `test` захватываемой группой, в том случае, если таковые имеются, за которым следует строка «b». * Символ не воспринимается как метасимвол в шаблонах замены.  
  
> [!NOTE]
>  Подстановки – это языковые элементы только регулярных выражений, которые распознаются в шаблонах замены. Все другие регулярных выражений элементов языка, включая [escape-последовательности символов](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются в только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции замены превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод. Если время ожидания не определяется в свойствах домена приложения или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не возникает.  
  
 Поскольку этот метод возвращает `input` без изменений, если нет соответствия, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод внесены замены входной строкой.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение, `\s+`, который соответствует один или несколько символов пробела. Строка замены "», заменяется одним пробелом.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 В следующем примере используется <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> метод для замены локальные имена компьютера и диск в формате UNC путь к локальному файлу. В регулярном выражении используется <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство имя локального компьютера и <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> метод, чтобы включить имена логических дисков. Для успешного выполнения в примере строковый литерал «MyMachine» следует заменить имя локального компьютера.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 Шаблон регулярного выражения определяется следующее выражение:  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`\\\\`|Соответствует двум обратной косой черты подряд (`\`) символов. Так как символ обратной косой черты интерпретируется как escape-символ, косую черту необходимо экранировать с дополнительную обратную косую черту.|  
|`(?i:" + Environment.MachineName + ")`|Выполнение сравнения без учета регистра строки, который возвращается методом <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство.|  
|`(?:\.\w+)*`|Совпадение точкой (`.`) за которым одной или несколькими символами слова. Это совпадение может произойти ноль или более раз. Сопоставленная часть выражения не выделяется.|  
|`\\`|Соответствует обратной косой черты (`\`) символов.|  
|`((?i:[" + driveNames + "]))`|Выполнение сравнения без учета регистра класса символов, который состоит из отдельно взятых. Это сопоставление выполняется первое полученное вложенное выражение.|  
|`\$`|Соответствует знак доллара (`$`) символов.|  
  
 Шаблон замены `$1` заменяет все совпадения с первое полученное вложенное выражение. То есть он заменяет UNC-имя компьютера и диск с буквой диска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="replacement" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage">
          <para>Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван. Если значение времени ожидания не был определен для домена приложения, а значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Рекомендуемые статический метод для замены сопоставления шаблона является <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Метод может использоваться для замены совпадения регулярного выражения, если выполняется хотя бы одно из следующих условий:  
  
-   Строка замены нельзя легко указать замены шаблоном регулярного выражения.  
  
-   Строка замены получается из некоторой обработки, выполненной на совпадающую строку.  
  
-   Строка замены получается из условной обработки.  
  
 Метод эквивалентен вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> метода и передачи каждого <xref:System.Text.RegularExpressions.Match> объекта в возвращаемом <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегата.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Параметр является делегатом для пользовательского метода, который определяется пользователем и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления <xref:System.Text.RegularExpressions.MatchEvaluator> делегата.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет совпадающую входные данные.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции замены превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод. Если время ожидания не определяется в свойствах домена приложения или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не возникает.  
  
 Поскольку этот метод возвращает `input` без изменений, если нет соответствия, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод внесены замены входной строкой.  
  
   
  
## Examples  
 Следующий пример использует регулярное выражение для извлечения отдельные слова из строки, а затем использует <xref:System.Text.RegularExpressions.MatchEvaluator> делегат, вызываемый метод с именем `WordScramble` , шифруется отдельных букв в слове. Чтобы сделать это, `WordScramble` метод создает массив, содержащий символы в соответствие. Он также создает параллельный массив, который он заполняет случайными числами с плавающей запятой. Массивы сортируются путем вызова <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> метод и упорядоченный массив предоставляется как аргумент для <xref:System.String> конструктора класса. Эта созданная строка возвращается `WordScramble` метод. Шаблон регулярного выражения `\w+` соответствует одной или несколькими символами слова; обработчик регулярных выражений будет продолжать добавлять символы для сопоставления, пока встретится несловообразующий символ, например символ пробела.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="evaluator" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage">
          <para>Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван. Если значение времени ожидания не был определен для домена приложения, а значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Статические рекомендуется для оценки и замена соответствия шаблону <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="count">Максимальное количество возможных случаев замены.</param>
        <summary>В указанной входной строке заменяется указанное максимальное количество строк, соответствующих шаблону регулярного выражения, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> Метод может использоваться для замены совпадения регулярного выражения, если выполняется хотя бы одно из следующих условий:  
  
-   Строка замены нельзя легко указать замены шаблоном регулярного выражения.  
  
-   Строка замены получается из некоторой обработки, выполненной на совпадающую строку.  
  
-   Строка замены получается из условной обработки.  
  
 Метод эквивалентен вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> метода и передачи первый `count` <xref:System.Text.RegularExpressions.Match> объектов в возвращаемом <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегата.  
  
 Регулярное выражение — это шаблон, определенный конструктором для текущего <xref:System.Text.RegularExpressions.Regex> объекта.  
  
 `evaluator` Параметр является делегатом для пользовательского метода, который определяется пользователем и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления <xref:System.Text.RegularExpressions.MatchEvaluator> делегата.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет совпадающую входные данные.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции замены превышает интервал времени ожидания, определяемое <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку этот метод возвращает `input` без изменений, если нет соответствия, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод внесены замены входной строкой.  
  
   
  
## Examples  
 В следующем примере регулярное выражение намеренно опечатка половины слов в списке. Она использует регулярное выражение `\w*(ie|ei)\w*` для сопоставления слов, содержащих символы «ie» или «ei». Передает Первая половина совпадающих слов `ReverseLetter` метод, который в свою очередь, использует <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метода для отмены «i» и «e» в совпадающую строку. Остальные слова остаются без изменений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 Определение регулярного выражения `\w*(ie|ei)\w*` показано в таблице ниже.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`\w*`|Совпадение с нулем или большим числом буквенных символов.|  
|`(ie&#124;ei)`|Соответствует «ie» или «ei».|  
|`\w*`|Совпадение с нулем или большим числом буквенных символов.|  
  
 Шаблон регулярного выражения `([ie])([ie])` в `ReverseLetter` метод соответствует первой «i» или «e» в diphthong «ie» или «ei» и назначается буква первая группа записи. Он соответствует второй «i» или «e» и назначает букву вторая группа записи. Затем два знака отменяются путем вызова <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> метод с шаблон замены `$2$1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="evaluator" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="replacement">Строка замены.</param>
        <param name="count">Максимальное возможное количество случаев замены.</param>
        <param name="startat">Позиция символа во входной строке, с которой начинается поиск.</param>
        <summary>В указанной входной подстроке заменяет указанное максимальное количество строк, соответствующих шаблону регулярного выражения, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск соответствий начинается `input` строка в позиции, указанной параметром `startat` параметр. Регулярное выражение — это шаблон, определенный конструктором для текущего <xref:System.Text.RegularExpressions.Regex> объекта. Если `count` является отрицательным, замена продолжается до конца строки. Если `count` превышает количество совпадений, все совпадения заменяются.  
  
 `replacement` Указывает строку, которая является для замены каждого соответствия во `input`. `replacement` может содержать любое сочетание текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку «*» следуют подстроку, сопоставленную с `test` захватываемой группой, в том случае, если таковые имеются, за которым следует строка «b». * Символ не воспринимается как метасимвол в шаблонах замены.  
  
> [!NOTE]
>  Подстановки – это языковые элементы только регулярных выражений, которые распознаются в шаблонах замены. Все другие регулярных выражений элементов языка, включая [escape-последовательности символов](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются в только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции замены превышает интервал времени ожидания, определяемое <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку этот метод возвращает `input` без изменений, если нет соответствия, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод внесены замены входной строкой.  
  
   
  
## Examples  
 Следующий пример двойные пробелы содержатся все, кроме первой строки в строке. Он определяет шаблон регулярного выражения, `^.*$`, выделяющий строки текста, вызовы <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> метода в соответствии с первой строки, строки и использует `Match.Index` и `Match.Count` свойства, чтобы определить начальную позицию второго Строка.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 Шаблон регулярного выражения `^.*$` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`^`|Поиск начала строки. (Обратите внимание, что <xref:System.Text.RegularExpressions.Regex> объект был создан с помощью <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> параметр; в противном случае этот класс символов будет соответствовать только начало строки ввода.)|  
|`.*`|Совпадение с любым символом ноль или более раз.|  
|`$`|Соответствует концу строки. (Обратите внимание, что <xref:System.Text.RegularExpressions.Regex> объект был создан с помощью <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> параметр; в противном случае этот класс символов будет соответствовать только начало строки ввода.)|  
  
 Строка замены (`vbCrLf + "$&"` в Visual Basic, `"\n$&"` в C#) добавляет новую строку перед совпадающую строку. Обратите внимание, что `\n` в C# пример интерпретируется как символ перевода строки для компилятора C#; он не представляет escape-символ регулярного выражения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="replacement" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="replacement">Строка замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, указанной строкой замены. Указанные параметры изменяют операцию сопоставления.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статический `Replace` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> с указанным шаблоном регулярного выражения и вызова метода `Replace`.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). При указании <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> для `options` параметра, поиск соответствий начинается в конце входной строки и перемещается влево ";" в противном случае поиск начинается в начале входной строки и сдвиг вправо.  
  
 `replacement` Указывает строку, которая является для замены каждого соответствия во `input`. `replacement` может содержать любое сочетание текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку «*» следуют подстроку, сопоставленную с `test` захватываемой группой, в том случае, если таковые имеются, за которым следует строка «b». * Символ не воспринимается как метасимвол в шаблонах замены.  
  
> [!NOTE]
>  Подстановки – это языковые элементы только регулярных выражений, которые распознаются в шаблонах замены. Все другие регулярных выражений элементов языка, включая [escape-последовательности символов](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются в только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции замены превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод. Если время ожидания не определяется в свойствах домена приложения или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не возникает.  
  
 Поскольку этот метод возвращает `input` без изменений, если нет соответствия, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод внесены замены входной строкой.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метод для замены локальные имена компьютера и диск в формате UNC путь к локальному файлу. В регулярном выражении используется <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство имя локального компьютера и <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> метод, чтобы включить имена логических дисков. Все Регулярное выражение сравнения строк без учета регистра. Для успешного выполнения в примере строковый литерал «MyMachine» следует заменить имя локального компьютера.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 Шаблон регулярного выражения определяется следующее выражение:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`\\\\`|Соответствует двум обратной косой черты подряд (`\`) символов. Так как символ обратной косой черты интерпретируется как escape-символ, косую черту необходимо экранировать с дополнительную обратную косую черту.|  
|`+ Environment.MachineName +`|Совпадает со строкой, которая возвращается <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство.|  
|`(?:\.\w+)*`|Совпадение точкой (`.`) за которым одной или несколькими символами слова. Это совпадение может произойти ноль или более раз. Сопоставленная часть выражения не выделяется.|  
|`\\`|Соответствует обратной косой черты (`\`) символов.|  
|`([" + driveNames + "])`|Соответствует класс символов, состоящий из отдельных букв диска. Это сопоставление выполняется первое полученное вложенное выражение.|  
|`\$`|Соответствует знак доллара (`$`) символов.|  
  
 Шаблон замены `$1` заменяет все совпадения с первое полученное вложенное выражение. То есть он заменяет UNC-имя компьютера и диск с буквой диска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="replacement" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage">
          <para>Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором он вызван. Если значение времени ожидания не был определен для домена приложения, а значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Рекомендуемые статический метод для замены сопоставления шаблона является <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Указанные параметры изменяют операцию сопоставления.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Метод может использоваться для замены соответствует регулярному выражению в, если выполняется хотя бы одно из следующих условий:  
  
-   Строка замены нельзя легко указать замены шаблоном регулярного выражения.  
  
-   Строка замены получается из некоторой обработки, выполненной на совпадающую строку.  
  
-   Строка замены получается из условной обработки.  
  
 Метод эквивалентен вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> метода и передачи каждого <xref:System.Text.RegularExpressions.Match> объекта в возвращаемом <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегата.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Параметр является делегатом для пользовательского метода, который определяется пользователем и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления <xref:System.Text.RegularExpressions.MatchEvaluator> делегата.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет совпадающую входные данные.  
  
 При указании <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> для `options` параметра, поиск соответствий начинается в конце входной строки и перемещается влево ";" в противном случае поиск начинается в начале входной строки и сдвиг вправо.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции замены превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод. Если время ожидания не определяется в свойствах домена приложения или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не возникает.  
  
 Поскольку этот метод возвращает `input` без изменений, если нет соответствия, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод внесены замены входной строкой.  
  
   
  
## Examples  
 Следующий пример использует регулярное выражение для извлечения отдельные слова из строки, а затем использует <xref:System.Text.RegularExpressions.MatchEvaluator> делегат, вызываемый метод с именем `WordScramble` , шифруется отдельных букв в слове. Чтобы сделать это, `WordScramble` метод создает массив, содержащий символы в соответствие. Он также создает параллельный массив, который он заполняет случайными числами с плавающей запятой. Массивы сортируются путем вызова <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> метод и упорядоченный массив предоставляется как аргумент для <xref:System.String> конструктора класса. Эта созданная строка возвращается `WordScramble` метод. Шаблон регулярного выражения `\w+` соответствует одной или несколькими символами слова; обработчик регулярных выражений будет продолжать добавлять символы для сопоставления, пока встретится несловообразующий символ, например символ пробела. Вызов <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> метод включает <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> параметр, чтобы комментарий в шаблоне регулярного выражения `\w+  # Matches all the characters in a word.` обрабатывается обработчиком регулярных выражений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="evaluator" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="count">Максимальное количество возможных случаев замены.</param>
        <param name="startat">Позиция символа во входной строке, с которой начинается поиск.</param>
        <summary>В указанной входной подстроке заменяется указанное максимальное количество строк, соответствующих шаблону регулярного выражения, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Метод может использоваться для замены совпадения регулярного выражения, если выполняется хотя бы одно из следующих условий:  
  
-   Строка замены нельзя легко указать замены шаблоном регулярного выражения.  
  
-   Строка замены получается из некоторой обработки, выполненной на совпадающую строку.  
  
-   Строка замены получается из условной обработки.  
  
 Метод эквивалентен вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> метода и передачи первый `count` <xref:System.Text.RegularExpressions.Match> объектов в возвращаемом <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегата.  
  
 Регулярное выражение — это шаблон, определенный конструктором для текущего <xref:System.Text.RegularExpressions.Regex> объекта.  
  
 `evaluator` Параметр является делегатом для пользовательского метода, который определяется пользователем и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления <xref:System.Text.RegularExpressions.MatchEvaluator> делегата.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет совпадающую входные данные.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции замены превышает интервал времени ожидания, определяемое <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку этот метод возвращает `input` без изменений, если нет соответствия, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод внесены замены входной строкой.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="evaluator" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="replacement">Строка замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, указанной строкой замены. Дополнительные параметры определяют параметры, которые изменяют соответствующую операцию и интервал времени ожидания, если совпадение не найдено.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статический `Replace` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> с указанным шаблоном регулярного выражения и вызова метода `Replace`.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). При указании <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> для `options` параметра, поиск соответствий начинается в конце входной строки и перемещается влево ";" в противном случае поиск начинается в начале входной строки и сдвиг вправо.  
  
 `replacement` Указывает строку, которая является для замены каждого соответствия во `input`. `replacement` может содержать любое сочетание текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку «*» следуют подстроку, сопоставленную с `test` захватываемой группой, в том случае, если таковые имеются, за которым следует строка «b». * Символ не воспринимается как метасимвол в шаблонах замены.  
  
> [!NOTE]
>  Подстановки – это языковые элементы только регулярных выражений, которые распознаются в шаблонах замены. Все другие регулярных выражений элементов языка, включая [escape-последовательности символов](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются в только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 `matchTimeout` Указывает о том, как долго шаблон соответствующий метод должен пытаться найти совпадения, до истечения времени ожидания. Установка интервала времени ожидания предотвращает регулярные выражения, зависящие от избыточный поиск с возвратом отображение перестает отвечать при обработке входных данных, содержащий ближайшие совпадения. Дополнительные сведения см. в разделе [советы и рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиск с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если совпадение не найдено в этого интервала времени, метод вызывает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в которой выполняется метод.  
  
 Поскольку этот метод возвращает `input` без изменений, если нет соответствия, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод внесены замены входной строкой.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод для замены локальные имена компьютера и диск в формате UNC путь к локальному файлу. В регулярном выражении используется <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство имя локального компьютера и <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> метод, чтобы включить имена логических дисков. Все Регулярное выражение сравнения строк без учета регистра, и любые операции замены одного времени ожидания, если совпадение не найдено в 0,5 секунды. Для успешного выполнения в примере строковый литерал «MyMachine» следует заменить имя локального компьютера.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 Шаблон регулярного выражения определяется следующее выражение:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание:|  
|-------------|-----------------|  
|`\\\\`|Соответствует двум обратной косой черты подряд (`\`) символов. Так как символ обратной косой черты интерпретируется как escape-символ, косую черту необходимо экранировать с дополнительную обратную косую черту.|  
|`+ Environment.MachineName +`|Совпадает со строкой, которая возвращается <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство.|  
|`(?:\.\w+)*`|Совпадение точкой (`.`) за которым одной или несколькими символами слова. Это совпадение может произойти ноль или более раз. Сопоставленная часть выражения не выделяется.|  
|`\\`|Соответствует обратной косой черты (`\`) символов.|  
|`([" + driveNames + "])`|Соответствует класс символов, состоящий из отдельных букв диска. Это сопоставление выполняется первое полученное вложенное выражение.|  
|`\$`|Соответствует знак доллара (`$`) символов.|  
  
 Шаблон замены `$1` заменяет все совпадения с первое полученное вложенное выражение. То есть он заменяет UNC-имя компьютера и диск с буквой диска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="replacement" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  -или-  Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage">
          <para>Мы рекомендуем задавать <paramref name="matchTimeout" /> параметр соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений, обеспечивает немного лучшую производительность. Тем не менее, следует отключить тайм-ауты только при следующих условиях: — когда входные данные, обрабатываемые регулярного выражения определяется из известного и надежного источника или состоит из статического текста. Это исключает текст, который был динамически ввода пользователями.  — Если для обеспечения эффективной обработки тщательно протестирован шаблон регулярного выражения соответствует, несовпадающие, а ближайшем.  -Если шаблон регулярного выражения содержит не языковые элементы, которые возникает избыточный поиск с возвратом при обработке почти совпадают.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющих параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>В указанной входной строке заменяет все подстроки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Дополнительные параметры определяют параметры, которые изменяют соответствующую операцию и интервал времени ожидания, если совпадение не найдено.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Метод может использоваться для замены совпадения регулярного выражения, если выполняется хотя бы одно из следующих условий:  
  
-   Если строка замены нельзя легко указать замены шаблоном регулярного выражения.  
  
-   Если строка замены получается из некоторой обработки выполняется над совпадающую строку.  
  
-   Если строка замены получается из условной обработки.  
  
 Метод эквивалентен вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> метода и передачи каждого <xref:System.Text.RegularExpressions.Match> объекта в возвращаемом <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегата.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Параметр является делегатом для пользовательского метода, который определяется пользователем и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления <xref:System.Text.RegularExpressions.MatchEvaluator> делегата.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет совпадающую входные данные.  
  
 При указании <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> для `options` параметра, поиск соответствий начинается в конце входной строки и перемещается влево ";" в противном случае поиск начинается в начале входной строки и сдвиг вправо.  
  
 `matchTimeout` Указывает о том, как долго шаблон соответствующий метод должен пытаться найти совпадения, до истечения времени ожидания. Установка интервала времени ожидания предотвращает регулярные выражения, зависящие от избыточный поиск с возвратом из кажется» перестает отвечать при обработке ввода, содержащий ближайшие совпадения. Дополнительные сведения см. в разделе [советы и рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиск с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если совпадение не найдено в этого интервала времени, метод вызывает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в которой выполняется метод.  
  
 Поскольку этот метод возвращает `input` без изменений, если нет соответствия, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод внесены замены входной строкой.  
  
   
  
## Examples  
 Следующий пример использует регулярное выражение для извлечения отдельные слова из строки, а затем использует <xref:System.Text.RegularExpressions.MatchEvaluator> делегат, вызываемый метод с именем `WordScramble` , шифруется отдельных букв в слове. Чтобы сделать это, `WordScramble` метод создает массив, содержащий символы в соответствие. Он также создает параллельный массив, который он заполняет случайными числами с плавающей запятой. Массивы сортируются путем вызова <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> метод и упорядоченный массив предоставляется как аргумент для <xref:System.String> конструктора класса. Эта созданная строка возвращается `WordScramble` метод. Шаблон регулярного выражения `\w+` соответствует одной или несколькими символами слова; обработчик регулярных выражений будет продолжать добавлять символы для сопоставления, пока встретится несловообразующий символ, например символ пробела. Вызов <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> метод включает <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> параметр, чтобы комментарий в шаблоне регулярного выражения `\w+  # Matches all the characters in a word.` обрабатывается обработчиком регулярных выражений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="evaluator" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  -или-  Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage">
          <para>Мы рекомендуем задавать <paramref name="matchTimeout" /> параметр соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений, обеспечивает немного лучшую производительность. Тем не менее, следует отключить тайм-ауты только при следующих условиях: — когда входные данные, обрабатываемые регулярного выражения определяется из известного и надежного источника или состоит из статического текста. Это исключает текст, который был динамически ввода пользователями.  — Если для обеспечения эффективной обработки тщательно протестирован шаблон регулярного выражения соответствует, несовпадающие, а ближайшем.  -Если шаблон регулярного выражения содержит не языковые элементы, которые возникает избыточный поиск с возвратом при обработке почти совпадают.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее на то, выполняется ли регулярным выражением поиск справа налево.</summary>
        <value>Значение <see langword="true" />, если регулярное выражение выполняет поиск справа налево; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> — `true` Если <xref:System.Text.RegularExpressions.Regex> создавался экземпляр <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> параметр.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных соответствием регулярного выражения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных шаблоном регулярного выражения, указанным в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Методы аналогичны <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> метода, за исключением того, что <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разделяет строку по разделителям регулярным выражением, вместо набора символов. Строка разделяется столько раз, сколько возможно. Если разделитель не найден, возвращаемое значение содержит один элемент, значение которого является исходной входной строкой.  
  
 Если несколько соответствий являются смежными, пустая строка вставляется в массив. Например разделение строки одиночным дефисом вызывает возвращаемый массив для включения пустую строку в позицию, где находятся два смежных дефиса, как показано в следующем коде.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 При обнаружении совпадения в начале или в конце входной строки, пустая строка входит в начале или конце возвращаемый массив. В следующем примере шаблон регулярного выражения `\d+` для разбиения входной строки на цифровые символы. Так как строка начинается и заканчивается сопоставления числовых символов, оно первый и последний элемент возвращаемого массива <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 Если используются скобки записи в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражения, любой записанный текст включается в результирующий строковый массив. Например если разделить строку «plum Груши» дефисами находиться внутри круглых скобок, возвращаемый массив включает элемент строки, содержащий дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 Тем не менее если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии платформы .NET Framework. В .NET Framework 1.0 и 1.1 Если соответствие не найдено в первый набор круглых скобок, записанный текст из дополнительных скобок записи не включается в возвращаемый массив. Начиная с .NET Framework 2.0, весь записанный текст также добавляется в возвращаемый массив. Например следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи записывает дефис, а второй набор записывает косую черту. Если код примера скомпилирован и запущен под управлением платформы .NET Framework версии 1.0 или 1.1, в нем исключаются символы косых черт. Если он компилируется и выполняется в .NET Framework 2.0 или более поздней версии, то они включаются.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 Если регулярное выражение может совпасть с пустой строкой, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> разобьет строку на массив строк для одного символа, потому что разделитель пустой строки можно найти в любом месте. Пример:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 Обратите внимание, что возвращаемый массив также включает пустую строку в начале и в конец массива.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции split превышает интервал времени ожидания, определяемое <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="count">Максимальное количество возможных случаев разделения.</param>
        <summary>Разделяет входную строку указанное максимальное количество раз в массив подстрок в позициях, определенных регулярным выражением, указанным в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Методы аналогичны <xref:System.String.Split%2A?displayProperty=nameWithType> метода, за исключением того, что <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разделяет строку по разделителям регулярным выражением, вместо набора символов. `count` Указывает максимальное количество подстрок, в который `input` можно разделить строку; последняя строка содержит неразделенный остаток строки. Объект `count` нулевое значение обеспечивает стандартное поведение разбивки столько раз, сколько возможно.  
  
 Если несколько соответствий, располагаются рядом друг с другом или если найдено совпадение в начале или конце `input`, и количество найденных совпадений по крайней мере два меньше, чем `count`, пустая строка вставляется в массив. То есть пустые строки, которые произойти из смежных соответствий или совпадений в начале или в конце входной строки учитываются при определении ли число соответствующих подстрок равно `count`. В следующем примере регулярное выражение `/d+` используется для разбиения входной строки, содержащей один или несколько десятичных цифр, в максимум три подстроки. Так как в начале входной строки соответствует шаблону регулярного выражения, первый элемент массива содержит <xref:System.String.Empty?displayProperty=nameWithType>, второй содержит первый набор буквенные символы во входной строке, а третий содержит остаток строки который следует за Третье соответствие.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 Если в регулярном выражении используются скобки записи, любой записанный текст включается в массив разделенных строк. Тем не менее, все элементы массива, содержащие записанный текст, не учитываются при определении ли достигнуто число совпадений `count`. Например разделение строки «apple яблоко слива Груши банана» на максимально возможные четыре подстроки, дает в 7 элементный массив, как следующий код показывает.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 Тем не менее если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии платформы .NET Framework. В .NET Framework 1.0 и 1.1 только записанный текст из первого набора скобок записи включен в возвращаемый массив. Начиная с .NET Framework 2.0, весь записанный текст добавляется в возвращаемый массив. Тем не менее, элементы в возвращенном массиве, содержащие записанный текст, не учитываются при определении ли число соответствующих подстрок равно `count`. Например в следующем коде регулярное выражение использует два набора скобок записи для извлечения элементов даты из строки даты. Первый набор скобок записи записывает дефис, а второй набор записывает косую черту. Вызов <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> метод затем указывает более двух элементов в возвращаемый массив. Если код примера скомпилирован и запущен под управлением платформы .NET Framework версии 1.0 или 1.1, метод возвращает массив строк двух элементов. Если он компилируется и выполняется в .NET Framework 2.0 или более поздней версии, метод возвращает массив строк с тремя элементами.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 Если регулярное выражение может совпасть с пустой строкой, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> разобьет строку на массив строк для одного символа, потому что разделитель пустой строки можно найти в любом месте. Следующий пример разделяет строку «символы» в, как много элементов, сколько их во входной строке. Так как пустая строка соответствует началу входной строки, нулевые строки вставлены в начале возвращаемого массива. В результате десятый элемент состоит из двух символов в конце входной строки.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции split превышает интервал времени ожидания, определяемое <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных шаблоном регулярного выражения.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Методы аналогичны <xref:System.String.Split%2A?displayProperty=nameWithType> метода, за исключением того, что <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разделяет строку по разделителям регулярным выражением, вместо набора символов. `input` Строка разделяется столько раз, сколько возможно. Если `pattern` не найден в `input` строка, возвращаемое значение содержит один элемент, значение которого является исходный `input` строки.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Скомпилированные регулярные выражения, используемые в вызовах статическому <xref:System.Text.RegularExpressions.Regex.Split%2A> методы автоматически сохраняются в кэше. Чтобы самостоятельно управлять временем жизни скомпилированные регулярные выражения, используйте экземпляр <xref:System.Text.RegularExpressions.Regex.Split%2A> методы.  
  
 Если несколько соответствий являются смежными, пустая строка вставляется в массив. Например разделение строки одиночным дефисом вызывает возвращаемый массив для включения пустую строку в позицию, где находятся два смежных дефиса, как показано в следующем коде.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 При обнаружении совпадения в начале или в конце входной строки, пустая строка входит в начале или конце возвращаемый массив. В следующем примере шаблон регулярного выражения `\d+` для разбиения входной строки на цифровые символы. Так как строка начинается и заканчивается сопоставления числовых символов, оно первый и последний элемент возвращаемого массива <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 Если используются скобки записи в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражения, любой записанный текст включается в результирующий строковый массив. Например если разделить строку «plum Груши» дефисами находиться внутри круглых скобок, возвращаемый массив включает элемент строки, содержащий дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Тем не менее если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии платформы .NET Framework. В .NET Framework 1.0 и 1.1 Если соответствие не найдено в первый набор круглых скобок, записанный текст из дополнительных скобок записи не включается в возвращаемый массив. Начиная с .NET Framework 2.0, весь записанный текст также добавляется в возвращаемый массив. Например следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи записывает дефис, а второй набор записывает косую черту. Если код примера скомпилирован и запущен под управлением платформы .NET Framework версии 1.0 или 1.1, в нем исключаются символы косых черт. Если он компилируется и выполняется в .NET Framework 2.0 или более поздней версии, то они включаются.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Если регулярное выражение может совпасть с пустой строкой, <xref:System.Text.RegularExpressions.Regex.Split%2A> разобьет строку на массив строк для одного символа, потому что разделитель пустой строки можно найти в любом месте. Пример:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 Обратите внимание, что возвращаемый массив также включает пустую строку в начале и в конец массива.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции split превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод. Если время ожидания не определяется в свойствах домена приложения или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не возникает.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage">
          <para>Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором был вызван метод. Если значение времени ожидания не был определен для домена приложения, а значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Статические рекомендуется для разбиения текста на соответствие шаблону <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="count">Максимальное количество возможных случаев разделения.</param>
        <param name="startat">Позиция символа во входной строке, с которой начинается поиск.</param>
        <summary>Разделяет входную строку указанное максимальное количество раз в массив подстрок в позициях, определенных регулярным выражением, указанным в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />. Поиск шаблона регулярного выражения начинается с указанной позиции элемента во входной строке.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Методы аналогичны <xref:System.String.Split%2A?displayProperty=nameWithType> метода, за исключением того, что <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разделяет строку по разделителям регулярным выражением, вместо набора символов. `count` Указывает максимальное количество подстрок, в который `input` разбиения строк; последняя строка содержит неразделенный остаток строки. Объект `count` нулевое значение обеспечивает стандартное поведение разбивки столько раз, сколько возможно. `startat` Параметр определяет точку, с которой начинается поиск первого разделителя (это может использоваться для пропуска начальных пробелов).  
  
 Если совпадений не обнаружено из `count`+ 1 позиции в строке, то метод возвращает массив одного элемента, который содержит `input` строки. Если один или несколько совпадений, первый элемент возвращаемого массива содержит первую часть строки с первого символа до одного символа до соответствия.  
  
 Если несколько соответствий являются смежными и количество найденных совпадений по крайней мере два меньше, чем `count`, пустая строка вставляется в массив. Аналогично Если соответствие найдено в `startat`, который является первым символом в строке, первый элемент возвращаемого массива является пустая строка. То есть пустые строки, которые являются результатом смежных соответствий учитываются при определении ли число соответствующих подстрок равно `count`. В следующем примере регулярное выражение `\d+` используется для поиска начальную позицию первой подстроки числовых символов в строке, а затем для разбиения строки более три раза, начиная с этой позиции. Так как шаблон регулярного выражения соответствует началу входной строки, возвращаемой строки массива состоит из пустая строка, Строка букв пяти символов и остаток строки,  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 Если в регулярном выражении используются скобки записи, любой записанный текст включается в массив разделенных строк. Тем не менее, все элементы массива, содержащие записанный текст, не учитываются при определении ли достигнуто число совпадений `count`. Например, разделение строки "«яблоко-абрикос-слива-груша-гранат-ананас-персик» на максимально возможные четыре подстроки, начиная с символа 15 в строку результатов в 7 элементный массив, как показано в следующем коде.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 Тем не менее если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии платформы .NET Framework. В .NET Framework 1.0 и 1.1 Если соответствие не найдено в первый набор круглых скобок, записанный текст из дополнительных скобок записи не включается в возвращаемый массив. Начиная с .NET Framework 2.0, весь записанный текст также добавляется в возвращаемый массив. Например следующий код использует два набора скобок записи для извлечения отдельных слов в строке. Первый набор скобок записи записывает дефис, а второй набор записывает вертикальную черту. Если код примера скомпилирован и запущен под управлением платформы .NET Framework версии 1.0 или 1.1, исключаются вертикальную панель символов; Если он компилируется и выполняется в .NET Framework 2.0 или более поздней версии, то они включаются.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 Если регулярное выражение может совпасть с пустой строкой, <xref:System.Text.RegularExpressions.Regex.Split%2A> разобьет строку на массив строк для одного символа, потому что разделитель пустой строки можно найти в любом месте. Следующий пример разделяется на строку «символы» столько же элементов содержит входной строки, начиная с символа «». Так как пустая строка соответствует концу входной строки, нулевые строки вставлены в конце возвращаемый массив.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции split превышает интервал времени ожидания, определяемое <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если интервал времени ожидания не задано, при вызове конструктора, исключение, если операция превышает любое значение времени ожидания, установленного для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных указанным шаблоном регулярного выражения. Указанные параметры изменяют операцию сопоставления.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Методы аналогичны <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> метода, за исключением того, что <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разделяет строку по разделителям регулярным выражением, вместо набора символов. Строка разделяется столько раз, сколько возможно. Если разделитель не найден, возвращаемое значение содержит один элемент, значение которого является исходный `input` строки.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Скомпилированные регулярные выражения, используемые в вызовах статическому <xref:System.Text.RegularExpressions.Regex.Split%2A> методы автоматически сохраняются в кэше. Чтобы самостоятельно управлять временем жизни скомпилированные регулярные выражения, используйте экземпляр <xref:System.Text.RegularExpressions.Regex.Split%2A> методы.  
  
 Если несколько соответствий являются смежными, пустая строка вставляется в массив. Например разделение строки одиночным дефисом вызывает возвращаемый массив для включения пустую строку в позицию, где находятся два смежных дефиса.  
  
 При обнаружении совпадения в начале или в конце входной строки, пустая строка входит в начале или конце возвращаемый массив. В следующем примере шаблон регулярного выражения `[a-z]+` для разбиения входной строки на любой прописные или строчные буквы. Так как строка начинается и заканчивается с соответствующим буквенные символы, первый и последний элемент возвращаемого массива равен <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 Если используются скобки записи в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражения, любой записанный текст включается в результирующий строковый массив. Например если разделить строку «plum Груши» дефисами находиться внутри круглых скобок, возвращаемый массив включает элемент строки, содержащий дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Тем не менее если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии платформы .NET Framework. В .NET Framework 1.0 и 1.1 Если соответствие не найдено в первый набор круглых скобок, записанный текст из дополнительных скобок записи не включается в возвращаемый массив. Начиная с .NET Framework 2.0, весь записанный текст также добавляется в возвращаемый массив. Например следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи записывает дефис, а второй набор записывает косую черту. Если код примера скомпилирован и запущен под управлением платформы .NET Framework версии 1.0 или 1.1, в нем исключаются символы косых черт. Если он компилируется и выполняется в .NET Framework 2.0 или более поздней версии, то они включаются.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Если регулярное выражение может совпасть с пустой строкой, <xref:System.Text.RegularExpressions.Regex.Split%2A> разобьет строку на массив строк для одного символа, потому что разделитель пустой строки можно найти в любом месте.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение, если время выполнения операции split превышает интервал времени ожидания, указанный для домена приложения, в котором был вызван метод. Если время ожидания не определяется в свойствах домена приложения или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не возникает.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage">
          <para>Этот метод времени ожидания после интервала, равное значение времени ожидания по умолчанию домена приложения, в котором был вызван метод. Если значение времени ожидания не был определен для домена приложения, а значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Статические рекомендуется для разбиения текста на соответствие шаблону <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных указанным шаблоном регулярного выражения. Дополнительные параметры определяют параметры, которые изменяют соответствующую операцию и интервал времени ожидания, если совпадение не найдено.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Методы аналогичны <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> метода, за исключением того, что <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разделяет строку по разделителям регулярным выражением, вместо набора символов. Строка разделяется столько раз, сколько возможно. Если разделитель не найден, возвращаемое значение содержит один элемент, значение которого является исходный `input` строки.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Скомпилированные регулярные выражения, используемые в вызовах статическому <xref:System.Text.RegularExpressions.Regex.Split%2A> методы автоматически сохраняются в кэше. Чтобы самостоятельно управлять временем жизни скомпилированные регулярные выражения, используйте экземпляр <xref:System.Text.RegularExpressions.Regex.Split%2A> методы.  
  
 Если несколько соответствий являются смежными, пустая строка вставляется в массив. Например разделение строки одиночным дефисом вызывает возвращаемый массив для включения пустую строку в позицию, где находятся два смежных дефиса.  
  
 При обнаружении совпадения в начале или в конце входной строки, пустая строка входит в начале или конце возвращаемый массив. В следующем примере шаблон регулярного выражения `[a-z]+` для разбиения входной строки на любой прописные или строчные буквы. Так как строка начинается и заканчивается с соответствующим буквенные символы, первый и последний элемент возвращаемого массива равен <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 Если используются скобки записи в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражения, любой записанный текст включается в результирующий строковый массив. Например если разделить строку «plum Груши» дефисами находиться внутри круглых скобок, возвращаемый массив включает элемент строки, содержащий дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Тем не менее если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии платформы .NET Framework. В .NET Framework 1.0 и 1.1 Если соответствие не найдено в первый набор круглых скобок, записанный текст из дополнительных скобок записи не включается в возвращаемый массив. Начиная с .NET Framework 2.0, весь записанный текст также добавляется в возвращаемый массив. Например следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи записывает дефис, а второй набор записывает косую черту. Если код примера скомпилирован и запущен под управлением платформы .NET Framework версии 1.0 или 1.1, в нем исключаются символы косых черт. Если он компилируется и выполняется в .NET Framework 2.0 или более поздней версии, то они включаются.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Если регулярное выражение может совпасть с пустой строкой, <xref:System.Text.RegularExpressions.Regex.Split%2A> разобьет строку на массив строк для одного символа, потому что разделитель пустой строки можно найти в любом месте.  
  
 `matchTimeout` Указывает о том, как долго шаблон соответствующий метод должен пытаться найти совпадения, до истечения времени ожидания. Установка интервала времени ожидания предотвращает регулярные выражения, зависящие от избыточный поиск с возвратом отображение перестает отвечать при обработке входных данных, содержащий ближайшие совпадения. Дополнительные сведения см. в разделе [советы и рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиск с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если совпадение не найдено в этого интервала времени, метод вызывает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в которой выполняется метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  -или-  Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage">
          <para>Мы рекомендуем задавать <paramref name="matchTimeout" /> параметр соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений, обеспечивает немного лучшую производительность. Тем не менее, следует отключить тайм-ауты только при следующих условиях: — когда входные данные, обрабатываемые регулярного выражения определяется из известного и надежного источника или состоит из статического текста. Это исключает текст, который был динамически ввода пользователями.  — Если для обеспечения эффективной обработки тщательно протестирован шаблон регулярного выражения соответствует, несовпадающие, а ближайшем.  -Если шаблон регулярного выражения содержит не языковые элементы, которые возникает избыточный поиск с возвратом при обработке почти совпадают.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">Объект, который требуется заполнить информацией о сериализации.</param>
        <param name="context">Место для хранения и извлечения сериализованных данных. Этот параметр зарезервирован для использования в будущем.</param>
        <summary>Заполняет объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> данными даты, необходимыми для десериализации текущего объекта <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает шаблон регулярного выражения, который был передан в конструктор <see langword="Regex" />.</summary>
        <returns>Параметр <paramref name="pattern" />, который был передан в конструктор <see langword="Regex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> является базовым классом регулярных выражений, созданные <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> метод. Эти скомпилированные регулярные выражения используйте <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> реализацию базового класса. При вызове из производного класса, <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> метод возвращает строку, который был передан в <paramref name="pattern" /> параметр <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> конструктора класса, который использовался для определения регулярного выражения.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Входная строка, содержащая текст для преобразования.</param>
        <summary>Преобразует все escape-символы во входной строке обратно в символы.</summary>
        <returns>Строка символов с любыми преобразованными символами, приведенными в их непреобразованную форму.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Метод выполняет одно из следующих двух преобразований:  
  
-   Он обращает преобразования, выполняемые <xref:System.Text.RegularExpressions.Regex.Escape%2A> метод путем удаления escape-символ (»\\«) из каждого символа, с помощью метода в escape-последовательность. К ним относятся \\, *, +,?, &#124;, {, [, (,), ^, $,., # и пробелы. Кроме того <xref:System.Text.RegularExpressions.Regex.Unescape%2A> метод отменяет преобразование преобразованных закрывающая скобка (]) и закрывающие скобки (}).  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Невозможно обратить строки, в которой полностью, так как он не может вывести точно были escape-символов,  
  
-   Она заменяет представление непечатаемых символов сами символы. Например он заменяет \a \x07. Представлений символов, которое оно заменяет являются \a, \b, \e, \n, \r, \f \t и \v.  
  
 Если <xref:System.Text.RegularExpressions.Regex.Unescape%2A> метод обнаруживает других escape-последовательности, преобразование невозможно, например \w или \s, он выдает <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="str" /> включает нераспознанную escape-последовательность.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="str" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>Значение <see langword="true" />, если свойство <see cref="P:System.Text.RegularExpressions.Regex.Options" /> содержит параметр <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>Значение <see langword="true" />, если свойство <see cref="P:System.Text.RegularExpressions.Regex.Options" /> содержит параметр <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">Время ожидания, которое требуется проверить.</param>
        <summary>Проверяет, попадает ли интервал времени ожидания в допустимый диапазон.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>