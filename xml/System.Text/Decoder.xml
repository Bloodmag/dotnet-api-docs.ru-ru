<Type Name="Decoder" FullName="System.Text.Decoder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="af988a5d852dff603b2e4e888be96288515f405e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531028" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Decoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Decoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Decoder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Decoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Decoder abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Конвертирует последовательность закодированных байтов в набор символов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить экземпляр реализации <xref:System.Text.Decoder> класса, приложение должно использовать <xref:System.Text.Encoding.GetDecoder%2A> метод <xref:System.Text.Encoding> реализации.  
  
 <xref:System.Text.Decoder.GetCharCount%2A> Метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.Decoder.GetChars%2A> метод выполняет фактическое декодирование. Существует несколько версий обоих методов, доступных в <xref:System.Text.Decoder> класса. Дополнительные сведения см. в разделе <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>. Объект <xref:System.Text.Decoder> сохраняет сведения о состоянии между последовательными вызовами `GetChars` или <xref:System.Text.Decoder.Convert%2A> методы, что позволяет ему правильно декодировать последовательности байтов, охватывающие блоки. <xref:System.Text.Decoder> Также сохраняет замыкающие байты в конце блоков данных и использует конечные байты при следующей операции декодирования. Таким образом <xref:System.Text.Encoding.GetDecoder%2A> и <xref:System.Text.Encoding.GetEncoder%2A> полезны для сетевых операций передачи данных и файл, так как эти операции часто работают с блоками данных, а не полные данные потока.  
  
> [!NOTE]
>  Если приложение выполняется с потоком данных, следует убедиться в том, что сведения о состоянии очищены, задав `flush` параметра `true` при вызове соответствующего метода. Если возникает исключение или приложение переключает потоки, он должен вызывать <xref:System.Text.Decoder.Reset%2A> очистить внутреннее состояние `Decoder` объекта.  
  
## <a name="version-considerations"></a>Описание версии  
 Объект <xref:System.Text.Decoder> или <xref:System.Text.Encoder> может быть сериализован во время операции преобразования. Состояние объекта сохраняется, если он десериализуется в той же версии платформы .NET Framework, но потеряно, если он десериализуется в другой версии.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Text.Decoder> для преобразования двух различных массивов байтов в массив символов. Один из байтов символов соединяет массивы. Это похоже на то, что <xref:System.IO.StreamReader> выполняет объект внутри при чтении потока.  
  
 [!code-cpp[Classic Decoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Decoder Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Decoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Decoder Example/CS/source.cs#1)]
 [!code-vb[Classic Decoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Decoder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Когда приложение наследует от этого класса, его необходимо переопределить все члены.</para>
    </block>
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Decoder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Decoder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.Decoder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить экземпляр реализации этого класса, приложение должно использовать <xref:System.Text.Encoding.GetDecoder%2A> метод <xref:System.Text.Encoding> реализации.  
  
   
  
## Examples  
 В следующем примере показано два способа инициализации нового <xref:System.Text.Decoder> экземпляра.  
  
 [!code-cpp[System.Text.Decoder.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.Decoder.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.Decoder.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует закодированную последовательность байтов в строку или массив символов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char), flush As Boolean, ByRef bytesUsed As Integer, ByRef charsUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <param name="bytesUsed">To be added.</param>
        <param name="charsUsed">To be added.</param>
        <param name="completed">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (byte* bytes, int byteCount, char* chars, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(System::Byte* bytes, int byteCount, char* chars, int charCount, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">Адрес буфера, содержащего последовательности байтов для преобразования.</param>
        <param name="byteCount">Число байтов, указанное в параметре <c>bytes</c>, которое требуется преобразовать.</param>
        <param name="chars">Адрес буфера для хранения преобразованных символов.</param>
        <param name="charCount">Максимальное число символов в <c>chars</c> для использования при преобразовании.</param>
        <param name="flush">
          Значение <see langword="true" /> указывает, что дальнейшие данные для преобразования отсутствуют. В противном случае — значение <see langword="false" />.</param>
        <param name="bytesUsed">При возврате этот метод содержит число байтов, созданных при преобразовании. Этот параметр передается неинициализированным.</param>
        <param name="charsUsed">При возврате этот метод содержит число символов из <c>chars</c>, которые использовались при преобразовании. Этот параметр передается неинициализированным.</param>
        <param name="completed">При возврате этот метод содержит значение <see langword="true" />, если все символы, заданные с помощью параметра <c>byteCount</c>, были преобразованы. В противном случае значение <see langword="false" />. Этот параметр передается неинициализированным.</param>
        <summary>Преобразует буфер закодированных байтов в символы в кодировке UTF-16 и сохраняет результат в другом буфере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следует помнить, что <xref:System.Text.Decoder> объект сохраняет состояние между вызовами <xref:System.Text.Decoder.Convert%2A>. Если приложение выполняется с потоком данных, он должен устанавливать `flush` параметр `true` чтобы убедиться в том, что сведения о состоянии очищены. Этот параметр декодер игнорирует недопустимые байты в конце блока данных и очищает внутренний буфер. Любые оставшиеся обработанные данные, который является частью логического устройства, например старший символ суррогатной пары, преобразуется в соответствии с текущими параметрами резервирования.  
  
 `Convert` Метод предназначен для использования в цикле для декодирования произвольного количества входных данных, например чтение данных из файла или потока. Результаты операции декодирования сохраняются в буфер фиксированного размера. <xref:System.Text.Decoder.GetChars%2A> будет вызывать исключение, если выходной буфер не имеет достаточного объема, но <xref:System.Text.Decoder.Convert%2A> будет столько же места можно заполнить и возвращения байтов, считанных и записанных символов. См. также <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> раздел, описывающий дополнительные комментарии.  
  
 `completed` Выходной параметр указывает, является ли все данные из входного буфера преобразованы и сохранены в выходном буфере. Этот параметр имеет значение `false` Если число байтов, заданные `byteCount` нельзя преобразовать без превышения числа знаков, указанное в `charCount` параметра. В этом случае приложение следует использовать содержимое выходного буфера или предоставить новый выходной буфер приращения `bytes` параметра на число байтов, указанное в `bytesUsed` параметра, затем вызовите `Convert` метод снова процесс оставшихся входных данных.  
  
 `completed` Параметр также может быть присвоено `false`, даже если `bytesUsed` и `byteCount` параметры равны. Такая ситуация возникает, если по-прежнему данные в <xref:System.Text.Decoder> объекта, не были сохранены в `bytes` буфера.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.Decoder.Convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> или <paramref name="bytes" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="charCount" /> или <paramref name="byteCount" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Выходной буфер слишком мал, чтобы содержать преобразованные входные данные. Размер выходного буфера должен быть больше или равен размеру, указанному методом <see cref="Overload:System.Text.Decoder.GetCharCount" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Decoder.Fallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex, int32 charCount, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer, charCount As Integer, flush As Boolean, ByRef bytesUsed As Integer, ByRef charsUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">Преобразуемый массив байтов.</param>
        <param name="byteIndex">Первый элемент преобразуемого массива <c>bytes</c>.</param>
        <param name="byteCount">Число преобразуемых элементов <c>bytes</c>.</param>
        <param name="chars">Массив для сохранения преобразованных символов.</param>
        <param name="charIndex">Первый элемент массива <c>chars</c>, в котором сохраняются данные.</param>
        <param name="charCount">Максимальное число элементов в <c>chars</c> для использования при преобразовании.</param>
        <param name="flush">
          Значение <see langword="true" /> указывает, что дальнейшие данные для преобразования отсутствуют. В противном случае — значение <see langword="false" />.</param>
        <param name="bytesUsed">При возврате этот метод содержит число байтов, которые использовались при преобразовании. Этот параметр передается неинициализированным.</param>
        <param name="charsUsed">При возврате этот метод содержит число символов из <c>chars</c>, которые были созданы при преобразовании. Этот параметр передается неинициализированным.</param>
        <param name="completed">При возврате этот метод содержит значение <see langword="true" />, если все символы, заданные с помощью параметра <c>byteCount</c>, были преобразованы. В противном случае значение <see langword="false" />. Этот параметр передается неинициализированным.</param>
        <summary>Преобразует массив закодированных байтов в символы в кодировке UTF-16 и сохраняет результат в другом массиве символов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следует помнить, что <xref:System.Text.Decoder> объект сохраняет состояние между вызовами <xref:System.Text.Decoder.Convert%2A>. Если приложение выполняется с потоком данных, он должен устанавливать `flush` параметр `true` чтобы убедиться в том, что сведения о состоянии очищены. Этот параметр декодер игнорирует недопустимые байты в конце блока данных и очищает внутренний буфер. Любые оставшиеся обработанные данные, который является частью логического устройства, например старший символ суррогатной пары, преобразуется в соответствии с текущими параметрами резервирования.  
  
 `Convert` Метод предназначен для использования в цикле для декодирования произвольного количества входных данных, например чтение данных из файла или потока. Результаты операции декодирования сохраняются в буфер фиксированного размера. <xref:System.Text.Decoder.GetChars%2A> будет вызывать исключение, если выходной буфер не имеет достаточного объема, но <xref:System.Text.Decoder.Convert%2A> будет столько же места можно заполнить и возвращения байтов, считанных и записанных символов. См. также <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> раздел, описывающий дополнительные комментарии.  
  
 `completed` Выходной параметр указывает, является ли все данные из входного буфера преобразованы и сохранены в выходном буфере. Этот параметр имеет значение `false` Если число байтов, заданные `byteCount` нельзя преобразовать без превышения числа знаков, указанное в `charCount` параметра. В этом случае приложение следует использовать содержимое выходного буфера или предоставить новый выходной буфер приращения `bytes` параметра на число байтов, указанное в `bytesUsed` параметра, затем вызовите `Convert` метод снова процесс оставшихся входных данных.  
  
 `completed` Параметр также может быть присвоено `false`, даже если `bytesUsed` и `byteCount` параметры равны. Такая ситуация возникает, если по-прежнему данные в <xref:System.Text.Decoder> объекта, не были сохранены в `bytes` буфера.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Text.Encoder.Convert%2A> метод для преобразования файла символов UTF-16, UTF-8. Затем он использует <xref:System.Text.Decoder.Convert%2A> метода для преобразования символов UTF-8 обратно в символы UTF-16.  
  
 [!code-csharp[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/cs/edCvt.cs#1)]
 [!code-vb[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/vb/edCvt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> или <paramref name="bytes" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение <paramref name="charIndex" />, <paramref name="charCount" />, <paramref name="byteIndex" /> или <paramref name="byteCount" /> меньше нуля.  
  
 - или -  
  
 Длина массива <paramref name="chars" /> - <paramref name="charIndex" /> меньше <paramref name="charCount" />.  
  
 - или -  
  
 Длина массива <paramref name="bytes" /> - <paramref name="byteIndex" /> меньше <paramref name="byteCount" />.</exception>
        <exception cref="T:System.ArgumentException">Выходной буфер слишком мал, чтобы содержать преобразованные входные данные. Размер выходного буфера должен быть больше или равен размеру, указанному методом <see cref="Overload:System.Text.Decoder.GetCharCount" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Decoder.Fallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback Fallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback Fallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Decoder.Fallback" />
      <MemberSignature Language="VB.NET" Value="Public Property Fallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ Fallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект <see cref="T:System.Text.DecoderFallback" /> для текущего объекта <see cref="T:System.Text.Decoder" />.</summary>
        <value>Объект <see cref="T:System.Text.DecoderFallback" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback> Объект представляет обработчик ошибок, который вызывается, когда невозможно преобразовать в закодированную последовательность байтов в символ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">В операции задания значением является <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentException">Невозможно задать новое значение, поскольку текущий объект <see cref="T:System.Text.DecoderFallbackBuffer" /> содержит данные, которые еще не были декодированы.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.FallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="FallbackBuffer">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallbackBuffer FallbackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallbackBuffer FallbackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Text.Decoder.FallbackBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FallbackBuffer As DecoderFallbackBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallbackBuffer ^ FallbackBuffer { System::Text::DecoderFallbackBuffer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallbackBuffer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Text.DecoderFallbackBuffer" />, связанный с текущим объектом <see cref="T:System.Text.Decoder" />.</summary>
        <value>Объект <see cref="T:System.Text.DecoderFallbackBuffer" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallbackBuffer> Объект представляет данные, используемые <xref:System.Text.DecoderFallback> объекта. <xref:System.Text.DecoderFallback> Объект представляет обработчик ошибок, который вызывается, когда невозможно преобразовать в закодированную последовательность байтов в символ.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.Fallback" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.ReadOnlySpan{System.Byte},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на первый декодируемый байт.</param>
        <param name="count">Число байтов для декодирования.</param>
        <param name="flush">
          <see langword="true" /> для имитации очистки внутреннего состояния кодировщика после расчета; в противном случае — <see langword="false" />.</param>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов, начало которой задается указателем байтов. Параметр указывает, следует ли очистить внутреннее состояние декодера после вычисления.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов и байтов во внутреннем буфере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не влияет на состояние декодера.  
  
 Для вычисления массиве точный размер, <xref:System.Text.Decoder.GetChars%2A> требуется для хранения полученных символов, приложение должно использовать <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Если `GetChars` вызывается с `flush` значение `false`, декодер сохраняет замыкающие байты в конце блока данных во внутреннем буфере и использует их при следующей операции декодирования. Приложение должно вызывать `GetCharCount` для блока данных непосредственно перед вызовом `GetChars` на том же блоке так, что в вычисление включаются все конечные байты из предыдущего блока.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Значение параметра <paramref name="bytes" /> равно <see langword="null" /> (<see langword="Nothing" /> в Visual Basic .NET).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Decoder.Fallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов из заданного массива байтов.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов и байтов во внутреннем буфере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не влияет на состояние декодера.  
  
 Для вычисления массиве точный размер, <xref:System.Text.Decoder.GetChars%2A> требуется для хранения полученных символов, приложение должно использовать <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Если `GetChars` вызывается с `flush` значение `false`, декодер сохраняет замыкающие байты в конце блока данных во внутреннем буфере и использует их при следующей операции декодирования. Приложение должно вызывать `GetCharCount` для блока данных непосредственно перед вызовом `GetChars` на том же блоке так, что в вычисление включаются все конечные байты из предыдущего блока.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Text.Decoder.GetCharCount%2A> метод для вычисления числа символов, необходимых для декодировать указанный диапазон байтов в массиве.  
  
 [!code-cpp[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Decoder.Fallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes, int index, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte(), index As Integer, count As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <param name="flush">
          <see langword="true" /> для имитации очистки внутреннего состояния кодировщика после расчета; в противном случае — <see langword="false" />.</param>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов из заданного массива байтов. Параметр указывает, следует ли очистить внутреннее состояние декодера после вычисления.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов и байтов во внутреннем буфере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не влияет на состояние декодера.  
  
 Для вычисления массиве точный размер, <xref:System.Text.Decoder.GetChars%2A> требуется для хранения полученных символов, приложение должно использовать <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Если `GetChars` вызывается с `flush` значение `false`, декодер сохраняет замыкающие байты в конце блока данных во внутреннем буфере и использует их при следующей операции декодирования. Приложение должно вызывать `GetCharCount` для блока данных непосредственно перед вызовом `GetChars` на том же блоке так, что в вычисление включаются все конечные байты из предыдущего блока.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Decoder.Fallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе декодирует последовательность байтов в набор символов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на первый декодируемый байт.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <param name="chars">Указатель на положение, с которого начинается запись результирующего набора символов.</param>
        <param name="charCount">Наибольшее количество символов для записи.</param>
        <param name="flush">
          Значение <see langword="true" /> соответствует очистке внутреннего состояния декодера после преобразования; в противоположном случае — значение <see langword="false" />.</param>
        <summary>При переопределении в производном классе декодирует последовательность байтов, начало которой задается указателем байтов, и все байты, расположенные во внутреннем буфере, в набор символов, которые сохраняются, начиная с заданного указателя символов. Параметр указывает, следует ли очистить внутреннее состояние декодера после выполнения преобразования.</summary>
        <returns>Фактическое число символов, записанных в местоположение, которое задано параметром <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следует помнить, что <xref:System.Text.Decoder> объект сохраняет состояние между вызовами <xref:System.Text.Decoder.GetChars%2A>. Если приложение выполняется с потоком данных, он должен устанавливать `flush` параметр `true` чтобы убедиться в том, что сведения о состоянии очищены. Этот параметр декодер игнорирует недопустимые байты в конце блока данных и очищает внутренний буфер.  
  
 Для вычисления буфера точный размер, `GetChars` требуется для хранения полученных символов, приложение должно использовать <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Если `GetChars` вызывается с `flush` значение `false`, декодер сохраняет замыкающие байты в конце блока данных во внутреннем буфере и использует их при следующей операции декодирования. Приложение должно вызывать `GetCharCount` для блока данных непосредственно перед вызовом `GetChars` на том же блоке так, что в вычисление включаются все конечные байты из предыдущего блока.  
  
 Если приложение является преобразование много сегментов входного потока, рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A> метод. <xref:System.Text.Decoder.GetChars%2A> будет вызывать исключение, если выходной буфер не имеет достаточного объема, но <xref:System.Text.Decoder.Convert%2A> будет столько же места можно заполнить и возвращения байтов, считанных и записанных символов. См. также <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> раздел, описывающий дополнительные комментарии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).  
  
 - или -  
  
 <paramref name="chars" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="byteCount" /> или <paramref name="charCount" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> меньше результирующего числа символов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Decoder.Fallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="byteIndex">Индекс первого декодируемого байта.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <param name="chars">Массив символов, в который будет помещен результирующий набор символов.</param>
        <param name="charIndex">Индекс, с которого начинается запись результирующего набора символов.</param>
        <summary>При переопределении в производном классе декодирует последовательность байтов из заданного массива байтов и все байты, расположенные во внутреннем буфере, в указанный массив символов.</summary>
        <returns>Фактическое число символов, записанных в <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следует помнить, что <xref:System.Text.Decoder> объект сохраняет состояние между вызовами <xref:System.Text.Decoder.GetChars%2A>. Если приложение выполняется с потоком данных, он должен устанавливать `flush` параметр `true` чтобы убедиться в том, что сведения о состоянии очищены. Этот параметр декодер игнорирует недопустимые байты в конце блока данных и очищает внутренний буфер.  
  
 Для вычисления массиве точный размер, `GetChars` требуется для хранения полученных символов, приложение должно использовать <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Если `GetChars` вызывается с `flush` значение `false`, декодер сохраняет замыкающие байты в конце блока данных во внутреннем буфере и использует их при следующей операции декодирования. Приложение должно вызывать `GetCharCount` для блока данных непосредственно перед вызовом `GetChars` на том же блоке так, что в вычисление включаются все конечные байты из предыдущего блока.  
  
 Если приложение является преобразование много сегментов входного потока, рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A> метод. <xref:System.Text.Decoder.GetChars%2A> будет вызывать исключение, если выходной буфер не имеет достаточного объема, но <xref:System.Text.Decoder.Convert%2A> будет столько же места можно заполнить и возвращения байтов, считанных и записанных символов. См. также <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> раздел, описывающий дополнительные комментарии.  
  
   
  
## Examples  
 В следующем примере показано, как декодировать диапазон элементов из массива байтов и сохранить их в массиве знаков Юникода. <xref:System.Text.Decoder.GetCharCount%2A> Метод используется для вычисления числа символов, необходимых для сохранения декодированных элементов в массиве `bytes`. <xref:System.Text.Decoder.GetChars%2A> Метод декодирует указанные элементы в массиве байтов и сохраняет их в новый массив символов.  
  
 [!code-cpp[System.Text.Decoder.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.Decoder.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.Decoder.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).  
  
 - или -  
  
 <paramref name="chars" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="byteIndex" />, <paramref name="byteCount" /> или <paramref name="charIndex" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="byteindex" /> и <paramref name="byteCount" /> не указывают допустимый диапазон в <paramref name="bytes" />.  
  
 - или -  
  
 Значение параметра <paramref name="charIndex" /> не является допустимым индексом в <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          Недостаточно емкости <paramref name="chars" /> от <paramref name="charIndex" /> до конца массива для размещения полученных символов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Decoder.Fallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="byteIndex">Индекс первого декодируемого байта.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <param name="chars">Массив символов, в который будет помещен результирующий набор символов.</param>
        <param name="charIndex">Индекс, с которого начинается запись результирующего набора символов.</param>
        <param name="flush">
          Значение <see langword="true" /> соответствует очистке внутреннего состояния декодера после преобразования; в противоположном случае — значение <see langword="false" />.</param>
        <summary>При переопределении в производном классе декодирует последовательность байтов из заданного массива байтов и все байты, расположенные во внутреннем буфере, в указанный массив символов. Параметр указывает, следует ли очистить внутреннее состояние декодера после выполнения преобразования.</summary>
        <returns>Фактическое количество символов, записанных в параметр <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следует помнить, что <xref:System.Text.Decoder> объект сохраняет состояние между вызовами <xref:System.Text.Decoder.GetChars%2A>. Если приложение выполняется с потоком данных, он должен устанавливать `flush` параметр `true` чтобы убедиться в том, что сведения о состоянии очищены. Этот параметр декодер игнорирует недопустимые байты в конце блока данных и очищает внутренний буфер.  
  
 Для вычисления массиве точный размер, `GetChars` требуется для хранения полученных символов, приложение должно использовать <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Если `GetChars` вызывается с `flush` значение `false`, декодер сохраняет замыкающие байты в конце блока данных во внутреннем буфере и использует их при следующей операции декодирования. Приложение должно вызывать `GetCharCount` для блока данных непосредственно перед вызовом `GetChars` на том же блоке так, что в вычисление включаются все конечные байты из предыдущего блока.  
  
 Если приложение является преобразование много сегментов входного потока, рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A> метод. <xref:System.Text.Decoder.GetChars%2A> будет вызывать исключение, если выходной буфер не имеет достаточного объема, но <xref:System.Text.Decoder.Convert%2A> будет столько же места можно заполнить и возвращения байтов, считанных и записанных символов. См. также <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> раздел, описывающий дополнительные комментарии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).  
  
 - или -  
  
 <paramref name="chars" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="byteIndex" />, <paramref name="byteCount" /> или <paramref name="charIndex" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="byteindex" /> и <paramref name="byteCount" /> не указывают допустимый диапазон в <paramref name="bytes" />.  
  
 - или -  
  
 Значение параметра <paramref name="charIndex" /> не является допустимым индексом в <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          Недостаточно емкости <paramref name="chars" /> от <paramref name="charIndex" /> до конца массива для размещения полученных символов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Decoder.Fallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает декодер в исходное состояние.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод очищает внутреннее состояние <xref:System.Text.Decoder> объекта. Метод очищает все сведения о состоянии, сохраненные на предыдущий вызов <xref:System.Text.Decoder.GetChars%2A> или <xref:System.Text.Decoder.Convert%2A>, в том числе конечные байты в конце предыдущего блока данных.  
  
 Приложение должно вызывать <xref:System.Text.Decoder.Reset%2A> метод, если необходимо повторно использовать же декодер, даже после исключения <xref:System.Text.Decoder.GetChars%2A>, <xref:System.Text.Decoder.Convert%2A>, или <xref:System.Text.Decoder.GetCharCount%2A>, или если декодер переключает потоки и начинает декодировать другой поток.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>