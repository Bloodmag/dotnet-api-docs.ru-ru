<Type Name="DecoderFallbackBuffer" FullName="System.Text.DecoderFallbackBuffer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="334e4a94e0c09dca04227f373df6acb3a69c9b91" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30529158" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class DecoderFallbackBuffer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DecoderFallbackBuffer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.DecoderFallbackBuffer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DecoderFallbackBuffer" />
  <TypeSignature Language="C++ CLI" Value="public ref class DecoderFallbackBuffer abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет буфер, позволяющий резервному обработчику возвращать в декодер альтернативную строку, если он не может декодировать входную последовательность байтов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодирование определяет сопоставление между символом Юникода и закодированную последовательность байтов. Операции декодирования, который преобразует входную последовательность байтов в выходной символ, не выполняется, если сопоставление не определено для последовательности определенный байт.  
  
 .NET Framework предоставляет механизм обработки ошибок, называемый резервным вариантом, если преобразование выполнить невозможно. Все обработчики резервной декодера необходимо реализовать следующие:  
  
-   Декодер отката, который представлен классом производным от <xref:System.Text.DecoderFallback> класса.  
  
-   Буфер резерва декодера, представленный объектом типа, производного от <xref:System.Text.DecoderFallbackBuffer> класс, который может возвращать строку в операцию преобразования.  
  
 В случае ошибки можно использовать три стратегии обработки ошибок преобразования:  
  
-   Наилучшее сопоставление. Буфер резерва декодера может возвращать строку, представляющую приближено к входной последовательности байтов. Платформа .NET Framework не предоставляет открытый наилучшего <xref:System.Text.DecoderFallbackBuffer> реализации.  
  
-   Замена. Буфер резерва декодера может вернуть строку, таких как знак вопроса ("?»), которое указывает, что не удалось декодировать последовательность байтов. В платформе .NET Framework <xref:System.Text.DecoderReplacementFallback> и <xref:System.Text.DecoderReplacementFallbackBuffer> классы предоставляют реализацию резервный буфер открытый замены. Конструктор <xref:System.Text.DecoderReplacementFallback> позволяет определить строку замены.  
  
-   Исключение. <xref:System.Text.DecoderFallbackBuffer> Реализация вызывает исключение, которое указывает, что не удается декодировать последовательность байтов и завершает операцию декодирования. В этом случае необходимо предоставить резервному обработчику <xref:System.Text.DecoderFallbackBuffer> реализацию, несмотря на то, что он не возвращает строки для декодера. В платформе .NET Framework <xref:System.Text.DecoderExceptionFallback> и <xref:System.Text.DecoderExceptionFallbackBuffer> классы предоставляют реализацию резервной стратегии исключения открытый, которой создается <xref:System.Text.DecoderFallbackException> когда не удается декодировать последовательность байтов.  
  
 Буфер, в <xref:System.Text.DecoderFallbackBuffer> реализации представляет всю строку, должны быть возвращены декодер в ответ на декодер резервной. Как правило реализации также включают сведения о состоянии, например индекса следующего символа, вернуться к декодера и количество оставшихся символов, должны быть возвращены. Поскольку <xref:System.Text.DecoderFallbackBuffer> — это абстрактный класс, требуется производным классам реализовывать по крайней мере следующие члены:  
  
-   <xref:System.Text.DecoderFallbackBuffer.Fallback%2A> Метод, который вызывается декодером, когда он не может декодировать последовательность байтов. Реализация резервный буфер декодера передает два блока данных: массив, содержащий байты, которые не удается декодировать и индекс первого байта в входного массива байтов. В обработчике исключений резервной декодер исключение в этом методе. В противном случае метод возвращает `true` если оно предоставляет переход на резервный ресурс или `false` Если это не так.  
  
-   <xref:System.Text.DecoderFallbackBuffer.GetNextChar%2A> Метод, который повторно вызывается декодером, если <xref:System.Text.DecoderFallbackBuffer.Fallback%2A> возвращает `true`. При последующих вызовах обработчик должен возвращать каждый символ в буфере. Вернув все символы, он должен возвращать U + 0000. Обработчик исключений резервной всегда возвращает U + 0000.  
  
-   <xref:System.Text.DecoderFallbackBuffer.MovePrevious%2A> Метод, который пытается переместить указатель в предыдущее расположение в буфере и указывает, успешно ли выполнено перемещение. Всегда возвращает обработчик исключений `false`.  
  
-   <xref:System.Text.DecoderFallbackBuffer.Remaining%2A> Свойство, которое указывает количество оставшихся символов, возвращаемых для декодера. Обработчик исключений резервной всегда возвращает ноль.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.DecoderFallback" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DecoderFallbackBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.DecoderFallbackBuffer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DecoderFallbackBuffer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.DecoderFallbackBuffer" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public abstract bool Fallback (byte[] bytesUnknown, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Fallback(unsigned int8[] bytesUnknown, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Fallback (bytesUnknown As Byte(), index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Fallback(cli::array &lt;System::Byte&gt; ^ bytesUnknown, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesUnknown" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytesUnknown">Входной массив байтов.</param>
        <param name="index">Позиция индекса байта в <c>bytesUnknown</c>.</param>
        <summary>При переопределении в производном классе готовит резервный буфер для обработки указанной входной последовательности байтов.</summary>
        <returns>
          <see langword="true" />, если резервный буфер может обработать <paramref name="bytesUnknown" />; <see langword="false" />, если резервный буфер игнорирует <paramref name="bytesUnknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>, <xref:System.Text.Encoding.GetString%2A?displayProperty=nameWithType>, И <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> вызов методов <xref:System.Text.DecoderFallbackBuffer.Fallback%2A> при обнаружении неизвестного входную последовательность байтов, не может быть декодирована. Возвращаемое значение `true` указывает, что резервный буфер может обрабатывать входной последовательности байтов, вследствие чего вызывающий метод, вызываемый <xref:System.Text.DecoderFallbackBuffer.GetNextChar%2A> метод для получения каждого символа из резервного буфера. Так как он не обрабатывает отдельных байтов <xref:System.Text.DecoderFallbackBuffer.Fallback%2A> метод в резервный обработчик исключений вызывает исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextChar">
      <MemberSignature Language="C#" Value="public abstract char GetNextChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char GetNextChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.DecoderFallbackBuffer.GetNextChar" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNextChar () As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract char GetNextChar();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе извлекает следующий символ в резервном буфере.</summary>
        <returns>Следующий символ в резервном буфере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывает операции декодирования <xref:System.Text.DecoderFallbackBuffer.Fallback%2A> метод, если операция обнаруживает в последовательность неизвестных байтов во входных данных. Если <xref:System.Text.DecoderFallbackBuffer.Fallback%2A> возвращает `true`, существует замещающую строку, которая может быть вставлен в выходных данных вместо декодирования неизвестные входные данные. Вызов операции декодирования <xref:System.Text.DecoderFallbackBuffer.GetNextChar%2A> метода несколько раз и получает один символ замены строки одновременно. При возвращении всех символов в буфере резерва декодера метод должен вернуть U + 0000.  
  
 Для обработчика исключений резервной <xref:System.Text.DecoderFallbackBuffer.GetNextChar%2A> метод должен возвращать U + 0000.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MovePrevious">
      <MemberSignature Language="C#" Value="public abstract bool MovePrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MovePrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.DecoderFallbackBuffer.MovePrevious" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MovePrevious () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MovePrevious();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производный класс становится причиной того, что в следующем вызове метод <see cref="M:System.Text.DecoderFallbackBuffer.GetNextChar" /> получает доступ к позиции символа в буфере данных, предшествующей текущей позиции символа.</summary>
        <returns>
          Значение <see langword="true" />, если операция <see cref="M:System.Text.DecoderFallbackBuffer.MovePrevious" /> выполнена успешно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Резервный обработчик исключений должен возвращать `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remaining">
      <MemberSignature Language="C#" Value="public abstract int Remaining { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Remaining" />
      <MemberSignature Language="DocId" Value="P:System.Text.DecoderFallbackBuffer.Remaining" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Remaining As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int Remaining { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе возвращает максимальное число символов в текущем объекте <see cref="T:System.Text.DecoderFallbackBuffer" />, которые остаются для обработки.</summary>
        <value>Количество символов в текущем резервном буфере, которые еще не были обработаны.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallbackBuffer.Fallback%2A> Возвращает `true` Если <xref:System.Text.DecoderFallbackBuffer.Remaining%2A> имеет ненулевое значение.  
  
 Для обработчика исключений резервной <xref:System.Text.DecoderFallbackBuffer.Remaining%2A> метод должен возвращать нуль.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.DecoderFallbackBuffer.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициализирует все данные и сведения о состоянии, относящиеся к этому резервному буферу.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>После вызова метода <see cref="M:System.Text.DecoderFallbackBuffer.Reset" /> метода <see cref="P:System.Text.DecoderFallbackBuffer.Remaining" /> свойство должно возвращать 0, <see cref="M:System.Text.DecoderFallbackBuffer.GetNextChar" /> метод должен возвращать U + 0000 и <see cref="M:System.Text.DecoderFallbackBuffer.MovePrevious" /> метод должен возвращать <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>