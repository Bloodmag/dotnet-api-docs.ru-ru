<Type Name="EncoderFallbackBuffer" FullName="System.Text.EncoderFallbackBuffer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="116c4743750d62c78bf7a85e6e5dff453828390b" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30529078" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class EncoderFallbackBuffer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit EncoderFallbackBuffer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.EncoderFallbackBuffer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class EncoderFallbackBuffer" />
  <TypeSignature Language="C++ CLI" Value="public ref class EncoderFallbackBuffer abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет буфер, позволяющий резервному обработчику возвращать в кодировщик альтернативную строку, если он не может закодировать входной символ.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодирование определяет сопоставление между символом Юникода и закодированную последовательность байтов. Операции кодирования, преобразующее входной символ в выходную последовательность байтов, не выполняется, если сопоставление не определено для конкретного символа.  
  
 .NET Framework предоставляет механизм обработки ошибок, называемый резервным вариантом, если преобразование выполнить невозможно. Все обработчики резервной кодировщика необходимо реализовать следующие:  
  
-   Кодировщик отката, который представлен классом производным от <xref:System.Text.EncoderFallback> класса.  
  
-   Буфер резерва кодировщика, представленный объектом типа, производного от <xref:System.Text.EncoderFallbackBuffer> класс, который может возвращать строку в операцию преобразования.  
  
 В случае ошибки можно использовать три стратегии обработки ошибок преобразования:  
  
-   Наилучшее сопоставление. Буфер резерва кодировщика может возвращать строку, представляющую приближено входной символ. Платформа .NET Framework не предоставляет открытый наилучшего <xref:System.Text.EncoderFallbackBuffer> реализации.  
  
-   Замена. Буфер резерва кодировщика можно вернуть строку, таких как знак вопроса ("?»), которое указывает, что символ не удается закодировать. В платформе .NET Framework <xref:System.Text.EncoderReplacementFallback> и <xref:System.Text.EncoderReplacementFallbackBuffer> классы предоставляют реализацию резервный буфер открытый замены. Конструктор <xref:System.Text.EncoderReplacementFallback> позволяет определить строку замены.  
  
-   Исключение. <xref:System.Text.EncoderFallbackBuffer> Реализация вызывает исключение, которое указывает, что символ не удается закодировать и завершает операции кодирования. В этом случае необходимо предоставить резервному обработчику <xref:System.Text.EncoderFallbackBuffer> реализацию, несмотря на то, что он не возвращает строки в кодировщик. В платформе .NET Framework <xref:System.Text.EncoderExceptionFallback> и <xref:System.Text.EncoderExceptionFallbackBuffer> классы предоставляют реализацию резервной стратегии исключения открытый, которой создается <xref:System.Text.EncoderFallbackException> когда символ не может быть закодирован.  
  
 Буфер, в <xref:System.Text.EncoderFallbackBuffer> реализации представляет всю строку, возвращаемых в ответ на кодировщик кодировщик резервной. Как правило реализации также включают сведения о состоянии, например индекса следующего символа, вернуться к кодировщик и количество оставшихся символов, должны быть возвращены. Поскольку <xref:System.Text.EncoderFallbackBuffer> — это абстрактный класс, требуется производным классам реализовывать по крайней мере следующие члены:  
  
-   Перегруженный <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> метод, который вызывается кодировщиком, когда он не может закодировать символ. Кодировщик передает два блока данных в резервном буфере реализацию: символа или суррогатной пары, который не удалось закодировать и индекс символа во входных данных. В обработчике отката исключений кодировщика исключение в этом методе. В противном случае метод возвращает `true` если оно предоставляет переход на резервный ресурс или `false` Если это не так.  
  
-   <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> Метод, который повторно вызывается кодировщиком, если <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> возвращает `true`. При последующих вызовах обработчик должен возвращать каждый символ в буфере. Вернув все символы, он должен возвращать U + 0000. Обработчик исключений всегда возвращает U + 0000.  
  
-   <xref:System.Text.EncoderFallbackBuffer.MovePrevious%2A> Метод, который пытается переместить указатель в предыдущее расположение в буфере и указывает, успешно ли выполнено перемещение. Всегда возвращает обработчик исключений `false`.  
  
-   <xref:System.Text.EncoderFallbackBuffer.Remaining%2A> Свойство, которое указывает количество оставшихся символов, возвращаемых в кодировщик. Обработчик исключений резервной всегда возвращает ноль.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.EncoderFallback" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected EncoderFallbackBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; EncoderFallbackBuffer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.EncoderFallbackBuffer" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Fallback">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Указывает, что замещающая строка доступна, если исходная входная последовательность не может быть закодирована или если исходная входная последовательность должна быть проигнорирована.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public abstract bool Fallback (char charUnknown, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Fallback(char charUnknown, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.Fallback(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Fallback (charUnknown As Char, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Fallback(char charUnknown, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charUnknown" Type="System.Char" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charUnknown">Входной символ.</param>
        <param name="index">Позиция индекса символа во входном буфере.</param>
        <summary>При переопределении в производном классе готовит резервный буфер для обработки указанного входного символа.</summary>
        <returns>
          <see langword="true" />, если резервный буфер может обработать <paramref name="charUnknown" />; <see langword="false" />, если резервный буфер игнорирует <paramref name="charUnknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> И <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вызов методов <xref:System.Text.DecoderFallbackBuffer.Fallback%28System.Byte%5B%5D%2CSystem.Int32%29> при обнаружении неизвестного входного символа, который не может быть закодирован. Возвращаемое значение `true` указывает, что резервный буфер может обрабатывать входного символа, вследствие чего вызывающий метод, вызываемый <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> метод для получения каждого символа из резервного буфера. Так как он не обрабатывает отдельных символов <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> метод в резервный обработчик исключений вызывает исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public abstract bool Fallback (char charUnknownHigh, char charUnknownLow, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Fallback(char charUnknownHigh, char charUnknownLow, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.Fallback(System.Char,System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Fallback (charUnknownHigh As Char, charUnknownLow As Char, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Fallback(char charUnknownHigh, char charUnknownLow, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charUnknownHigh" Type="System.Char" />
        <Parameter Name="charUnknownLow" Type="System.Char" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charUnknownHigh">Старший символ-заместитель входной пары.</param>
        <param name="charUnknownLow">Младший символ-заместитель входной пары.</param>
        <param name="index">Позиция индекса суррогатной пары во входном буфере.</param>
        <summary>При переопределении в производном классе готовит резервный буфер для обработки указанной суррогатной пары.</summary>
        <returns>
          <see langword="true" />, если резервный буфер может обработать <paramref name="charUnknownHigh" /> и <paramref name="charUnknownLow" />, <see langword="false" />, если резервный буфер игнорирует суррогатную пару.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> И <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вызов методов <xref:System.Text.EncoderFallbackBuffer.Fallback%28System.Char%2CSystem.Char%2CSystem.Int32%29> при обнаружении суррогатной пары во входные данные. Возвращаемое значение `true` указывает, что резервный буфер может обрабатывать суррогатной пары, что приведет к тому вызывающий метод, вызываемый <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> метод для получения каждого символа из резервного буфера.  Так как он не обрабатывает отдельных символов <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> метод в резервный обработчик исключений вызывает исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextChar">
      <MemberSignature Language="C#" Value="public abstract char GetNextChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char GetNextChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.GetNextChar" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNextChar () As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract char GetNextChar();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе извлекает следующий символ в резервном буфере.</summary>
        <returns>Следующий символ в резервном буфере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывает операции кодирования <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> метод, если операция обнаруживает неизвестный символ или суррогатную пару во входных данных. Например, в случае замены задания резервной стратегии, если <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> возвращает метод `true`, замещающая строка существует, можно закодировать вместо неизвестных входных данных. Вызов операции кодирования <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> метода несколько раз и получает один символ замены строки одновременно. Если все знаки в резервном буфере были возвращены в кодировщик <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> метод должен возвращать U + 0000.  
  
 Для обработчика исключений резервной <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> метод должен возвращать U + 0000.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MovePrevious">
      <MemberSignature Language="C#" Value="public abstract bool MovePrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MovePrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.MovePrevious" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MovePrevious () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MovePrevious();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производный класс становится причиной того, что в следующем вызове метод <see cref="M:System.Text.EncoderFallbackBuffer.GetNextChar" /> получает доступ к позиции символа в буфере данных, предшествующей текущей позиции символа.</summary>
        <returns>
          Значение <see langword="true" />, если операция <see cref="M:System.Text.EncoderFallbackBuffer.MovePrevious" /> выполнена успешно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Резервный обработчик исключений должен возвращать `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remaining">
      <MemberSignature Language="C#" Value="public abstract int Remaining { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Remaining" />
      <MemberSignature Language="DocId" Value="P:System.Text.EncoderFallbackBuffer.Remaining" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Remaining As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int Remaining { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе возвращает максимальное число символов в текущем объекте <see cref="T:System.Text.EncoderFallbackBuffer" />, которые остаются для обработки.</summary>
        <value>Количество символов в текущем резервном буфере, которые еще не были обработаны.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> Возвращает `true` Если <xref:System.Text.EncoderFallbackBuffer.Remaining%2A> имеет ненулевое значение.  
  
 Для обработчика исключений резервной <xref:System.Text.DecoderFallbackBuffer.Remaining%2A> метод должен возвращать нуль.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициализирует все данные и сведения о состоянии, относящиеся к этому резервному буферу.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>После вызова метода <see cref="M:System.Text.EncoderFallbackBuffer.Reset" /> метода <see cref="P:System.Text.EncoderFallbackBuffer.Remaining" /> свойство должно возвращать 0, <see cref="M:System.Text.EncoderFallbackBuffer.GetNextChar" /> метод должен возвращать U + 0000 и <see cref="M:System.Text.EncoderFallbackBuffer.MovePrevious" /> метод должен возвращать <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>