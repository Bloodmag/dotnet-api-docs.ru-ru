<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="adda8f83141f6520fcaefa264a4ae9446935542e" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683696" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет кодировку символов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодирование - это процесс преобразования набора символов Юникода в последовательность байтов. В отличие от этого декодирование — это процесс преобразования последовательности закодированных байтов в набор символов Юникода. Сведения о Юникоде преобразование форматов (форматах UTF) и другие кодировки, поддерживаемые <xref:System.Text.Encoding>, в разделе [кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Обратите внимание, что <xref:System.Text.Encoding> предназначен для работы с символами Юникода вместо произвольных двоичных данных, таких как массивы байтов. Если необходимо закодировать произвольные двоичные данные в текст, следует использовать такой протокол, как uuencode, который реализуется методами, такими как <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Платформа .NET Framework предоставляет следующие реализации <xref:System.Text.Encoding> класс для поддержки текущих кодировок Юникода и других кодировок:  
  
-   <xref:System.Text.ASCIIEncoding> Кодирует символы Юникода как один 7-разрядных символов ASCII. Данная кодировка поддерживает только значения символов от U + 0000 и U + 007F. Кодовая страница 20127. Также доступно в <xref:System.Text.Encoding.ASCII%2A> свойство.  
  
-   <xref:System.Text.UTF7Encoding> Кодирует символы Юникода в кодировке UTF-7. Эта кодировка поддерживает все символы Юникода. Кодовая страница 65000. Также доступно в <xref:System.Text.Encoding.UTF7%2A> свойство.  
  
-   <xref:System.Text.UTF8Encoding> Кодирует символы Юникода с использованием кодировки UTF-8. Эта кодировка поддерживает все символы Юникода. Кодовая страница 65001. Также доступно в <xref:System.Text.Encoding.UTF8%2A> свойство.  
  
-   <xref:System.Text.UnicodeEncoding> Кодирует символы Юникода в кодировке UTF-16. Поддерживаются оба порядка прямым порядком следования байтов и больших порядком байтов. Также доступно в <xref:System.Text.Encoding.Unicode%2A> свойство и <xref:System.Text.Encoding.BigEndianUnicode%2A> свойства.  
  
-   <xref:System.Text.UTF32Encoding> Кодирует символы Юникода в кодировке UTF-32. Прямой порядок байтов (кодовая страница 12000) поддерживаются как и байтов с обратным порядком байтов (кодовая страница 12001) заказов. Также доступно в <xref:System.Text.Encoding.UTF32%2A> свойство.  
  
 <xref:System.Text.Encoding> Класс в основном предназначен для преобразования между разными кодировками и Юникодом. Часто один из производных классов Юникода является правильным выбором для вашего приложения.  
  
 Используйте <xref:System.Text.Encoding.GetEncoding%2A> метод для получения других кодировок и вызвать <xref:System.Text.Encoding.GetEncodings%2A> метод для получения списка всех кодировок.  
  
 В следующей таблице перечислены кодировок, поддерживаемых платформой .NET Framework. Перечисляются каждой кодировки номер кодовой страницы и значения кодировки <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> и <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> свойства. Звездочка в последнем столбце указывает, что кодовая страница встроена в .NET Framework, независимо от базовой платформы. Обратите внимание, что кодовые страницы, <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> свойство соответствует международному стандарту не обязательно соответствуют полностью с этого стандарта.  
  
|Кодовая страница|name|Отображаемое имя|Поддержка .NET framework|  
|---------------|----------|------------------|----------------------------|  
|37|IBM037|IBM EBCDIC (США Канада)||  
|437|IBM437|OEM США||  
|500|IBM500|IBM EBCDIC (международный)||  
|708|ASMO-708|Арабский (ASMO 708)||  
|720|DOS-720|Арабский (DOS)||  
|737|ibm737|Греческий (DOS)||  
|775|ibm775|Балтийская (DOS)||  
|850|ibm850|Западноевропейская (DOS)||  
|852|ibm852|Центральная Европа (DOS)||  
|855|IBM855|OEM-кириллица||  
|857|ibm857|Турецкий (DOS)||  
|858|IBM00858|OEM многоязычная латиница I||  
|860|IBM860|Португальский (DOS)||  
|861|ibm861|Исландский (DOS)||  
|862|DOS-862|Иврит (DOS)||  
|863|IBM863|Французский (Канада) (DOS)||  
|864|IBM864|Арабский (864)||  
|865|IBM865|Северная Европа (DOS)||  
|866|cp866|Кириллица (DOS)||  
|869|ibm869|Греческая современная (DOS)||  
|870|IBM870|IBM EBCDIC (многоязыковой латиница-2)||  
|874|Windows 874|Тайский (Windows)||  
|875|cp875|IBM EBCDIC (греческая современная)||  
|932|shift_jis|Японская (Shift-JIS)||  
|936|GB2312|Китайский, упрощенное письмо (GB2312)|✓|  
|949|ks_c_5601-1987|Корейский||  
|950|Big5|Китайская традиционная (Big5)||  
|1026|IBM1026|IBM EBCDIC (турецкий латиница-5)||  
|1047|IBM01047|IBM Latin-1||  
|1140|IBM01140|IBM EBCDIC (США Канада евро)||  
|1141|IBM01141|IBM EBCDIC (Германия евро)||  
|1142|IBM01142|IBM EBCDIC (Дания Норвегия евро)||  
|1143|IBM01143|IBM EBCDIC (евро Финляндия Швеция)||  
|1144|IBM01144|IBM EBCDIC (Италия евро)||  
|1145|IBM01145|IBM EBCDIC (Испания евро)||  
|1146|IBM01146|IBM EBCDIC (UK евро)||  
|1147|IBM01147|IBM EBCDIC (Франция евро)||  
|1148|IBM01148|IBM EBCDIC (международная евро)||  
|1149|IBM01149|IBM EBCDIC (Исландский евро)||  
|1200|UTF-16|Юникод|✓|  
|1201|unicodeFFFE|Юникод (обратный порядок байтов)|✓|  
|1250|Windows-1250|Центральная Европа (Windows)||  
|1251|Windows 1251|Кириллица (Windows)||  
|1252|Windows-1252|Западноевропейская (Windows)|✓|  
|1253|Windows 1253|Греческий (Windows)||  
|1254|Windows 1254|Турецкий (Windows)||  
|1255|Windows 1255|Иврит (Windows)||  
|1256|Windows 1256|Арабский (Windows)||  
|1257|Windows 1257|Балтийская (Windows)||  
|1258|Windows 1258|Вьетнамский (Windows)||  
|1361|Джохаб|Корейская (джохаб)||  
|10000|Macintosh|Западноевропейская (Mac)||  
|10001|x mac японского языка.|Японский (Mac)||  
|10002|x-mac-chinesetrad|Китайский (традиционный) (Mac)||  
|10003|x mac корейского языка.|Корейская (Mac)|✓|  
|10004|x mac арабского языка.|Арабский (Mac)||  
|10005|x-mac иврит|Иврит (Mac)||  
|10006|x mac греческого языков.|Греческий (Mac)||  
|10007|x mac кириллица|Кириллица (Mac)||  
|10008|x-mac-chinesesimp|Китайский, упрощенное письмо (Mac)|✓|  
|10010|x-mac румынский|Румынский (Mac)||  
|10017|x-mac украинский|Украинский (Mac)||  
|10021|x mac тайского языка|Тайский (Mac)||  
|10029|x-mac-ce|Центральная Европа (Mac)||  
|10079|x-mac исландская|Исландский (Mac)||  
|10081|x mac турецкого языка|Турецкий (Mac)||  
|10082|x — mac Хорватский|Хорватский (Mac)||  
|12000|UTF-32|Юникод (UTF-32)|✓|  
|12001|utf-32BE|Юникод (UTF-32 с прямым порядком байтов)|✓|  
|20000|x китайский общих ИМЕН.|Китайский традиционный (имена Сертификатов)||  
|20001|x cp20001|TCA-тайваньская||  
|20002|x китайский Eten|Китайский традиционный (Eten)||  
|20003|x cp20003|IBM5550-тайваньская||  
|20004|x cp20004|Тайваньский телетекста||  
|20005|x cp20005|Тайваньский Wang||  
|20105|x IA5|Западноевропейская (IA5)||  
|20106|x IA5 немецкого языка.|Немецкий (IA5)||  
|20107|x-IA5 — шведский|Шведский (IA5)||  
|20108|x-IA5-норвежский|Норвежский (IA5)||  
|20127|US-ascii|US-ASCII|✓|  
|20261|x cp20261|T.61||  
|20269|x cp20269|ISO-6937||  
|20273|IBM273|IBM EBCDIC (Германия)||  
|20277|IBM277|IBM EBCDIC (Дания Норвегия)||  
|20278|IBM278|IBM EBCDIC (Финляндия и Швеция)||  
|20280|IBM280|IBM EBCDIC (Италия)||  
|20284|IBM284|IBM EBCDIC (Испания)||  
|20285|IBM285|IBM EBCDIC (ВЕЛИКОБРИТАНИЯ)||  
|20290|IBM290|IBM EBCDIC (японская катакана)||  
|20297|IBM297|IBM EBCDIC (Франция)||  
|20420|IBM420|IBM EBCDIC (арабский)||  
|20423|IBM423|IBM EBCDIC (русский)||  
|20424|IBM424|IBM EBCDIC (иврит)||  
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC (Корейская расширенная)||  
|20838|Тайский IBM|IBM EBCDIC (тайский)||  
|20866|КОИ8 r|Кириллица (КОИ8 R)||  
|20871|IBM871|IBM EBCDIC (исландская)||  
|20880|IBM880|IBM EBCDIC (кириллица русский)||  
|20905|IBM905|IBM EBCDIC (турецкий)||  
|20924|IBM00924|IBM Latin-1||  
|20932|EUC-JP|Японская (JIS 0208-1990 и 0212-1990)||  
|20936|x cp20936|Китайский, упрощенное письмо (GB2312-80)|✓|  
|20949|x cp20949|Корейский Wansung|✓|  
|21025|cp1025|IBM EBCDIC (кириллица болгарский Сербский)||  
|21866|КОИ8 u|Кириллица (КОИ8 U)||  
|28591|ISO-8859-1|Западноевропейская (ISO)|✓|  
|28592|ISO-8859-2|Центральная Европа (ISO)||  
|28593|ISO-8859-3|Латиница 3 (ISO)||  
|28594|ISO-8859-4|Балтийская (ISO)||  
|28595|ISO-8859-5|Кириллица (ISO)||  
|28596|ISO-8859-6|Арабский (ISO)||  
|28597|ISO-8859-7|Греческий (ISO)||  
|28598|ISO-8859-8|Иврит (ISO-Visual)|✓|  
|28599|ISO-8859-9|Турецкий (ISO)||  
|28603|ISO-8859-13|Эстонский (ISO)||  
|28605|ISO-8859-15|Латиница 9 (ISO)||  
|29001|x Europa|Europa||  
|38598|ISO-8859-8-i|Иврит (ISO логический)|✓|  
|50220|ISO-2022-jp|Японская (JIS)|✓|  
|50221|csISO2022JP|Японская (JIS однобайтная кана)|✓|  
|50222|ISO-2022-jp|Японская (JIS однобайтная кана с JIS - т / SI)|✓|  
|50225|ISO-2022-kr|Корейская (ISO)|✓|  
|50227|x-cp50227|Китайский, упрощенное письмо (ISO-2022)|✓|  
|51932|EUC-jp|Японский (EUC)|✓|  
|51936|EUC CN|Китайский, упрощенное письмо (EUC)|✓|  
|51949|EUC kr|Корейский (EUC)|✓|  
|52936|Гц gb-2312|Китайский, упрощенное письмо (ГЦ)|✓|  
|54936|GB18030|Китайская упрощенная (GB18030)|✓|  
|57002|x-iscii-de.|ISCII деванагари|✓|  
|57003|x iscii быть|Бенгальский ISCII|✓|  
|57004|x-iscii-ta|Тамильский ISCII|✓|  
|57005|x-iscii-te|Телугу ISCII|✓|  
|57006|x iscii как|Ассамский ISCII|✓|  
|57007|или x iscii|Ория ISCII|✓|  
|57008|x-iscii ка|Каннада ISCII|✓|  
|57009|x iscii скользящее среднее|Малайялам ISCII|✓|  
|57010|x iscii графического интерфейс|Гуджарати ISCII|✓|  
|57011|x-iscii-pa|Панджаби ISCII|✓|  
|65000|UTF-7|Юникод (UTF-7)|✓|  
|65001|UTF-8|Юникод (UTF-8)|✓|  
  
 В следующем примере вызывается <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> и <xref:System.Text.Encoding.GetEncoding%28System.String%29> методы получения греческий (Windows) код страницы кодировки. Он сравнивает <xref:System.Text.Encoding> объектов, возвращенных вызовы методов, чтобы показать, что они равны, и затем отображает maps кодовая точка Юникода и соответствующие значение кодовой страницы для каждого символа в Греческий алфавит.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 UTF-16 и UTF-32 кодировщики можно использовать обратный порядок байтов (самый старший байт первый) или в прямом порядке байтов (младший байт первый). Например прописная латинская буква (U + 0041) сериализуется как выглядит следующим образом (в шестнадцатеричном формате).  
  
-   Обратный порядок следования байтов UTF-16: 00 41  
  
-   UTF-16 прямом порядке байтов: 41 00  
  
-   UTF-32 обратный порядок байтов: 00 00 00 41  
  
-   UTF-32 прямом порядке байтов: 41 00 00 00  
  
 Может оказаться более эффективным, для хранения символов Юникода с использованием собственного порядка байтов. Например лучше использовать прямом порядке байтов на платформах с прямым порядком, таких как компьютеры Intel.  
  
 <xref:System.Text.Encoding.GetPreamble%2A> Извлекает массив байтов, который включает отметку порядка байтов (BOM). Если указан как префикс этот массив байтов в поток в кодировке, декодер определить используемый формат кодировки.  
  
 Дополнительные сведения о порядке байтов и метка порядка байтов в разделе Юникод [домашней странице Юникода](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Обратите внимание, что классы кодировок позволяют ошибки:  
  
-   Без предупреждения изменять для «?» символов.  
  
-   Используйте символ «оптимальных параметров».  
  
-   Изменить на поведение конкретного приложения с использованием <xref:System.Text.EncoderFallback> и <xref:System.Text.DecoderFallback> классы с замещающий символ U + FFFD Юникода.  
  
 Для ошибок потока данных должно создавать исключения. Приложение использует флаг «throwonerror», если применимо, или использует <xref:System.Text.EncoderExceptionFallback> и <xref:System.Text.DecoderExceptionFallback> классы. Наиболее подходящая fallback часто не рекомендуется, так как он может привести к потере данных или путаницы и медленнее, чем обычная замена символов. Для кодировки ANSI рекомендуется применять эту стратегию значение по умолчанию.  
  
   
  
## Examples  
 В следующем примере строка преобразуется из одной кодировки в другую.  
  
> [!NOTE]
>  Массив byte [] является единственным типом в данном примере, который содержит закодированные данные. .NET Char и строковые типы являются сами по себе Юникод, поэтому <xref:System.Text.Encoding.GetChars%2A> вызов декодирует данные в формат Юникод.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производные классы переопределяют этот конструктор.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">Идентификатор кодовой страницы предпочтительной кодировки.  
  
 - или -  
  
 0, если требуется использовать кодировку по умолчанию.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />, соответствующий заданной кодовой странице.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производные классы переопределяют этот конструктор.  
  
 Создание вызовов этот конструктор производного класса <xref:System.Text.Encoding> объект, который использует резервную стратегию наилучшего соответствия для кодирования и декодирования операций. Как <xref:System.Text.Encoding.DecoderFallback%2A> и <xref:System.Text.Encoding.EncoderFallback%2A> свойства доступны только для чтения и не может быть изменено. Для управления резервной стратегии для класса, производного от <xref:System.Text.Encoding>, вызовите <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="codePage" /> меньше нуля.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">Идентификатор кодовой страницы кодировки.</param>
        <param name="encoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда символ не может быть закодирован с использованием текущей кодировки.</param>
        <param name="decoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда последовательность байтов не может быть декодирована с использованием текущей кодировки.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />, соответствующий заданной кодовой странице, с использованием указанных стратегий резервирования кодировщика и декодера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор является `protected`; производные классы переопределить его.  
  
 Вызов этого конструктора производного класса для управления этот резервный механизм кодирования и декодирования стратегии. <xref:System.Text.Encoding> Конструкторы класса создать только для чтения кодирования объектами, которые не допускают кодировщика или декодера отката для установки, после создания объекта.  
  
 Если параметр `encoderFallback` или `decoderFallback` имеет значение null, используется стратегия наилучшего соответствия в качестве соответствующей резервной стратегии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="codePage" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для набора символов ASCII (7-разрядных).</summary>
        <value>Кодировка набора символов ASCII (7-разрядных).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Символы ASCII ограничены нижними 128 символами Юникода, от U + 0000 до U + 007F.  
  
 При выборе кодировки ASCII для вашего приложения, учитывайте следующее:  
  
-   Кодировка ASCII обычно подходит для протоколов, требующих ASCII.  
  
-   Если вам требуется 8-разрядная кодировка (которое иногда ошибочно называют «ASCII»), кодировка UTF-8 предпочтительнее ASCII кодирования. Для символов 0-7F результаты одинаковы, но использование UTF-8 позволяет избежать потери данных благодаря возможности представления всех символов Юникода, которые можно представить. Обратите внимание, что в кодировке ASCII 8-го бит неоднозначности, допускающая злонамеренное использование, но кодировку UTF-8 устраняет эту неопределенность 8-й бит.  
  
-   До .NET Framework версии 2.0 .NET Framework разрешен спуфинг, игнорируя 8-й бит. Начиная с .NET Framework 2.0, не относящихся к ASCII кодовые точки откат во время декодирования.  
  
 <xref:System.Text.ASCIIEncoding> Объект, возвращаемый этим свойством не может иметь необходимого поведения для вашего приложения. Он использует резервную стратегию замены для замены каждой строки, он не может закодировать и каждый байт, он не может декодировать, вопросительным знаком ("?») символов. Вместо этого можно вызвать метод <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> метод для создания <xref:System.Text.ASCIIEncoding> объект которого является либо <xref:System.Text.EncoderFallbackException> или <xref:System.Text.DecoderFallbackException>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 В следующем примере показано влияние кодировки ASCII на символы, которые находятся за пределами диапазона ASCII.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для формата UTF-16 с обратным порядком байтов.</summary>
        <value>Объект кодировки для формата UTF-16 с обратным порядком байтов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding> Объект, возвращаемый этим свойством не может иметь необходимого поведения для вашего приложения. Он использует резервную стратегию замены для замены каждой строки, он не может закодировать и каждый байт, он не может декодировать, вопросительным знаком ("?») символов. Вместо этого можно вызвать метод <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> конструктор для создания экземпляра с обратным порядком байтов <xref:System.Text.UnicodeEncoding> объект которого является либо <xref:System.Text.EncoderFallbackException> или <xref:System.Text.DecoderFallbackException>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 Возвращенный <xref:System.Text.UnicodeEncoding> объект имеет <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, и <xref:System.Text.Encoding.WebName%2A> свойства, позволяющие найти имя «unicodeFFFE». Несмотря на то, что метка порядка обратным порядком байтов UTF-16 — шестнадцатеричное число FEFF, имя «unicodeFFFE» была выбрана, так как метка порядка байтов отображается как шестнадцатеричное число FFFE на компьютерах с прямым порядком байтов Windows.  
  
   
  
## Examples  
 В следующем примере считывается в текстовый файл с кодировкой UTF-16, используя обратный порядок байтов.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 Приведенный ниже определяет число байтов, необходимых для кодирования массива символов, выполняется кодирование символов и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает имя текущей кодировки, которое может использоваться с тегами текста сообщения почтового агента.</summary>
        <value>Имя текущего объекта <see cref="T:System.Text.Encoding" />, которое может использоваться с тегами текста сообщения почтового агента.  
  
 - или -  
  
 Пустая строка (""), если текущий объект <see cref="T:System.Text.Encoding" /> не может использоваться.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При необходимости кодировку для имя тела, необходимо вызвать <xref:System.Text.Encoding.GetEncoding%2A> с <xref:System.Text.Encoding.BodyName%2A> свойство. Этот метод часто извлекает другую кодировку из тестовой кодировки, для которой он вызывается. Обычно только почтовые приложения необходимо получить такое кодирование; Большинство других приложений, чтобы описать кодировку следует использовать его <xref:System.Text.Encoding.WebName%2A>.  
  
 В некоторых случаях значение <xref:System.Text.Encoding.BodyName%2A> свойство соответствует свойству международный стандарт, который определяет эту кодировку. Это не означает соответствия реализация полностью с этого стандарта.  
  
   
  
## Examples  
 В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки, имеющие одно или несколько имен, которые отличаются от <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Он отображает <xref:System.Text.Encoding.EncodingName%2A> , но сравниваются по нему.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создается неполная копия текущего объекта <see cref="T:System.Text.Encoding" />.</summary>
        <returns>Копия текущего объекта <see cref="T:System.Text.Encoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Копия класса доступна для записи даже в том случае, если исходный <xref:System.Text.Encoding> объект доступен только для чтения. Таким образом можно изменить свойства копии.  
  
 Неполная копия объекта является копией только данного объекта. Если в объекте содержатся ссылки на другие объекты, создаются в неполной копии не объектов, который ссылается. Он ссылается на исходные объекты вместо него. Напротив глубокую копию объекта создает копию объекта и копию всего содержимого, прямо или косвенно ссылается этот объект.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает идентификатор кодовой страницы текущего объекта <see cref="T:System.Text.Encoding" />.</summary>
        <value>Идентификатор кодовой страницы текущего объекта <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки, имеющие одно или несколько имен, которые отличаются от <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Он отображает <xref:System.Text.Encoding.EncodingName%2A> , но сравниваются по нему.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует массив байтов из одной кодировки в другую.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Формат кодировки параметра <c>bytes</c>.</param>
        <param name="dstEncoding">Целевой формат кодировки.</param>
        <param name="bytes">Преобразуемые байты.</param>
        <summary>Преобразует весь массив байтов из одной кодировки в другую.</summary>
        <returns>Массив типа <see cref="T:System.Byte" />, содержащий результаты преобразования <paramref name="bytes" /> из <paramref name="srcEncoding" /> в <paramref name="dstEncoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример преобразует строку в кодировке Юникод в строки в кодировке ASCII. Поскольку возвращенный объект кодировки ASCII <xref:System.Text.Encoding.ASCII%2A> свойство использует резервную стратегию замены и Pi символ не является частью набора символов ASCII, знак Pi заменяется вопросительным знаком, как показано в примере выходных данных.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="srcEncoding" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="dstEncoding" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 **srcEncoding.** Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 **dstEncoding.** Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Кодировка исходного массива, <c>bytes</c>.</param>
        <param name="dstEncoding">Кодировка выходного массива.</param>
        <param name="bytes">Преобразуемый массив байтов.</param>
        <param name="index">Индекс первого элемента преобразуемого массива <c>bytes</c>.</param>
        <param name="count">Число байтов, которые требуется преобразовать.</param>
        <summary>Преобразует диапазон байтов в массиве байтов из одной кодировки в другую.</summary>
        <returns>Массив типа <see cref="T:System.Byte" />, содержащий результат преобразования диапазона байтов из массива <paramref name="bytes" /> из <paramref name="srcEncoding" /> в <paramref name="dstEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="srcEncoding" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="dstEncoding" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> и <paramref name="count" /> не определяют допустимый диапазон в массиве байтов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 **srcEncoding.** Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 **dstEncoding.** Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Text.DecoderFallback" /> для текущего объекта <see cref="T:System.Text.Encoding" />.</summary>
        <value>Резервный объект декодера для текущего объекта <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback> Объект представляет обработчик ошибок, который вызывается, когда не удается декодировать в закодированную последовательность байтов в символ. Один из следующих типов обработчика поддерживается:  
  
-   Стратегия наилучшего соответствия резервному обработчику, который заменяет байтов, которые не удается декодировать символ некоторые подходящие замены.  
  
-   Замена резервному обработчику, который заменяет некоторые произвольный замещающий символ байтов, которые не удается декодировать. Платформа .NET Framework включает один резервному обработчику замены <xref:System.Text.DecoderFallback>, по умолчанию заменяет байтов, которые не удается декодировать, вопросительным знаком ("?») символов.  
  
-   Резервный обработчика исключений, который создает исключение, если байт не может быть декодирована. Платформа .NET Framework включает один резервный обработчик исключений <xref:System.Text.DecoderExceptionFallback>, какие вызывает <xref:System.Text.DecoderFallbackException> когда не удается декодировать байты.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Для данного свойства задано значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Невозможно задать значение, поскольку текущий объект <see cref="T:System.Text.Encoding" /> предназначен только для чтения.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает кодировку по умолчанию для данной реализации .NET.</summary>
        <value>Кодировка по умолчанию для данной реализации .NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Разные компьютеры могут использовать различные кодировки по умолчанию и кодировку по умолчанию можно изменить на одном компьютере. Если вы используете <xref:System.Text.Encoding.Default%2A> кодировка для кодирования и декодирования данных потоковой передачи между компьютерами или извлечь в разное время на одном компьютере может преобразовать эти данные неправильно. Кроме того, кодировка возвращенных <xref:System.Text.Encoding.Default%2A> свойство использует резервную стратегию наилучшего соответствия для сопоставления символы, поддерживаемые в кодовой странице неподдерживаемые символы. По этим причинам с использованием кодировки по умолчанию не рекомендуется. Чтобы обеспечить правильное декодирование закодированных байтов, следует использовать кодировку Юникод, таких как <xref:System.Text.UTF8Encoding> или <xref:System.Text.UnicodeEncoding>. Также можно использовать протокол более высокого уровня, чтобы убедиться, что тот же формат используется для кодирования и декодирования.  

### <a name="the-default-property-in-the-net-framework"></a>Свойство по умолчанию в платформе .NET Framework

В платформе .NET Framework, на рабочем столе Windows <xref:System.Text.Encoding.Default%2A> свойство всегда возвращает active кодовой страницы системы и создает <xref:System.Text.Encoding> объекта, который соответствует к нему. Текущая кодовая страница может быть кодовой страницей ANSI, которая включает кодировки ASCII и дополнительные символы, которые различаются по кодовой странице. Так как все <xref:System.Text.Encoding.Default%2A> кодировки, кодовые страницы ANSI потерять данные, рассмотрите возможность использования <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> вместо кодировки. UTF-8 идентична часто в U + 00 диапазона U + 7F, но позволяет кодировать символы за пределами диапазона ASCII без потери.

## <a name="the-default-property-on-net-core"></a>Свойство по умолчанию на основе .NET Core

На основе .NET Core <xref:System.Text.Encoding.Default%2A> свойство всегда возвращает <xref:System.Text.UTF8Encoding>. UTF-8 поддерживается на всех операционных систем (Windows, Linux и Max OS X) на котором выполняются приложения .NET Core.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Text.EncoderFallback" /> для текущего объекта <see cref="T:System.Text.Encoding" />.</summary>
        <value>Резервный объект кодировщика для текущего объекта <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.EncoderFallback> Объект представляет обработчик ошибок, который вызывается, когда символ не может преобразован в закодированную последовательность байтов. Один из следующих типов обработчика поддерживается:  
  
-   Стратегия наилучшего соответствия резервному обработчику, который заменяет символы, которые не удается закодировать определенным символом подходящие замены.  
  
-   Замена резервному обработчику, который заменяет символы, которые не удается закодировать некоторых произвольных замещающий символ. Платформа .NET Framework включает один обработчик резервной замены, <xref:System.Text.EncoderFallback>, по умолчанию заменяет символы, которые не удается закодировать с вопросительным знаком ("?») символов.  
  
-   Резервный обработчика исключений, который создает исключение, если символы не может быть закодирован. Платформа .NET Framework включает один резервный обработчик исключений <xref:System.Text.EncoderExceptionFallback>, какие вызывает <xref:System.Text.EncoderFallbackException> когда не удается декодировать символов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Для данного свойства задано значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Невозможно задать значение, поскольку текущий объект <see cref="T:System.Text.Encoding" /> предназначен только для чтения.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает описание текущей кодировки, которое может быть прочитано пользователем.</summary>
        <value>Описание текущего объекта <see cref="T:System.Text.Encoding" />, которое может быть прочитано пользователем.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.EncodingName%2A> Свойство предназначено для отображения. Чтобы найти имя, которое может быть передан <xref:System.Text.Encoding.GetEncoding%2A> используйте <xref:System.Text.Encoding.WebName%2A> свойство.  
  
   
  
## Examples  
 В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки, имеющие одно или несколько имен, которые отличаются от <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Он отображает <xref:System.Text.Encoding.EncodingName%2A> , но сравниваются по нему.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> для сравнения с текущим экземпляром.</param>
        <summary>Определяет, равен ли указанный объект <see cref="T:System.Object" /> текущему экземпляру.</summary>
        <returns>
          Значение <see langword="true" />, если <paramref name="value" /> является экземпляром <see cref="T:System.Text.Encoding" />, равным текущему экземпляру; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Два экземпляра <xref:System.Text.Encoding> считаются равными, если они соответствуют ту же кодовую страницу и их `EncoderFallback` и `DecoderFallback` объекты равны. В частности, все производные кодовые страницы имеют кодовую страницу 0 и их резервные варианты обычно `null` (`Nothing` в Visual Basic .NET). Таким образом они считаются равными. Одно из них является то, что при <xref:System.Text.Encoding.Equals%2A> используется для заполнения хэш-таблицу, все производные кодировки считаются равными и попадают в один и тот же слот таблицы хэша.  
  
   
  
## Examples  
 Следующий пример возвращает два экземпляра одной кодировки (один по кодовой странице), а другой — по имени и проверки их равенства.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе вычисляет количество байтов, полученных при кодировании набора символов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий символы, которые требуется закодировать.</param>
        <summary>При переопределении в производном классе вычисляет количество байтов, полученных при кодировании всех символов из заданного массива символов.</summary>
        <returns>Количество байтов, полученных при кодировании всех символов из указанного массива символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.Encoding.GetBytes%2A> для сохранения полученные байты, вызвать <xref:System.Text.Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно обеспечивает выделения меньше памяти, пока <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байт привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактической кодировкой. <xref:System.Text.Encoding.GetBytes%2A> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обрабатывать эти символы, с помощью нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами с учетом состояния, которое сохраняется <xref:System.Text.Encoder> объект используется.  
  
-   Если приложение обрабатывает входные строки, следует использовать строку версии <xref:System.Text.Encoding.GetBytes%2A> метод.  
  
-   Версия буфер символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно в несколько вызовов с помощью <xref:System.Text.Encoder> объекта или вставка в существующие буферы. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, следует использовать выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивов байтов является лучшим вариантом.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует возможный объем данных, а вызывает исключение, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим вариантом.  
  
   
  
## Examples  
 Приведенный ниже определяет число байтов, необходимых для кодирования массива символов, выполняется кодирование символов и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая набор символов для кодирования.</param>
        <summary>При переопределении в производном классе вычисляет число байтов, полученных при кодировании символов в заданной строке.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.Encoding.GetBytes%2A> для сохранения полученные байты, вызвать <xref:System.Text.Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно обеспечивает выделения меньше памяти, пока <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байт привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактической кодировкой. <xref:System.Text.Encoding.GetBytes%2A> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обрабатывать эти символы, с помощью нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами с учетом состояния, которое сохраняется <xref:System.Text.Encoder> объект используется.  
  
-   Если приложение обрабатывает входные строки, строковую версию <xref:System.Text.Encoding.GetBytes%2A> рекомендуется.  
  
-   Версия буфер символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно в несколько вызовов с помощью <xref:System.Text.Encoder> объекта или вставка в существующие буферы. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивов байтов является лучшим вариантом.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует возможный объем данных, а вызывает исключение, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим вариантом.  
  
   
  
## Examples  
 Следующий пример определяет число байтов, необходимых для кодирования строки или диапазона в строке, выполняется кодирование символов и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Указатель на первый кодируемый символ.</param>
        <param name="count">Число кодируемых символов.</param>
        <summary>При переопределении в производном классе вычисляет количество байтов, полученных при кодировании набора символов, начиная с заданного указателя символа.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления массиве точный размер, <xref:System.Text.Encoding.GetBytes%2A> требуется для хранения байтов, необходимо вызвать <xref:System.Text.Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно обеспечивает выделения меньше памяти, пока <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> Метод определяет, сколько байт привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> метод выполняет фактической кодировкой. <xref:System.Text.Encoding.GetBytes%2A> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые рекомендации по использованию этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обрабатывать эти символы, с помощью нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами с учетом состояния, которое сохраняется <xref:System.Text.Encoder> объект используется.  
  
-   Если приложение обрабатывает входные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A> метод.  
  
-   Версия буфер символов Юникода <xref:System.Text.Encoding.GetBytes%2A> позволяет использовать некоторые быстрые способы, особенно в несколько вызовов с помощью <xref:System.Text.Encoder> объекта или вставка в существующие буферы. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивов байтов является лучшим вариантом.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует возможный объем данных, а вызывает исключение, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим вариантом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий набор кодируемых символов.</param>
        <param name="index">Индекс первого кодируемого символа.</param>
        <param name="count">Число кодируемых символов.</param>
        <summary>При переопределении в производном классе вычисляет количество байтов, полученных при кодировании набора символов из указанного массива символов.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.Encoding.GetBytes%2A> для сохранения полученные байты, вызвать <xref:System.Text.Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно обеспечивает выделения меньше памяти, пока <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байт привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактической кодировкой. <xref:System.Text.Encoding.GetBytes%2A> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обрабатывать эти символы, с помощью нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами с учетом состояния, которое сохраняется <xref:System.Text.Encoder> объект используется.  
  
-   Если приложение обрабатывает входные строки, строковую версию <xref:System.Text.Encoding.GetBytes%2A> рекомендуется.  
  
-   Версия буфер символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно в несколько вызовов с помощью <xref:System.Text.Encoder> объекта или вставка в существующие буферы. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивов байтов является лучшим вариантом.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует возможный объем данных, а вызывает исключение, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим вариантом.  
  
   
  
## Examples  
 Приведенный ниже определяет число байтов, необходимое для кодирования трех символов из массива символов, выполняется кодирование символов и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе кодирует набор символов в последовательность байтов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий символы, которые требуется закодировать.</param>
        <summary>При переопределении в производном классе кодирует все символы из указанного массива символов в последовательность байтов.</summary>
        <returns>Массив байтов, содержащий результаты кодирования указанного набора символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байт привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактической кодировкой. <xref:System.Text.Encoding.GetBytes%2A> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обрабатывать эти символы, с помощью нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами с учетом состояния, которое сохраняется <xref:System.Text.Encoder> объект используется. (Например, последовательность символов, которая содержит пары символов-заместителей может заканчиваться старшим символом-заместителем. <xref:System.Text.Encoder> Запомнит старший символ-заместитель, чтобы ее можно использовать совместно с младшим символом-заместителем в начале следующего вызова. <xref:System.Text.Encoding> Невозможно использовать для сохранения состояния, поэтому символ будет отправляться <xref:System.Text.EncoderFallback>.)  
  
-   Если приложение обрабатывает входные строки, следует вызывать строковую версию <xref:System.Text.Encoding.GetBytes%2A> метод.  
  
-   Версия буфер символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно в несколько вызовов с помощью <xref:System.Text.Encoder> объекта или вставка в существующие буферы. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивов байтов является лучшим вариантом.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует возможный объем данных, а вызывает исключение, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим вариантом.  
  
   
  
## Examples  
 Приведенный ниже определяет число байтов, необходимых для кодирования массива символов, выполняется кодирование символов и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая символы, которые требуется закодировать.</param>
        <summary>При переопределении в производном классе кодирует все символы заданной строки в последовательность байтов.</summary>
        <returns>Массив байтов, содержащий результаты кодирования указанного набора символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байт привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактической кодировкой. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обрабатывать эти символы, с помощью нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами с учетом состояния, которое сохраняется <xref:System.Text.Encoder> объект используется. (Например, последовательность символов, которая содержит пары символов-заместителей может заканчиваться старшим символом-заместителем. <xref:System.Text.Encoder> Запомнит старший символ-заместитель, чтобы ее можно использовать совместно с младшим символом-заместителем в начале следующего вызова. <xref:System.Text.Encoding> Невозможно использовать для сохранения состояния, поэтому символ будет отправляться <xref:System.Text.EncoderFallback>.)  
  
-   Если приложение обрабатывает входные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Версия буфер символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно в несколько вызовов с помощью <xref:System.Text.Encoder> объекта или вставка в существующие буферы. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивов байтов является лучшим вариантом.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует возможный объем данных, а вызывает исключение, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим вариантом.  
  
   
  
## Examples  
 Следующий пример определяет число байтов, необходимых для кодирования строки или диапазона в строке, выполняется кодирование символов и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий набор кодируемых символов.</param>
        <param name="index">Индекс первого кодируемого символа.</param>
        <param name="count">Число кодируемых символов.</param>
        <summary>При переопределении в производном классе кодирует набор символов из указанного массива символов в последовательность байтов.</summary>
        <returns>Массив байтов, содержащий результаты кодирования указанного набора символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байт привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактической кодировкой. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обрабатывать эти символы, с помощью нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами с учетом состояния, которое сохраняется <xref:System.Text.Encoder> объект используется. (Например, последовательность символов, которая содержит пары символов-заместителей может заканчиваться старшим символом-заместителем. <xref:System.Text.Encoder> Запомнит старший символ-заместитель, чтобы ее можно использовать совместно с младшим символом-заместителем в начале следующего вызова. <xref:System.Text.Encoding> Невозможно использовать для сохранения состояния, поэтому символ будет отправляться <xref:System.Text.EncoderFallback>.)  
  
-   Если приложение обрабатывает входные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Версия буфер символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно в несколько вызовов с помощью <xref:System.Text.Encoder> объекта или вставка в существующие буферы. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивов байтов является лучшим вариантом.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует возможный объем данных, а вызывает исключение, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим вариантом.  
  
   
  
## Examples  
 Приведенный ниже определяет число байтов, необходимое для кодирования трех символов из массива символов, выполняется кодирование символов и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Указатель на первый кодируемый символ.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Указатель на положение, с которого начинается запись результирующей последовательности байтов.</param>
        <param name="byteCount">Максимальное число байтов для записи.</param>
        <summary>При переопределении в производном классе кодирует набор символов, начало которого задается указателем символа, в последовательность байтов, которые сохраняются, начиная с заданного указателя байта.</summary>
        <returns>Фактическое число байтов, записанных в местоположение, которое задано параметром <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления массиве точный размер, <xref:System.Text.Encoding.GetBytes%2A> требует, чтобы сохранить полученные байты, вызовите <xref:System.Text.Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно обеспечивает выделения меньше памяти, пока <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> объект, предоставляемый <xref:System.Text.Encoding.GetDecoder%2A>настроек или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байт привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактической кодировкой. <xref:System.Text.Encoding.GetBytes%2A> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обрабатывать эти символы, с помощью нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами с учетом состояния, которое сохраняется <xref:System.Text.Encoder> объект используется. (Например, последовательность символов, которая содержит пары символов-заместителей может заканчиваться старшим символом-заместителем. <xref:System.Text.Encoder> Запомнит старший символ-заместитель, чтобы ее можно использовать совместно с младшим символом-заместителем в начале следующего вызова. <xref:System.Text.Encoding> Невозможно использовать для сохранения состояния, поэтому символ будет отправляться <xref:System.Text.EncoderFallback>.)  
  
-   Если приложение обрабатывает входные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Версия буфер символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно в несколько вызовов с помощью <xref:System.Text.Encoder> объекта или вставка в существующие буферы. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивов байтов является лучшим вариантом.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует возможный объем данных, а вызывает исключение, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим вариантом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="chars" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="charCount" /> или <paramref name="byteCount" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> меньше результирующего числа байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий набор кодируемых символов.</param>
        <param name="charIndex">Индекс первого кодируемого символа.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Массив байтов, в который будет помещена результирующая последовательность байтов.</param>
        <param name="byteIndex">Индекс, с которого начинается запись результирующей последовательности байтов.</param>
        <summary>При переопределении в производном классе кодирует набор символов из указанного массива символов в указанный массив байтов.</summary>
        <returns>Фактическое число байтов, записанных в <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.Encoding.GetBytes%2A> для хранения байтов, необходимо вызвать <xref:System.Text.Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно обеспечивает выделения меньше памяти, пока <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байт привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактической кодировкой. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обрабатывать эти символы, с помощью нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами с учетом состояния, которое сохраняется <xref:System.Text.Encoder> объект используется. (Например, последовательность символов, которая содержит пары символов-заместителей может заканчиваться старшим символом-заместителем. <xref:System.Text.Encoder> Запомнит старший символ-заместитель, чтобы ее можно использовать совместно с младшим символом-заместителем в начале следующего вызова. <xref:System.Text.Encoding> Невозможно использовать для сохранения состояния, поэтому символ будет отправляться <xref:System.Text.EncoderFallback>.)  
  
-   Если приложение обрабатывает входные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Версия буфер символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно в несколько вызовов с помощью <xref:System.Text.Encoder> объекта или вставка в существующие буферы. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивов байтов является лучшим вариантом.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует возможный объем данных, а вызывает исключение, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим вариантом.  
  
   
  
## Examples  
 Приведенный ниже определяет число байтов, необходимое для кодирования трех символов из массива символов, выполняется кодирование символов и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="chars" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="charIndex" />, <paramref name="charCount" /> или <paramref name="byteIndex" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="charIndex" /> и <paramref name="charCount" /> не указывают допустимый диапазон в <paramref name="chars" />.  
  
 - или -  
  
 Значение параметра <paramref name="byteIndex" /> не является допустимым индексом в <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          Недостаточно емкости <paramref name="bytes" /> от <paramref name="byteIndex" /> до конца массива для размещения полученных байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая набор символов для кодирования.</param>
        <param name="charIndex">Индекс первого кодируемого символа.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Массив байтов, в который будет помещена результирующая последовательность байтов.</param>
        <param name="byteIndex">Индекс, с которого начинается запись результирующей последовательности байтов.</param>
        <summary>При переопределении в производном классе кодирует набор символов из заданной строки в заданный массив байтов.</summary>
        <returns>Фактическое число байтов, записанных в <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.Encoding.GetBytes%2A> для хранения байтов, необходимо вызвать <xref:System.Text.Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно обеспечивает выделения меньше памяти, пока <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байт привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактической кодировкой. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обрабатывать эти символы, с помощью нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами с учетом состояния, которое сохраняется <xref:System.Text.Encoder> объект используется. (Например, последовательность символов, которая содержит пары символов-заместителей может заканчиваться старшим символом-заместителем. <xref:System.Text.Encoder> Запомнит старший символ-заместитель, чтобы ее можно использовать совместно с младшим символом-заместителем в начале следующего вызова. <xref:System.Text.Encoding> Невозможно использовать для сохранения состояния, поэтому символ будет отправляться <xref:System.Text.EncoderFallback>.)  
  
-   Если приложение обрабатывает входные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Версия буфер символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно в несколько вызовов с помощью <xref:System.Text.Encoder> объекта или вставка в существующие буферы. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивов байтов является лучшим вариантом.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует возможный объем данных, а вызывает исключение, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим вариантом.  
  
   
  
## Examples  
 Следующий пример определяет число байтов, необходимых для кодирования строки или диапазона в строке, выполняется кодирование символов и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="s" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="charIndex" />, <paramref name="charCount" /> или <paramref name="byteIndex" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="charIndex" /> и <paramref name="charCount" /> не указывают допустимый диапазон в <paramref name="chars" />.  
  
 - или -  
  
 Значение параметра <paramref name="byteIndex" /> не является допустимым индексом в <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          Недостаточно емкости <paramref name="bytes" /> от <paramref name="byteIndex" /> до конца массива для размещения полученных байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании всех байтов из заданного массива байтов.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> для хранения полученных символов, следует использовать <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> метода. Чтобы вычислить максимальный размер массива, необходимо использовать <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> метода. <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Метод обычно обеспечивает выделения меньше памяти, пока <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> метод, который обрабатывает несколько проходов на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться декодировать множество входных байтов из кодовой страницы и обработать эти байты с использованием нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами.  
  
-   Если приложение обрабатывает строки, следует использовать <xref:System.Text.Encoding.GetString%2A> метода. Поскольку этот метод должен проверить длину строки и выделить буфер, она будет немного медленнее, но результирующий <xref:System.String> типа является предпочтительным.  
  
-   Байтовая версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно с несколькими вызовами в больших буферов. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > версии, что поддержка выходных символов лучшим вариантом является буферов.  
  
-   Рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetCharCount%2A>. Метод преобразования преобразует возможный объем данных и вызывает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока, этот метод часто является лучшим вариантом.  
  
   
  
## Examples  
 В следующем примере кодирует строку в массив байтов и затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на первый декодируемый байт.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов, начало которой задается указателем байтов.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления массиве точный размер, <xref:System.Text.Encoding.GetChars%2A> требуется для хранения полученных символов, следует использовать <xref:System.Text.Encoding.GetCharCount%2A> метода. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxCharCount%2A> метод. <xref:System.Text.Encoding.GetCharCount%2A> Метод обычно обеспечивает выделения меньше памяти, пока <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.Encoding.GetChars%2A> метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetChars%2A> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> метод, который обрабатывает несколько проходов на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться декодировать множество входных байтов из кодовой страницы и обработать эти байты с использованием нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами.  
  
-   Если приложение обрабатывает строки выходных данных, рекомендуется использовать <xref:System.Text.Encoding.GetString%2A> метода. Поскольку этот метод должен проверить длину строки и выделить буфер, она будет немного медленнее, но результирующий <xref:System.String> типа является предпочтительным.  
  
-   Байтовая версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно с несколькими вызовами в больших буферов. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > версии, что поддержка выходных символов лучшим вариантом является буферов.  
  
-   Рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetCharCount%2A>. Метод преобразования преобразует возможный объем данных и вызывает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока, этот метод часто является лучшим вариантом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов из заданного массива байтов.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.Encoding.GetChars%2A> для хранения полученных символов, следует использовать <xref:System.Text.Encoding.GetCharCount%2A> метода. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxCharCount%2A> метод. <xref:System.Text.Encoding.GetCharCount%2A> Метод обычно обеспечивает выделения меньше памяти, пока <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.Encoding.GetChars%2A> метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetChars%2A> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> метод, который обрабатывает несколько проходов на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться декодировать множество входных байтов из кодовой страницы и обработать эти байты с использованием нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами.  
  
-   Если приложение обрабатывает строки выходных данных, рекомендуется использовать <xref:System.Text.Encoding.GetString%2A> метода. Поскольку этот метод должен проверить длину строки и выделить буфер, она будет немного медленнее, но результирующий <xref:System.String> типа является предпочтительным.  
  
-   Байтовая версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно с несколькими вызовами в больших буферов. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > версии, что поддержка выходных символов лучшим вариантом является буферов.  
  
-   Рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetCharCount%2A>. Метод преобразования преобразует возможный объем данных и вызывает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока, этот метод часто является лучшим вариантом.  
  
   
  
## Examples  
 В следующем примере строка преобразуется из одной кодировки в другую.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 В следующем примере кодирует строку в массив байтов и затем Декодирует диапазон байтов в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе декодирует последовательность байтов в набор символов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <summary>При переопределении в производном классе декодирует все байты из указанного массива байтов в набор символов.</summary>
        <returns>Массив символов, содержащий результаты декодирования указанной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Получает символы из входной последовательности байтов. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> из-за <xref:System.Text.Encoding> ожидает дискретных преобразования во время <xref:System.Text.Decoder> предназначена для нескольких проходов на один входящий поток.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 **Примечание** этот метод предназначен для работы с символами Юникода, а не на произвольный двоичных данных, таких как массивы байтов. Если вам нужно закодировать произвольные двоичные данные в текст, следует использовать такой протокол, как uuencode, который реализуется методами, такими как <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.Encoding.GetChars%2A> метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> метод, который обрабатывает несколько проходов на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться декодировать множество входных байтов из кодовой страницы и обработать эти байты с использованием нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами, так как последовательности байтов могут быть прерваны, при обработке в пакетах. (Например, часть последовательности shift ISO-2022 могут в конечном итоге один <xref:System.Text.Encoding.GetChars%2A> вызова и продолжения в начале следующего <xref:System.Text.Encoding.GetChars%2A> вызова. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> вызывает этот резервный механизм для этих неполных последовательностей, но <xref:System.Text.Decoder> запоминает те последовательности для следующего вызова.)  
  
-   Если приложение обрабатывает строки выходных данных, рекомендуется использовать <xref:System.Text.Encoding.GetString%2A> метода. Поскольку этот метод должен проверить длину строки и выделить буфер, она будет немного медленнее, но результирующий <xref:System.String> типа является предпочтительным.  
  
-   Байтовая версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно с несколькими вызовами в больших буферов. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > версии, что поддержка выходных символов лучшим вариантом является буферов.  
  
-   Рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetCharCount%2A>. Метод преобразования преобразует возможный объем данных и вызывает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока, этот метод часто является лучшим вариантом.  
  
   
  
## Examples  
 В следующем примере кодирует строку в массив байтов и затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе декодирует последовательность байтов из указанного массива байтов в набор символов.</summary>
        <returns>Массив символов, содержащий результаты декодирования указанной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Получает символы из входной последовательности байтов. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> из-за <xref:System.Text.Encoding> ожидает дискретных преобразования во время <xref:System.Text.Decoder> предназначена для нескольких проходов на один входящий поток.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 **Примечание** этот метод предназначен для работы с символами Юникода, а не на произвольный двоичных данных, таких как массивы байтов. Если вам нужно закодировать произвольные двоичные данные в текст, следует использовать такой протокол, как uuencode, который реализуется методами, такими как <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.Encoding.GetChars%2A> метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> метод, который обрабатывает несколько проходов на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться декодировать множество входных байтов из кодовой страницы и обработать эти байты с использованием нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами, так как последовательности байтов могут быть прерваны, при обработке в пакетах. (Например, часть последовательности shift ISO-2022 могут в конечном итоге один <xref:System.Text.Encoding.GetChars%2A> вызова и продолжения в начале следующего <xref:System.Text.Encoding.GetChars%2A> вызова. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> вызывает этот резервный механизм для этих неполных последовательностей, но <xref:System.Text.Decoder> запоминает те последовательности для следующего вызова.)  
  
-   Если приложение обрабатывает строки выходных данных, рекомендуется использовать <xref:System.Text.Encoding.GetString%2A> метода. Поскольку этот метод должен проверить длину строки и выделить буфер, она будет немного медленнее, но результирующий <xref:System.String> типа является предпочтительным.  
  
-   Байтовая версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно с несколькими вызовами в больших буферов. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > версии, что поддержка выходных символов лучшим вариантом является буферов.  
  
-   Рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetCharCount%2A>. Метод преобразования преобразует возможный объем данных и вызывает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока, этот метод часто является лучшим вариантом.  
  
   
  
## Examples  
 В следующем примере кодирует строку в массив байтов и затем Декодирует диапазон байтов в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на первый декодируемый байт.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <param name="chars">Указатель на положение, с которого начинается запись результирующего набора символов.</param>
        <param name="charCount">Наибольшее количество символов для записи.</param>
        <summary>При переопределении в производном классе декодирует последовательность байтов, которая начинается с заданного указателя байта, в набор символов, которые сохраняются, начиная с заданного указателя символа.</summary>
        <returns>Фактическое число символов, записанных в местоположение, которое задано параметром <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления массиве точный размер, <xref:System.Text.Encoding.GetChars%2A> требуется для хранения полученных символов, следует использовать <xref:System.Text.Encoding.GetCharCount%2A> метода. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxCharCount%2A> метод. <xref:System.Text.Encoding.GetCharCount%2A> Метод обычно обеспечивает выделения меньше памяти, пока <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Получает символы из входной последовательности байтов. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> из-за <xref:System.Text.Encoding> ожидает дискретных преобразования во время <xref:System.Text.Decoder> предназначена для нескольких проходов на один входящий поток.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> объект, предоставляемый <xref:System.Text.Encoding.GetDecoder%2A>настроек или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 **Примечание** этот метод предназначен для работы с символами Юникода, а не на произвольный двоичных данных, таких как массивы байтов. Если вам нужно закодировать произвольные двоичные данные в текст, следует использовать такой протокол, как uuencode, который реализуется методами, такими как <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.Encoding.GetChars%2A> метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> метод, который обрабатывает несколько проходов на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться декодировать множество входных байтов из кодовой страницы и обработать эти байты с использованием нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами, так как последовательности байтов могут быть прерваны, при обработке в пакетах. (Например, часть последовательности shift ISO-2022 могут в конечном итоге один <xref:System.Text.Encoding.GetChars%2A> вызова и продолжения в начале следующего <xref:System.Text.Encoding.GetChars%2A> вызова. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> вызывает этот резервный механизм для этих неполных последовательностей, но <xref:System.Text.Decoder> запоминает те последовательности для следующего вызова.)  
  
-   Если приложение обрабатывает строку выходов, <xref:System.Text.Encoding.GetString%2A> рекомендуется использовать метод. Поскольку этот метод должен проверить длину строки и выделить буфер, она будет немного медленнее, но результирующий <xref:System.String> типа является предпочтительным.  
  
-   Байтовая версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно с несколькими вызовами в больших буферов. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > версии, что поддержка выходных символов лучшим вариантом является буферов.  
  
-   Рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetCharCount%2A>. Метод преобразования преобразует возможный объем данных и вызывает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока, этот метод часто является лучшим вариантом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="byteCount" /> или <paramref name="charCount" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> меньше результирующего числа символов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="byteIndex">Индекс первого декодируемого байта.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <param name="chars">Массив символов, в который будет помещен результирующий набор символов.</param>
        <param name="charIndex">Индекс, с которого начинается запись результирующего набора символов.</param>
        <summary>При переопределении в производном классе декодирует последовательность байтов из указанного массива байтов в указанный массив символов.</summary>
        <returns>Фактическое число символов, записанных в <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.Encoding.GetChars%2A> для хранения полученных символов, следует использовать <xref:System.Text.Encoding.GetCharCount%2A> метода. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxCharCount%2A> метод. <xref:System.Text.Encoding.GetCharCount%2A> Метод обычно обеспечивает выделения меньше памяти, пока <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > возвращает символы из входной последовательности байтов. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> из-за <xref:System.Text.Encoding> ожидает дискретных преобразования во время <xref:System.Text.Decoder> предназначен для несколько проходов на один входящий поток.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 **Примечание** этот метод предназначен для работы с символами Юникода, а не на произвольный двоичных данных, таких как массивы байтов. Если вам нужно закодировать произвольные двоичные данные в текст, следует использовать такой протокол, как uuencode, который реализуется методами, такими как <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.Encoding.GetChars%2A> метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразования отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> метод, который обрабатывает несколько проходов на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться декодировать множество входных байтов из кодовой страницы и обработать эти байты с использованием нескольких вызовов. В этом случае, возможно, необходимо сохранять состояние между вызовами, так как последовательности байтов могут быть прерваны, при обработке в пакетах. (Например, часть последовательности shift ISO-2022 могут в конечном итоге один [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > вызова и продолжения в начале следующего [\], Int32, Int32, Char\<перекрестные ссылки на модель : System.Text.Encoding.GetChars%2A > вызова. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > вызовет этот резервный механизм для этих неполных последовательности, но <xref:System.Text.Decoder> запоминает те последовательности для следующего вызова.)  
  
-   Если приложение обрабатывает строку выходов, <xref:System.Text.Encoding.GetString%2A> рекомендуется использовать метод. Поскольку этот метод должен проверить длину строки и выделить буфер, она будет немного медленнее, но результирующий <xref:System.String> типа является предпочтительным.  
  
-   Байтовая версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые способы, особенно с несколькими вызовами в больших буферов. Иметь в виду, что эта версия метода небезопасна, поскольку требуется указатели.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > версии, что поддержка выходных символов лучшим вариантом является буферов.  
  
-   Рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetCharCount%2A>. Метод преобразования преобразует возможный объем данных и вызывает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока, этот метод часто является лучшим вариантом.  
  
   
  
## Examples  
 В следующем примере строка преобразуется из одной кодировки в другую.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 В следующем примере кодирует строку в массив байтов и затем Декодирует диапазон байтов в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="byteIndex" />, <paramref name="byteCount" /> или <paramref name="charIndex" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="byteindex" /> и <paramref name="byteCount" /> не указывают допустимый диапазон в <paramref name="bytes" />.  
  
 - или -  
  
 Значение параметра <paramref name="charIndex" /> не является допустимым индексом в <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          Недостаточно емкости <paramref name="chars" /> от <paramref name="charIndex" /> до конца массива для размещения полученных символов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе получает декодер, который преобразует последовательность байтов в последовательность символов.</summary>
        <returns>Объект <see cref="T:System.Text.Decoder" />, преобразующий закодированную последовательность байтов в последовательность символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Метод преобразует последовательные блоки байтов в последовательные блоки символов в так же, как <xref:System.Text.Encoding.GetChars%2A> метода этого класса. Однако <xref:System.Text.Decoder> хранит сведения о состоянии между вызовами, что позволяет правильно декодировать последовательности байтов, охватывающие блоки. <xref:System.Text.Decoder> Также сохраняет замыкающие байты в конце блоков данных и использует конечные байты при следующей операции декодирования. Таким образом <xref:System.Text.Encoding.GetDecoder%2A> и <xref:System.Text.Encoding.GetEncoder%2A> полезны для передачи по сети и операции с файлами, так как эти операции часто работают с блоками данных, а не полные данные потока.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Реализация по умолчанию возвращает <see cref="T:System.Text.Decoder" /> , который вызывает <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> и <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> методы текущего <see cref="T:System.Text.Encoding" />. Необходимо переопределить этот метод для возврата <see cref="T:System.Text.Decoder" /> , сохраняет свое состояние между вызовами.</para>
        </block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе получает кодировщик, который преобразует последовательность символов Юникода в закодированную последовательность байтов.</summary>
        <returns>Объект <see cref="T:System.Text.Encoder" />, преобразующий последовательность символов Юникода в закодированную последовательность байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> Метод преобразует последовательные блоки символов в последовательные блоки байтов таким способом, аналогичным <xref:System.Text.Encoding.GetBytes%2A> метода этого класса. Однако <xref:System.Text.Encoder> хранит сведения о состоянии между вызовами, что позволяет правильно кодировать последовательности символов, охватывающие блоки. <xref:System.Text.Encoder> Также сохраняет замыкающие символы в конце блоков данных и использует замыкающие символы при выполнении следующей операции кодирования. Например может оказаться, что блок данных с несоответствиями старшим символом-заместителем и сопоставления младший символ-заместитель может находиться в следующем блоке данных. Таким образом <xref:System.Text.Encoding.GetDecoder%2A> и <xref:System.Text.Encoding.GetEncoder%2A> полезны для передачи по сети и операции с файлами, так как эти операции часто работают с блоками данных, а не полные данные потока.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Реализация по умолчанию возвращает <see cref="T:System.Text.Encoder" /> , который вызывает <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> и <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> методы текущего <see cref="T:System.Text.Encoding" />. Необходимо переопределить этот метод для возврата <see cref="T:System.Text.Encoder" /> , сохраняет свое состояние между вызовами.</para>
        </block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает кодировку для указанной кодовой страницы.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">Идентификатор кодовой страницы предпочтительной кодировки. Возможные значения перечислены в столбце кодовой страницы таблицы, которая отображается в теме класса <see cref="T:System.Text.Encoding" />.  
  
 - или -  
  
 0 (ноль), если требуется использовать кодировку по умолчанию.</param>
        <summary>Возвращает кодировку, связанную с указанным идентификатором кодовой страницы.</summary>
        <returns>Кодирование, связанное с заданной страницей кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Резервному обработчику зависит тип кодировки `codepage`. Если `codepage` код страницы или двухбайтовый символ кодировка (DBCS), используется стратегия наилучшего соответствия резервному обработчику. В противном случае используется резервному обработчику замены. Эти обработчики резервной может не подойти для вашего приложения. Чтобы указать резервному обработчику, используется кодировка, заданная `codepage`, можно вызвать <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> перегрузки.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Метод зависит от базовой платформы для поддержки большинства кодовых страниц. Тем не менее платформа .NET Framework поддерживает изначально некоторых кодировок. Список кодовых страниц см. в разделе <xref:System.Text.Encoding> разделе, посвященном классу. Кроме того, можно вызвать метод <xref:System.Text.Encoding.GetEncodings%2A> метод, чтобы получить массив <xref:System.Text.EncodingInfo> объектов, содержащих сведения о все кодировки.  
  
 Помимо кодировки, которые поддерживаются на определенной платформе версии платформы .NET Framework по своей природе <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает все дополнительные кодировки, которые становятся доступными, зарегистрировав <xref:System.Text.EncodingProvider> объекта. Если же кодировку был зарегистрирован с помощью нескольких <xref:System.Text.EncodingProvider> объектов, этот метод возвращает последнее из них зарегистрирован.  

Можно также указать значение 0 для `codepage` аргумент. Точное поведение зависит от ли кодировкам сделаны доступными посредством регистрации <xref:System.Text.EncodingProvider> объекта:

- Если один или несколько поставщиков кодировки зарегистрировано, возвращает кодировку последнего зарегистрированного поставщика, который выбрал вернуть кодировку, когда <xref:System.Text.Encoding.GetEncoding%2A> методу передается `codepage` аргументом 0.     

- На платформе .NET Framework, если кодировка не поставщик был зарегистрирован, если <xref:System.Text.CodePagesEncodingProvider> зарегистрированный поставщик кодировки, или если отсутствует зарегистрированный поставщик кодировки обрабатывает `codepage` значение 0, возвращается текущая кодовая страница операционной системы. Чтобы определить активную кодовую страницу в системах Windows, вызовите Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) функции из платформы .NET Framework, на рабочем столе Windows.

- На основе .NET Core, если не был зарегистрирован поставщик кодировки, или если отсутствует зарегистрированный поставщик кодировки обрабатывает `codepage` значение 0, возвращается <xref:System.Text.UTF8Encoding>.
  
> [!NOTE]
>  Некоторые неподдерживаемые кодовые страницы Причина <xref:System.ArgumentException> исключение, в то время как другие вызвать <xref:System.NotSupportedException>. Таким образом, код должен перехватывать все исключения, приведенные в раздел "исключения".  
  
> [!NOTE]
>  Кодовые страницы ANSI могут быть разными на разных компьютерах и можно изменить на одном компьютере, что приведет к повреждению данных. По этой причине, если текущая кодовая страница является кодовой страницей ANSI, кодирования и декодирования данных, используя кодовую страницу по умолчанию, возвращаемый методом `Encoding.GetEncoding(0)` не рекомендуется. Для получения согласованных результатов следует использовать кодировку Юникод, например UTF-8 (кодовая страница 65001) или UTF-16, вместо конкретной кодовой странице.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Возвращает кэшированный экземпляр с параметрами по умолчанию. Для получения экземпляра с различными параметрами следует использовать конструкторы производных классов. Например <xref:System.Text.UTF32Encoding> класс предоставляет конструктор, который дает возможность включить обнаружение ошибок.  

   
  
## Examples  
 Следующий пример возвращает два экземпляра одной кодировки (один по кодовой странице), а другой — по имени и проверки их равенства.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Параметр <paramref name="codepage" /> меньше нуля или больше 65 535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> не поддерживается используемой платформой.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> не поддерживается используемой платформой.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя кодовой страницы предпочтительной кодировки. Любое значение, возвращаемое свойством <see cref="P:System.Text.Encoding.WebName" />, является допустимым. Возможные значения перечислены в столбце "Имя" таблицы, отображаемой в разделе класса <see cref="T:System.Text.Encoding" />.</param>
        <summary>Возвращает кодировку, связанную с указанным именем кодовой страницы.</summary>
        <returns>Кодировка, связанная с указанной кодовой страницей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Резервному обработчику зависит тип кодировки `name`. Если `name` код страницы или двухбайтовый символ кодировка (DBCS), используется стратегия наилучшего соответствия резервному обработчику. В противном случае используется резервному обработчику замены. Эти обработчики резервной может не подойти для вашего приложения. Чтобы указать резервному обработчику, используется кодировка, заданная `name`, можно вызвать <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> перегрузки.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Метод зависит от базовой платформы для поддержки большинства кодовых страниц. Тем не менее платформа .NET Framework поддерживает изначально некоторых кодировок. Список кодовых страниц см. в разделе <xref:System.Text.Encoding> разделе, посвященном классу. Кроме того, можно вызвать метод <xref:System.Text.Encoding.GetEncodings%2A> метод, чтобы получить массив <xref:System.Text.EncodingInfo> объектов, содержащих сведения о все кодировки. 
  
 Помимо кодировки, которые поддерживаются на определенной платформе версии платформы .NET Framework по своей природе <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает все дополнительные кодировки, которые становятся доступными, зарегистрировав <xref:System.Text.EncodingProvider> объекта. Если же кодировку был зарегистрирован с помощью нескольких <xref:System.Text.EncodingProvider> объектов, этот метод возвращает последнее из них зарегистрирован.  
   
> [!NOTE]
>  Кодовые страницы ANSI могут быть разными на разных компьютерах, или могут быть изменены для одного компьютера, что приведет к повреждению данных. Для получения согласованных результатов следует использовать Юникод, например UTF-8 (кодовая страница 65001) или UTF-16, вместо конкретной кодовой странице.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> Возвращает кэшированный экземпляр с параметрами по умолчанию. Для получения экземпляра с различными параметрами следует использовать конструкторы производных классов. Например <xref:System.Text.UTF32Encoding> класс предоставляет конструктор, который дает возможность включить обнаружение ошибок.  
  
## Examples  
 Следующий пример возвращает два экземпляра одной кодировки (один по кодовой странице), а другой — по имени и проверки их равенства.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> не является допустимым именем кодовой страницы.  
  
 - или -  
  
 Кодовая страница, указанная с помощью параметра <paramref name="name" />, не поддерживается используемой платформой.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">Идентификатор кодовой страницы предпочтительной кодировки. Возможные значения перечислены в столбце кодовой страницы таблицы, которая отображается в теме класса <see cref="T:System.Text.Encoding" />.  
  
 - или -  
  
 0 (ноль), если требуется использовать кодировку по умолчанию.</param>
        <param name="encoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда символ не может быть закодирован с использованием текущей кодировки.</param>
        <param name="decoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда последовательность байтов не может быть декодирована с использованием текущей кодировки.</param>
        <summary>Возвращает кодировку, связанную с указанным идентификатором кодовой страницы. С помощью параметров задается обработчик ошибок для символов, которые не удается закодировать, и последовательностей байтов, которые не удается декодировать.</summary>
        <returns>Кодирование, связанное с заданной страницей кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Некоторые страницы неподдерживаемого кода вызвать исключение <xref:System.ArgumentException> исключение, в то время как другие вызвать <xref:System.NotSupportedException>. Таким образом, код должен перехватывать все исключения, приведенные в раздел "исключения".  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Метод зависит от базовой платформы для поддержки большинства кодовых страниц. Тем не менее платформа .NET Framework поддерживает изначально некоторых кодировок. Список кодовых страниц см. в разделе <xref:System.Text.Encoding> разделе, посвященном классу. Можно вызвать <xref:System.Text.Encoding.GetEncodings%2A> метод в полной версии .NET Framework, на рабочем столе Windows, чтобы получить список всех кодировок.   
  
 Помимо кодировки, которые поддерживаются на определенной платформе версии платформы .NET Framework по своей природе <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает все дополнительные кодировки, которые становятся доступными, зарегистрировав <xref:System.Text.EncodingProvider> объекта.  Если же кодировку был зарегистрирован с помощью нескольких <xref:System.Text.EncodingProvider> объектов, этот метод возвращает последнее из них зарегистрирован.  

Можно также указать значение 0 для `codepage` аргумент. Точное поведение зависит от ли кодировкам сделаны доступными посредством регистрации <xref:System.Text.EncodingProvider> объекта:

- Если один или несколько поставщиков кодировки зарегистрировано, возвращает кодировку последнего зарегистрированного поставщика, который выбрал вернуть кодировку, когда <xref:System.Text.Encoding.GetEncoding%2A> методу передается `codepage` аргументом 0.     

- На платформе .NET Framework, если кодировка не поставщик был зарегистрирован, если <xref:System.Text.CodePagesEncodingProvider> зарегистрированный поставщик кодировки, или если отсутствует зарегистрированный поставщик кодировки обрабатывает `codepage` значение 0, возвращается текущая кодовая страница.

- На основе .NET Core, если не был зарегистрирован поставщик кодировки, или если отсутствует зарегистрированный поставщик кодировки обрабатывает `codepage` значение 0, возвращает <xref:System.Text.UTF8Encoding> кодировку.

> [!NOTE]
>  Кодовые страницы ANSI могут быть разными на разных компьютерах и можно изменить на одном компьютере, что приведет к повреждению данных. По этой причине, если текущая кодовая страница является кодовой страницей ANSI, кодирования и декодирования данных, используя кодовую страницу по умолчанию, возвращаемый методом `Encoding.GetEncoding(0)` не рекомендуется. Для получения согласованных результатов следует использовать Юникод, например UTF-8 (кодовая страница 65001) или UTF-16, вместо конкретной кодовой странице. 
  
 Чтобы получить кодировку, связанную с текущая кодовая страница, можно указать значение 0 для `codepage` аргумент или, если код выполняется в полной версии .NET Framework на рабочем столе Windows, извлечь значение <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> свойства. Чтобы определить текущий текущая кодовая страница, вызовите Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) функции из платформы .NET Framework, на рабочем столе Windows.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Возвращает кэшированный экземпляр с параметрами по умолчанию. Для получения экземпляра с различными параметрами следует использовать конструкторы производных классов. Например <xref:System.Text.UTF32Encoding> класс предоставляет конструктор, который дает возможность включить обнаружение ошибок.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> метод.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Параметр <paramref name="codepage" /> меньше нуля или больше 65 535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> не поддерживается используемой платформой.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> не поддерживается используемой платформой.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">Имя кодовой страницы предпочтительной кодировки. Любое значение, возвращаемое свойством <see cref="P:System.Text.Encoding.WebName" />, является допустимым. Возможные значения перечислены в столбце "Имя" таблицы, отображаемой в разделе класса <see cref="T:System.Text.Encoding" />.</param>
        <param name="encoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда символ не может быть закодирован с использованием текущей кодировки.</param>
        <param name="decoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда последовательность байтов не может быть декодирована с использованием текущей кодировки.</param>
        <summary>Возвращает кодировку, связанную с указанным именем кодовой страницы. С помощью параметров задается обработчик ошибок для символов, которые не удается закодировать, и последовательностей байтов, которые не удается декодировать.</summary>
        <returns>Кодирование, связанное с заданной страницей кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetEncoding%2A> Метод зависит от базовой платформы для поддержки большинства кодовых страниц. Тем не менее платформа .NET Framework поддерживает изначально некоторых кодировок.  
  
 Помимо кодировки, которые поддерживаются на определенной платформе версии платформы .NET Framework по своей природе <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает все дополнительные кодировки, которые становятся доступными, зарегистрировав <xref:System.Text.EncodingProvider> объекта. Если же кодировку был зарегистрирован с помощью нескольких <xref:System.Text.EncodingProvider> объектов, этот метод возвращает последнее из них зарегистрирован. 
  
> [!NOTE]
>  Кодовые страницы ANSI могут быть разными на разных компьютерах и можно изменить на одном компьютере, что приведет к повреждению данных. Для получения согласованных результатов следует использовать кодировку Юникод, например UTF-8 (кодовая страница 65001) или UTF-16, вместо конкретной кодовой странице.  
  
 Список кодовых страниц см. в разделе <xref:System.Text.Encoding> разделе, посвященном классу. Можно вызвать <xref:System.Text.Encoding.GetEncodings%2A> метод в полной версии .NET Framework, на рабочем столе Windows, чтобы получить список всех кодировок.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Возвращает кэшированный экземпляр с параметрами по умолчанию. Для получения экземпляра с различными параметрами следует использовать конструкторы производных классов. Например <xref:System.Text.UTF32Encoding> класс предоставляет конструктор, который дает возможность включить обнаружение ошибок.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> метод.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> не является допустимым именем кодовой страницы.  
  
 - или -  
  
 Кодовая страница, указанная с помощью параметра <paramref name="name" />, не поддерживается используемой платформой.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив, содержащий все кодировки.</summary>
        <returns>Массив, содержащий все кодировки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает список поддерживаемых кодировок, которые однозначно определяются по кодовой странице. Таблица со списком поддерживаемых кодировок, в разделе <xref:System.Text.Encoding> разделе, посвященном классу.  
  
> [!NOTE]
>  Список поддерживаемых кодировок, возвращаемых <xref:System.Text.Encoding.GetEncodings%2A> метода не включает все дополнительные кодировки, доступная по любому <xref:System.Text.EncodingProvider> реализации, которые были зарегистрированы путем вызова метода <xref:System.Text.Encoding.RegisterProvider%2A> метод.  
  
 Кодировки 50220 и 50222 будут связаны с именем «iso-2022-jp», но они не совпадают. Кодировка 50220 преобразует полуширинные символы катакана символам катакана полной ширины, тогда как кодировка 50222 использует последовательность shift-/ shift out для кодирования символов катакана половинной ширины. Отображаемое имя кодировки 50222 — «японский (JIS разрешить 1 байт кана с JIS - так / SI)» позволяет отличать его от кодировки 50220, имеющая отображаемое имя «Японская (JIS)».  
  
 Если запрашивается кодирования имя «iso-2022-jp», .NET Framework возвращает кодировку 50220. Тем не менее кодировку, которая подходит для вашего приложения зависит от предпочтительного способа обработки полуширинные символы катакана.  
  
 Чтобы получить в определенной кодировке, следует использовать <xref:System.Text.Encoding.GetEncoding%2A> метода.  
  
 <xref:System.Text.Encoding.GetEncodings%2A> Иногда используется, чтобы предоставить пользователю список кодировок в файле **сохранение** диалоговое окно. Однако многие кодировки Юникод, либо неполными и преобразовать много символов для «?», или имеют незначительно отличающиеся поведение на разных платформах. Рекомендуется использовать значение по умолчанию UTF-8 или UTF-16.  
  
   
  
## Examples  
 В следующем примере проверяется значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код текущего экземпляра.</summary>
        <returns>Хэш-код для текущего экземпляра.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Число кодируемых символов.</param>
        <summary>При переопределении в производном классе вычисляет максимальное количество байтов, полученных при кодировании заданного количества символов.</summary>
        <returns>Максимальное количество байтов, полученных при кодировании заданного количества символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `charCount` Фактически указывает количество <xref:System.Char> объекты, представляющие символы Юникода для кодирования, так как платформа .NET Framework внутренним образом использует UTF-16 для представления символов Юникода. Таким образом, большинство символов Юникода могут быть представлены одним <xref:System.Char> объекта, а символ Юникода, представленного суррогатной пары, например, требуются две <xref:System.Char> объектов.  
  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.Encoding.GetBytes%2A> для хранения байтов, следует использовать <xref:System.Text.Encoding.GetByteCount%2A> метода. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно обеспечивает выделения меньше памяти, пока <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> Извлекает худший номер, включая Наихудший случай для выбранного в данный момент <xref:System.Text.EncoderFallback>. Если выбран резервный вариант с потенциально длинной строкой <xref:System.Text.Encoding.GetMaxByteCount%2A> извлекает большие значения, особенно в случаях, где Наихудший случай для кодировки связан с переключением режимов для каждого символа. Например это может произойти по ISO-2022-JP. Дополнительные сведения см. в записи блога «[в Encoding.GetMaxByteCount() и Encoding.GetMaxCharCount()?](http://go.microsoft.com/fwlink/?LinkId=153702)» (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 В большинстве случаев этот метод извлекает адекватные значения для коротких строк. Для больших строк необходимо выбирать между использованием очень больших буферов и перехват ошибок в тех редких случаях, когда более рационального буфер слишком мал. Может потребоваться использовать другой подход с использованием <xref:System.Text.Encoding.GetByteCount%2A> или <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 При использовании <xref:System.Text.Encoding.GetMaxByteCount%2A>, необходимо выделить в выходной буфер, в зависимости от максимальный размер входного буфера. Если размер выходного буфера ограничен, можно использовать <xref:System.Text.Encoding.Convert%2A> метода.  
  
 Обратите внимание, что <xref:System.Text.Encoding.GetMaxByteCount%2A> учитывает потенциальные оставшиеся суррогаты из предыдущей операции декодера. Из-за декодер передав значение 1 в метод извлекает 2 для однобайтовой кодировки, например ASCII. Следует использовать <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> свойства, если эта информация не требуется.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` не обязательно совпадает со значением `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Приведенный ниже определяет число байтов, необходимых для кодирования массива символов, выполняется кодирование символов и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="charCount" /> меньше нуля.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Все <see cref="T:System.Text.Encoding" /> реализации должны гарантировать отсутствие исключений переполнения буфера, если размер буфера выбран в соответствии с результатами вычисления этого метода.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе вычисляет максимальное количество символов, полученных при декодировании заданного количества байтов.</summary>
        <returns>Максимальное количество символов, полученных при декодировании заданного количества байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.Encoding.GetChars%2A> для хранения полученных символов, следует использовать <xref:System.Text.Encoding.GetCharCount%2A> метода. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxCharCount%2A> метод. <xref:System.Text.Encoding.GetCharCount%2A> Метод обычно обеспечивает выделения меньше памяти, пока <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> Извлекает худший номер, включая Наихудший случай для выбранного в данный момент <xref:System.Text.DecoderFallback>. Если выбран резервный вариант с потенциально длинной строкой <xref:System.Text.Encoding.GetMaxCharCount%2A> извлекает большие значения.  
  
 В большинстве случаев этот метод извлекает адекватные числа для коротких строк. Для больших строк необходимо выбирать между использованием очень больших буферов и отслеживанием ошибок в редких случаях, более рационального буфер слишком мал. Может потребоваться использовать другой подход с использованием <xref:System.Text.Encoding.GetCharCount%2A> или <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> не связан с <xref:System.Text.Encoding.GetBytes%2A>. Если требуется подобная функция, для использования с <xref:System.Text.Encoding.GetBytes%2A>, следует использовать <xref:System.Text.Encoding.GetMaxByteCount%2A>.  
  
 При использовании <xref:System.Text.Encoding.GetMaxCharCount%2A>, необходимо выделить в выходной буфер, в зависимости от максимальный размер входного буфера. Если размер выходного буфера ограничен, можно использовать <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> метода.  
  
 Обратите внимание, что <xref:System.Text.Encoding.GetMaxCharCount%2A> рассматривает наихудшее остался байтов из предыдущей операции кодировщика. Для большинства кодовых страниц при передаче значения 0 этот метод извлекает значения больше или равно 1.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` не обязательно совпадает со значением `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 В следующем примере кодирует строку в массив байтов и затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="byteCount" /> меньше нуля.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Все <see cref="T:System.Text.Encoding" /> реализации должны гарантировать отсутствие исключений переполнения буфера, если размер буфера выбран в соответствии с результатами вычисления этого метода.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает последовательность байтов, задающую используемую кодировку.</summary>
        <returns>Массив байтов, в котором содержится последовательность байтов, задающая используемую кодировку.  
  
 - или -  
  
 Массив байтов нулевой длины, если преамбула не требуется.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При необходимости <xref:System.Text.Encoding> объект предоставляет преамбулу — массив байтов, которые может иметь префикс в последовательность байтов, полученных в результате кодирования. Если преамбула содержит метку порядка следования байтов (в Юникоде, кодовая точка U + FEFF), декодер получает возможность определить порядок следования байтов и формат преобразования или UTF.  
  
 Метка порядка байтов (BOM) Юникода сериализуется следующим образом (в шестнадцатеричном формате):  
  
-   UTF-8: EF BB BF  
  
-   UTF-16 обратный порядок байтов: FE FF  
  
-   UTF-16 прямом порядке байтов: FF FE  
  
-   UTF-32 обратный порядок байтов: 00 00 FE FF  
  
-   UTF-32 прямом порядке байтов: FF FE 00 00  
  
 Спецификации, следует использовать, поскольку она обеспечивает почти точную идентификацию кодировки для файлов, в противном случае теряют ссылку на <xref:System.Text.Encoding> объекта, например, без тега или неправильно отмечен веб-данных или случайное текстовые файлы, сохраненные, когда организация не иметь расставленными или других данных. Часто возникающих пользователя избавить согласованных и правильных тегов в данных, желательно в кодировке UTF-8 или UTF-16.  
  
 Для стандартов, предоставляющих тип кодировки метка BOM отчасти избыточный. Тем не менее он может использоваться, чтобы помочь серверу отправлять правильный заголовок кодировки. Кроме того он может использоваться как переход на резервный ресурс в случае, если кодировка, в противном случае не потеряны.  
  
 Есть некоторые недостатки использования метки порядка БАЙТОВ. Например сложно выбрать способы ограничения полей базы данных, используйте метки порядка БАЙТОВ. Объединение файлов может вызвать проблемы также, например, когда файлы сливаются таким образом, что необязательный символ может оказаться в центре данных. Несмотря на некоторые недостатки Однако использование спецификации настоятельно рекомендуется.  
  
 Дополнительные сведения о порядке байтов и метка порядка байтов в разделе Юникод [домашней странице Юникода](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Чтобы обеспечить правильное декодирование закодированных байтов, необходимо использовать перед закодированных байтов с начальной части. Однако большинство кодировок преамбула не предоставляется. Чтобы обеспечить правильное декодирование закодированных байтов, следует использовать кодировку Юникод, то есть <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, или <xref:System.Text.UTF32Encoding>, с начальной части.  
  
   
  
## Examples  
 В следующем примере определяется порядок байтов кодировки на основе преамбулы.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе декодирует последовательность байтов в строку.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <summary>При переопределении в производном классе декодирует все байты из указанного массива байтов в строку.</summary>
        <returns>Строка, содержащая результаты декодирования заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> объект, возвращаемый <xref:System.Text.Encoding.GetDecoder%2A> метод deri Разрешить класса.  
  
 В разделе «Примечания» <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> справочном разделе для обсуждения декодирования методики и рекомендации.  
  
 Обратите внимание, что точное поведение <xref:System.Text.Encoding.GetString%2A> метод для какого-либо <xref:System.Text.Encoding> реализация зависит от резервную стратегию, определенным для этого <xref:System.Text.Encoding> объекта. Дополнительные сведения см. раздел «Выбор резервной стратегии» [кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md) раздела.  
  
   
  
## Examples  
 В следующем примере считывается строка в кодировке UTF-8 из двоичного файла, представленного <xref:System.IO.FileStream> объекта. Для файлов, которые меньше 2048 байтов, он считывает содержимое этого файла в массив байтов и вызывает метод <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> метод, чтобы выполнить декодирование. Для обработки больших файлов он 2048 байтов за раз считывает в массив байтов, вызовы <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод, чтобы определить количество символов, содержащихся в массиве, а затем набирает <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> метод, чтобы выполнить декодирование.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 В примере используется следующий текст, который должен быть сохранен файл в кодировке UTF-8, с именем Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Массив байтов содержит недопустимые точки кода Юникод.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на массив байтов.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе декодирует указанное количество байтов начиная с указанного адреса в строку.</summary>
        <returns>Строка, содержащая результаты декодирования заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetString%2A> Метод предназначен для оптимизации производительности, когда у вас есть собственный указатель на массив байтов. Вместо создания управляемого массива байтов и затем декодирования этот метод можно вызывать вместо без создания промежуточных объектов.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> объект, возвращаемый <xref:System.Text.Encoding.GetDecoder%2A> метод deri Разрешить класса.  
  
 В разделе «Примечания» <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> справочном разделе для обсуждения декодирования методики и рекомендации.  
  
 Обратите внимание, что точное поведение <xref:System.Text.Encoding.GetString%2A> метод для какого-либо <xref:System.Text.Encoding> реализация зависит от резервную стратегию, определенным для этого <xref:System.Text.Encoding> объекта. Дополнительные сведения см. раздел «Выбор резервной стратегии» [кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md) раздела.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> является пустым указателем</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="byteCount" /> меньше нуля.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе декодирует последовательность байтов из указанного массива байтов в строку.</summary>
        <returns>Строка, содержащая результаты декодирования заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 В разделе «Примечания» <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> справочном разделе для обсуждения декодирования методики и рекомендации.  
  
   
  
## Examples  
 В следующем примере считывается строка в кодировке UTF-8 из двоичного файла, представленного <xref:System.IO.FileStream> объекта. Для файлов, которые меньше 2048 байтов, он считывает содержимое этого файла в массив байтов и вызывает метод <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> метод, чтобы выполнить декодирование. Для обработки больших файлов он 2048 байтов за раз считывает в массив байтов, вызовы <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод, чтобы определить количество символов, содержащихся в массиве, а затем набирает <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> метод, чтобы выполнить декодирование.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 В примере используется следующий текст, который должен быть сохранен файл в кодировке UTF-8, с именем Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Массив байтов содержит недопустимые точки кода Юникод.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает имя текущей кодировки, которое может использоваться с тегами заголовка сообщения почтового агента.</summary>
        <value>Имя текущего объекта <see cref="T:System.Text.Encoding" />, которое может использоваться с тегами заголовка сообщения почтового агента.  
  
 - или -  
  
 Пустая строка (""), если текущий объект <see cref="T:System.Text.Encoding" /> не может использоваться.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если требуется кодировку для имени заголовка, необходимо вызвать <xref:System.Text.Encoding.GetEncoding%2A> метод с <xref:System.Text.Encoding.HeaderName%2A> свойство. Этот метод часто извлекает другую кодировку из тестовой кодировки, для которой он вызывается. Обычно требуется только приложения электронной почты для получения такой кодировки.  
  
 В некоторых случаях значение <xref:System.Text.Encoding.BodyName%2A> свойство соответствует свойству международный стандарт, который определяет эту кодировку. Это не означает соответствия реализация полностью с этого стандарта.  
  
 Обратите внимание, что <xref:System.Text.Encoding.WebName%2A> возвращает имя, используемое для описания кодировку. <xref:System.Text.Encoding.HeaderName%2A> Свойство определяет другую кодировку, которая может лучше подходит для приложения электронной почты, например. Однако не рекомендуется использовать свойство для задания кодировки.  
  
   
  
## Examples  
 В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки, имеющие одно или несколько имен, которые отличаются от <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Он отображает <xref:System.Text.Encoding.EncodingName%2A> , но сравниваются по нему.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает значение, которое указывает, является ли текущая кодировка всегда нормированной.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает значение, которое указывает, является ли текущая кодировка всегда нормализованной с использованием формы нормализации по умолчанию.</summary>
        <returns>
          <see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> всегда нормирован; в противоположном случае — <see langword="false" />. Значение по умолчанию: <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Формы нормализации по умолчанию является <xref:System.Text.NormalizationForm.FormC>, с использованием полной канонической декомпозиции, следуют замена последовательностей их первичными составляющими, если это возможно.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">Одно из значений перечисления <see cref="T:System.Text.NormalizationForm" />.</param>
        <summary>При переопределении в производном классе получает значение, которое указывает, является ли текущая кодировка всегда нормализованной с использованием заданной по умолчанию формы нормализации.</summary>
        <returns>
          <see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> всегда нормализуется с использованием заданного значения <see cref="T:System.Text.NormalizationForm" />; в противоположном случае — <see langword="false" />. Значение по умолчанию: <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Формы нормализации по умолчанию является <xref:System.Text.NormalizationForm.FormC>, с использованием полной канонической декомпозиции, следуют замена последовательностей их первичными составляющими, если это возможно.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами браузера для отображения содержимого.</summary>
        <value>
          <see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами браузера для отображения содержимого; в противоположном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяется значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами браузера для сохранения содержимого.</summary>
        <value>
          <see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами браузера для сохранения содержимого; в противоположном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяется значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами электронной почты и новостей для отображения содержимого.</summary>
        <value>
          <see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами электронной почты и новостей для отображения содержимого; в противоположном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяется значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами электронной почты и новостей для сохранения содержимого.</summary>
        <value>
          <see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами почты и новостей для сохранения содержимого; в противоположном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяется значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, является ли текущая кодировка доступной только для чтения.</summary>
        <value>
          Значение <see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> доступен только для чтения, в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, используются ли в текущей кодировке однобайтовые кодовые точки.</summary>
        <value>
          <see langword="true" />, если в текущем объекте <see cref="T:System.Text.Encoding" /> используются однобайтовые кодовые точки; в противоположном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В однобайтовой кодировки, например, <xref:System.Text.ASCIIEncoding>, это свойство получает `true`.  
  
> [!CAUTION]
>  Следует соблюдать осторожность, приложение работает со значением для <xref:System.Text.Encoding.IsSingleByte%2A>. Предположение способ обработки "кодировки" может быть неправильно. Например, Windows-1252 имеет значение `true` для <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, но Encoding.GetMaxByteCount(1) возвращает 2. Это потому, что метод учитывает потенциальные оставшиеся суррогаты из предыдущей операции декодера.  
  
   
  
## Examples  
 В следующем примере проверяется значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Подкласс класса <see cref="T:System.Text.EncodingProvider" />, который предоставляет доступ к дополнительным кодировкам символов.</param>
        <summary>Регистрирует поставщик кодировки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.RegisterProvider%2A> Метод позволяет зарегистрировать класс, производный от <xref:System.Text.EncodingProvider> , делает кодировки доступен на платформе, в противном случае их не поддерживает. После регистрации кодировки поставщика кодировки, которые он поддерживает можно получить путем вызова любой <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> перегрузки. При наличии нескольких поставщиков кодирования, <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> метод пытается получить с заданной кодировкой от каждого поставщика, начиная с самой последней зарегистрированный.

Регистрация поставщика кодировки с помощью <xref:System.Text.Encoding.RegisterProvider%2A> метод также изменяет поведение [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) и [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) методы при передаче аргумента `0`:

- Если зарегистрированный поставщик <xref:System.Text.CodePagesEncodingProvider>, метод возвращает кодировку, которая соответствует active кодовой страницы системы, если в операционной системе Windows.

- Настраиваемый поставщик кодировки можно выбрать, какую кодировку, возвращаемое, если любой из этих <xref:System.Text.Encoding.GetEncoding%2A> перегруженных версий метода передается аргумент `0`. Возвращает кодировку, что поставщик можно также выбрать <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> возвращении метода `null`. 
  
 [!INCLUDE[net_v46](~/includes/net-v46-md.md)] включает один поставщик кодировки, <xref:System.Text.CodePagesEncodingProvider>, который делает доступными кодировки, которые имеются в полной версии платформы .NET Framework, но не доступны в [!INCLUDE[net_v46](~/includes/net-v46-md.md)]. По умолчанию [!INCLUDE[net_v46](~/includes/net-v46-md.md)] поддерживает только кодировки Юникод, ASCII и кодовой страницы 28591.  
  
 Если тот же поставщик кодировки используется в нескольких вызовах <xref:System.Text.Encoding.RegisterProvider%2A> метод только первый вызов метода регистрирует поставщик. Последующие вызовы учитываются.  
  
 Если <xref:System.Text.Encoding.RegisterProvider%2A> метод вызывается для регистрации нескольких поставщиков, которые обрабатывают ту же кодировку, последний зарегистрированный поставщик используется для всех операциях кодирования и декодирования. Все ранее зарегистрированных поставщиков учитываются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="provider" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для формата UTF-16 с прямым порядком байтов.</summary>
        <value>Кодировка для формата UTF-16 с прямым порядком байтов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сведения о кодировках, поддерживаемых .NET Framework и обсуждение какие Юникод, кодировка, используемая в разделе [кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UnicodeEncoding> Объект, возвращаемый этим свойством не может иметь необходимого поведения для вашего приложения. Он использует резервную стратегию замены для замены каждой строки, он не может закодировать и каждый байт, он не может декодировать, вопросительным знаком ("?») символов. Вместо этого можно вызвать метод <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> конструктор для создания экземпляра с прямым порядком байтов <xref:System.Text.UnicodeEncoding> объект которого является либо <xref:System.Text.EncoderFallbackException> или <xref:System.Text.DecoderFallbackException>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 Приведенный ниже определяет число байтов, необходимых для кодирования массива символов, выполняется кодирование символов и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для формата UTF-32 с прямым порядком байтов.</summary>
        <value>Объект кодировки для формата UTF-32 с прямым порядком байтов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding> Объект, возвращаемый этим свойством не может иметь необходимого поведения для вашего приложения. Она использует резервную стратегию замены для каждой строки, он не может закодировать и каждый байт, он не может декодировать заменить замещающий символ Юникода (U + FFFE). Вместо этого можно вызвать метод <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> конструктора для создания <xref:System.Text.UTF32Encoding> объект которого является либо <xref:System.Text.EncoderFallbackException> или <xref:System.Text.DecoderFallbackException>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Сведения о прямом порядке байтов см. в разделе <xref:System.Text.Encoding> разделе, посвященном классу.  
  
 Сведения о кодировках, поддерживаемых .NET Framework и обсуждение какие Юникод, кодировка, используемая в разделе [кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Приведенный ниже определяет число байтов, необходимых для кодирования массива символов, выполняется кодирование символов и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для формата UTF-7.</summary>
        <value>Кодировка для формата UTF-7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В основном в средах, которые традиционно ограниченные 7 бит, например NNTP и некоторые приложения электронной почты используется кодировка UTF-7. Из-за проблем с надежности и безопасности не следует использовать UTF7 кодирование в 8-разрядных сред где кодировку UTF-8 можно использовать вместо него.  
  
   
  
## Examples  
 Приведенный ниже определяет число байтов, необходимых для кодирования массива символов, выполняется кодирование символов и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для формата UTF-8.</summary>
        <value>Кодировка для формата UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает <xref:System.Text.UTF8Encoding> объекта, кодирует (кодировки UTF-16) символов Юникода в последовательность от одной до четырех байтов на один знак, и который декодирует массива байтов в кодировке UTF-8 (кодировки UTF-16) символов Юникода. Сведения о кодировке, поддерживаемые .NET Framework и обсуждение какие Юникод, кодировка, используемая в разделе [кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UTF8Encoding> Объект, возвращаемый этим свойством не может иметь необходимого поведения для вашего приложения.  
  
-   Он возвращает <xref:System.Text.UTF8Encoding> объект, предоставляющий метка порядка байтов (BOM) Юникода. Для создания экземпляра кодировкой UTF-8, не предоставляет Спецификации, вызвать любой перегрузки <xref:System.Text.UTF8Encoding.%23ctor%2A> конструктор.  
  
-   Он возвращает <xref:System.Text.UTF8Encoding> объект, который использует резервную стратегию замены для замены каждой строки, он не может закодировать и каждый байт, он не может декодировать, вопросительным знаком ("?») символов. Вместо этого можно вызвать метод <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> конструктора для создания <xref:System.Text.UTF8Encoding> объект которого является либо <xref:System.Text.EncoderFallbackException> или <xref:System.Text.DecoderFallbackException>, как показано в следующем примере.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 В следующем примере определяется массив, состоящий из следующих символов:  
  
-   ЛАТИНСКАЯ СТРОЧНАЯ БУКВА Z (U + 007A)  
  
-   ЛАТИНИЦА МАЛЫЙ ПИСЬМА (U + 0061)  
  
-   ОБЪЕДИНЕНИЕ БРЕВЕ; (U + 0306)  
  
-   ЛАТИНСКАЯ СТРОЧНАЯ БУКВА AE С АКУТОМ (U + 01FD)  
  
-   ГРЕЧЕСКИЙ СТРОЧНАЯ БУКВА БЕТА-ВЕРСИИ (U + 03B2)  
  
-   Суррогатная пара (U + D800 U + DD54), являющийся ГРЕЧЕСКОЙ ACROPHONIC ATTIC один ТЫСЯЧ STATERS (U + 10154).  
  
 Он отображает блоков кода UTF-16 для каждого символа, а также определяет число байтов, необходимых с помощью кодировщика UTF-8 для кодирования массива символов. Затем выполняется кодирование символов и отображаются полученные байты кодировки UTF-8.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает для текущей кодировки имя, зарегистрированное в IANA (Internet Assigned Numbers Authority).</summary>
        <value>Имя IANA для текущего объекта <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.WebName%2A> Свойства совпадает со значением <xref:System.Text.EncodingInfo.Name%2A> свойство.  
  
 Обратите внимание, что <xref:System.Text.Encoding.WebName%2A> возвращает IANA зарегистрировано имя кодировки. Если его значение является именем стандарта, реализация кодировки может не соответствовать в полном объеме для этого стандарта. <xref:System.Text.Encoding.HeaderName%2A> Свойство определяет другую кодировку, которая может заголовки электронной почты. Однако большинство приложений следует использовать <xref:System.Text.Encoding.WebName%2A> вместо него.  
  
 Дополнительные сведения об IANA [www.iana.org](https://www.iana.org/).  
  
 <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> Совпадает со значением <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> возвращенных <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. Некоторые веб-имена являются дубликатами; см. в разделе примечаний для <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> для получения дополнительной информации.  
  
   
  
## Examples  
 Следующий пример включает <xref:System.Text.Encoding.WebName%2A> в заголовок HTML.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки, имеющие одно или несколько имен, которые отличаются от <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Он отображает <xref:System.Text.Encoding.EncodingName%2A> , но сравниваются по нему.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает кодовую страницу операционной системы Windows, наиболее точно соответствующую текущей кодировке.</summary>
        <value>Кодовая страница операционной системы Windows, наиболее точно соответствующая текущему объекту <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляется для обеспечения совместимости с многоязыковой поддержки Windows (MLang) API, например, при определении семейств шрифтов. Для глобализации одну из кодировок Юникода рекомендуется использовать вместо него. Также рекомендуется использовать <xref:System.Text.Encoding.WebName%2A> вместо <xref:System.Text.Encoding.WindowsCodePage%2A> для идентификации кодовую страницу.  
  
   
  
## Examples  
 В следующем примере определяется кодовая страница Windows, наиболее точно соответствующая каждой кодировке.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>