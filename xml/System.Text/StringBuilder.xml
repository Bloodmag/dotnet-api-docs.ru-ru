<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="29e851adfc42ab7a599e5f18e1799ded1499426e" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37610838" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a mutable string of characters. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс представляет объект строкового типа, значение которого является изменяемая последовательность символов.  
  
 Содержание  
  
-   [Типы String и StringBuilder](#StringAndSB)  
  
-   [Как работает StringBuilder](#HowWorks)  
  
-   [Выделение памяти](#Memory)  
  
-   [Создание экземпляра объекта StringBuilder](#Instantiating)  
  
-   [Вызов методов StringBuilder](#Calling)  
  
-   [Выполнение операций StringBuilder](#Operations)  
  
    -   [Итерация StringBuilder символов](#Iterating)  
  
    -   [Добавление текста в объект StringBuilder](#Adding)  
  
    -   [Удаление текста из объекта StringBuilder](#Deleting)  
  
    -   [Изменение текста в объект StringBuilder](#Modifying)  
  
-   [Поиск текста в объект StringBuilder](#Searching)  
  
-   [Преобразование объекта StringBuilder в строку](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>Типы String и StringBuilder  
 Несмотря на то что <xref:System.Text.StringBuilder> и <xref:System.String> обе они представляют последовательности символов, они реализуются по-разному. <xref:System.String> является неизменяемым типом. То есть каждой операции, который отображается для изменения <xref:System.String> объект фактически создает новую строку.  
  
 Например, вызов <xref:System.String.Concat%2A?displayProperty=nameWithType> метод в следующем примере C#, по-видимому, измените значение параметра строковую переменную с именем `value`. На самом деле <xref:System.String.Concat%2A> возвращает `value` объекта, имеющего другое значение и адрес из `value` объект, который был передан в метод. Обратите внимание, что пример должно быть скомпилировано с использованием `/unsafe` параметр компилятора.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 Для подпрограмм, выполняющих обширной строками (например, приложения, измените строку несколько раз в цикле) несколько раз изменения строки можно точное к значительному снижению производительности. Альтернативой является использование <xref:System.Text.StringBuilder>, — это класс, изменяемую строку. Изменяемость означает, что после создания экземпляра класса, его можно изменить путем добавления, удаления, замены или Вставка символов. Объект <xref:System.Text.StringBuilder> объект поддерживает буфер, чтобы вместить расширения к строке. Новые данные добавляются в буфер, если доступно места; в противном случае выделяется новый, больший буфер, данные из исходного буфера копируются в новый буфер, и затем добавляются новые данные в новый буфер.  
  
> [!IMPORTANT]
>  Несмотря на то что <xref:System.Text.StringBuilder> класса, как правило, обеспечивает лучшую производительность, чем <xref:System.String> класс, вы не может заменить автоматически <xref:System.String> с <xref:System.Text.StringBuilder> каждый раз, когда требуется для работы со строками. Производительность зависит от размера строки, объем памяти, выделяемой для новой строки, системы, на котором выполняется приложение и тип операции. Вы должны быть готовы протестировать приложение, чтобы определить, является ли <xref:System.Text.StringBuilder> действительно предлагает значительного выигрыша в производительности.  
  
 Рассмотрите возможность использования <xref:System.String> класса в этих условиях:  
  
-   Когда число изменений, приложение будет строка мал. В этих случаях <xref:System.Text.StringBuilder> может незначительно предложения или не улучшение производительности по сравнению <xref:System.String>.  
  
-   При выполнении фиксированное число операции объединения, особенно со строковыми литералами. В этом случае компилятор может объединять операции объединения в одной операции.  
  
-   При наличии можно выполнять широкий поиск при построении строки. <xref:System.Text.StringBuilder> Отсутствует класс поиска методов, таких как `IndexOf` или `StartsWith`. Вам придется преобразовать <xref:System.Text.StringBuilder> объект <xref:System.String> для этих операций и это отключить выгода от использования <xref:System.Text.StringBuilder>. Дополнительные сведения см. в разделе [поиск текста в объект StringBuilder](#Searching) раздел.  
  
 Рассмотрите возможность использования <xref:System.Text.StringBuilder> класса в этих условиях:  
  
-   Когда это должно происходить чтобы ваше приложение произвело неизвестное количество изменений в строку во время разработки (например, при использовании цикла для объединения случайное число строк, содержащих ввод данных пользователем).  
  
-   Когда это должно происходить чтобы ваше приложение произвело значительное количество изменений в строку.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>Как работает StringBuilder  
 <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> Свойство указывает количество символов <xref:System.Text.StringBuilder> содержит объект. При добавлении символов для <xref:System.Text.StringBuilder> объекта, его длина увеличивается, пока он равен размеру <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> свойство, которое определяет число символов, которые может содержать объект. Если количество добавленных символов вызывает длину <xref:System.Text.StringBuilder> объект превышение его текущей емкости, новую память выделяется, значение <xref:System.Text.StringBuilder.Capacity%2A> свойство удваивается, добавляются новые символы <xref:System.Text.StringBuilder> объекта и его <xref:System.Text.StringBuilder.Length%2A>настройки свойства. Дополнительная память для <xref:System.Text.StringBuilder> объект выделяется динамически, пока не достигнет значения, определяемого <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> свойство. При достижении максимальной емкости без дальнейшего памяти, выделяемой для <xref:System.Text.StringBuilder> объекта и попытка добавления символов или разверните его за пределы максимальной вместимости создает либо <xref:System.ArgumentOutOfRangeException> или <xref:System.OutOfMemoryException> исключение.  
  
 В следующем примере показано как <xref:System.Text.StringBuilder> объект выделяет новую память и его емкость динамически увеличивается расширяет строку, назначенный объекту. Код создает <xref:System.Text.StringBuilder> путем вызова его конструктора (без параметров) по умолчанию. Емкость по умолчанию данного объекта по 16 символов, которое приближается к максимальному более 2 миллиардов знаков. Добавление строки «Это предложение». приводит новое выделение памяти, так как длина строки (19 символов) превышает емкость по умолчанию <xref:System.Text.StringBuilder> объекта. Емкость объекта удваивается до 32 символов, добавляется новая строка и длину объекта теперь равно 19 символов. Затем код добавляет строку «This is Дополнительные предложения». значение <xref:System.Text.StringBuilder> объекта 11 раз. Каждый раз, когда операции добавления вызывает длину <xref:System.Text.StringBuilder> вдвое превышать его емкость вместимости существующего объекта и <xref:System.Text.StringBuilder.Append%2A> операция выполнена успешно.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>Выделение памяти  
 Емкость по умолчанию <xref:System.Text.StringBuilder> объект — 16 символов, а его максимальная емкость по умолчанию — <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Эти значения по умолчанию используются в том случае, если вы вызываете <xref:System.Text.StringBuilder.%23ctor> и <xref:System.Text.StringBuilder.%23ctor%28System.String%29> конструкторы.  
  
 Можно явно определить исходная емкость <xref:System.Text.StringBuilder> объект одним из следующих способов:  
  
-   При вызовах <xref:System.Text.StringBuilder> конструкторы, которые включает в себя `capacity` при создании объекта.  
  
-   Назначив новое значение явным образом <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> свойство, чтобы развернуть существующий <xref:System.Text.StringBuilder> объекта. Обратите внимание, что свойство вызывает исключение, если новое значение емкости меньше, чем существующий емкости или больше, чем <xref:System.Text.StringBuilder> Максимальная емкость объекта.  
  
-   Путем вызова <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> метод с новым значением емкости. Новое значение емкости не должно быть больше, чем <xref:System.Text.StringBuilder> Максимальная емкость объекта. Тем не менее, в отличие от присвоения <xref:System.Text.StringBuilder.Capacity%2A> свойства <xref:System.Text.StringBuilder.EnsureCapacity%2A> не выдает исключение, если требуемый новое значение емкости меньше, чем емкость; таким образом, вызов метода не влияет.  
  
 Если назначено длину строки <xref:System.Text.StringBuilder> объект в вызове конструктора превышает емкость по умолчанию или указанной емкостью <xref:System.Text.StringBuilder.Capacity%2A> свойство имеет значение длины строки, указанной с помощью `value` параметра.  
  
 Можно явно определить максимальную емкость <xref:System.Text.StringBuilder> путем вызова метода <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> конструктор. Невозможно изменить максимальную емкость путем присвоения нового значения для <xref:System.Text.StringBuilder.MaxCapacity%2A> свойство, так как она доступна только для чтения.  
  
 Как в предыдущем разделе показано, всякий раз, когда емкость памяти недостаточно, дополнительно выделяется и емкость <xref:System.Text.StringBuilder> объекта удваивается до значения, определяемого <xref:System.Text.StringBuilder.MaxCapacity%2A> свойство.  
  
 Как правило емкость по умолчанию и максимальная емкость адекватны для большинства приложений. Можно принять эти значения при следующих условиях:  
  
-   Если конечный размер <xref:System.Text.StringBuilder> объект высокой вероятностью расширяться чрезвычайно большого, обычно сверх несколько мегабайт. В этом случае может быть некоторое повышение производительности от установки начального <xref:System.Text.StringBuilder.Capacity%2A> свойство значение большим, чтобы устранить необходимость использования более слишком много памяти.  
  
-   Если ваше приложение работает в системе с ограниченным объемом памяти. В этом случае может понадобиться рассмотреть параметр <xref:System.Text.StringBuilder.MaxCapacity%2A> значение меньше, чем <xref:System.Int32.MaxValue?displayProperty=nameWithType> Если приложение обрабатывает больших строк, которые могут вызвать его для выполнения в среде, ограниченных в памяти.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>Создание экземпляра объекта StringBuilder  
 Вы создаете экземпляры <xref:System.Text.StringBuilder> объекта путем вызова одного из его шесть перегруженные конструкторы класса, которые перечислены в следующей таблице. Три из конструкторов для создания экземпляра <xref:System.Text.StringBuilder> объекта, значение которого является пустой строкой, но установить его <xref:System.Text.StringBuilder.Capacity%2A> и <xref:System.Text.StringBuilder.MaxCapacity%2A> значения по-разному. Остальные три конструктора определяют <xref:System.Text.StringBuilder> объект, имеющий значение подстроки и емкости. Два из трех конструкторов использовать по умолчанию максимальная емкость <xref:System.Int32.MaxValue?displayProperty=nameWithType>, а третий позволяет задать максимальную емкость.  
  
|Конструктор|Строковое значение|Емкость|Максимальная емкость|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Определяется `capacity` параметр|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Определяется `capacity` параметр|Определяется `maxCapacity` параметр|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Определяется `value` параметр|16 или `value`. <xref:System.String.Length%2A>, какое значение больше|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Определяется `value` параметр|Определяется `capacity` параметр или `value`. <xref:System.String.Length%2A>, какое значение больше.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|Определяется `value`. <xref:System.String.Substring%2A>(`startIndex`, `length`)|Определяется `capacity` параметр или `value`. <xref:System.String.Length%2A>, какое значение больше.|Определяется `maxCapacity` параметр|  
  
 В следующем примере используется три из этих перегрузок конструктора для создания экземпляра <xref:System.Text.StringBuilder> объектов.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>Вызов методов StringBuilder  
 Большинство методов, измените строку в <xref:System.Text.StringBuilder> экземпляра возвращают ссылку на тот же экземпляр. Это позволяет вызывать <xref:System.Text.StringBuilder> методы двумя способами:  
  
-   Можно вызывать отдельные методы и игнорировать возвращаемое значение, как показано в следующем примере.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   Можно сделать ряд вызовов методов в одной инструкции. Это может быть удобно, если для одного оператора, который добавляет последовательных операций записи. Следующий пример объединяет три вызова метода из предыдущего примера в одну строку кода.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>Выполнение операций StringBuilder  
 Можно использовать методы <xref:System.Text.StringBuilder> класса для выполнения итерации, добавление, удаление и изменение символов в <xref:System.Text.StringBuilder> объекта.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>Итерация StringBuilder символов  
 Можно получить доступ к символы в <xref:System.Text.StringBuilder> объекта с помощью <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> свойство. В C# <xref:System.Text.StringBuilder.Chars%2A> является индексатором; в Visual Basic, это свойство по умолчанию <xref:System.Text.StringBuilder> класса. Это дает возможность задать или извлечь отдельные символы с использованием только индексов без явного указания ссылки <xref:System.Text.StringBuilder.Chars%2A> свойство. Символы в <xref:System.Text.StringBuilder> объект начинаются с индексом 0 (ноль) и индексировать по-прежнему <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 В следующем примере показано <xref:System.Text.StringBuilder.Chars%2A> свойство. Десять случайных чисел, чтобы к нему добавляется <xref:System.Text.StringBuilder> объекта, а затем выполняет итерацию каждого символа. Если категории символов Юникода <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, он сокращает число на 1 (или меняется на 9 номер, если его значение равно 0). В примере отображается содержимое <xref:System.Text.StringBuilder> оба объекта до и после изменения значений отдельных символов.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>Добавление текста в объект StringBuilder  
 <xref:System.Text.StringBuilder> Класс включает следующие методы для расширения содержимого <xref:System.Text.StringBuilder> объекта:  
  
-   <xref:System.Text.StringBuilder.Append%2A> Метод добавляет строка, подстроку, массив символов, часть в массив символов, один символ повторяется несколько раз, либо строковое представление примитивных типов данных тип на <xref:System.Text.StringBuilder> объекта.  
  
-   <xref:System.Text.StringBuilder.AppendLine%2A> Метод добавляет знак завершения строки или строки вместе с признаком конца строки для <xref:System.Text.StringBuilder> объекта.  
  
-   <xref:System.Text.StringBuilder.AppendFormat%2A> Метод добавляет к <xref:System.Text.StringBuilder> объекта. Строковые представления объектов, включенных в результирующей строке может отражать соглашения о форматировании текущего языка и региональных параметров системы или указанного языка и региональных параметров.  
  
-   <xref:System.Text.StringBuilder.Insert%2A> Метод вставляет строка, подстроку, нескольких повторений строка, массив символов, часть массив символов, или строковое представление примитивных типов данных введите в указанной позиции в <xref:System.Text.StringBuilder> объекта. Отсчитываемый от нуля индекс, определяется положение.  
  
 В следующем примере используется <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, и <xref:System.Text.StringBuilder.Insert%2A> методы, чтобы развернуть текст <xref:System.Text.StringBuilder> объекта.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>Удаление текста из объекта StringBuilder  
 <xref:System.Text.StringBuilder> Класс включает методы, которые можно уменьшить размер текущего <xref:System.Text.StringBuilder> экземпляра. <xref:System.Text.StringBuilder.Clear%2A> Метод удаляет все символы и задает <xref:System.Text.StringBuilder.Length%2A> свойства значение 0. <xref:System.Text.StringBuilder.Remove%2A> Метод удаляет указанное количество символов, начиная с определенного индекса позиции. Кроме того, можно удалить символы в конце <xref:System.Text.StringBuilder> объекта, задав его <xref:System.Text.StringBuilder.Length%2A> значение не меньше длины текущего экземпляра.  
  
 Следующий пример удаляет текст из <xref:System.Text.StringBuilder> объекта, отображается его итоговый емкости, максимальная емкость и значения свойств длиной, а затем вызывает <xref:System.Text.StringBuilder.Clear%2A> метод для удаления всех символов из <xref:System.Text.StringBuilder> объекта.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>Изменение текста в объект StringBuilder  
 <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> Метод заменяет все вхождения символа или строки во всем <xref:System.Text.StringBuilder> объекта или в диапазоне определенный символ. В следующем примере используется <xref:System.Text.StringBuilder.Replace%2A> метод для замены всех точек восклицательный знак (!) вопросительные знаки (?) в <xref:System.Text.StringBuilder> объекта.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Поиск текста в объект StringBuilder  
 <xref:System.Text.StringBuilder> Класс включает методы, аналогичную <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, и <xref:System.String.StartsWith%2A?displayProperty=nameWithType> методы, предоставляемые <xref:System.String> класс, который можно выполнять поиск объектов, для конкретного символа или подстроки. Определение наличия или начальная позиция знака подстроки требуется выполнить <xref:System.String> значение с помощью поиска в строковый метод или метод регулярного выражения. Существует четыре способа для реализации такого поиска, как показано в следующей таблице.  
  
|Метод|Преимущества|Недостатки|  
|---------------|----------|----------|  
|Найдите строковые значения перед добавлением их к <xref:System.Text.StringBuilder> объекта.|Это удобно для определения того, существует ли подстрока.|Не может использоваться, если важно позицию индекса подстроки.|  
|Вызовите <xref:System.Text.StringBuilder.ToString%2A> и поиска, возвращенного <xref:System.String> объекта.|Прост в использовании при указании весь текст в <xref:System.Text.StringBuilder> объекта, а затем начните изменить его.|Неудобно в повторяющемся вызове <xref:System.Text.StringBuilder.ToString%2A> Если необходимо внести изменения, перед добавлением весь текст <xref:System.Text.StringBuilder> объекта.<br /><br /> Необходимо помнить, для работы с конца <xref:System.Text.StringBuilder> текста объекта, если вы вносите изменения.|  
|Используйте <xref:System.Text.StringBuilder.Chars%2A> свойство последовательно искомый диапазон символов.|Полезно, если вас интересует отдельные символы или небольшой подстроки.|Неудобно, если количество символов для поиска велико или логика поиска сложна.<br /><br />Приводит к очень низкой производительности для объектов, которые выросли очень больших через повторяющиеся вызовы.  |  
|Преобразовать <xref:System.Text.StringBuilder> объект <xref:System.String> объекта и внесения изменений на <xref:System.String> объекта.|Полезно, если количество изменений мал.|Инвертирует преимущества высокой производительности <xref:System.Text.StringBuilder> , если большое количество изменений.|  
  
 Давайте рассмотрим эти методы более подробно.  
  
-   Если цель поиска — для определения наличия определенной подстрокой (то есть, если вы не заинтересованы в положение подстроки), можно выполнить поиск строки перед их сохранением в <xref:System.Text.StringBuilder> объекта. Следующий пример предоставляет одна возможная реализация. Он определяет `StringBuilderFinder` класс, конструктор которого передается ссылка на <xref:System.Text.StringBuilder> объекта и в строке искомая подстрока. В этом случае в примере предпринимается попытка определить ли записанные температуры в шкале Цельсия или Фаренгейта и добавляет соответствующие вводного текста в начале <xref:System.Text.StringBuilder> объекта. Генератор случайных чисел используется для выбора массив, содержащий данные в градусах Цельсия или Фаренгейта.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   Вызовите <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> метод для преобразования <xref:System.Text.StringBuilder> объект <xref:System.String> объекта. Выполните поиск строки с помощью методов, таких как <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> или <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, или можно использовать регулярные выражения и <xref:System.Text.RegularExpressions.Regex> класса для поиска шаблонов. Так как оба <xref:System.Text.StringBuilder> и <xref:System.String> объекты используют для хранения символов, значения индекса этих символов, подстрок, кодировкой UTF-16 и совпадения регулярного выражения одинаковы в обоих объектах. Это позволяет использовать <xref:System.Text.StringBuilder> методы для внесения изменений в той же позиции, по которому этот текст, обнаруженный в <xref:System.String> объекта.  
  
    > [!NOTE]
    >  Если будет применен такой подход, вы должны работать с конца <xref:System.Text.StringBuilder> объекта для его начала, чтобы не нужно повторно преобразовать <xref:System.Text.StringBuilder> объект в строку.  
  
     Этот подход показан в приведенном ниже примере. Он сохраняет четыре вхождения каждой буквы английского алфавита в <xref:System.Text.StringBuilder> объекта. Затем он преобразует текст, <xref:System.String> и использует регулярное выражение для идентификации начальное положение каждой последовательности четырех символов. Наконец добавляется символ подчеркивания перед каждой последовательности четырех символов, за исключением первой последовательности и преобразует первый знак последовательности в верхний регистр.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   Используйте <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> свойства диапазон символов в последовательно <xref:System.Text.StringBuilder> объекта. Этот подход может оказаться практические Если количество символов для поиска имеет большой размер или логике поиска особенно сложен. Для последствия для производительности символ за символом доступа на основе индекса для очень больших, chunked <xref:System.Text.StringBuilder> объектов, см. в документации <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> свойство. 
  
     Следующий пример идентичен предыдущему примеру функциональных возможностей, но отличается в реализации. Она использует <xref:System.Text.StringBuilder.Chars%2A> свойство, чтобы определить, когда изменилось значение символа, вставляет символ подчеркивания в этой позиции и преобразует в верхний регистр первый символ в новой последовательности.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   Store без изменений текста в <xref:System.Text.StringBuilder> , вызовите <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> метод для преобразования <xref:System.Text.StringBuilder> объект <xref:System.String> объекта и внесения изменений на <xref:System.String> объекта. Этот подход можно использовать при наличии нескольких изменений; в противном случае стоимость работы со строками неизменяемый может отменить преимущества производительности с помощью <xref:System.Text.StringBuilder> объекта.  
  
     В следующем примере же функциональность для двух предыдущих примеров, но отличается в реализации. Он создает <xref:System.Text.StringBuilder> объекта, преобразует ее в <xref:System.String> объекта, а затем использует регулярное выражение для выполнения всех оставшихся изменений в строке. <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Метод использует лямбда-выражение для выполнения замены каждого соответствия.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>Преобразование объекта StringBuilder в строку  
 Необходимо преобразовать объект <xref:System.Text.StringBuilder> в <xref:System.String>, прежде чем передавать представленную объектом <xref:System.Text.StringBuilder> строку методу, который содержит параметр <xref:System.String>, или вывести ее в пользовательском интерфейсе. Выполнить это преобразование путем вызова <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> метод. Иллюстрация, см. в предыдущем примере, который вызывает <xref:System.Text.StringBuilder.ToString%2A> метод для преобразования <xref:System.Text.StringBuilder> объекта в строку, таким образом, его можно передать в метод регулярного выражения.  
  
   
  
## Examples  
 В следующем примере показано, как вызывать многие из методов, определенных <xref:System.Text.StringBuilder> класса.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
    </block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строковое значение данного экземпляра присваивается <xref:System.String.Empty?displayProperty=nameWithType>, и параметр capacity имеет значение емкости по умолчанию зависит от реализации.  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор без параметров.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">The suggested starting size of this instance.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class using the specified capacity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Параметр определяет максимальное количество символов, которые могут храниться в памяти, назначенной текущим экземпляром. Его значение будет назначено <xref:System.Text.StringBuilder.Capacity%2A> свойство. Если количество символов для сохранения в текущем экземпляре превышает это `capacity` значение, <xref:System.Text.StringBuilder> объект выделяет дополнительную память для их хранения.  
  
 Строковое значение данного экземпляра присваивается <xref:System.String.Empty?displayProperty=nameWithType>. Если `capacity` равно нулю, используется емкость по умолчанию зависит от реализации.  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор с указанной емкостью.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> is less than zero.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string used to initialize the value of the instance. If <c>value</c> is <see langword="null" />, the new <see cref="T:System.Text.StringBuilder" /> will contain the empty string (that is, it contains <see cref="F:System.String.Empty" />).</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class using the specified string.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `value` равно `null`, то новый <xref:System.Text.StringBuilder> будет содержать пустую строку (то есть, он содержит <xref:System.String.Empty>).  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор с указанной строкой.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">The suggested starting size of the <see cref="T:System.Text.StringBuilder" />.</param>
        <param name="maxCapacity">The maximum number of characters the current string can contain.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class that starts with a specified capacity and can grow to a specified maximum.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Параметр определяет максимальное количество символов, которые могут храниться в памяти, назначенной текущим экземпляром. Его значение будет назначено <xref:System.Text.StringBuilder.Capacity%2A> свойство. Если количество символов для сохранения в текущем экземпляре превышает это `capacity` значение, <xref:System.Text.StringBuilder> объект выделяет дополнительную память для их хранения.  
  
 Если `capacity` равно нулю, используется емкость по умолчанию зависит от реализации.  
  
 `maxCapacity` Свойство определяет максимальное количество символов, содержащихся в текущем экземпляре. Его значение будет назначено <xref:System.Text.StringBuilder.MaxCapacity%2A> свойство. Если количество символов для сохранения в текущем экземпляре превышает это `maxCapacity` значение, <xref:System.Text.StringBuilder> объект не выделить дополнительную память, но вместо этого формируется исключение.  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор с указанной емкости и максимальная емкость.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxCapacity" /> is less than one, <paramref name="capacity" /> is less than zero, or <paramref name="capacity" /> is greater than <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The string used to initialize the value of the instance. If <c>value</c> is <see langword="null" />, the new <see cref="T:System.Text.StringBuilder" /> will contain the empty string (that is, it contains <see cref="F:System.String.Empty" />).</param>
        <param name="capacity">The suggested starting size of the <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class using the specified string and capacity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Параметр определяет максимальное количество символов, которые могут храниться в памяти, назначенной текущим экземпляром. Его значение будет назначено <xref:System.Text.StringBuilder.Capacity%2A> свойство. Если количество символов для сохранения в текущем экземпляре превышает это `capacity` значение, <xref:System.Text.StringBuilder> объект выделяет дополнительную память для их хранения.  
  
 Если `capacity` равно нулю, используется емкость по умолчанию зависит от реализации.  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор с начальной строки и указанной емкостью.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> is less than zero.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The string that contains the substring used to initialize the value of this instance. If <c>value</c> is <see langword="null" />, the new <see cref="T:System.Text.StringBuilder" /> will contain the empty string (that is, it contains <see cref="F:System.String.Empty" />).</param>
        <param name="startIndex">The position within <c>value</c> where the substring begins.</param>
        <param name="length">The number of characters in the substring.</param>
        <param name="capacity">The suggested starting size of the <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class from the specified substring and capacity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Параметр определяет максимальное количество символов, которые могут храниться в памяти, назначенной текущим экземпляром. Его значение будет назначено <xref:System.Text.StringBuilder.Capacity%2A> свойство. Если количество символов для сохранения в текущем экземпляре превышает это `capacity` значение, <xref:System.Text.StringBuilder> объект выделяет дополнительную память для их хранения.  
  
 Если `capacity` равно нулю, используется емкость по умолчанию зависит от реализации.  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор с указанной строкой.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> is less than zero.  -or-  <paramref name="startIndex" /> plus <paramref name="length" /> is not a position within <paramref name="value" />.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Appends the string representation of a specified object to this instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">The Boolean value to append.</param>
        <summary>Appends the string representation of a specified Boolean value to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Вызовы методов <xref:System.Boolean.ToString?displayProperty=nameWithType> метод, чтобы получить строковое представление `value`. При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 8-bit unsigned integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> Вызовы методов <xref:System.Byte.ToString%28System.IFormatProvider%29> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">The UTF-16-encoded code unit to append.</param>
        <summary>Appends the string representation of a specified <see cref="T:System.Char" /> object to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">The array of characters to append.</param>
        <summary>Appends the string representation of the Unicode characters in a specified array to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет все символы в указанном массиве для текущего экземпляра в том же порядке, как они указаны в `value`. Если `value` является `null`, изменения не вносятся.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified decimal number to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Вызовы методов <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified double-precision floating-point number to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> Вызовы методов <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 16-bit signed integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> Вызовы методов <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 32-bit signed integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29> Вызовы методов <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 64-bit signed integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> Вызовы методов <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The object to append.</param>
        <summary>Appends the string representation of a specified object to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Object%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере. Он определяет `Dog` класса, создает `Dog` объекта и делает три вызова <xref:System.Text.StringBuilder.Append%2A> метод, чтобы создать строку, содержащую имя и в своем классе dog.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Object%29> Вызовы методов <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, чтобы получить строковое представление `value`. Если `value` — `null`, изменения не вносятся в <xref:System.Text.StringBuilder> объекта.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 8-bit signed integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> Вызовы методов <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified single-precision floating-point number to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> Вызовы методов <xref:System.Single.ToString%2A?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to append.</param>
        <summary>Appends a copy of the specified string to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.String%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Если `value` является `null`, изменения не вносятся.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 16-bit unsigned integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Вызовы методов <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value`. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 32-bit unsigned integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Вызовы <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 64-bit unsigned integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Вызовы методов <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The character to append.</param>
        <param name="repeatCount">The number of times to append <c>value</c>.</param>
        <summary>Appends a specified number of copies of the string representation of a Unicode character to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="repeatCount" /> is less than zero.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Out of memory.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="valueCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A pointer to an array of characters.</param>
        <param name="valueCount">The number of characters in the array.</param>
        <summary>Appends an array of Unicode characters starting at a specified address to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет `valueCount` символов, начиная с адреса `value` текущему экземпляру.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="valueCount" /> is less than zero.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> is a null pointer.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A character array.</param>
        <param name="startIndex">The starting position in <c>value</c>.</param>
        <param name="charCount">The number of characters to append.</param>
        <summary>Appends the string representation of a specified subarray of Unicode characters to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет заданный диапазон символов в `value` текущему экземпляру. Если `value` — `null` и `startIndex` и `count` оба ноль, не изменяются.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />, and <paramref name="startIndex" /> and <paramref name="charCount" /> are not zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> is less than zero.  -or-  <paramref name="startIndex" /> is less than zero.  -or-  <paramref name="startIndex" /> + <paramref name="charCount" /> is greater than the length of <paramref name="value" />.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The string that contains the substring to append.</param>
        <param name="startIndex">The starting position of the substring within <c>value</c>.</param>
        <param name="count">The number of characters in <c>value</c> to append.</param>
        <summary>Appends a copy of a specified substring to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет заданный диапазон символов в `value` текущему экземпляру. Если `value` — `null` и `startIndex` и `count` оба ноль, не изменяются.  
  
 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />, and <paramref name="startIndex" /> and <paramref name="count" /> are not zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> less than zero.  -or-  <paramref name="startIndex" /> less than zero.  -or-  <paramref name="startIndex" /> + <paramref name="count" /> is greater than the length of <paramref name="value" />.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a corresponding object argument.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">A composite format string.</param>
        <param name="arg0">An object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a single argument.</summary>
        <returns>A reference to this instance with <paramref name="format" /> appended. Each format item in <paramref name="format" /> is replaced by the string representation of <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования. Индекс элемента форматирования должен быть 0, в соответствии с `arg0`, один объект в списке параметров этого метода. Процесс форматирования каждый элемент формата заменяется строковым представлением `arg0`.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. При отсутствии параметра в *индекс* позиции, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` Представляет объект для форматирования. Каждый элемент формата в `format` заменяется строковым представлением `arg0`. Если элемент формата включает `formatString` и `arg0` реализует <xref:System.IFormattable> интерфейс, затем `arg0.ToString(formatString, null)` определяет форматирование. В противном случае `arg0.ToString()` определяет форматирование.  
  
 Если строка, назначенная `format` является «Спасибо за пожертвование {0: ###} консервных банок нашей благотворительной организации.» и `arg0` должно быть целым числом со значением 10, возвращаемое значение будет «Спасибо за пожертвование 10 консервных банок нашей благотворительной организации».  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">A composite format string.</param>
        <param name="args">An array of objects to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a corresponding argument in a parameter array.</summary>
        <returns>A reference to this instance with <paramref name="format" /> appended. Each format item in <paramref name="format" /> is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процессе форматирования каждый элемент формата заменяется строковым представлением соответствующего объекта.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. При отсутствии параметра в *индекс* позиции, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `args` Представляет объекты, которые необходимо отформатировать. Каждый элемент формата в `format` заменяется строковым представлением соответствующего объекта в `args`. Если элемент формата включает `formatString` и соответствующего объекта в `args` реализует <xref:System.IFormattable> интерфейс, затем `args[index].ToString(formatString, provider)` определяет форматирование. В противном случае `args[index].ToString()` определяет форматирование.  
  
 Если строка, назначенная `format` является «Спасибо за пожертвование {0: ###} консервных банок нашей благотворительной организации.» и `arg0` должно быть целым числом со значением 10, возвращаемое значение будет «Спасибо за пожертвование 10 консервных банок нашей благотворительной организации».  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to the length of the <paramref name="args" /> array.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <param name="format">A composite format string.</param>
        <param name="arg0">The object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a single argument using a specified format provider.</summary>
        <returns>A reference to this instance after the append operation has completed. After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> in which any format specification is replaced by the string representation of <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения `arg0` текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования. Индекс каждого элемента форматирования должен равняться нулю (0), так как этот метод содержит список аргументов с одним аргументом. Процесс форматирования каждый элемент формата заменяется строковым представлением `arg0`.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. В этом случае с момента <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> метод имеет один аргумент в списке аргументов, значение *индекс* всегда должен быть 0. Если это не так, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Параметр указывает <xref:System.IFormatProvider> реализация, которую может предоставить сведения о форматировании для объектов в `args`. Параметр `provider` может иметь любое из следующих значений.  
  
-   Объект <xref:System.Globalization.CultureInfo> объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0` если он является числовым значением.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0` Если это значение даты и времени.  
  
-   Пользовательский <xref:System.IFormatProvider> реализация, которая предоставляет сведения о форматировании `arg0`. Как правило, также реализует такой реализации <xref:System.ICustomFormatter> интерфейс.  
  
 Если `provider` параметр `null`, форматирования сведения извлекаются из текущего языка и региональных параметров.  
  
 `arg0` Представляет объект для форматирования. Каждый элемент формата в `format` заменяется строковым представлением `arg0`. Если элемент формата включает `formatString` и `arg0` реализует <xref:System.IFormattable> интерфейс, затем `arg0.ToString(formatString, provider)` определяет форматирование. В противном случае `arg0.ToString()` определяет форматирование.  
  
   
  
## Examples  
 Включает в себя следующие два вызова <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> метод. Используют соглашения о форматировании языка и региональных параметров Английский — Великобритания (en-GB). Первый Вставляет строковое представление <xref:System.Decimal> значение валюты в результирующую строку. Второй операции вставки <xref:System.DateTime> значение в двух местах, в результате строки, первый включая только для краткосрочного Дата строки, а вторая строка короткого времени.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to one (1).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <param name="format">A composite format string.</param>
        <param name="args">An array of objects to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a corresponding argument in a parameter array using a specified format provider.</summary>
        <returns>A reference to this instance after the append operation has completed. After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> where any format specification is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процессе форматирования каждый элемент формата заменяется строковым представлением соответствующего объекта.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. При отсутствии параметра в *индекс* позиции, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Параметр указывает <xref:System.IFormatProvider> реализация, которую может предоставить сведения о форматировании для объектов в `args`. Параметр `provider` может иметь любое из следующих значений.  
  
-   Объект <xref:System.Globalization.CultureInfo> объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения об особенностях язык и региональные параметры форматирования для числовых значений в `args`.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo> объект, предоставляющий сведения об особенностях язык и региональные параметры форматирования для значений даты и времени в `args`.  
  
-   Пользовательский <xref:System.IFormatProvider> реализация, которая предоставляет сведения о форматировании для одного или нескольких объектов в `args`. Как правило, также реализует такой реализации <xref:System.ICustomFormatter> интерфейс. Во втором примере в следующем разделе показан <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> вызов метода с пользовательским <xref:System.IFormatProvider> реализации.  
  
 Если `provider` параметр `null`, сведения о поставщике формата получается из текущего языка и региональных параметров.  
  
 `args` Представляет объекты, которые необходимо отформатировать. Каждый элемент формата в `format` заменяется строковым представлением соответствующего объекта в `args`. Если элемент формата включает `formatString` и соответствующего объекта в `args` реализует <xref:System.IFormattable> интерфейс, затем `args[index].ToString(formatString, provider)` определяет форматирование. В противном случае `args[index].ToString()` определяет форматирование.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 В следующем примере определяется пользовательский <xref:System.IFormatProvider> реализацию, именуемую `CustomerFormatter` , форматы чисел с дефисами клиента 10-значный после четвертая и седьмая цифр. Он передается <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> метод, чтобы создать строку, содержащую номер форматированный клиента и имя клиента.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to the length of the <paramref name="args" /> array.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">A composite format string.</param>
        <param name="arg0">The first object to format.</param>
        <param name="arg1">The second object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of either of two arguments.</summary>
        <returns>A reference to this instance with <paramref name="format" /> appended. Each format item in <paramref name="format" /> is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют `arg0` и `arg1`, два объекта в списке параметров этого метода. Процессе форматирования каждый элемент формата заменяется строковым представлением соответствующего объекта.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. При отсутствии параметра в *индекс* позиции, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` и `arg1` представляют объекты, которые необходимо отформатировать. Каждый элемент формата в `format` заменяется строковым представлением любого `arg0` или `arg1`. Если элемент формата включает `formatString` и соответствующий объект реализует <xref:System.IFormattable> интерфейс, затем `arg` *x* `.ToString(formatString, provider)` определяет форматирование, где *x* — Это индекс аргумента. В противном случае `arg` *x* `.ToString()` определяет форматирование.  
  
 Если строка, назначенная `format` является «Спасибо за пожертвование {0: ###} консервных банок нашей благотворительной организации.» и `arg0` должно быть целым числом со значением 10, возвращаемое значение будет «Спасибо за пожертвование 10 консервных банок нашей благотворительной организации».  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to 2.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <param name="format">A composite format string.</param>
        <param name="arg0">The first object to format.</param>
        <param name="arg1">The second object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of either of two arguments using a specified format provider.</summary>
        <returns>A reference to this instance after the append operation has completed. After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> where any format specification is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процессе форматирования каждый элемент формата заменяется строковым представлением соответствующего объекта.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. При отсутствии параметра в *индекс* позиции, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Параметр указывает <xref:System.IFormatProvider> реализация, которую может предоставить сведения о форматировании `arg0` и `arg1`. Параметр `provider` может иметь любое из следующих значений.  
  
-   Объект <xref:System.Globalization.CultureInfo> объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0` или `arg1` если они являются числовыми значениями.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0` или `arg1` если они значений даты и времени.  
  
-   Пользовательский <xref:System.IFormatProvider> реализация, которая предоставляет сведения о форматировании `arg0` и `arg1`. Как правило, также реализует такой реализации <xref:System.ICustomFormatter> интерфейс.  
  
 Если `provider` параметр `null`, сведения о поставщике формата получается из текущего языка и региональных параметров.  
  
 `arg0` и `arg1` представляют объекты, которые необходимо отформатировать. Каждый элемент формата в `format` заменяется строковым представлением объект, имеющий соответствующий индекс. Если элемент формата включает `formatString` и соответствующий аргумент реализует <xref:System.IFormattable> интерфейс, а затем аргумента `ToString(formatString, provider)` метод определяет форматирование. В противном случае аргумент `ToString()` метод определяет форматирование.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> метод для отображения данных температуры и времени, хранящиеся в универсальной <xref:System.Collections.Generic.Dictionary%602> объекта. Обратите внимание на то, что строка формата имеет три элемента форматирования, несмотря на то, что существует только для объектов для форматирования. Это обусловлено тем, первый объект в списке (значение даты и времени) используется два элемента форматирования: первый элемент отображает формат, время, а вторая отображает дату.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to 2 (two).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">A composite format string.</param>
        <param name="arg0">The first object to format.</param>
        <param name="arg1">The second object to format.</param>
        <param name="arg2">The third object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of either of three arguments.</summary>
        <returns>A reference to this instance with <paramref name="format" /> appended. Each format item in <paramref name="format" /> is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют `arg0` через `arg2`, объекты в списке параметров этого метода. Процессе форматирования каждый элемент формата заменяется строковым представлением соответствующего объекта.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. При отсутствии параметра в *индекс* позиции, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`, `arg1`, и `arg2` представляют объекты, которые необходимо отформатировать. Каждый элемент формата в `format` заменяется строковым представлением любого `arg0`, `arg1`, или `arg2`в зависимости от индекса элемента форматирования. Если элемент формата включает `formatString` и соответствующего объекта в `args` реализует <xref:System.IFormattable> интерфейс, затем `arg` *x* `.ToString(formatString, null)` определяет форматирование, где * x* — это индекс аргумента. В противном случае `arg` *x* `.ToString()` определяет форматирование.  
  
 Если строка, назначенная `format` является «Спасибо за пожертвование {0: ###} консервных банок нашей благотворительной организации.» и `arg0` должно быть целым числом со значением 10, возвращаемое значение будет «Спасибо за пожертвование 10 консервных банок нашей благотворительной организации».  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to 3.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <param name="format">A composite format string.</param>
        <param name="arg0">The first object to format.</param>
        <param name="arg1">The second object to format.</param>
        <param name="arg2">The third object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of either of three arguments using a specified format provider.</summary>
        <returns>A reference to this instance after the append operation has completed. After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> where any format specification is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процессе форматирования каждый элемент формата заменяется строковым представлением соответствующего объекта.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. При отсутствии параметра в *индекс* позиции, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Параметр указывает <xref:System.IFormatProvider> реализация, которую может предоставить сведения о форматировании `arg0` и `arg1`. Параметр `provider` может иметь любое из следующих значений.  
  
-   Объект <xref:System.Globalization.CultureInfo> объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0` или `arg1` если они являются числовыми значениями.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0`, `arg1`, или `arg2` если они значений даты и времени.  
  
-   Пользовательский <xref:System.IFormatProvider> реализация, которая предоставляет сведения о форматировании `arg0`, `arg1`, и `arg2`. Как правило, также реализует такой реализации <xref:System.ICustomFormatter> интерфейс.  
  
 Если `provider` параметр `null`, сведения о поставщике формата получается из текущего языка и региональных параметров.  
  
 `arg0`, `arg1`, и `arg2` представляют объекты, которые необходимо отформатировать. Каждый элемент формата в `format` заменяется строковым представлением объект, имеющий соответствующий индекс. Если элемент формата включает `formatString` и соответствующий аргумент реализует <xref:System.IFormattable> интерфейс, а затем аргумента `ToString(formatString, provider)` метод определяет форматирование. В противном случае аргумент `ToString()` метод определяет форматирование.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> метод, чтобы проиллюстрировать результат логического значения `And` операции с помощью целочисленных значений. Обратите внимание, строка формата содержит шесть элементов форматирования, что метод имеет только три элемента в списке аргументов, так как каждый элемент форматируется двумя разными способами.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The index of a format item is less than 0 (zero), or greater than or equal to 3 (three).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Appends the default line terminator, or a copy of a specified string and the default line terminator, to the end of this instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appends the default line terminator to the end of the current <see cref="T:System.Text.StringBuilder" /> object.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Знак завершения строки по умолчанию является текущее значение <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> свойства.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendLine%2A> метод.  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to append.</param>
        <summary>Appends a copy of the specified string followed by the default line terminator to the end of the current <see cref="T:System.Text.StringBuilder" /> object.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Знак завершения строки по умолчанию является текущее значение <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> свойства.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v40_short](~/includes/NET-v40-Short-MD.MD)] и [! INCLUDE[net_v45](~/includes/NET-v45-MD.MD)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство . Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum number of characters that can be contained in the memory allocated by the current instance.</summary>
        <value>Максимальное число символов, которое может содержаться в памяти, назначенной текущим экземпляром. Это значение может меняться в диапазоне от <see cref="P:System.Text.StringBuilder.Length" /> до <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> не влияет на строковое значение текущего экземпляра. <xref:System.Text.StringBuilder.Capacity%2A> может быть уменьшен, поскольку он не меньше, чем <xref:System.Text.StringBuilder.Length%2A>.  
  
 <xref:System.Text.StringBuilder> Динамически выделяет больше пространства, при необходимости и увеличивает <xref:System.Text.StringBuilder.Capacity%2A> соответствующим образом. Для повышения производительности <xref:System.Text.StringBuilder> может выделять больше памяти, чем требуется. Размер выделенной памяти зависит от реализации.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Capacity%2A> свойство.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than the current length of this instance.  -or-  The value specified for a set operation is greater than the maximum capacity.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The position of the character.</param>
        <summary>Gets or sets the character at the specified character position in this instance.</summary>
        <value>Символ Юникода в позиции <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` Параметр — это положение символа в <xref:System.Text.StringBuilder>. Первый символ в строке находится по индексу 0. Длина строки — количество символов, содержащихся в нем. Последний доступный знак <xref:System.Text.StringBuilder> экземпляр является индексом <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 <xref:System.Text.StringBuilder.Chars%2A> по умолчанию свойство <xref:System.Text.StringBuilder> класса. В C# это индексатора. Это означает, что отдельные символы могут быть получены от <xref:System.Text.StringBuilder.Chars%2A> свойства, как показано в следующем примере, который подсчитывает число является буквой алфавита, пробелы и знаков препинания в строку.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>Производительность и символьного индексирования

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is outside the bounds of this instance while setting a character.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> is outside the bounds of this instance while getting a character.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes all characters from the current <see cref="T:System.Text.StringBuilder" /> instance.</summary>
        <returns>An object whose <see cref="P:System.Text.StringBuilder.Length" /> is 0 (zero).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Clear%2A> удобный метод, которое эквивалентно значению параметра <xref:System.Text.StringBuilder.Length%2A> свойства текущего экземпляра 0 (ноль).  
  
 Вызов <xref:System.Text.StringBuilder.Clear%2A> метод не изменяет текущий экземпляр <xref:System.Text.StringBuilder.Capacity%2A> или <xref:System.Text.StringBuilder.MaxCapacity%2A> свойство.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Text.StringBuilder> объекта со строкой, а вызовы <xref:System.Text.StringBuilder.Clear%2A> метод, а затем добавляет новую строку.  
  
 [!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">The starting position in this instance where characters will be copied from. The index is zero-based.</param>
        <param name="destination">The array where characters will be copied.</param>
        <param name="destinationIndex">The starting position in <c>destination</c> where characters will be copied. The index is zero-based.</param>
        <param name="count">The number of characters to be copied.</param>
        <summary>Copies the characters from a specified segment of this instance to a specified segment of a destination <see cref="T:System.Char" /> array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.CopyTo%2A> Метод должен использоваться в редких случаях, когда необходимо эффективно копировать последующих разделах <xref:System.Text.StringBuilder> в массив. Массив должен иметь фиксированный размер, выделенные для повторного использования и глобального доступа.  
  
 Например, приложение может заполнить <xref:System.Text.StringBuilder> объекта с большим числом символов, а затем используйте <xref:System.Text.StringBuilder.CopyTo%2A> метод копирования небольших, последовательные части <xref:System.Text.StringBuilder> в массив, в котором обрабатываются элементы. Когда все данные в <xref:System.Text.StringBuilder> обработки объекта, размер <xref:System.Text.StringBuilder> объекта, равным нулю, и цикл повторяется.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.CopyTo%2A> метод.  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" />, or <paramref name="count" />, is less than zero.  -or-  <paramref name="sourceIndex" /> is greater than the length of this instance.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceIndex" /> + <paramref name="count" /> is greater than the length of this instance.  -or-  <paramref name="destinationIndex" /> + <paramref name="count" /> is greater than the length of <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">The minimum capacity to ensure.</param>
        <summary>Ensures that the capacity of this instance of <see cref="T:System.Text.StringBuilder" /> is at least the specified value.</summary>
        <returns>The new capacity of this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий объем будет меньше, чем `capacity` параметра, происходит перераспределение памяти для данного экземпляра для по крайней мере `capacity` знаков; в противном случае изменения памяти не происходит.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.EnsureCapacity%2A> метод.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> is less than zero.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">An object to compare with this instance, or <see langword="null" />.</param>
        <summary>Returns a value indicating whether this instance is equal to a specified object.</summary>
        <returns>
          <see langword="true" /> if this instance and <paramref name="sb" /> have equal string, <see cref="P:System.Text.StringBuilder.Capacity" />, and <see cref="P:System.Text.StringBuilder.MaxCapacity" /> values; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем коде используется <xref:System.Text.StringBuilder.Equals%2A> метод для проверки двух <xref:System.Text.StringBuilder> объекты равны. Метод вызывается повторно после небольших изменений к каждому объекту, а результаты выводятся на консоль.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inserts the string representation of a specified object into this instance at a specified character position.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a Boolean value into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость настроена, при необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [! Вызывает метод Include[net_v40_long](~/includes/NET-v40-Long-MD.MD)] <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a specified 8-bit unsigned integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [! Вызывает метод Include[net_v40_long](~/includes/NET-v40-Long-MD.MD)] <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a specified Unicode character into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The character array to insert.</param>
        <summary>Inserts the string representation of a specified array of Unicode characters into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
 Если `value` — `null`, <xref:System.Text.StringBuilder> не изменяется.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a decimal number into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [! Вызывает метод Include[net_v40_long](~/includes/NET-v40-Long-MD.MD)] <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a double-precision floating-point number into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [! Вызывает метод Include[net_v40_long](~/includes/NET-v40-Long-MD.MD)] <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a specified 16-bit signed integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [! Вызывает метод Include[net_v40_long](~/includes/NET-v40-Long-MD.MD)] <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a specified 32-bit signed integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [! Вызывает метод Include[net_v40_long](~/includes/NET-v40-Long-MD.MD)] <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a 64-bit signed integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [! Вызывает метод Include[net_v40_long](~/includes/NET-v40-Long-MD.MD)] <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The object to insert, or <see langword="null" />.</param>
        <summary>Inserts the string representation of an object into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
 Если `value` является `null`, значение данного экземпляра остается неизменным.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [! Вызывает метод Include[net_v40_long](~/includes/NET-v40-Long-MD.MD)] <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a specified 8-bit signed integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость настроена, при необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [! Вызывает метод Include[net_v40_long](~/includes/NET-v40-Long-MD.MD)] <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a single-precision floating point number into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [! Вызывает метод Include[net_v40_long](~/includes/NET-v40-Long-MD.MD)] <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The string to insert.</param>
        <summary>Inserts a string into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость настроена, при необходимости.  
  
 Этот экземпляр <xref:System.Text.StringBuilder> изменяется не в том случае, если `value` — `null`, или `value` не `null` , но его длина равна нулю.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the current length of this instance.  -or-  The current length of this <see cref="T:System.Text.StringBuilder" /> object plus the length of <paramref name="value" /> exceeds <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a 16-bit unsigned integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [! Вызывает метод Include[net_v40_long](~/includes/NET-v40-Long-MD.MD)] <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a 32-bit unsigned integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [! Вызывает метод Include[net_v40_long](~/includes/NET-v40-Long-MD.MD)] <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a 64-bit unsigned integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [! Вызывает метод Include[net_v40_long](~/includes/NET-v40-Long-MD.MD)] <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The string to insert.</param>
        <param name="count">The number of times to insert <c>value</c>.</param>
        <summary>Inserts one or more copies of a specified string into this instance at the specified character position.</summary>
        <returns>A reference to this instance after insertion has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
 Это <xref:System.Text.StringBuilder> объекта не изменяется, если `value` — `null`, `value` не `null` , но его длина равна нулю, или `count` равно нулю.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero or greater than the current length of this instance.  -or-  <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.OutOfMemoryException">The current length of this <see cref="T:System.Text.StringBuilder" /> object plus the length of <paramref name="value" /> times <paramref name="count" /> exceeds <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">A character array.</param>
        <param name="startIndex">The starting index within <c>value</c>.</param>
        <param name="charCount">The number of characters to insert.</param>
        <summary>Inserts the string representation of a specified subarray of Unicode characters into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />, and <paramref name="startIndex" /> and <paramref name="charCount" /> are not zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />, <paramref name="startIndex" />, or <paramref name="charCount" /> is less than zero.  -or-  <paramref name="index" /> is greater than the length of this instance.  -or-  <paramref name="startIndex" /> plus <paramref name="charCount" /> is not a position within <paramref name="value" />.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the length of the current <see cref="T:System.Text.StringBuilder" /> object.</summary>
        <value>Длина этого экземпляра.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Длина <xref:System.Text.StringBuilder> объект определяется его число <xref:System.Char> объектов.  
  
 Как и <xref:System.String.Length%2A?displayProperty=nameWithType> свойства <xref:System.Text.StringBuilder.Length%2A> свойство, указывающее длину текущего строкового объекта. В отличие от <xref:System.String.Length%2A?displayProperty=nameWithType> свойство, которое доступно только для чтения, <xref:System.Text.StringBuilder.Length%2A> свойства можно изменить длину строки, хранящейся в <xref:System.Text.StringBuilder> объекта.  
  
 Если указанная длина меньше, чем текущая длина текущего <xref:System.Text.StringBuilder> объект усекается до указанной длины. Если указанная длина больше, чем текущая длина, конец строковое значение текущего <xref:System.Text.StringBuilder> объект дополняется символом NULL Юникода (U + 0000).  
  
 Если указанная длина больше текущей емкости, <xref:System.Text.StringBuilder.Capacity%2A> увеличивается, так как это не меньше указанной длины.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Length%2A> свойство.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than zero or greater than <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum capacity of this instance.</summary>
        <value>Наибольшее количество символов, которое может содержать данный экземпляр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Максимальная емкость для этой реализации — <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Тем не менее это значение зависит от реализации и может отличаться в других реализациях. Можно явно задать максимальную емкость <xref:System.Text.StringBuilder> путем вызова метода <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> конструктор.  
  
 В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <xref:System.Text.StringBuilder> путем вызова метода <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> конструктор, длина и емкость <xref:System.Text.StringBuilder> экземпляр может выйти за пределы значение его <xref:System.Text.StringBuilder.MaxCapacity%2A> свойство. Это может произойти, особенно при вызове <xref:System.Text.StringBuilder.Append%2A> и <xref:System.Text.StringBuilder.AppendFormat%2A> методы для добавления небольших строк.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <param name="length">The number of characters to remove.</param>
        <summary>Removes the specified range of characters from this instance.</summary>
        <returns>A reference to this instance after the excise operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий метод удаляет указанный диапазон символов из текущего экземпляра. Символы в (`startIndex` + `length`) перемещаются `startIndex`, и строковое значение текущего экземпляра сокращается на `length`. Емкость текущего экземпляра не изменится.  
  
> [!NOTE]
>  <xref:System.Text.StringBuilder.Remove%2A> Метод изменяет значение текущего <xref:System.Text.StringBuilder> экземпляра и возвращает этот экземпляр. Создание и не возвращают новый <xref:System.Text.StringBuilder> объекта.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Remove%2A> метод.  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="startIndex" /> or <paramref name="length" /> is less than zero, or <paramref name="startIndex" /> + <paramref name="length" /> is greater than the length of this instance.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Replaces all occurrences of a specified character or string in this instance with another specified character or string.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">The character to replace.</param>
        <param name="newChar">The character that replaces <c>oldChar</c>.</param>
        <summary>Replaces all occurrences of a specified character in this instance with another specified character.</summary>
        <returns>A reference to this instance with <paramref name="oldChar" /> replaced by <paramref name="newChar" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение по порядковому номеру с учетом регистра для идентификации вхождения `oldChar` в текущем экземпляре. Размер текущего <xref:System.Text.StringBuilder> экземпляра остается неизменным после замены.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Replace%2A> метод.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">The string to replace.</param>
        <param name="newValue">The string that replaces <c>oldValue</c>, or <see langword="null" />.</param>
        <summary>Replaces all occurrences of a specified string in this instance with another specified string.</summary>
        <returns>A reference to this instance with all instances of <paramref name="oldValue" /> replaced by <paramref name="newValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение по порядковому номеру с учетом регистра для идентификации вхождения `oldValue` в текущем экземпляре. Если `newValue` — `null` или <xref:System.String.Empty?displayProperty=nameWithType>, все вхождения `oldValue` удаляются.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Replace%2A> метод.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The length of <paramref name="oldValue" /> is zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">The character to replace.</param>
        <param name="newChar">The character that replaces <c>oldChar</c>.</param>
        <param name="startIndex">The position in this instance where the substring begins.</param>
        <param name="count">The length of the substring.</param>
        <summary>Replaces, within a substring of this instance, all occurrences of a specified character with another specified character.</summary>
        <returns>A reference to this instance with <paramref name="oldChar" /> replaced by <paramref name="newChar" /> in the range from <paramref name="startIndex" /> to <paramref name="startIndex" /> + <paramref name="count" /> -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение по порядковому номеру с учетом регистра для идентификации вхождения `oldChar` в текущем экземпляре. Размер текущего <xref:System.Text.StringBuilder> объект остается неизменным после замены.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Replace%2A> метод.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> + <paramref name="count" /> is greater than the length of the value of this instance.  -or-  <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">The string to replace.</param>
        <param name="newValue">The string that replaces <c>oldValue</c>, or <see langword="null" />.</param>
        <param name="startIndex">The position in this instance where the substring begins.</param>
        <param name="count">The length of the substring.</param>
        <summary>Replaces, within a substring of this instance, all occurrences of a specified string with another specified string.</summary>
        <returns>A reference to this instance with all instances of <paramref name="oldValue" /> replaced by <paramref name="newValue" /> in the range from <paramref name="startIndex" /> to <paramref name="startIndex" /> + <paramref name="count" /> - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение по порядковому номеру с учетом регистра для идентификации вхождения `oldValue` в указанной подстроки. Если `newValue` — `null` или <xref:System.String.Empty?displayProperty=nameWithType>, все вхождения `oldValue` удаляются.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Replace%2A> метод.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The length of <paramref name="oldValue" /> is zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="startIndex" /> plus <paramref name="count" /> indicates a character position not within this instance.  -or-  Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">The object to populate with serialization information.</param>
        <param name="context">The place to store and retrieve serialized data. Reserved for future use.</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data necessary to deserialize the current <see cref="T:System.Text.StringBuilder" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `context` Параметр зарезервирован для использования в будущем и не участвует в этой операции.  
  
 Дополнительные сведения см. в описании метода <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts the value of a <see cref="T:System.Text.StringBuilder" /> to a <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converts the value of this instance to a <see cref="T:System.String" />.</summary>
        <returns>A string whose value is the same as this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо вызвать <xref:System.Text.StringBuilder.ToString%2A> метод для преобразования <xref:System.Text.StringBuilder> объект <xref:System.String> перед можно передать строку, представленную объектом <xref:System.Text.StringBuilder> в метод, имеющий <xref:System.String> параметра или для отображения его в пользовательском интерфейсе.  
  
   
  
## Examples  
 В следующем примере демонстрируется вызов метода <xref:System.Text.StringBuilder.ToString%2A>. Этот пример является частью большего примера для <xref:System.Text.StringBuilder> класса.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">The starting position of the substring in this instance.</param>
        <param name="length">The length of the substring.</param>
        <summary>Converts the value of a substring of this instance to a <see cref="T:System.String" />.</summary>
        <returns>A string whose value is the same as the specified substring of this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо вызвать <xref:System.Text.StringBuilder.ToString%2A> метод для преобразования <xref:System.Text.StringBuilder> объект <xref:System.String> перед можно передать строку, представленную объектом <xref:System.Text.StringBuilder> в метод, имеющий <xref:System.String> параметра или для отображения его в пользовательском интерфейсе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.  -or-  The sum of <paramref name="startIndex" /> and <paramref name="length" /> is greater than the length of the current instance.</exception>
      </Docs>
    </Member>
  </Members>
</Type>