<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="be19bdb3283edd18f1fefcc8e73a6e60f1c1de24" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911224" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет изменяемую строку символов. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс представляет объект строкового типа, значение которого является изменяемой последовательностью символов.  
  
 Содержание  
  
-   [Типы String и StringBuilder](#StringAndSB)  
  
-   [Как работает StringBuilder](#HowWorks)  
  
-   [Выделение памяти](#Memory)  
  
-   [Создание экземпляра объекта StringBuilder](#Instantiating)  
  
-   [Вызов методов StringBuilder](#Calling)  
  
-   [Выполнение операций StringBuilder](#Operations)  
  
    -   [Итерация StringBuilder символов](#Iterating)  
  
    -   [Добавление текста в объект StringBuilder](#Adding)  
  
    -   [Удаление текста из объекта StringBuilder](#Deleting)  
  
    -   [Изменение текста в объект StringBuilder](#Modifying)  
  
-   [Поиск текста в объект StringBuilder](#Searching)  
  
-   [Преобразование объекта StringBuilder в строку](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>Типы String и StringBuilder  
 Несмотря на то что <xref:System.Text.StringBuilder> и <xref:System.String> оба представляют последовательности символов, они реализованы по-разному. <xref:System.String> является неизменяемым типом. То есть каждой операции, которое отображается для изменения <xref:System.String> объект фактически создает новую строку.  
  
 Например, вызов <xref:System.String.Concat%2A?displayProperty=nameWithType> метод в следующем примере C#, по-видимому, измените значение строковую переменную с именем `value`. На самом деле <xref:System.String.Concat%2A> возвращает `value` объекта, имеющего другое значение и адрес из `value` объектом, переданным методу. Обратите внимание, что пример должны компилироваться с помощью `/unsafe` параметр компилятора.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 Для подпрограмм, выполняющих широко строками (например, приложения, изменяющие строку несколько раз в цикле) изменив строку несколько раз можно точное к значительному снижению производительности. Альтернативой является использование <xref:System.Text.StringBuilder>, — это класс, изменяемую строку. Изменяемость означает, что после создания экземпляра класса его можно изменить путем добавления, удаления, замены или Вставка символов. Объект <xref:System.Text.StringBuilder> объект поддерживает буфер, чтобы вместить их развертывание в строку. Новые данные добавляются в буфер, если доступно места; в противном случае выделяется новый, больший буфера, данные из исходного буфера копируются в новый буфер и затем добавляются новые данные в новый буфер.  
  
> [!IMPORTANT]
>  Несмотря на то что <xref:System.Text.StringBuilder> класса, как правило, обеспечивает лучшую производительность, чем <xref:System.String> класса, не заменяйте автоматически <xref:System.String> с <xref:System.Text.StringBuilder> каждый раз, когда необходимо манипулировать строками. Производительность зависит от размера строки, объем памяти, выделяемой для новой строки, системы, на котором выполняется приложение и тип операции. Следует предусмотреть протестировать приложение, чтобы определить, является ли <xref:System.Text.StringBuilder> фактически обеспечивает значительное улучшение производительности.  
  
 Рассмотрите возможность использования <xref:System.String> класса при следующих условиях:  
  
-   Если количество изменений, приложение будет выполнять строка мал. В этих случаях <xref:System.Text.StringBuilder> может незначительно предложение или улучшение производительности по <xref:System.String>.  
  
-   При выполнении операции объединения, особенно со строковыми литералами фиксированным числом. В этом случае компилятор может объединить операции объединения в одной операции.  
  
-   При необходимости вести расширенный поиск при построении строки. <xref:System.Text.StringBuilder> Отсутствует класс поиска методов, таких как `IndexOf` или `StartsWith`. Вам придется преобразовать <xref:System.Text.StringBuilder> объект <xref:System.String> для этих операций и это отключить выгода от использования <xref:System.Text.StringBuilder>. Дополнительные сведения см. в разделе [поиск текста в объект StringBuilder](#Searching) раздела.  
  
 Рассмотрите возможность использования <xref:System.Text.StringBuilder> класса при следующих условиях:  
  
-   Если предполагается, что приложение для обеспечения неизвестное количество изменений в строку во время разработки (например, при использовании цикла для сцепления случайное число строк, содержащих ввод данных пользователем).  
  
-   Если предполагается, что приложение, чтобы сделать значительное количество изменений в строку.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>Как работает StringBuilder  
 <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> Свойство указывает количество символов <xref:System.Text.StringBuilder> в настоящее время содержит объект. При добавлении символов для <xref:System.Text.StringBuilder> объекта, его длина увеличивается, пока он равен размеру <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> свойство, которое определяет число символов, которые могут храниться в объекте. Если количество символов, добавленных вызывает длина <xref:System.Text.StringBuilder> объекта превысит его текущей емкости, новую память выделяется, значение <xref:System.Text.StringBuilder.Capacity%2A> свойство удваивается, добавляются новые символы <xref:System.Text.StringBuilder> объекта и его <xref:System.Text.StringBuilder.Length%2A>настройки свойства. Дополнительную память для <xref:System.Text.StringBuilder> объект выделяется динамически, пока не достигнет значения, определяемого <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> свойство. При достижении максимальной емкости дополнительные модули памяти не может быть выделено для <xref:System.Text.StringBuilder> объекта и попытка добавления символов или разверните его за пределы максимального уровня создает либо <xref:System.ArgumentOutOfRangeException> или <xref:System.OutOfMemoryException> исключение.  
  
 В следующем примере показано как <xref:System.Text.StringBuilder> объект выделяет память для новых и повышает его емкость динамически при расширении строки, назначенный объекту. Код создает <xref:System.Text.StringBuilder> , вызывая его конструктор (без параметров). Емкость по умолчанию для этого объекта 16 символов, который исчерпана более 2 миллиардов знаков. Добавление строки «Это предложение». приводит новое выделение памяти, так как длина строки (19 символов) превышает объем по умолчанию <xref:System.Text.StringBuilder> объекта. Емкость объекта удваивается до 32 символов, добавляется новая строка и длину объекта теперь равно 19 символов. Затем код добавляет строку «Это дополнительные предложения». значение <xref:System.Text.StringBuilder> объекта 11 раз. Каждый раз, когда операции добавления вызывает длина <xref:System.Text.StringBuilder> превышают его емкость объему существующий объект в два раза и <xref:System.Text.StringBuilder.Append%2A> операция выполнена успешно.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>Выделение памяти  
 Емкости по умолчанию <xref:System.Text.StringBuilder> объект — 16 символов, а максимальная емкость по умолчанию — <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Эти значения по умолчанию используются в том случае, если вы вызываете <xref:System.Text.StringBuilder.%23ctor> и <xref:System.Text.StringBuilder.%23ctor%28System.String%29> конструкторы.  
  
 Можно явным образом определить начальная емкость <xref:System.Text.StringBuilder> объекта одним из следующих способов:  
  
-   Можно вызвать любую из <xref:System.Text.StringBuilder> конструкторы, которые включают `capacity` параметр при создании объекта.  
  
-   Путем явного присвоения нового значения для <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> свойства существующего <xref:System.Text.StringBuilder> объекта. Обратите внимание, что свойство вызывает исключение, если новая емкость меньше, чем существующий емкости или больше, чем <xref:System.Text.StringBuilder> Максимальная емкость объекта.  
  
-   Путем вызова <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> метод с новой емкости. Новая емкость не должна быть больше, чем <xref:System.Text.StringBuilder> Максимальная емкость объекта. Тем не менее, в отличие от присвоения <xref:System.Text.StringBuilder.Capacity%2A> свойства <xref:System.Text.StringBuilder.EnsureCapacity%2A> не вызывает исключение, если нужный новую емкость меньше, чем существующие емкости; таким образом, вызов метода не влияет.  
  
 Если длина строки назначено <xref:System.Text.StringBuilder> объекта в вызове конструктора превышает емкость по умолчанию или указанную емкость <xref:System.Text.StringBuilder.Capacity%2A> свойству длину строки, указанной `value` параметра.  
  
 Можно явным образом определить максимальную емкость <xref:System.Text.StringBuilder> путем вызова метода <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> конструктор. Невозможно изменить максимальную емкость путем присвоения нового значения для <xref:System.Text.StringBuilder.MaxCapacity%2A> свойства, так как она доступна только для чтения.  
  
 Предыдущего раздела показано всякий раз, когда существующий емкости недостатка больший объем памяти выделяется и емкости <xref:System.Text.StringBuilder> объекта удваивается до значения, определяемого <xref:System.Text.StringBuilder.MaxCapacity%2A> свойство.  
  
 В общем случае емкость по умолчанию и максимальная емкость не подходит для большинства приложений. Можно принять эти значения при следующих условиях:  
  
-   Если конечный размер <xref:System.Text.StringBuilder> объекта скорее всего, будет расти чрезвычайно большого, обычно сверх несколько мегабайт. В этом случае может быть некоторое повышение производительности от установки начального <xref:System.Text.StringBuilder.Capacity%2A> свойство значительно большое значение для устранения необходимости для перераспределения слишком много памяти.  
  
-   Если приложение выполняется в системе с ограниченным объемом памяти. В этом случае может понадобиться рассмотреть параметр <xref:System.Text.StringBuilder.MaxCapacity%2A> свойства меньше, чем <xref:System.Int32.MaxValue?displayProperty=nameWithType> Если приложение обрабатывает большие строки, которые могут привести к выполняются в среде с ограниченным объемом памяти.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>Создание экземпляра объекта StringBuilder  
 Можно создать <xref:System.Text.StringBuilder> объекта путем вызова одного из его шесть перегруженные конструкторы класса, перечисленные в следующей таблице. Три из конструкторов для создания экземпляра <xref:System.Text.StringBuilder> объект, значение которого является пустой строкой, но задать его <xref:System.Text.StringBuilder.Capacity%2A> и <xref:System.Text.StringBuilder.MaxCapacity%2A> значения по-разному. Остальные три конструктора определяют <xref:System.Text.StringBuilder> объект, имеющий значение подстроки и емкости. Два из трех конструкторов использования по умолчанию максимальная емкость <xref:System.Int32.MaxValue?displayProperty=nameWithType>, а третий позволяет задать максимальную емкость.  
  
|Конструктор|Строковое значение|Емкость|Максимальная емкость|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Определяется `capacity` параметр|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Определяется `capacity` параметр|Определяется `maxCapacity` параметр|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Определяется `value` параметр|16 или `value`. <xref:System.String.Length%2A>, какое значение больше|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Определяется `value` параметр|Определяется `capacity` параметр или `value`. <xref:System.String.Length%2A>, какая величина больше.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|Определяется `value`. <xref:System.String.Substring%2A>(`startIndex`, `length`)|Определяется `capacity` параметр или `value`. <xref:System.String.Length%2A>, какая величина больше.|Определяется `maxCapacity` параметр|  
  
 В следующем примере используется три эти перегрузки конструктора для создания экземпляра <xref:System.Text.StringBuilder> объектов.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>Вызов методов StringBuilder  
 Большинство методов, измените строку в <xref:System.Text.StringBuilder> экземпляр возвращают ссылку на тот же экземпляр. Это позволяет вызывать <xref:System.Text.StringBuilder> методы двумя способами:  
  
-   Можно произвести отдельные вызовы и пропустите возвращаемого значения, так как в следующем примере выполняется.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   Можно сделать ряд вызовов метода в одной инструкции. Это может быть удобно, если для одной инструкции, образует цепочку последовательных операций записи. Следующий пример объединяет три вызова метода из предыдущего примера в единой строки кода.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>Выполнение операций StringBuilder  
 Можно использовать методы <xref:System.Text.StringBuilder> класса для выполнения итерации, добавления, удаления и изменения символов в <xref:System.Text.StringBuilder> объекта.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>Итерация StringBuilder символов  
 Можно получить доступ к символов в <xref:System.Text.StringBuilder> с использованием <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> свойство. В C# <xref:System.Text.StringBuilder.Chars%2A> является индексатором; в Visual Basic, это свойство по умолчанию для <xref:System.Text.StringBuilder> класса. Это дает возможность задать или получить отдельных символов с использованием только индексов без явного указания ссылки <xref:System.Text.StringBuilder.Chars%2A> свойство. Символы в <xref:System.Text.StringBuilder> объекта начинаются с индексом 0 (ноль) и индекс по-прежнему <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Chars%2A> свойство. Он добавляет 10 случайных чисел до <xref:System.Text.StringBuilder> объекта, а затем выполняет итерацию каждый символ. Если категории символов Юникода <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, число уменьшается на 1 (или изменяется номер 9, если его значение равно 0). В примере отображается содержимое <xref:System.Text.StringBuilder> оба объекта до и после изменения значений отдельных символов.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>Добавление текста в объект StringBuilder  
 <xref:System.Text.StringBuilder> Класс содержит следующие методы для расширения содержимого <xref:System.Text.StringBuilder> объекта:  
  
-   <xref:System.Text.StringBuilder.Append%2A> Метод добавляет строку, подстроку, массив символов, часть в массив символов, один символ повторяется несколько раз, либо строковое представление примитивных данных тип на <xref:System.Text.StringBuilder> объекта.  
  
-   <xref:System.Text.StringBuilder.AppendLine%2A> Метод добавляет знак завершения строки или строки вместе с признаком конца строки для <xref:System.Text.StringBuilder> объекта.  
  
-   <xref:System.Text.StringBuilder.AppendFormat%2A> Добавляет метод к <xref:System.Text.StringBuilder> объекта. Строковые представления объектов, включенные в результирующей строке может отражают соглашения о форматировании текущего языка и региональных параметров системы или заданных региональных параметров.  
  
-   <xref:System.Text.StringBuilder.Insert%2A> Метод вставляет строки, подстроки, несколько повторения строки, массив символов, часть массив символов, или строковое представление примитивных данных введите в указанной позиции в <xref:System.Text.StringBuilder> объекта. Положение определяется отсчитываемый от нуля индекс.  
  
 В следующем примере используется <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, и <xref:System.Text.StringBuilder.Insert%2A> методов, чтобы развернуть текст <xref:System.Text.StringBuilder> объекта.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>Удаление текста из объекта StringBuilder  
 <xref:System.Text.StringBuilder> Класс содержит методы, которые можно уменьшить размер текущего <xref:System.Text.StringBuilder> экземпляра. <xref:System.Text.StringBuilder.Clear%2A> Метод удаляет все символы и задает <xref:System.Text.StringBuilder.Length%2A> свойства значение 0. <xref:System.Text.StringBuilder.Remove%2A> Метод удаляет указанное число знаков, начиная с определенного индекса. Кроме того, можно удалить символы в конце <xref:System.Text.StringBuilder> , задавая его <xref:System.Text.StringBuilder.Length%2A> свойства, значение которого меньше, чем длина текущего экземпляра.  
  
 Следующий пример удаляет текст из <xref:System.Text.StringBuilder> объекта, отображается его полученный емкости, максимальной емкости и длины значений свойств, а затем вызывает <xref:System.Text.StringBuilder.Clear%2A> метод для удаления всех символов из <xref:System.Text.StringBuilder> объекта.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>Изменение текста в объект StringBuilder  
 <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> Метод заменяет все вхождения символа или строки во всем <xref:System.Text.StringBuilder> объекта или в диапазоне конкретный символ. В следующем примере используется <xref:System.Text.StringBuilder.Replace%2A> метод для замены всех точек восклицательный знак (!) вопросительные знаки (?) в <xref:System.Text.StringBuilder> объекта.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Поиск текста в объект StringBuilder  
 <xref:System.Text.StringBuilder> Класс включает методы аналогично <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, и <xref:System.String.StartsWith%2A?displayProperty=nameWithType> методы, предоставляемые <xref:System.String> класс, который можно выполнять поиск объектов для конкретного символа или подстроки. Определение наличия или начальной позицией знака подстроки требуется выполнить поиск <xref:System.String> значение с помощью поиска в строковый метод или метод регулярного выражения. Существует четыре способа для реализации таких результатов поиска, как показано в следующей таблице.  
  
|Метод|Преимущества|Недостатки|  
|---------------|----------|----------|  
|Найдите строковые значения перед добавлением их к <xref:System.Text.StringBuilder> объекта.|Служит для определения того, существует ли подстроки.|Не может использоваться, если важно индекс подстроки.|  
|Вызовите <xref:System.Text.StringBuilder.ToString%2A> и поиска, возвращенный <xref:System.String> объекта.|Прост в использовании при указании текст для <xref:System.Text.StringBuilder> объекта, а затем начните изменить его.|Сложно в повторяющемся вызове <xref:System.Text.StringBuilder.ToString%2A> Если необходимо внести изменения, перед добавлением весь текст <xref:System.Text.StringBuilder> объекта.<br /><br /> Необходимо помнить, для работы с конца <xref:System.Text.StringBuilder> текста объекта, если вы вносите изменения.|  
|Используйте <xref:System.Text.StringBuilder.Chars%2A> свойство последовательно поиск в диапазоне символов.|Полезно, если вы хотите с отдельных символов или небольшой подстроки.|Если существует большое число символов для поиска или логику поиска в сложных громоздким.<br /><br />Приводит к очень низкой производительности для объектов увеличившимися очень через метод повторные вызовы.  |  
|Преобразовать <xref:System.Text.StringBuilder> объект <xref:System.String> объекта и внесения изменений на <xref:System.String> объекта.|Полезно, если количество изменений мал.|Инвертирует выигрыш в производительности <xref:System.Text.StringBuilder> класса при большом количество изменений.|  
  
 Давайте рассмотрим эти методы более подробно.  
  
-   Если поиск предназначена для определения наличия определенной подстрокой (то есть, если вы не хотите в позиция подстроки), можно выполнить поиск строки перед их сохранением в <xref:System.Text.StringBuilder> объекта. Ниже приведен один из возможных вариантов реализации. Он определяет `StringBuilderFinder` , конструктор которого передается ссылка на класс <xref:System.Text.StringBuilder> объекта и подстрока для поиска в строке. В этом случае в примере предпринимается попытка определить, имеют ли записанные температуры в шкале Цельсия или Фаренгейта и добавляет соответствующие вводный текст в начало <xref:System.Text.StringBuilder> объекта. Генератор случайных чисел используется для выбора массив, содержащий данные в градусах Цельсия или Фаренгейта.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   Вызовите <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> метод преобразования <xref:System.Text.StringBuilder> объект <xref:System.String> объекта. Строки можно найти с помощью методов, таких как <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> или <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, или можно использовать регулярные выражения и <xref:System.Text.RegularExpressions.Regex> класса для поиска по шаблону. Так как оба <xref:System.Text.StringBuilder> и <xref:System.String> объекты используют кодировку для хранения символов, позиции индекса символов подстроки, UTF-16 и совпадения регулярного выражения совпадают в обоих объектах. Это позволяет использовать <xref:System.Text.StringBuilder> методы для внесения изменений в той же позиции, с которой текст найден в <xref:System.String> объекта.  
  
    > [!NOTE]
    >  Если принять этот подход должен работать в конце <xref:System.Text.StringBuilder> объекта для его запуска, чтобы не нужно повторно преобразовать <xref:System.Text.StringBuilder> объекта в строку.  
  
     Этот подход показан в приведенном ниже примере. Он сохраняет четыре вхождения каждой буквы английского алфавита в <xref:System.Text.StringBuilder> объекта. Текст, который затем преобразуется <xref:System.String> объекта и регулярное выражение используется для идентификации начальную позицию каждой последовательности четырех символов. Наконец он добавляет символ подчеркивания перед каждой последовательности четыре символа, за исключением первой последовательности и преобразует первый знак последовательности в верхний регистр.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   Используйте <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> свойство последовательно поиск диапазона символов в <xref:System.Text.StringBuilder> объекта. Если существует большое число символов для поиска или особо сложной логики поиска этот подход может быть непрактично. Для доступа на основе индекса символ за символом для влияет на производительность очень большой, chunked <xref:System.Text.StringBuilder> объектов, см. в документации для <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> свойства. 
  
     В следующем примере ту же функциональность, в предыдущем примере, но отличается в реализации. Она использует <xref:System.Text.StringBuilder.Chars%2A> свойство, чтобы определить, когда изменилось значение символа, вставляет символ подчеркивания в этой позиции и преобразует первый символ в новой последовательности в верхний регистр.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   Сохранить без изменений текста в <xref:System.Text.StringBuilder> , вызовите <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> метод преобразования <xref:System.Text.StringBuilder> объект <xref:System.String> объекта и внесения изменений на <xref:System.String> объекта. Этот подход можно использовать, если имеется несколько изменений; в противном случае стоимость работы с неизменяемыми строки могут поставить под сомнение повышение производительности с использованием <xref:System.Text.StringBuilder> объекта.  
  
     В следующем примере ту же функциональность два предыдущих примера, но отличается в реализации. Он создает <xref:System.Text.StringBuilder> объекта, преобразуется в <xref:System.String> объекта, а затем использует регулярное выражение для выполнения всех оставшихся изменений в строке. <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Метод использует лямбда-выражение для выполнения замены каждого соответствия.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>Преобразование объекта StringBuilder в строку  
 Необходимо преобразовать объект <xref:System.Text.StringBuilder> в <xref:System.String>, прежде чем передавать представленную объектом <xref:System.Text.StringBuilder> строку методу, который содержит параметр <xref:System.String>, или вывести ее в пользовательском интерфейсе. Преобразование выполняется путем вызова <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> метод. Иллюстрация, см. в предыдущем примере, который вызывает <xref:System.Text.StringBuilder.ToString%2A> метод преобразования <xref:System.Text.StringBuilder> объекта в строку, чтобы его можно передавать в метод регулярного выражения.  
  
   
  
## Examples  
 Приведенный ниже показано, как вызывать многие из методов, определенных <xref:System.Text.StringBuilder> класса.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
    </block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строковое значение этого экземпляра имеет значение <xref:System.String.Empty?displayProperty=nameWithType>, и емкость задана как емкость по умолчанию, зависящие от реализации.  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор без параметров.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Предлагаемый начальный размер этого экземпляра.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />, используя указанную емкость.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Параметр определяет максимальное число символов, которые могут храниться в памяти, назначенной текущим экземпляром. Его значение будет назначено <xref:System.Text.StringBuilder.Capacity%2A> свойство. Если количество символов для хранения в текущем экземпляре превышает это `capacity` значение, <xref:System.Text.StringBuilder> объект выделяет дополнительную память для их хранения.  
  
 Строковое значение этого экземпляра имеет значение <xref:System.String.Empty?displayProperty=nameWithType>. Если `capacity` равен нулю, используется емкость по умолчанию зависит от реализации.  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор с указанной емкостью.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="capacity" /> меньше нуля.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка, используемая для инициализации значения экземпляра. Если <c>value</c> равно <see langword="null" />, то новый <see cref="T:System.Text.StringBuilder" /> будет содержать пустую строку (то есть он содержит <see cref="F:System.String.Empty" />).</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />, используя указанную строку.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `value` равно `null`, то новый <xref:System.Text.StringBuilder> будет содержать пустую строку (то есть, он содержит <xref:System.String.Empty>).  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор с указанной строкой.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Предлагаемый начальный размер <see cref="T:System.Text.StringBuilder" />.</param>
        <param name="maxCapacity">Наибольшее допустимое количество знаков в текущей строке.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />, который начинается с указанной емкости и может увеличиваться до указанного максимального значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Параметр определяет максимальное число символов, которые могут храниться в памяти, назначенной текущим экземпляром. Его значение будет назначено <xref:System.Text.StringBuilder.Capacity%2A> свойство. Если количество символов для хранения в текущем экземпляре превышает это `capacity` значение, <xref:System.Text.StringBuilder> объект выделяет дополнительную память для их хранения.  
  
 Если `capacity` равен нулю, используется емкость по умолчанию зависит от реализации.  
  
 `maxCapacity` Свойство определяет максимальное число символов, которые может содержать текущий экземпляр. Его значение будет назначено <xref:System.Text.StringBuilder.MaxCapacity%2A> свойство. Если количество символов для хранения в текущем экземпляре превышает это `maxCapacity` значение <xref:System.Text.StringBuilder> объекта не выделить дополнительную память, но выдает исключение.  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор с указанной емкости и максимальной емкости.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxCapacity" /> меньше единицы, <paramref name="capacity" /> меньше нуля или <paramref name="capacity" /> больше, чем <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка, используемая для инициализации значения экземпляра. Если <c>value</c> равно <see langword="null" />, то новый <see cref="T:System.Text.StringBuilder" /> будет содержать пустую строку (то есть он содержит <see cref="F:System.String.Empty" />).</param>
        <param name="capacity">Предлагаемый начальный размер <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />, используя указанную строку и емкость.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Параметр определяет максимальное число символов, которые могут храниться в памяти, назначенной текущим экземпляром. Его значение будет назначено <xref:System.Text.StringBuilder.Capacity%2A> свойство. Если количество символов для хранения в текущем экземпляре превышает это `capacity` значение, <xref:System.Text.StringBuilder> объект выделяет дополнительную память для их хранения.  
  
 Если `capacity` равен нулю, используется емкость по умолчанию зависит от реализации.  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор с начальной строки и указанной емкостью.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="capacity" /> меньше нуля.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка, содержащая подстроку, применяемую для инициализации значения этого экземпляра. Если <c>value</c> равно <see langword="null" />, то новый <see cref="T:System.Text.StringBuilder" /> будет содержать пустую строку (то есть он содержит <see cref="F:System.String.Empty" />).</param>
        <param name="startIndex">Позиция в пределах <c>value</c>, с которой начинается подстрока.</param>
        <param name="length">Число символов в подстроке.</param>
        <param name="capacity">Предлагаемый начальный размер <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" /> из указанной подстроки и емкости.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Параметр определяет максимальное число символов, которые могут храниться в памяти, назначенной текущим экземпляром. Его значение будет назначено <xref:System.Text.StringBuilder.Capacity%2A> свойство. Если количество символов для хранения в текущем экземпляре превышает это `capacity` значение, <xref:System.Text.StringBuilder> объект выделяет дополнительную память для их хранения.  
  
 Если `capacity` равен нулю, используется емкость по умолчанию зависит от реализации.  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор с указанной строкой.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="capacity" /> меньше нуля.  
  
 - или -  
  
 Сумма значений <paramref name="startIndex" /> и <paramref name="length" /> не равна положению в <paramref name="value" />.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет строковое представление указанного объекта к данному экземпляру.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое логическое значение.</param>
        <summary>Добавляет строковое представление указанного логического значения к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Вызовы метода <xref:System.Boolean.ToString?displayProperty=nameWithType> метод, чтобы получить строковое представление `value`. При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 8-разрядного целого числа без знака к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> Вызовы метода <xref:System.Byte.ToString%28System.IFormatProvider%29> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Для управления форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Единица кода в кодировке UTF-16 для добавления.</param>
        <summary>Добавляет строковое представление указанного объекта <see cref="T:System.Char" /> в данный экземпляр.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Массив символов для добавления.</param>
        <summary>Добавляет строковое представление символа Юникода в указанном массиве к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет все символы в указанном массиве в текущий экземпляр в том же порядке, как они отображаются в `value`. Если `value` — `null`, изменения не вносятся.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного десятичного числа к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Вызовы метода <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Для управления форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного числа с плавающей запятой с удвоенной точностью к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> Вызовы метода <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Для управления форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 16-разрядного целого числа со знаком к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> Вызовы метода <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Для управления форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 32-разрядного целого числа со знаком к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29> Вызовы метода <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Для управления форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 64-разрядного целого числа со знаком к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> Вызовы метода <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> Чтобы получить строковое представление `value` для текущего языка и региональных параметров. Для управления форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемый объект.</param>
        <summary>Добавляет строковое представление указанного объекта к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Object%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере. Он определяет `Dog` класса, создает `Dog` объекта и делает три вызова <xref:System.Text.StringBuilder.Append%2A> метод, чтобы создать строку, содержащую имя dog и в своем роде.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Object%29> Вызовы метода <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, чтобы получить строковое представление `value`. Если `value` — `null`, изменения не вносятся в <xref:System.Text.StringBuilder> объекта.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 8-разрядного целого числа со знаком к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> Вызовы метода <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Для управления форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного числа с плавающей запятой с обычной точностью к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> Вызовы метода <xref:System.Single.ToString%2A?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Для управления форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемая строка.</param>
        <summary>Добавляет копию указанной строки к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.String%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Если `value` — `null`, изменения не вносятся.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 16-разрядного целого числа без знака к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Вызовы метода <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value`. Для управления форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 32-разрядного целого числа без знака к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Вызовы <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Для управления форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 64-разрядного целого числа без знака к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Вызовы метода <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Для управления форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемый символ.</param>
        <param name="repeatCount">Сколько раз следует добавить <c>value</c>.</param>
        <summary>Добавляет указанное число копий строкового представления символа Юникода к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="repeatCount" /> меньше нуля.  
  
 - или -  
  
 Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="valueCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Указатель на массив символов.</param>
        <param name="valueCount">Количество символов в массиве.</param>
        <summary>Добавляет к данному экземпляру массив символов Юникода начиная с указанного адреса.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет `valueCount` символов, начиная с адреса `value` с текущим экземпляром.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="valueCount" /> меньше нуля.  
  
 - или -  
  
 Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> является пустым указателем</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Массив символов.</param>
        <param name="startIndex">Начальная позиция в массиве <c>value</c>.</param>
        <param name="charCount">Количество добавляемых знаков.</param>
        <summary>Добавляет строковое представление указанного дочернего массива символов Юникода к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет указанный диапазон символов в `value` с текущим экземпляром. Если `value` — `null` и `startIndex` и `count` как ноль, не изменяются.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Значение параметра <paramref name="value" /> — <see langword="null" />, а значения <paramref name="startIndex" /> и <paramref name="charCount" /> не равны нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="charCount" /> меньше нуля.  
  
 - или -  
  
 Значение параметра <paramref name="startIndex" /> меньше нуля.  
  
 - или -  
  
 Значение <paramref name="startIndex" /> + <paramref name="charCount" /> превышает длину <paramref name="value" />.  
  
 - или -  
  
 Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка, содержащая добавляемую подстроку.</param>
        <param name="startIndex">Начальная позиция подстроки в пределах <c>value</c>.</param>
        <param name="count">Число знаков в <c>value</c> для добавления.</param>
        <summary>Добавляет копию указанной подстроки к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет указанный диапазон символов в `value` с текущим экземпляром. Если `value` — `null` и `startIndex` и `count` как ноль, не изменяются.  
  
 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство в существующую ссылку и необходимо назначить возвращаемое значение <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Значение параметра <paramref name="value" /> — <see langword="null" />, а значения <paramref name="startIndex" /> и <paramref name="count" /> не равны нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 <paramref name="startIndex" /> меньше нуля.  
  
 - или -  
  
 Значение <paramref name="startIndex" /> + <paramref name="count" /> превышает длину <paramref name="value" />.  
  
 - или -  
  
 Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением соответствующего аргумента объекта.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением одного аргумента.</summary>
        <returns>Ссылка на данный экземпляр с добавленным <paramref name="format" />. Каждый элемент формата в параметре <paramref name="format" /> заменяется строковым представлением параметра <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования. Индекс элемента форматирования должен быть 0, чтобы они соответствовали `arg0`, одного объекта в списке параметров данного метода. В процессе форматирования каждый элемент формата заменяется строковое представление `arg0`.  
  
 Синтаксис элементов форматирования выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция форматируемого объекта в списке параметров. Если объект, заданный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если параметр отсутствует в *индекс* положение, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное количество символов в строковом представлении параметра. Если положительное, параметр по правому краю; Если значение отрицательное, это по левому краю.|  
|:*formatString*|Строка стандартного или пользовательского формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` Представляет объект для форматирования. Каждый элемент формата в `format` заменяется строковым представлением `arg0`. Если элемент формата включает `formatString` и `arg0` реализует <xref:System.IFormattable> интерфейс, затем `arg0.ToString(formatString, null)` определяет форматирование. В противном случае `arg0.ToString()` определяет форматирование.  
  
 Если в строке, назначенной `format` является «Спасибо за пожертвование {0: ###} консервных банок нашей благотворительной организации.» и `arg0` должно быть целым числом со значением 10, возвращаемое значение будет «Спасибо за в пожертвование 10 консервных банок нашей благотворительной организации.»  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> недопустим.  
  
 - или -  
  
 Индекс элемента формата меньше нуля или не меньше 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="args">Массив объектов для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением соответствующего аргумента в массиве параметров.</summary>
        <returns>Ссылка на данный экземпляр с добавленным <paramref name="format" />. Каждый элемент формата в параметре <paramref name="format" /> заменяется строковым представлением соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объектам в списке параметров данного метода. Процесс форматирования заменяет каждый элемент формата строковым представлением соответствующего объекта.  
  
 Синтаксис элементов форматирования выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция форматируемого объекта в списке параметров. Если объект, заданный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если параметр отсутствует в *индекс* положение, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное количество символов в строковом представлении параметра. Если положительное, параметр по правому краю; Если значение отрицательное, это по левому краю.|  
|:*formatString*|Строка стандартного или пользовательского формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `args` Представляет объекты для форматирования. Каждый элемент формата в `format` заменяется строковым представлением соответствующего объекта в `args`. Если элемент формата включает `formatString` и соответствующего объекта в `args` реализует <xref:System.IFormattable> интерфейс, затем `args[index].ToString(formatString, provider)` определяет форматирование. В противном случае `args[index].ToString()` определяет форматирование.  
  
 Если в строке, назначенной `format` является «Спасибо за пожертвование {0: ###} консервных банок нашей благотворительной организации.» и `arg0` должно быть целым числом со значением 10, возвращаемое значение будет «Спасибо за в пожертвование 10 консервных банок нашей благотворительной организации.»  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="format" /> или <paramref name="args" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> недопустим.  
  
 - или -  
  
 Индекс элемента формата меньше нуля или больше либо равен длине массива <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением одного аргумента с использованием указанного поставщика формата.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления. После операции добавления этот экземпляр содержит все данные, существовавшие до операции, к которым добавляется копия параметра <paramref name="format" />, где все спецификации форматирования заменяются представлением <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения `arg0` в текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования. Индекс каждого элемента форматирования должен быть ноль (0), поскольку он содержит список аргументов с одним аргументом. В процессе форматирования каждый элемент формата заменяется строковое представление `arg0`.  
  
 Синтаксис элементов форматирования выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция форматируемого объекта в списке параметров. Если объект, заданный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. В этом случае с момента <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> метод имеет один аргумент в списке аргументов, значение *индекс* всегда должен быть 0. Если нет, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное количество символов в строковом представлении параметра. Если положительное, параметр по правому краю; Если значение отрицательное, это по левому краю.|  
|:*formatString*|Строка стандартного или пользовательского формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Указывает <xref:System.IFormatProvider> реализацию, которая может предоставить сведения о форматировании для объектов в `args`. Параметр `provider` может иметь любое из следующих значений.  
  
-   Объект <xref:System.Globalization.CultureInfo> объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0` , если он является числовым значением.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0` Если это значение даты и времени.  
  
-   Настраиваемый <xref:System.IFormatProvider> реализацию, предоставляющий сведения о форматировании `arg0`. Как правило, такой подход также реализует <xref:System.ICustomFormatter> интерфейса.  
  
 Если `provider` параметр `null`, форматирования получить сведения из текущего языка и региональных параметров.  
  
 `arg0` Представляет объект для форматирования. Каждый элемент формата в `format` заменяется строковым представлением `arg0`. Если элемент формата включает `formatString` и `arg0` реализует <xref:System.IFormattable> интерфейс, затем `arg0.ToString(formatString, provider)` определяет форматирование. В противном случае `arg0.ToString()` определяет форматирование.  
  
   
  
## Examples  
 Включает в себя следующие два вызова <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> метод. Используют соглашения о форматировании языка и региональных параметров Великобритания английского (en-GB). Первый Вставляет строковое представление <xref:System.Decimal> значение валюты в результирующую строку. Второй операции вставки <xref:System.DateTime> значение в двух местах, в результате строки, первая включая только краткосрочного Дата строки, а вторая строка короткое время.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> недопустим.  
  
 - или -  
  
 Индекс элемента формата меньше нуля или больше либо равен единице.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">Строка составного формата.</param>
        <param name="args">Массив объектов для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением соответствующего аргумента в массиве параметров с помощью указанного поставщика формата.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления. После операции добавления этот экземпляр содержит все данные, существовавшие до операции, к которым добавляется копия параметра <paramref name="format" />, где все спецификации форматирования заменяются представлением строки соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объектам в списке параметров данного метода. Процесс форматирования заменяет каждый элемент формата строковым представлением соответствующего объекта.  
  
 Синтаксис элементов форматирования выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция форматируемого объекта в списке параметров. Если объект, заданный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если параметр отсутствует в *индекс* положение, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное количество символов в строковом представлении параметра. Если положительное, параметр по правому краю; Если значение отрицательное, это по левому краю.|  
|:*formatString*|Строка стандартного или пользовательского формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Указывает <xref:System.IFormatProvider> реализацию, которая может предоставить сведения о форматировании для объектов в `args`. Параметр `provider` может иметь любое из следующих значений.  
  
-   Объект <xref:System.Globalization.CultureInfo> объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения об особенностях язык и региональные параметры форматирования для числовых значений в `args`.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo> объект, предоставляющий языком и региональными параметрами сведения о форматировании значений даты и времени в `args`.  
  
-   Настраиваемый <xref:System.IFormatProvider> реализацию, которая предоставляет сведения о форматировании для одного или нескольких объектов в `args`. Как правило, такой подход также реализует <xref:System.ICustomFormatter> интерфейса. Во втором примере в следующем разделе показано <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> вызов метода с пользовательским <xref:System.IFormatProvider> реализации.  
  
 Если `provider` параметр `null`, сведения о формате поставщика извлекаются из текущего языка и региональных параметров.  
  
 `args` Представляет объекты для форматирования. Каждый элемент формата в `format` заменяется строковым представлением соответствующего объекта в `args`. Если элемент формата включает `formatString` и соответствующего объекта в `args` реализует <xref:System.IFormattable> интерфейс, затем `args[index].ToString(formatString, provider)` определяет форматирование. В противном случае `args[index].ToString()` определяет форматирование.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 В следующем примере определяется настраиваемый <xref:System.IFormatProvider> реализацию с именем `CustomerFormatter` , форматирующий клиента 10-значный номер с дефисами после четвертой и седьмой цифры. Оно передается <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> метод, чтобы создать строку, содержащую номер форматированные клиента и имя клиента.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> недопустим.  
  
 - или -  
  
 Индекс элемента формата меньше нуля или больше либо равен длине массива <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением любого из двух аргументов.</summary>
        <returns>Ссылка на данный экземпляр с добавленным <paramref name="format" />. Каждый элемент формата в параметре <paramref name="format" /> заменяется строковым представлением соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют `arg0` и `arg1`, два объекта в списке параметров данного метода. Процесс форматирования заменяет каждый элемент формата строковым представлением соответствующего объекта.  
  
 Синтаксис элементов форматирования выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция форматируемого объекта в списке параметров. Если объект, заданный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если параметр отсутствует в *индекс* положение, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное количество символов в строковом представлении параметра. Если положительное, параметр по правому краю; Если значение отрицательное, это по левому краю.|  
|:*formatString*|Строка стандартного или пользовательского формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` и `arg1` представления объектов для форматирования. Каждый элемент формата в `format` заменяется строковым представлением любого `arg0` или `arg1`. Если элемент формата включает `formatString` и соответствующий объект реализует <xref:System.IFormattable> интерфейс, затем `arg` *x* `.ToString(formatString, provider)` определяет форматирование, где *x* — Это индекс аргумента. В противном случае `arg` *x* `.ToString()` определяет форматирование.  
  
 Если в строке, назначенной `format` является «Спасибо за пожертвование {0: ###} консервных банок нашей благотворительной организации.» и `arg0` должно быть целым числом со значением 10, возвращаемое значение будет «Спасибо за в пожертвование 10 консервных банок нашей благотворительной организации.»  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> недопустим.  
  
 - или -  
  
 Индекс элемента формата меньше нуля или больше либо равен двум.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением любого из двух аргументов с помощью указанного поставщика формата.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления. После операции добавления этот экземпляр содержит все данные, существовавшие до операции, к которым добавляется копия параметра <paramref name="format" />, где все спецификации форматирования заменяются представлением строки соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объектам в списке параметров данного метода. Процесс форматирования заменяет каждый элемент формата строковым представлением соответствующего объекта.  
  
 Синтаксис элементов форматирования выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция форматируемого объекта в списке параметров. Если объект, заданный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если параметр отсутствует в *индекс* положение, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное количество символов в строковом представлении параметра. Если положительное, параметр по правому краю; Если значение отрицательное, это по левому краю.|  
|:*formatString*|Строка стандартного или пользовательского формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Указывает <xref:System.IFormatProvider> реализацию, которая может предоставить сведения о форматировании `arg0` и `arg1`. Параметр `provider` может иметь любое из следующих значений.  
  
-   Объект <xref:System.Globalization.CultureInfo> объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0` или `arg1` , если они являются числовыми значениями.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0` или `arg1` одинаковых значений даты и времени.  
  
-   Настраиваемый <xref:System.IFormatProvider> реализацию, предоставляющий сведения о форматировании `arg0` и `arg1`. Как правило, такой подход также реализует <xref:System.ICustomFormatter> интерфейса.  
  
 Если `provider` параметр `null`, сведения о формате поставщика извлекаются из текущего языка и региональных параметров.  
  
 `arg0` и `arg1` представления объектов для форматирования. Каждый элемент формата в `format` заменяется строковым представлением объекта, который имеет соответствующий индекс. Если элемент формата включает `formatString` и соответствующий аргумент реализует <xref:System.IFormattable> интерфейс, то значение аргумента `ToString(formatString, provider)` метод определяет форматирование. В противном случае — значение аргумента `ToString()` метод определяет форматирование.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> метод для отображения времени и температуры данные, хранящиеся в универсальный <xref:System.Collections.Generic.Dictionary%602> объекта. Обратите внимание, что строка формата три элемента форматирования, несмотря на то, что существует только для объектов для форматирования. Это, поскольку первый объект в списке (значение даты и времени) используется двумя элементами формата: первый отображает элемент форматирования, время, а вторая отображает дату.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> недопустим.  
  
 - или -  
  
 Индекс элемента формата меньше нуля или больше либо равен двум.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <param name="arg2">Третий объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением любого из трех аргументов.</summary>
        <returns>Ссылка на данный экземпляр с добавленным <paramref name="format" />. Каждый элемент формата в параметре <paramref name="format" /> заменяется строковым представлением соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют `arg0` через `arg2`, объекты в списке параметров данного метода. Процесс форматирования заменяет каждый элемент формата строковым представлением соответствующего объекта.  
  
 Синтаксис элементов форматирования выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция форматируемого объекта в списке параметров. Если объект, заданный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если параметр отсутствует в *индекс* положение, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное количество символов в строковом представлении параметра. Если положительное, параметр по правому краю; Если значение отрицательное, это по левому краю.|  
|:*formatString*|Строка стандартного или пользовательского формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`, `arg1`, и `arg2` представления объектов для форматирования. Каждый элемент формата в `format` заменяется строковым представлением любого `arg0`, `arg1`, или `arg2`, в зависимости от индекса элемента форматирования. Если элемент формата включает `formatString` и соответствующего объекта в `args` реализует <xref:System.IFormattable> интерфейс, затем `arg` *x* `.ToString(formatString, null)` определяет форматирование, где * x* — это индекс аргумента. В противном случае `arg` *x* `.ToString()` определяет форматирование.  
  
 Если в строке, назначенной `format` является «Спасибо за пожертвование {0: ###} консервных банок нашей благотворительной организации.» и `arg0` должно быть целым числом со значением 10, возвращаемое значение будет «Спасибо за в пожертвование 10 консервных банок нашей благотворительной организации.»  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> недопустим.  
  
 - или -  
  
 Индекс элемента формата меньше нуля либо больше или равен 3.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <param name="arg2">Третий объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением любого из трех аргументов с помощью указанного поставщика формата.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления. После операции добавления этот экземпляр содержит все данные, существовавшие до операции, к которым добавляется копия параметра <paramref name="format" />, где все спецификации форматирования заменяются представлением строки соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объектам в списке параметров данного метода. Процесс форматирования заменяет каждый элемент формата строковым представлением соответствующего объекта.  
  
 Синтаксис элементов форматирования выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция форматируемого объекта в списке параметров. Если объект, заданный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если параметр отсутствует в *индекс* положение, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное количество символов в строковом представлении параметра. Если положительное, параметр по правому краю; Если значение отрицательное, это по левому краю.|  
|:*formatString*|Строка стандартного или пользовательского формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Указывает <xref:System.IFormatProvider> реализацию, которая может предоставить сведения о форматировании `arg0` и `arg1`. Параметр `provider` может иметь любое из следующих значений.  
  
-   Объект <xref:System.Globalization.CultureInfo> объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0` или `arg1` , если они являются числовыми значениями.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0`, `arg1`, или `arg2` одинаковых значений даты и времени.  
  
-   Настраиваемый <xref:System.IFormatProvider> реализацию, предоставляющий сведения о форматировании `arg0`, `arg1`, и `arg2`. Как правило, такой подход также реализует <xref:System.ICustomFormatter> интерфейса.  
  
 Если `provider` параметр `null`, сведения о формате поставщика извлекаются из текущего языка и региональных параметров.  
  
 `arg0`, `arg1`, и `arg2` представления объектов для форматирования. Каждый элемент формата в `format` заменяется строковым представлением объекта, который имеет соответствующий индекс. Если элемент формата включает `formatString` и соответствующий аргумент реализует <xref:System.IFormattable> интерфейс, то значение аргумента `ToString(formatString, provider)` метод определяет форматирование. В противном случае — значение аргумента `ToString()` метод определяет форматирование.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> метод, чтобы проиллюстрировать результат логического значения `And` операцию с целочисленных значений. Обратите внимание, строка формата содержит шесть элементов форматирования, что метод имеет только три элемента в списке аргументов, так как каждый элемент форматируется различными способами.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> недопустим.  
  
 - или -  
  
 Индекс элемента формата меньше нуля или не меньше трех.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет знак завершения строки по умолчанию или копию указанной строки и знак завершения строки по умолчанию в конце этого экземпляра.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Добавляет знак завершения строки по умолчанию в конец текущего объекта <see cref="T:System.Text.StringBuilder" />.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Признак конца строки по умолчанию является текущее значение <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> свойства.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendLine%2A> метод.  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемая строка.</param>
        <summary>Добавляет копию указанной строки и знак завершения строки по умолчанию в конец текущего объекта <see cref="T:System.Text.StringBuilder" />.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Признак конца строки по умолчанию является текущее значение <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> свойства.  
  
 При необходимости, корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значения его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное число знаков, которое может содержаться в памяти, назначенной текущим экземпляром.</summary>
        <value>Максимальное число символов, которое может содержаться в памяти, назначенной текущим экземпляром. Это значение может меняться в диапазоне от <see cref="P:System.Text.StringBuilder.Length" /> до <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> не влияет на строковое значение текущего экземпляра. <xref:System.Text.StringBuilder.Capacity%2A> можно снизить, пока он не меньше, чем <xref:System.Text.StringBuilder.Length%2A>.  
  
 <xref:System.Text.StringBuilder> Динамически выделяет больше пространства, при необходимости и увеличивает <xref:System.Text.StringBuilder.Capacity%2A> соответствующим образом. Из соображений производительности <xref:System.Text.StringBuilder> может выделить больше памяти, чем требуется. Объем выделенной памяти зависит от реализации.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Capacity%2A> свойство.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, указанное для операции задания, меньше текущей длины данного экземпляра.  
  
 - или -  
  
 Значение, заданное для операции задания, больше максимальной емкости.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция символа.</param>
        <summary>Возвращает или задает символ на указанной позиции в данном экземпляре.</summary>
        <value>Символ Юникода в позиции <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` Параметр — это положение символа в пределах <xref:System.Text.StringBuilder>. Первый символ в строке имеет индекс 0. Длина строки — количество символов, содержащихся в нем. Последний доступный знак <xref:System.Text.StringBuilder> экземпляр является индексом <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 <xref:System.Text.StringBuilder.Chars%2A> по умолчанию свойство <xref:System.Text.StringBuilder> класса. В C# это индексатора. Это означает, что отдельные символы могут быть извлечены из <xref:System.Text.StringBuilder.Chars%2A> свойства, как показано в следующем примере подсчитывается количество буквы, символы разделители и символы пунктуации в строке.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>Производительность и символьный индексирования

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          При задании символа <paramref name="index" /> находится за пределами данного экземпляра.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          При получении символа <paramref name="index" /> находится за пределами данного экземпляра.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все символы из текущего экземпляра <see cref="T:System.Text.StringBuilder" />.</summary>
        <returns>Объект, длина <see cref="P:System.Text.StringBuilder.Length" /> которого равна 0 (нулю).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Clear%2A> удобный метод, которое эквивалентно значению параметра <xref:System.Text.StringBuilder.Length%2A> свойство текущего экземпляра 0 (ноль).  
  
 Вызов <xref:System.Text.StringBuilder.Clear%2A> метод не изменяет текущий экземпляр <xref:System.Text.StringBuilder.Capacity%2A> или <xref:System.Text.StringBuilder.MaxCapacity%2A> свойства.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Text.StringBuilder> объекта со строкой, вызовы <xref:System.Text.StringBuilder.Clear%2A> метода, а затем добавляет новую строку.  
  
 [!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Начальная позиция в этом экземпляре, откуда будут скопированы символы. Индексация начинается с нуля.</param>
        <param name="destination">Массив, в который копируются символы.</param>
        <param name="destinationIndex">Начальная позиция в массиве <c>destination</c>, в которую копируются символы. Индексация начинается с нуля.</param>
        <param name="count">Число копируемых знаков.</param>
        <summary>Копирует символы из указанного сегмента этого экземпляра в указанный массив <see cref="T:System.Char" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.CopyTo%2A> Метод предназначен для использования в редких случаях при необходимости для эффективного копирования последующие разделы <xref:System.Text.StringBuilder> в массив. Массив должен быть фиксированного размера, предварительно выделенной для повторного использования и глобального доступа.  
  
 Например, приложение может заполнить <xref:System.Text.StringBuilder> объекта с большим количеством символов, а затем использовать <xref:System.Text.StringBuilder.CopyTo%2A> метод копирования небольшой последовательными фрагментов <xref:System.Text.StringBuilder> в массив, в котором обрабатываются элементы. Когда все данные в <xref:System.Text.StringBuilder> обработки объекта размер <xref:System.Text.StringBuilder> объекта равно нулю и повторении цикла.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.CopyTo%2A> метод.  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="destination" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра равно <paramref name="sourceIndex" />, <paramref name="destinationIndex" /> или <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 <paramref name="sourceIndex" /> больше длины этого экземпляра.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceIndex" /> + <paramref name="count" /> больше длины этого экземпляра.  
  
 - или -  
  
 Значение <paramref name="destinationIndex" /> + <paramref name="count" /> превышает длину <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Минимальная емкость для проверки.</param>
        <summary>Гарантирует, что емкость данного экземпляра <see cref="T:System.Text.StringBuilder" /> не меньше указанного значения.</summary>
        <returns>Новая емкость этого экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущая емкость меньше, чем `capacity` параметра, происходит перераспределение памяти для данного экземпляра для по крайней мере `capacity` знаков; в противном случае изменения памяти не происходит.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.EnsureCapacity%2A> метод.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="capacity" /> меньше нуля.  
  
 - или -  
  
 Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">Объект, сравниваемый с этим экземпляром, или значение <see langword="null" />.</param>
        <summary>Возвращает значение, показывающее, равен ли данный экземпляр заданному объекту.</summary>
        <returns>
          <see langword="true" />, если данный экземпляр и <paramref name="sb" /> имеют одинаковую строку, <see cref="P:System.Text.StringBuilder.Capacity" /> и значения <see cref="P:System.Text.StringBuilder.MaxCapacity" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем коде используется <xref:System.Text.StringBuilder.Equals%2A> метод для проверки двух <xref:System.Text.StringBuilder> объекты равны. Метод вызывается повторно после небольших изменений к каждому объекту, а результаты выводятся на консоль.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вставляет строковое представление указанного объекта в данный экземпляр на указанную позицию символа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление логического значения в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость настроена, при необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> при вставке <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод создает <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление указанного 8-разрядного целого числа без знака в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости, корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> при вставке <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод создает <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление указанного символа Юникода в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости, корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.  
  
 - или -  
  
 Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Массив символов для вставки.</param>
        <summary>Вставляет строковое представление указанного массива символов Юникода в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости, корректируется емкость данного экземпляра.  
  
 Если `value` — `null`, <xref:System.Text.StringBuilder> не изменяется.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.  
  
 - или -  
  
 Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление десятичного числа в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости, корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> при вставке <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод создает <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление числа с плавающей запятой с удвоенной точностью в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости, корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> при вставке <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод создает <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление указанного 16-разрядного знакового целого числа в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости, корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> при вставке <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод создает <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление указанного 32-разрядного знакового целого числа в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости, корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> при вставке <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод создает <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление 64-разрядного знакового целого числа в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости, корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> при вставке <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод создает <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Объект для вставки или значение <see langword="null" />.</param>
        <summary>Вставляет строковое представление объекта в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости, корректируется емкость данного экземпляра.  
  
 Если `value` — `null`, значение данного экземпляра остается неизменным.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> при вставке <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод создает <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление указанного 8-разрядного знакового целого числа в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость настроена, при необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> при вставке <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод создает <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление числа одинарной точности с плавающей запятой с обычной точностью в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости, корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> при вставке <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод создает <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Строка, которую требуется вставить.</param>
        <summary>Вставляет строку в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость настроена, при необходимости.  
  
 Этот экземпляр <xref:System.Text.StringBuilder> не изменяется, если `value` — `null`, или `value` не `null` , но его длина равна нулю.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> меньше нуля или больше текущей длины данного экземпляра.  
  
 - или -  
  
 Текущая длина этого объекта <see cref="T:System.Text.StringBuilder" /> вместе с длиной <paramref name="value" /> превышает значение <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление 16-разрядного целого числа без знака в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости, корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> при вставке <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод создает <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление 32-разрядного целого числа без знака в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости, корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> при вставке <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод создает <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление 64-разрядного целого числа без знака в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости, корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> при вставке <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод создает <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Строка, которую требуется вставить.</param>
        <param name="count">Сколько раз следует вставить <c>value</c>.</param>
        <summary>Вставляет одну или более копий указанной строки в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости, корректируется емкость данного экземпляра.  
  
 Это <xref:System.Text.StringBuilder> объекта не изменяется, если `value` — `null`, `value` не `null` , но его длина равна нулю, или `count` равно нулю.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> меньше нуля или больше текущей длины данного экземпляра.  
  
 - или -  
  
 Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.OutOfMemoryException">Текущая длина этого объекта <see cref="T:System.Text.StringBuilder" /> вместе со значением длительности <paramref name="value" /> параметра <paramref name="count" /> превышает значение <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Массив символов.</param>
        <param name="startIndex">Начальный индекс внутри <c>value</c>.</param>
        <param name="charCount">Число символов для вставки.</param>
        <summary>Вставляет строковое представление указанного подмассива символов Юникода в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости, корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Значение параметра <paramref name="value" /> — <see langword="null" />, а значения <paramref name="startIndex" /> и <paramref name="charCount" /> не равны нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра равно <paramref name="index" />, <paramref name="startIndex" /> или <paramref name="charCount" /> меньше нуля.  
  
 - или -  
  
 <paramref name="index" /> больше длины этого экземпляра.  
  
 - или -  
  
 Сумма значений <paramref name="startIndex" /> и <paramref name="charCount" /> не равна положению в <paramref name="value" />.  
  
 - или -  
  
 Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает длину текущего объекта <see cref="T:System.Text.StringBuilder" />.</summary>
        <value>Длина этого экземпляра.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Длина <xref:System.Text.StringBuilder> объект определяется по ее номеру <xref:System.Char> объектов.  
  
 Как <xref:System.String.Length%2A?displayProperty=nameWithType> свойства <xref:System.Text.StringBuilder.Length%2A> свойство, указывающее длину текущего строкового объекта. В отличие от <xref:System.String.Length%2A?displayProperty=nameWithType> свойство, которое доступно только для чтения, <xref:System.Text.StringBuilder.Length%2A> свойства можно изменить длину строки, хранящейся в <xref:System.Text.StringBuilder> объекта.  
  
 Если указанная длина меньше текущей длины текущего <xref:System.Text.StringBuilder> объект усекается до указанной длины. Если указанная длина больше текущей длины, конец строковое значение текущего <xref:System.Text.StringBuilder> объекта дополняется символом NULL Юникода (U + 0000).  
  
 Если указанная длина больше текущей емкости <xref:System.Text.StringBuilder.Capacity%2A> увеличивается, чтобы оно больше или равно указанной длины.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Length%2A> свойство.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Указанное для заданной операции значение меньше нуля или больше, чем <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальную емкость данного экземпляра.</summary>
        <value>Наибольшее количество символов, которое может содержать данный экземпляр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Максимальный объем для этой реализации <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Тем не менее это значение зависит от реализации и может отличаться в других реализациях. Можно явно задать максимальную емкость <xref:System.Text.StringBuilder> путем вызова метода <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> конструктор.  
  
 В[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и [!INCLUDE[net_v45](~/includes/net-v45-md.md)], при создании экземпляра <xref:System.Text.StringBuilder> путем вызова метода <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> конструктор, длина и емкость <xref:System.Text.StringBuilder> экземпляр может выйти за пределы значения его <xref:System.Text.StringBuilder.MaxCapacity%2A> свойство. Это может произойти, особенно при вызове <xref:System.Text.StringBuilder.Append%2A> и <xref:System.Text.StringBuilder.AppendFormat%2A> методы для добавления небольших строк.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <param name="length">Число знаков для удаления.</param>
        <summary>Удаляет указанный диапазон символов из данного экземпляра.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции удаления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий метод удаляет указанный диапазон символов из текущего экземпляра. Знаки с (`startIndex` + `length`) перемещаются `startIndex`, и строковое значение текущего экземпляра сокращается на `length`. Емкость текущего экземпляра не изменится.  
  
> [!NOTE]
>  <xref:System.Text.StringBuilder.Remove%2A> Метод изменяет значение текущего <xref:System.Text.StringBuilder> и возвращает этот экземпляр. Не создается и возвращается новый <xref:System.Text.StringBuilder> объекта.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Remove%2A> метод.  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Если <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля или <paramref name="startIndex" /> + <paramref name="length" /> больше длины этого экземпляра.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Замещает все вхождения указанного символа или строки в данном экземпляре на другой указанный символ или строку.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Замещаемый символ.</param>
        <param name="newChar">Символ, замещающий <c>oldChar</c>.</param>
        <summary>Замещает все вхождения указанного символа в данном экземпляре на другой указанный знак.</summary>
        <returns>Ссылка на данный экземпляр с помощью <paramref name="oldChar" /> заменяется на <paramref name="newChar" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение порядковый номер, с учетом регистра для идентификации вхождения `oldChar` в текущем экземпляре. Размер текущего <xref:System.Text.StringBuilder> экземпляра не меняется после замены.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Replace%2A> метод.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Замещаемая строка.</param>
        <param name="newValue">Строка, замещающая <c>oldChar</c>, или <see langword="null" />.</param>
        <summary>Замещает все вхождения указанной строки в данном экземпляре на другую указанную строку.</summary>
        <returns>Ссылка на данный экземпляр со всеми экземплярами <paramref name="oldValue" /> заменяется на <paramref name="newValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение порядковый номер, с учетом регистра для идентификации вхождения `oldValue` в текущем экземпляре. Если `newValue` — `null` или <xref:System.String.Empty?displayProperty=nameWithType>, все вхождения `oldValue` удаляются.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Replace%2A> метод.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="oldValue" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="oldValue" /> равна нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">Замещаемый символ.</param>
        <param name="newChar">Символ, замещающий <c>oldChar</c>.</param>
        <param name="startIndex">Позиция в данном экземпляре, с которой начинается подстрока.</param>
        <param name="count">Длина подстроки.</param>
        <summary>Замещает все вхождения указанного символа в подстроке данного экземпляра на другой указанный символ.</summary>
        <returns>Ссылка на данный экземпляр с <paramref name="oldChar" /> заменяется на <paramref name="newChar" /> в диапазоне от <paramref name="startIndex" /> до <paramref name="startIndex" /> + <paramref name="count" /> –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение порядковый номер, с учетом регистра для идентификации вхождения `oldChar` в текущем экземпляре. Размер текущего <xref:System.Text.StringBuilder> объект не изменяется после замены.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Replace%2A> метод.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> + <paramref name="count" /> больше длины значения этого экземпляра.  
  
 - или -  
  
 Значение параметра <paramref name="startIndex" /> или <paramref name="count" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">Замещаемая строка.</param>
        <param name="newValue">Строка, замещающая <c>oldChar</c>, или <see langword="null" />.</param>
        <param name="startIndex">Позиция в данном экземпляре, с которой начинается подстрока.</param>
        <param name="count">Длина подстроки.</param>
        <summary>Замещает все вхождения указанной строки в подстроке данного экземпляра на другую указанную строку.</summary>
        <returns>Ссылка на данный экземпляр со всеми экземплярами <paramref name="oldValue" /> заменяется на <paramref name="newValue" /> в диапазоне от <paramref name="startIndex" /> до <paramref name="startIndex" /> + <paramref name="count" /> – 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение порядковый номер, с учетом регистра для идентификации вхождения `oldValue` в указанной подстроки. Если `newValue` — `null` или <xref:System.String.Empty?displayProperty=nameWithType>, все вхождения `oldValue` удаляются.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Replace%2A> метод.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="oldValue" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="oldValue" /> равна нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="startIndex" /> или <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Значение <paramref name="startIndex" /> плюс <paramref name="count" /> указывает позицию символа вне пределов данного экземпляра.  
  
 - или -  
  
 Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Объект, который требуется заполнить информацией о сериализации.</param>
        <param name="context">Место для хранения и извлечения сериализованных данных. Зарезервировано для будущего использования.</param>
        <summary>Заполняет объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> данными даты, необходимыми для десериализации текущего объекта <see cref="T:System.Text.StringBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `context` Параметр зарезервирован для использования в будущем и не участвует в этой операции.  
  
 Дополнительные сведения см. в описании метода <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="info" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразовывает значение типа <see cref="T:System.Text.StringBuilder" /> в значение <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразует значение данного экземпляра в <see cref="T:System.String" />.</summary>
        <returns>Строка, чье значение совпадает с данным экземпляром.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо вызвать <xref:System.Text.StringBuilder.ToString%2A> метода для преобразования <xref:System.Text.StringBuilder> объект <xref:System.String> объекта, прежде чем можно передать строку, представленную <xref:System.Text.StringBuilder> объект для метода, имеющего <xref:System.String> параметр или его отображения в пользовательском интерфейсе.  
  
   
  
## Examples  
 В следующем примере демонстрируется вызов метода <xref:System.Text.StringBuilder.ToString%2A>. Данный пример является частью большего примера, приведенного для <xref:System.Text.StringBuilder> класса.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Начальная позиция подстроки в данном экземпляре.</param>
        <param name="length">Длина подстроки.</param>
        <summary>Преобразует значение подстроки этого экземпляра в <see cref="T:System.String" />.</summary>
        <returns>Строка, чье значение совпадает с указанной подстрокой данного экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо вызвать <xref:System.Text.StringBuilder.ToString%2A> метода для преобразования <xref:System.Text.StringBuilder> объект <xref:System.String> объекта, прежде чем можно передать строку, представленную <xref:System.Text.StringBuilder> объект для метода, имеющего <xref:System.String> параметр или его отображения в пользовательском интерфейсе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля.  
  
 - или -  
  
 Сумма <paramref name="startIndex" /> и <paramref name="length" /> больше, чем длина текущего экземпляра.</exception>
      </Docs>
    </Member>
  </Members>
</Type>