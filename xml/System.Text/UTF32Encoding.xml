<Type Name="UTF32Encoding" FullName="System.Text.UTF32Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b5c8f619a477fdc9f8a9bc17d4405164f258102c" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531418" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class UTF32Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit UTF32Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF32Encoding" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class UTF32Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF32Encoding sealed : System::Text::Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Представляет кодировку символов Юникода в формате UTF-32.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодирование - это процесс преобразования набора символов Юникода в последовательность байтов. Декодирование представляет собой процесс преобразования последовательности закодированных байтов в набор символов Юникода.  
  
 [Стандарт Юникод](http://go.microsoft.com/fwlink/?linkid=37123) назначает каждому символу в каждом поддерживаемом символьном кодовая точка (номер). Формат преобразования Юникода (UTF) способ кодирования кодовой точки. [Стандарт Юникод](http://go.microsoft.com/fwlink/?linkid=37123) использует следующие форматы UTF:  
  
-   UTF-8, который представляет каждую кодовую точку в виде последовательности от одного до четырех байтов.  
  
-   UTF-16, который представляет каждую кодовую точку в виде последовательности из одной или двух 16-битовых целых чисел.  
  
-   UTF-32, который представляет каждую кодовую точку как 32-разрядное целое число.  
  
 Дополнительные сведения о UTF и других кодировках, поддерживаемых <xref:System.Text>, см.  
  
 <xref:System.Text.UTF32Encoding> Класс представляет кодировку UTF-32. Кодировщик может использовать обратный порядок байтов (самый старший байт первый) или в прямом порядке байтов (младший байт первый). Например прописная латинская буква (кодовая точка U + 0041) сериализуется как выглядит следующим образом (в шестнадцатеричном формате).  
  
-   Обратный порядок байтов: 00 00 00 41  
  
-   Прямом порядке байтов: 41 00 00 00  
  
 Может оказаться более эффективным, для хранения символов Юникода с использованием собственного порядка байтов. Например лучше использовать прямом порядке байтов на платформах с прямым порядком, таких как компьютеры Intel. <xref:System.Text.UTF32Encoding> соответствует кодовых страниц Windows 12000 (прямом порядке байтов) и 12001 (обратный порядок байтов). «Порядок байтов» конкретной архитектуры можно определить, вызвав <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> метод.  
  
 При необходимости <xref:System.Text.UTF32Encoding> объект предоставляет метку порядка байтов (BOM), который является массивом байтов, которые может иметь префикс в последовательность байтов, полученных в результате кодирования. Если преамбула содержит метку порядка байтов (BOM), декодер получает возможность определить порядок следования байтов и формат преобразования или UTF массива байтов.  
  
 Если <xref:System.Text.UTF32Encoding> экземпляр настроен для поддержки Спецификации, его можно получить, вызвав <xref:System.Text.UTF32Encoding.GetPreamble%2A> метода; в противном случае метод возвращает пустой массив. Обратите внимание, что даже если <xref:System.Text.UTF32Encoding> настроен для поддержки Спецификации объект, необходимо включить BOM в начале потока закодированных байтов в виде соответствующих; методы кодирования <xref:System.Text.UTF32Encoding> класса не делать это автоматически.  
  
 Чтобы включить обнаружение ошибок и защищенности экземпляра класса, следует создать экземпляр <xref:System.Text.UTF32Encoding> путем вызова метода <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> конструктор и параметр его `throwOnInvalidBytes` аргумент `true`. Обнаружения ошибок, вызывает метод, который обнаруживает недопустимую последовательность символов или байтов, <xref:System.ArgumentException> исключение. Без обнаружение ошибок исключение не создается и Недопустимая последовательность обычно игнорируется.  
  
 Можно создать экземпляр <xref:System.Text.UTF32Encoding> объекта несколькими способами, в зависимости от того, требуется ли он для предоставления метку порядка байтов (BOM), нужно ли кодировку с прямым или обратным порядком байтов и того, требуется ли включить функцию обнаружения ошибок. В следующей таблице перечислены <xref:System.Text.UTF32Encoding> конструкторы и <xref:System.Text.Encoding> свойства, которые возвращают <xref:System.Text.UnicodeEncoding> объекта.  
  
|Член|Порядок байтов|СПЕЦИФИКАЦИИ|Обнаружение ошибок|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>|Обратный порядок байтов|Да|Нет (стратегия замены)|  
|<xref:System.Text.UTF32Encoding.%23ctor?displayProperty=nameWithType>|Обратный порядок байтов|Да|Нет (стратегия замены)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Возможность настройки|Возможность настройки|Нет (стратегия замены)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Возможность настройки|Возможность настройки|Возможность настройки|  
  
 <xref:System.Text.UTF32Encoding.GetByteCount%2A> Метод определяет, сколько байт привести кодировании набора символов Юникода и <xref:System.Text.UTF32Encoding.GetBytes%2A> метод выполняет фактической кодировкой.  
  
 Аналогичным образом <xref:System.Text.UTF32Encoding.GetCharCount%2A> метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.UTF32Encoding.GetChars%2A> и <xref:System.Text.UTF32Encoding.GetString%2A> методы выполняют фактическое декодирование.  
  
 Для кодировщика или декодера, который может сохранить сведения о состоянии при кодирования или декодирования данных, занимающих несколько блоков (например, строка 1 миллиона символов, закодированные в сегменты 100 000 символов), используйте <xref:System.Text.UTF32Encoding.GetEncoder%2A> и <xref:System.Text.UTF32Encoding.GetDecoder%2A> свойства, соответственно.  
  
   
  
## Examples  
 В следующем примере показано поведение <xref:System.Text.UTF32Encoding> объекты с и без обнаружение ошибок включено. Создает массив байтов, в которых последние четыре байта представляют недействительной суррогатной пары; старший заместитель U + D8FF следуют U + 01FF, который находится вне диапазона суррогаты низкий (0xDC00 до 0xDFFF). Без обнаружения ошибки декодер UTF32 использует резервную стратегию замены для замены недействительной суррогатной пары замещающим символом (U + FFFD).  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 В следующем примере кодируется строка символов Юникода в массив байтов с помощью <xref:System.Text.UTF32Encoding> объекта. Массив байтов, затем декодируется в строку, чтобы показать, что без потери данных.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/snippet.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/snippet.vb#1)]  
  
 В следующем примере та же строка на предыдущий, за исключением того, он записывает закодированных байтов в файл и добавляет в поток байтов с отметкой порядка байтов (BOM). Затем он считывает из файла двумя различными способами: как текстовый файл с помощью <xref:System.IO.StreamReader> объекту и как двоичный файл. Как и следовало ожидать в случае ни Спецификации включается в вновь чтения строки.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/bom1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Text.UnicodeEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.UTF32Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.UTF32Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает экземпляр, который используется в прямом порядке байтов, предоставляет метку порядка байтов Юникода и не выдает исключение при обнаружении недопустимой кодировки.  
  
> [!NOTE]
>  По соображениям безопасности следует включить обнаружение ошибок путем вызова <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> конструктор и присвоения его `throwOnInvalidCharacters` аргумент `true`.  
  
   
  
## Examples  
 Следующий пример извлекает и отображает порядок байтов пометить для разных <xref:System.Text.UTF32Encoding> экземпляров.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          Значение <see langword="true" /> соответствует использованию обратного порядка байтов (самый старший байт располагается на первом месте); значение <see langword="false" /> соответствует использованию прямого порядка байтов (на первом месте находится самый младший байт).</param>
        <param name="byteOrderMark">
          Значение <see langword="true" /> указывает, что предоставляется метка порядка байтов Юникода; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.UTF32Encoding" />. Параметры указывают, следует ли использовать обратный порядок байтов и возвращает ли метод <see cref="M:System.Text.UTF32Encoding.GetPreamble" /> метку порядка байтов Юникода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает экземпляр, который не выдает исключение при обнаружении недопустимой кодировки.  
  
> [!NOTE]
>  По соображениям безопасности следует включить обнаружение ошибок путем вызова <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> конструктор и присвоения его `throwOnInvalidCharacters` аргумент `true`.  
  
   
  
## Examples  
 Следующий пример извлекает и отображает порядок байтов пометить для разных <xref:System.Text.UTF32Encoding> экземпляров.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidCharacters As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidCharacters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          Значение <see langword="true" /> соответствует использованию обратного порядка байтов (самый старший байт располагается на первом месте); значение <see langword="false" /> соответствует использованию прямого порядка байтов (на первом месте находится самый младший байт).</param>
        <param name="byteOrderMark">
          Значение <see langword="true" /> указывает, что предоставляется метка порядка байтов Юникода; в противном случае — значение <see langword="false" />.</param>
        <param name="throwOnInvalidCharacters">
          <see langword="true" />, чтобы указать, что следует выдавать исключение при обнаружении недопустимой кодировки; в противном случае — <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.UTF32Encoding" />. Параметры указывают, следует ли использовать обратный порядок байтов, должна ли предоставляться метка порядка байтов Юникода и следует ли создавать исключение при обнаружении недопустимой кодировки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `throwOnInvalidCharacters` — `true`, вызывает метод, обнаруживающий недопустимые последовательности байтов <xref:System.ArgumentException?displayProperty=nameWithType>. В противном случае этот метод создает исключение, и Недопустимая последовательность игнорируется.  
  
> [!NOTE]
>  По соображениям безопасности следует включить обнаружение ошибок путем вызова <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> конструктор и присвоения его `throwOnInvalidCharacters` аргумент `true`.  
  
   
  
## Examples  
 В следующем примере показано поведение <xref:System.Text.UTF32Encoding>, как с обнаружение ошибок включено, так и без.  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект <see cref="T:System.Object" />, который требуется сравнить с текущим объектом.</param>
        <summary>Определяет, равен ли заданный объект <see cref="T:System.Object" /> текущему объекту <see cref="T:System.Text.UTF32Encoding" />.</summary>
        <returns>
          Значение <see langword="true" />, если <paramref name="value" /> является экземпляром класса <see cref="T:System.Text.UTF32Encoding" /> и равен текущему объекту; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Два <xref:System.Text.UTF32Encoding> объекты считаются равными, если выполняются все следующие условия:  
  
-   Оба объекта используют одинаковый порядок следования байтов.  
  
-   Оба объекта предоставляться метка порядка байтов или оба — нет.  
  
-   Оба объекта используют одинаковые резерва кодировщика.  
  
-   Оба объекта используют же резервный декодера.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Text.UTF32Encoding> объекты с помощью различных параметров, значений и затем выполняется их проверка на равенство.  
  
 [!code-cpp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Подсчитывает количество байтов, полученных при кодировании набора символов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Объект <see cref="T:System.String" />, содержащий кодируемый набор символов.</param>
        <summary>Вычисляет количество байтов, полученных при кодировании символов в заданном объекте <see cref="T:System.String" />.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения полученные байты, вызов <xref:System.Text.UTF32Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.UTF32Encoding.GetByteCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Чтобы обеспечить правильное декодирование закодированных байтов когда они сохраняются в виде файла или потока, можно задать префикс закодированных байтов преамбулу в виде потока. Вставка преамбулу в начале потока байтов (например, в начале последовательности байтов для записи в файл) ответственность разработчика и число байтов в преамбула не отражаются в значение, возвращаемое <xref:System.Text.UTF32Encoding.GetByteCount%2A> метод.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> и <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> методы для вычисления фактического и максимального числа байтов, необходимых для кодирования строки. Он также отображает фактическое число байтов, необходимое для хранения потока данных с отметкой порядка байтов.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="s" /> содержит недопустимую последовательность символов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Указатель на первый кодируемый символ.</param>
        <param name="count">Число кодируемых символов.</param>
        <summary>Вычисляет число байтов, полученных при кодировании набора символов начиная с заданного указателя символа.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения полученные байты, вызов <xref:System.Text.UTF32Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF32Encoding.GetByteCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Чтобы обеспечить правильное декодирование закодированных байтов если они сохраняются как файл или поток, можно задать префикс закодированных байтов преамбулу в виде потока. Вставка преамбулу в начале потока байтов (например, в начале последовательности байтов для записи в файл) ответственность разработчика и число байтов в преамбула не отражаются в значение, возвращаемое <xref:System.Text.UTF32Encoding.GetByteCount%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="chars" /> содержит недопустимую последовательность символов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий набор кодируемых символов.</param>
        <param name="index">Индекс первого кодируемого символа.</param>
        <param name="count">Число кодируемых символов.</param>
        <summary>Вычисляет число байтов, полученных при кодировании набора символов из указанного массива символов.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения полученные байты, вызов <xref:System.Text.UTF32Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.UTF32Encoding.GetByteCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Чтобы обеспечить правильное декодирование закодированных байтов если они сохраняются как файл или поток, можно задать префикс закодированных байтов преамбулу в виде потока. Вставка преамбулу в начале потока байтов (например, в начале последовательности байтов для записи в файл) ответственность разработчика и число байтов в преамбула не отражаются в значение, возвращаемое <xref:System.Text.UTF32Encoding.GetByteCount%2A> метод.  
  
   
  
## Examples  
 В следующем примере заполняется массив с латиница прописные и строчные буквы и вызовы <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> метод для определения числа байтов, необходимое для кодирования латинские символы нижнего регистра. Затем отображается эти сведения, а также общее число байтов, которые требуются при добавлении метку порядка следования байтов. Он сравнивает это значение со значения, возвращенного <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> метода, который указывает максимальное число байтов, необходимых для кодирования латинские символы нижнего регистра. В следующем примере заполняется массив с сочетания символов греческий и кириллица и вызывает <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> метод для определения числа байтов, необходимое для кодирования символов кириллицы. Затем отображается эти сведения, а также общее число байтов, которые требуются при добавлении метку порядка следования байтов. Он сравнивает это значение со значения, возвращенного <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> метода, который указывает максимальное число байтов, необходимых для кодирования символов кириллицы.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="chars" />.  
  
 - или -  
  
 Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="chars" /> содержит недопустимую последовательность символов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Кодирует набор символов в последовательность байтов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Указатель на первый кодируемый символ.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Указатель на положение, с которого начинается запись результирующей последовательности байтов.</param>
        <param name="byteCount">Максимальное число байтов для записи.</param>
        <summary>Кодирует набор символов, начало которого задается указателем символа, в последовательность байтов, которые сохраняются начиная с заданного указателя байта.</summary>
        <returns>Фактическое число байтов, записанных в местоположение, которое задано параметром <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения полученные байты, вызов <xref:System.Text.UTF32Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.UTF32Encoding.GetByteCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Данные для преобразования, например чтение данных из потока, могут быть доступны только в виде последовательных блоков. В этом случае или если объем данных слишком велико, что необходимо разделить на более мелкие блоки, приложение использует <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.UTF32Encoding.GetDecoder%2A> метода или <xref:System.Text.UTF32Encoding.GetEncoder%2A> метода, соответственно.  
  
> [!NOTE]
>  Чтобы обеспечить правильное декодирование закодированных байтов когда они сохраняются в виде файла или потока, можно задать префикс закодированных байтов преамбулу в виде потока. Вставка преамбулу в начале байтового потока (например, в начале последовательности байтов для записи в файл) ответственность разработчика. <xref:System.Text.UTF32Encoding.GetBytes%2A> Метод не добавить заголовок в начало последовательность закодированных байтов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="chars" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="charCount" /> или <paramref name="byteCount" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="chars" /> содержит недопустимую последовательность символов.  
  
 - или -  
  
 <paramref name="byteCount" /> меньше результирующего числа байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий набор кодируемых символов.</param>
        <param name="charIndex">Индекс первого кодируемого символа.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Массив байтов, в который будет помещена результирующая последовательность байтов.</param>
        <param name="byteIndex">Индекс, с которого начинается запись результирующей последовательности байтов.</param>
        <summary>Кодирует набор символов из заданного массива символов в указанный массив байтов.</summary>
        <returns>Фактическое число байтов, записанных в <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения полученные байты, вызов <xref:System.Text.UTF32Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.UTF32Encoding.GetByteCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Данные для преобразования, например чтение данных из потока, могут быть доступны только в виде последовательных блоков. В этом случае или если объем данных слишком велико, что необходимо разделить на более мелкие блоки, приложение использует <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.UTF32Encoding.GetDecoder%2A> метода или <xref:System.Text.UTF32Encoding.GetEncoder%2A> метода, соответственно.  
  
> [!NOTE]
>  Чтобы обеспечить правильное декодирование закодированных байтов когда они сохраняются в виде файла или потока, можно задать префикс закодированных байтов преамбулу в виде потока. Вставка преамбулу в начале байтового потока (например, в начале последовательности байтов для записи в файл) ответственность разработчика. <xref:System.Text.UTF32Encoding.GetBytes%2A> Метод не добавить заголовок в начало последовательность закодированных байтов.  
  
   
  
## Examples  
 В следующем примере определяет число байтов, необходимое для кодирования трех символов из массива символов, затем выполняется кодирование символов и отображаются полученные байты.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/VB/GetBytes_CharArr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="chars" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="charIndex" />, <paramref name="charCount" /> или <paramref name="byteIndex" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="charIndex" /> и <paramref name="charCount" /> не указывают допустимый диапазон в <paramref name="chars" />.  
  
 - или -  
  
 Значение параметра <paramref name="byteIndex" /> не является допустимым индексом в <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="chars" /> содержит недопустимую последовательность символов.  
  
 - или -  
  
 Недостаточно емкости <paramref name="bytes" /> от <paramref name="byteIndex" /> до конца массива для размещения полученных байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Объект <see cref="T:System.String" />, содержащий кодируемый набор символов.</param>
        <param name="charIndex">Индекс первого кодируемого символа.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Массив байтов, в который будет помещена результирующая последовательность байтов.</param>
        <param name="byteIndex">Индекс, с которого начинается запись результирующей последовательности байтов.</param>
        <summary>Кодирует набор символов из заданного объекта <see cref="T:System.String" /> в указанный массив байтов.</summary>
        <returns>Фактическое число байтов, записанных в <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения полученные байты, вызов <xref:System.Text.UTF32Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.UTF32Encoding.GetByteCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Данные для преобразования, например чтение данных из потока, могут быть доступны только в виде последовательных блоков. В этом случае или если объем данных слишком велико, что необходимо разделить на более мелкие блоки, приложение использует <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.UTF32Encoding.GetDecoder%2A> метода или <xref:System.Text.UTF32Encoding.GetEncoder%2A> метода, соответственно.  
  
> [!NOTE]
>  Чтобы обеспечить правильное декодирование закодированных байтов когда они сохраняются в виде файла или потока, можно задать префикс закодированных байтов преамбулу в виде потока. Вставка преамбулу в начале байтового потока (например, в начале последовательности байтов для записи в файл) ответственность разработчика. <xref:System.Text.UTF32Encoding.GetBytes%2A> Метод не добавить заголовок в начало последовательность закодированных байтов.  
  
   
  
## Examples  
 В следующем примере определяет число байтов, необходимых для кодирования строки, а затем кодирует строку и выводит полученные байты.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="s" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="charIndex" />, <paramref name="charCount" /> или <paramref name="byteIndex" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="charIndex" /> и <paramref name="charCount" /> не указывают допустимый диапазон в <paramref name="chars" />.  
  
 - или -  
  
 Значение параметра <paramref name="byteIndex" /> не является допустимым индексом в <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="s" /> содержит недопустимую последовательность символов.  
  
 - или -  
  
 Недостаточно емкости <paramref name="bytes" /> от <paramref name="byteIndex" /> до конца массива для размещения полученных байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вычисляет количество символов, полученных при декодировании последовательности байтов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на первый декодируемый байт.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>Вычисляет количество символов, полученных при декодировании последовательности байтов начиная с заданного указателя байта.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding.GetCharCount%2A> вычисляет размер точное массива, необходимого <xref:System.Text.UTF32Encoding.GetChars%2A> для сохранения полученных символов. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> метод. <xref:System.Text.UTF32Encoding.GetCharCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и параметр <paramref name="bytes" /> содержит недопустимую последовательность байтов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>Вычисляет количество символов, полученных при декодировании последовательности байтов из заданного массива байтов.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding.GetCharCount%2A> Метод вычисляет размер точное массива, необходимого <xref:System.Text.UTF32Encoding.GetChars%2A> для сохранения полученных символов. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> метод. <xref:System.Text.UTF32Encoding.GetCharCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
   
  
## Examples  
 В следующем примере кодирует строку в массив байтов и затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.  
  
 - или -  
  
 Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и параметр <paramref name="bytes" /> содержит недопустимую последовательность байтов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Декодирует последовательность байтов в набор символов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на первый декодируемый байт.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <param name="chars">Указатель на положение, с которого начинается запись результирующего набора символов.</param>
        <param name="charCount">Наибольшее количество символов для записи.</param>
        <summary>Декодирует последовательность байтов, начало которой задается указателем байта, в набор символов, которые сохраняются начиная с заданного указателя символа.</summary>
        <returns>Фактическое число символов, записанных в местоположение, указанное с помощью параметра <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UTF32Encoding.GetChars%2A> для хранения полученных символов, вызовите <xref:System.Text.UTF32Encoding.GetCharCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> метод. <xref:System.Text.UTF32Encoding.GetCharCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Если массив байтов был возвращен методом виду не Спецификации типа диапазона байтов для декодирования включает отметку порядка байтов (BOM), символ U + FFFE включается в массив символов, возвращаемый этим методом. Его можно удалить путем вызова <xref:System.String.TrimStart%2A?displayProperty=nameWithType> метод.  
  
 Данные для преобразования, например чтение данных из потока, могут быть доступны только в виде последовательных блоков. В этом случае или если объем данных слишком велико, что необходимо разделить на более мелкие блоки, приложение использует <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.UTF32Encoding.GetDecoder%2A> метода или <xref:System.Text.UTF32Encoding.GetEncoder%2A> метода, соответственно.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="byteCount" /> или <paramref name="charCount" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и параметр <paramref name="bytes" /> содержит недопустимую последовательность байтов.  
  
 - или -  
  
 <paramref name="charCount" /> меньше результирующего числа символов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="byteIndex">Индекс первого декодируемого байта.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <param name="chars">Массив символов, в который будет помещен результирующий набор символов.</param>
        <param name="charIndex">Индекс, с которого начинается запись результирующего набора символов.</param>
        <summary>Декодирует последовательность байтов из заданного массива байтов в указанный массив символов.</summary>
        <returns>Фактическое число символов, записанных в <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UTF32Encoding.GetChars%2A> для хранения полученных символов, вызовите <xref:System.Text.UTF32Encoding.GetCharCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> метод. <xref:System.Text.UTF32Encoding.GetCharCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Если массив байтов был возвращен методом виду не Спецификации типа диапазона байтов для декодирования включает отметку порядка байтов (BOM), символ U + FFFE включается в массив символов, возвращаемый этим методом. Его можно удалить путем вызова <xref:System.String.TrimStart%2A?displayProperty=nameWithType> метод.  
  
 Данные для преобразования, например чтение данных из потока, могут быть доступны только в виде последовательных блоков. В этом случае или если объем данных слишком велико, что необходимо разделить на более мелкие блоки, приложение использует <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.UTF32Encoding.GetDecoder%2A> метода или <xref:System.Text.UTF32Encoding.GetEncoder%2A> метода, соответственно.  
  
   
  
## Examples  
 В следующем примере кодирует строку в массив байтов и затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="byteIndex" />, <paramref name="byteCount" /> или <paramref name="charIndex" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="byteindex" /> и <paramref name="byteCount" /> не указывают допустимый диапазон в <paramref name="bytes" />.  
  
 - или -  
  
 Значение параметра <paramref name="charIndex" /> не является допустимым индексом в <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и параметр <paramref name="bytes" /> содержит недопустимую последовательность байтов.  
  
 - или -  
  
 Недостаточно емкости <paramref name="chars" /> от <paramref name="charIndex" /> до конца массива для размещения полученных символов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает средство декодирования, преобразующее последовательность байтов в кодировке UTF-32 в последовательность символов Юникода.</summary>
        <returns>Объект <see cref="T:System.Text.Decoder" />, преобразующий последовательность байтов в кодировке UTF-32 в последовательность символов Юникода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Метод преобразует последовательные блоки байтов в последовательные блоки символов в так же, как <xref:System.Text.UTF32Encoding.GetChars%2A> метод. Однако <xref:System.Text.Decoder> хранит сведения о состоянии между вызовами, что позволяет ему правильно декодировать последовательности байтов, охватывающие блоки. <xref:System.Text.Decoder> Также сохраняет замыкающие байты в конце блоков данных и использует конечные байты при следующей операции декодирования. Таким образом <xref:System.Text.UTF32Encoding.GetDecoder%2A> и <xref:System.Text.UTF32Encoding.GetEncoder%2A> полезны для передачи по сети и операции с файлами, так как эти операции часто работают с блоками данных, а не полные данные потока.  
  
 Если обнаружение ошибок включено, то есть `throwOnInvalidCharacters` было присвоено значение параметра конструктора `true`, также включена функция обнаружения ошибок в <xref:System.Text.Decoder> возвращаемый этим методом. Если включена функция обнаружения ошибок и обнаружена недопустимая последовательность, состояние декодера является неопределенным и обработка должна быть остановлена.  
  
   
  
## Examples  
 В следующем примере кодировщик и декодер для кодирования строки в массив байтов и затем декодирования байтов в массив символов.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает средство кодирования, преобразующее последовательность символов Юникода в последовательность байтов в кодировке UTF-32.</summary>
        <returns>Объект <see cref="T:System.Text.Encoder" />, преобразующий последовательность символов Юникода в последовательность байтов в кодировке UTF-32.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> Метод преобразует последовательные блоки символов в последовательные блоки байтов таким способом, аналогичным <xref:System.Text.UTF32Encoding.GetBytes%2A> метод. Однако <xref:System.Text.Encoder> хранит сведения о состоянии между вызовами, что позволяет правильно кодировать последовательности символов, охватывающие блоки. <xref:System.Text.Encoder> Также сохраняет замыкающие символы в конце блоков данных и использует замыкающие символы при выполнении следующей операции кодирования. Например может оказаться, что блок данных с несоответствиями старший символ-заместитель и сопоставления младшим символом-заместителем может находиться в следующем блоке данных. Таким образом <xref:System.Text.UTF32Encoding.GetDecoder%2A> и <xref:System.Text.UTF32Encoding.GetEncoder%2A> полезны для передачи по сети и операции с файлами, так как эти операции часто работают с блоками данных, а не полные данные потока.  
  
 Если обнаружение ошибок включено, то есть `throwOnInvalidCharacters` было присвоено значение параметра конструктора `true`, также включена функция обнаружения ошибок в <xref:System.Text.Encoder> возвращаемый этим методом. Если включена функция обнаружения ошибок и обнаружена недопустимая последовательность, состояние кодировщика является неопределенным и обработка должна быть остановлена.  
  
   
  
## Examples  
 В следующем примере кодировщик и декодер для кодирования строки в массив байтов и затем декодирования байтов в массив символов.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код текущего экземпляра.</summary>
        <returns>Хэш-код для текущего объекта <see cref="T:System.Text.UTF32Encoding" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Число кодируемых символов.</param>
        <summary>Вычисляет максимальное количество байтов, полученных при кодировании заданного числа символов.</summary>
        <returns>Максимальное количество байтов, полученных при кодировании заданного количества символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения полученные байты, вызов <xref:System.Text.UTF32Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.UTF32Encoding.GetByteCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> — Это худший число, включая Наихудший случай для выбранного в данный момент <xref:System.Text.EncoderFallback>. Если выбран резервный вариант с потенциально длинной строкой <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> может возвращать большие значения.  
  
 В большинстве случаев этот метод возвращает адекватные числа для коротких строк. Для больших строк необходимо выбирать между использованием очень больших буферов и отслеживанием ошибок в тех редких случаях, более рационального буфера превышено. Можно также использовать другой подход и использовать <xref:System.Text.UTF32Encoding.GetByteCount%2A> или <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> не имеет отношения к <xref:System.Text.UTF32Encoding.GetChars%2A>. Если требуется подобная функция, для использования с <xref:System.Text.UTF32Encoding.GetChars%2A>, используйте <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` не обязательно совпадает со значением `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 В следующем примере определяет число байтов, необходимых для кодирования строки, а затем кодирует строку и выводит полученные байты.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="charCount" /> меньше нуля.  
  
 - или -  
  
 Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Число байтов для декодирования.</param>
        <summary>Вычисляет максимальное количество символов, полученных при декодировании заданного числа байтов.</summary>
        <returns>Максимальное количество символов, полученных при декодировании заданного количества байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UTF32Encoding.GetChars%2A> для хранения полученных символов, вызовите <xref:System.Text.UTF32Encoding.GetCharCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> метод. <xref:System.Text.UTF32Encoding.GetCharCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> — Это худший число, включая Наихудший случай для выбранного в данный момент <xref:System.Text.DecoderFallback>. Если выбран резервный вариант с потенциально длинной строкой <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> может возвращать большие значения.  
  
 В большинстве случаев этот метод возвращает адекватные числа для коротких строк. Для больших строк необходимо выбирать между использованием очень больших буферов и отслеживанием ошибок в тех редких случаях, более рационального буфера превышено. Можно также использовать другой подход и использовать <xref:System.Text.UTF32Encoding.GetCharCount%2A> или <xref:System.Text.Decoder.Convert%2A>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> не имеет отношения к <xref:System.Text.UTF32Encoding.GetBytes%2A>. Если требуется подобная функция, для использования с <xref:System.Text.UTF32Encoding.GetBytes%2A>, используйте <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` не обязательно совпадает со значением `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 В следующем примере кодирует строку в массив байтов и затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="byteCount" /> меньше нуля.  
  
 - или -  
  
 Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает метку порядка байтов Юникода в кодировке UTF-32, если объект <see cref="T:System.Text.UTF32Encoding" /> настроен для ее предоставления.</summary>
        <returns>Массив байтов, содержащий метку порядка байтов Юникода, если объект <see cref="T:System.Text.UTF32Encoding" /> настроен для его предоставления. В противном случае этот метод возвращает массив байтов нулевой длины.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding> Объект может предоставлять преамбулу, который является массивом байтов, которые может иметь префикс в последовательность байтов, полученных в результате кодирования. Предшествующим последовательность закодированных байтов с отметкой порядка байтов (U + 0000 U + FEFF кодовые точки) декодер может определить порядок байтов и формат преобразования или UTF. Метка порядка байтов (BOM) Юникода сериализуется следующим образом (в шестнадцатеричном формате):  
  
-   Обратный порядок байтов: 00 00 FE FF  
  
-   Прямом порядке байтов: FF FE 00 00  
  
 Можно создать экземпляр <xref:System.Text.UTF32Encoding> которого <xref:System.Text.UTF32Encoding.GetPreamble%2A> метод возвращает допустимый Спецификации одним из следующих способов:  
  
-   Путем получения <xref:System.Text.UTF32Encoding> объект, возвращаемый <xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType> свойство.  
  
-   Путем вызова без параметров <xref:System.Text.UTF32Encoding.%23ctor> конструктора для создания <xref:System.Text.UTF32Encoding> объекта.  
  
-   Указав `true` в качестве значения `byteOrderMark` аргумент <xref:System.Text.UTF32Encoding.%23ctor%2A> и <xref:System.Text.UTF32Encoding.%23ctor%2A> конструкторы.  
  
 Мы рекомендуем использовать Спецификации, поскольку она обеспечивает почти точную идентификацию кодировки для файлов, в противном случае теряют ссылку на <xref:System.Text.UTF32Encoding> объекта, например, без тега или неправильно отмечен веб-данных или хранятся файлы произвольного текста, когда организация не имела расставленными или других данных. Часто возникающих пользователя избавить согласованных и правильных тегов в данных.  
  
 Для стандартов, предоставляющих тип кодировки метка BOM отчасти избыточный. Тем не менее он может использоваться, чтобы помочь серверу отправлять правильный заголовок кодировки. Кроме того он может использоваться как переход на резервный ресурс в случае, если кодировка, в противном случае не потеряны.  
  
 Есть некоторые недостатки использования метки порядка БАЙТОВ. Например сложно выбрать способы ограничения полей базы данных, используйте метки порядка БАЙТОВ. Объединение файлов может вызвать проблемы также, например, когда файлы сливаются таким образом, что необязательный символ может оказаться в центре данных. Несмотря на некоторые недостатки Однако использование спецификации настоятельно рекомендуется.  
  
 Дополнительные сведения о порядке байтов и метка порядка байтов в разделе Юникод [домашней странице Юникода](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Чтобы обеспечить правильное декодирование закодированных байтов, необходимо использовать перед закодированных байтов с начальной части. Обратите внимание, что <xref:System.Text.UTF32Encoding.GetBytes%2A> метод не добавить метки порядка БАЙТОВ в последовательность закодированных байтов; BOM в начале соответствующие байтового потока является разработчик.  
  
   
  
## Examples  
 Следующие код пример извлекает и отображает порядок байтов пометить для разных <xref:System.Text.UTF32Encoding> экземпляров.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 В следующем примере создается два <xref:System.Text.UTF32Encoding> объектов, в первом из которых не поддерживает Спецификации, а второй — какие не. Затем он вызывает <xref:System.Text.UTF32Encoding.GetPreamble%2A> метод для записи BOM в файл перед записью строка в кодировке UTF-32. Как показывают выходные данные примера, файла, содержащего байты из второй кодировщика имеет четыре большее число байтов, первый.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/getpreamble1.vb#2)]  
  
 Вы также можете сравнить файлы с помощью `fc` команду в окне консоли, или можно проверить файлы в текстовом редакторе, который включает режим шестнадцатеричное представление. Обратите внимание, что когда файл открыт в редакторе, который поддерживает UTF-32, Спецификации не отображается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>Декодирует диапазон байтов из массива байтов в строку.</summary>
        <returns>Строка, содержащая результаты декодирования заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Если диапазон байтов для декодирования включает отметку порядка байтов (BOM), а массив байтов был возвращен методом виду не Спецификации типа, символ U + FFFE включается в массиве символов, возвращаемый этим методом. Его можно удалить путем вызова <xref:System.String.TrimStart%2A?displayProperty=nameWithType> метод.  
  
 Данные для преобразования, например чтение данных из потока, могут быть доступны только в виде последовательных блоков. В этом случае или если объем данных слишком велико, что необходимо разделить на более мелкие блоки, приложение должно использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.UTF32Encoding.GetDecoder%2A> метода или <xref:System.Text.UTF32Encoding.GetEncoder%2A> метода, соответственно.  
  
   
  
## Examples  
 Следующий пример кодирует строку в два массива массивов байтов, в прямом порядке и в обратном порядке байтов. Затем он декодирует байты обратно в строку.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/getstring.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString.vb#1)]  
  
 В следующем примере массив инициализируется путем вызова <xref:System.Text.UTF32Encoding.GetByteCount%2A> метод, чтобы определить точно количество байтов перед зашифрованную строку, а затем добавив размер отметку порядка байтов (BOM). Затем в примере вызывается <xref:System.Text.UTF32Encoding.GetPreamble%2A> для сохранения Спецификации массив до вызова метода <xref:System.Text.UTF32Encoding.GetBytes%2A> метод для хранения закодированных байтов в массив. Затем в примере вызывается <xref:System.Text.UTF32Encoding.GetString%2A> метод Декодируемая строка.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/GetString1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString1.vb#2)]  
  
 Обратите внимание, что в этом случае декодированную строку отличается от исходной строки, так как он начинается с метки порядка байтов 32-разрядных U + FFFE U + 0000. Это означает, что две строки будут неравны и, если строка является выходные данные, Спецификации отображается как замещающий символ «?».  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и параметр <paramref name="bytes" /> содержит недопустимую последовательность байтов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md)).  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>