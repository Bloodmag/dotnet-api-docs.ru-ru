<Type Name="UnicodeEncoding" FullName="System.Text.UnicodeEncoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="37bb8ffd133cbb1ddd3c3fdd2f593086d39584aa" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531568" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UnicodeEncoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnicodeEncoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UnicodeEncoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UnicodeEncoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnicodeEncoding : System::Text::Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет кодировку символов Юникода в формате UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодирование - это процесс преобразования набора символов Юникода в последовательность байтов. Декодирование представляет собой процесс преобразования последовательности закодированных байтов в набор символов Юникода.  
  
 [Стандарт Юникод](http://go.microsoft.com/fwlink/?linkid=37123) назначает каждому символу в каждом поддерживаемом символьном кодовая точка (номер). Формат преобразования Юникода (UTF) способ кодирования кодовой точки. [Стандарт Юникод](http://go.microsoft.com/fwlink/?linkid=37123) использует следующие форматы UTF:  
  
-   UTF-8, который представляет каждую кодовую точку в виде последовательности от одного до четырех байтов.  
  
-   UTF-16, который представляет каждую кодовую точку в виде последовательности из одной или двух 16-битовых целых чисел.  
  
-   UTF-32, который представляет каждую кодовую точку как 32-разрядное целое число.  
  
 Дополнительные сведения о UTF и других кодировках, поддерживаемых <xref:System.Text>, в разделе [кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UnicodeEncoding> Класс представляет кодировку UTF-16. Кодировщик может использовать либо обратный порядок байтов (самый старший байт первый) или в прямом порядке байтов (младший байт первый). Например прописная латинская буква (кодовая точка U + 0041) сериализуется как выглядит следующим образом (в шестнадцатеричном формате).  
  
-   Обратный порядок байтов: 00 00 00 41  
  
-   Прямом порядке байтов: 41 00 00 00  
  
 Может оказаться более эффективным, для хранения символов Юникода с использованием собственного порядка байтов с конкретной платформой. Например лучше использовать прямом порядке байтов на платформах с прямым порядком, таких как компьютеры Intel. <xref:System.Text.UnicodeEncoding> Класс соответствует кодовых страниц Windows 1200 (прямом порядке байтов) и 1201 (обратный порядок байтов). «Порядок байтов» конкретной архитектуры можно определить, вызвав <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> метод.  
  
 При необходимости <xref:System.Text.UnicodeEncoding> объект предоставляет метку порядка байтов (BOM), который является массивом байтов, которые может иметь префикс в последовательность байтов, полученных в результате кодирования. Если преамбула содержит метку порядка байтов (BOM), декодер получает возможность определить порядок следования байтов и формат преобразования или UTF.  
  
 Если <xref:System.Text.UnicodeEncoding> экземпляр настроен для поддержки Спецификации, его можно получить, вызвав <xref:System.Text.UnicodeEncoding.GetPreamble%2A> метода; в противном случае метод возвращает пустой массив. Обратите внимание, что даже если <xref:System.Text.UnicodeEncoding> настроен для поддержки Спецификации объект, необходимо включить BOM в начале потока закодированных байтов в виде соответствующих; методы кодирования <xref:System.Text.UnicodeEncoding> класса не делать это автоматически.  
  
 Чтобы включить обнаружение ошибок и защищенности экземпляра класса, следует создать экземпляр <xref:System.Text.UnicodeEncoding> путем вызова метода <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> конструктор и параметр его `throwOnInvalidBytes` аргумент `true`. Обнаружения ошибок, вызывает метод, который обнаруживает недопустимую последовательность символов или байтов <xref:System.ArgumentException>. Без обнаружение ошибок исключение не создается и Недопустимая последовательность обычно игнорируется.  
  
 Можно создать экземпляр <xref:System.Text.UnicodeEncoding> объекта несколькими способами, в зависимости от того, требуется ли он для предоставления метку порядка байтов (BOM), нужно ли кодировку с прямым или обратным порядком байтов и того, требуется ли включить функцию обнаружения ошибок. В следующей таблице перечислены <xref:System.Text.UnicodeEncoding> конструкторы и <xref:System.Text.Encoding> свойства, которые возвращают <xref:System.Text.UnicodeEncoding> объекта.  
  
|Член|Порядок байтов|СПЕЦИФИКАЦИИ|Обнаружение ошибок|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.BigEndianUnicode%2A>|Обратный порядок байтов|Да|Нет (стратегия замены)|  
|<xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType>|Обратный порядок байтов|Да|Нет (стратегия замены)|  
|<xref:System.Text.UnicodeEncoding.%23ctor?displayProperty=nameWithType>|Обратный порядок байтов|Да|Нет (стратегия замены)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29>|Возможность настройки|Возможность настройки|Нет (стратегия замены)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Возможность настройки|Возможность настройки|Возможность настройки|  
  
 <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Метод определяет, сколько байт привести кодировании набора символов Юникода и <xref:System.Text.UnicodeEncoding.GetBytes%2A> метод выполняет фактической кодировкой.  
  
 Аналогичным образом <xref:System.Text.UnicodeEncoding.GetCharCount%2A> метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.UnicodeEncoding.GetChars%2A> и <xref:System.Text.UnicodeEncoding.GetString%2A> методы выполняют фактическое декодирование.  
  
 Для кодировщика или декодера, который может сохранить сведения о состоянии при кодирования или декодирования данных, занимающих несколько блоков (например, строка 1 миллиона символов, закодированные в сегменты 100 000 символов), используйте <xref:System.Text.UnicodeEncoding.GetEncoder%2A> и <xref:System.Text.UnicodeEncoding.GetDecoder%2A> свойства, соответственно.  
  
   
  
## Examples  
 Следующий пример демонстрирует кодирования строки символов Юникода в массив байтов с помощью <xref:System.Text.UnicodeEncoding> объекта. Массив байтов декодируется в строку, чтобы показать, что без потери данных.  
  
 [!code-cpp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/snippet.vb#1)]  
  
 В следующем примере та же строка на предыдущий, за исключением того, он записывает закодированных байтов в файл и добавляет в поток байтов с отметкой порядка байтов (BOM). Затем он считывает из файла двумя различными способами: как текстовый файл с помощью <xref:System.IO.StreamReader> объекту и как двоичный файл. Как и следовало ожидать в случае ни Спецификации включается в вновь чтения строки.  
  
 [!code-csharp[System.Text.UnicodeEncoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF32Encoding" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.UTF7Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.UnicodeEncoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.UnicodeEncoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает экземпляр, который используется в прямом порядке байтов, предоставляет метку порядка байтов Юникода и не выдает исключение при обнаружении недопустимой кодировки.  
  
> [!NOTE]
>  По соображениям безопасности следует включить обнаружение ошибок путем вызова <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> конструктор и присвоения его `throwOnInvalidBytes` аргумент `true`.  
  
   
  
## Examples  
 Ниже приведен пример, как создать новый <xref:System.Text.UnicodeEncoding> экземпляра и отображаемое имя кодировки.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          Значение <see langword="true" /> соответствует использованию обратного порядка байтов (самый старший байт располагается на первом месте); значение <see langword="false" /> соответствует использованию прямого порядка байтов (на первом месте находится самый младший байт).</param>
        <param name="byteOrderMark">
          Значение <see langword="true" /> указывает, что метод <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> возвращает метку порядка байтов Юникода; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.UnicodeEncoding" />. Параметры указывают, следует ли использовать обратный порядок байтов и возвращает ли метод <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> метку порядка байтов Юникода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает экземпляр, который не выдает исключение при обнаружении недопустимой кодировки.  
  
> [!NOTE]
>  По соображениям безопасности следует включить обнаружение ошибок путем вызова <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> конструктор и присвоения его `throwOnInvalidBytes` аргумент `true`.  
  
 `byteOrderMark` Параметр управляет работой <xref:System.Text.UnicodeEncoding.GetPreamble%2A> метод. Если `true`, метод возвращает массив байтов, содержащий отметки порядка байтов (BOM) Юникода в формате UTF-16.  Если `false`, он возвращает массив байтов нулевой длины. Однако задание `byteOrderMark` для `true` не приводит к <xref:System.Text.UnicodeEncoding.GetBytes%2A> метод в качестве префикса BOM в начале массива байтов, ни его причиной <xref:System.Text.UnicodeEncoding.GetByteCount%2A> метод, чтобы включить число байтов в Спецификации в счетчик байтов.  
  
   
  
## Examples  
 Ниже приведен пример, как создать новый <xref:System.Text.UnicodeEncoding> экземпляра, определяя, нужно ли поддерживать сортировку с прямым порядком следования байтов или больших порядок байтов и Юникод метку порядка байтов.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          Значение <see langword="true" /> соответствует использованию обратного порядка байтов (самый старший байт располагается на первом месте); значение <see langword="false" /> соответствует использованию прямого порядка байтов (на первом месте находится самый младший байт).</param>
        <param name="byteOrderMark">
          Значение <see langword="true" /> указывает, что метод <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> возвращает метку порядка байтов Юникода; в противном случае — значение <see langword="false" />.</param>
        <param name="throwOnInvalidBytes">
          <see langword="true" />, чтобы указать, что следует выдавать исключение при обнаружении недопустимой кодировки; в противном случае — <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.UnicodeEncoding" />. Параметры указывают, следует ли использовать обратный порядок байтов, должна ли предоставляться метка порядка байтов Юникода и следует ли создавать исключение при обнаружении недопустимой кодировки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `byteOrderMark` Параметр управляет работой <xref:System.Text.UnicodeEncoding.GetPreamble%2A> метод. Если `true`, метод возвращает массив байтов, содержащий отметки порядка байтов (BOM) Юникода в формате UTF-16.  Если `false`, он возвращает массив байтов нулевой длины. Однако задание `byteOrderMark` для `true` не приводит к <xref:System.Text.UnicodeEncoding.GetBytes%2A> метод в качестве префикса BOM в начале массива байтов, ни его причиной <xref:System.Text.UnicodeEncoding.GetByteCount%2A> метод, чтобы включить число байтов в Спецификации в счетчик байтов.  
  
 Если `throwOnInvalidBytes` параметр `true`, вызывает метод, обнаруживающий недопустимые последовательности байтов <xref:System.ArgumentException?displayProperty=nameWithType>. В противном случае этот метод создает исключение, и Недопустимая последовательность игнорируется.  
  
> [!NOTE]
>  По соображениям безопасности в приложениях рекомендуется использовать этот конструктор для создания экземпляра <xref:System.Text.UnicodeEncoding> класса и включить обнаружение ошибок, задав `throwOnInvalidBytes` для `true`.  
  
   
  
## Examples  
 В следующем примере показано поведение <xref:System.Text.UnicodeEncoding>, как с обнаружение ошибок включено, так и без.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/VB/errordetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="CharSize">
      <MemberSignature Language="C#" Value="public const int CharSize = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 CharSize = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Text.UnicodeEncoding.CharSize" />
      <MemberSignature Language="VB.NET" Value="Public Const CharSize As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int CharSize = 2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Представляет размер символа Юникода в байтах. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значением этого поля является константой 32-разрядное знаковое со значением 2.  
  
   
  
## Examples  
 Следующий пример демонстрирует способы возврата значение <xref:System.Text.UnicodeEncoding.CharSize> и отобразить ее.  
  
 [!code-cpp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CPP/charsize.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CS/charsize.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/VB/charsize.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект, который требуется сравнить с текущим объектом.</param>
        <summary>Определяет, равен ли заданный объект <see cref="T:System.Object" /> текущему объекту <see cref="T:System.Text.UnicodeEncoding" />.</summary>
        <returns>
          Значение <see langword="true" />, если <paramref name="value" /> является экземпляром класса <see cref="T:System.Text.UnicodeEncoding" /> и равен текущему объекту; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Два <xref:System.Text.UnicodeEncoding> объекты считаются равными, если выполняются все следующие условия:  
  
-   Оба объекта используют одинаковый порядок следования байтов (с прямым или обратным порядком).  
  
-   Оба объекта предоставляться метка порядка байтов или оба — нет.  
  
-   Оба объекта используют одинаковые резерва кодировщика.  
  
-   Оба объекта используют же резервный декодера.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Text.UnicodeEncoding.Equals%2A> тестируемого метода ли текущий <xref:System.Text.UnicodeEncoding> объект равен другой <xref:System.Text.UnicodeEncoding> объекта. Пять <xref:System.Text.UnicodeEncoding> объекты создаются и сравнение, и отображаются результаты сравнения.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Подсчитывает количество байтов, полученных при кодировании набора символов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая кодируемый набор символов.</param>
        <summary>Вычисляет количество байтов, полученных при кодировании символов в указанной строке.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UnicodeEncoding.GetBytes%2A> для хранения полученные байты, вызов <xref:System.Text.UnicodeEncoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> метод. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
> [!NOTE]
>  Чтобы обеспечить правильное декодирование закодированных байтов когда они сохраняются в виде файла или потока, можно задать префикс закодированных байтов преамбулу в виде потока. Вставка преамбулу в начале потока байтов (например, в начале последовательности байтов для записи в файл) ответственность разработчика и число байтов в преамбула не отражаются в значение, возвращаемое <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> метод.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> и <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> методы для вычисления фактического и максимального числа байтов, необходимых для кодирования строки. Он также отображает фактическое число байтов, необходимое для хранения потока данных с отметкой порядка байтов.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="s" /> содержит недопустимую последовательность символов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Указатель на первый кодируемый символ.</param>
        <param name="count">Число кодируемых символов.</param>
        <summary>Вычисляет число байтов, полученных при кодировании набора символов начиная с заданного указателя символа.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления массиве точный размер, <xref:System.Text.UnicodeEncoding.GetBytes%2A> требует, чтобы сохранить полученные байты, вызовите <xref:System.Text.UnicodeEncoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> метод. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
> [!NOTE]
>  Чтобы обеспечить правильное декодирование закодированных байтов когда они сохраняются в виде файла или потока, можно задать префикс закодированных байтов преамбулу в виде потока. Вставка преамбулу в начале потока байтов (например, в начале последовательности байтов для записи в файл) ответственность разработчика и число байтов в преамбула не отражаются в значение, возвращаемое <xref:System.Text.UTF8Encoding.GetByteCount%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.ArgumentException">Включена функция обнаружения ошибок, <paramref name="chars" /> содержит недопустимую последовательность символов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий набор кодируемых символов.</param>
        <param name="index">Индекс первого кодируемого символа.</param>
        <param name="count">Число кодируемых символов.</param>
        <summary>Вычисляет число байтов, полученных при кодировании набора символов из указанного массива символов.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UnicodeEncoding.GetBytes%2A> для хранения полученные байты, приложение использует <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> метод. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок включено, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Чтобы обеспечить правильное декодирование закодированных байтов когда они сохраняются в виде файла или потока, можно задать префикс закодированных байтов преамбулу в виде потока. Вставка преамбулу в начале потока байтов (например, в начале последовательности байтов для записи в файл) ответственность разработчика и число байтов в преамбула не отражаются в значение, возвращаемое <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> метод.  
  
   
  
## Examples  
 В следующем примере заполняется массив с латиница прописные и строчные буквы и вызовы <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> метод для определения числа байтов, необходимое для кодирования латинские символы нижнего регистра. Затем отображается эти сведения, а также общее число байтов, которые требуются при добавлении метку порядка следования байтов. Он сравнивает это значение со значения, возвращенного <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> метода, который указывает максимальное число байтов, необходимых для кодирования латинские символы нижнего регистра. В следующем примере заполняется массив с сочетания символов греческий и кириллица и вызывает <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> метод для определения числа байтов, необходимое для кодирования символов кириллицы. Затем отображается эти сведения, а также общее число байтов, которые требуются при добавлении метку порядка следования байтов. Он сравнивает это значение со значения, возвращенного <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> метода, который указывает максимальное число байтов, необходимых для кодирования символов кириллицы.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="chars" />.  
  
 - или -  
  
 Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="chars" /> содержит недопустимую последовательность символов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Кодирует набор символов в последовательность байтов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Указатель на первый кодируемый символ.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Указатель на положение, с которого начинается запись результирующей последовательности байтов.</param>
        <param name="byteCount">Максимальное число байтов для записи.</param>
        <summary>Кодирует набор символов, начало которого задается указателем символа, в последовательность байтов, которые сохраняются начиная с заданного указателя байта.</summary>
        <returns>Фактическое число байтов, записанных в местоположение, которое задано параметром <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления массиве точный размер, <xref:System.Text.UnicodeEncoding.GetBytes%2A> требует, чтобы сохранить полученные байты, вызовите <xref:System.Text.UnicodeEncoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> метод. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Данные для преобразования, например чтение данных из потока, могут быть доступны только в виде последовательных блоков. В этом случае или если объем данных слишком велико, что необходимо разделить на более мелкие блоки, приложение должно использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> объект, предоставляемый <xref:System.Text.UnicodeEncoding.GetDecoder%2A> или <xref:System.Text.UnicodeEncoding.GetEncoder%2A> метода, соответственно.  
  
> [!NOTE]
>  Чтобы обеспечить правильное декодирование закодированных байтов когда они сохраняются в виде файла или потока, можно задать префикс закодированных байтов преамбулу в виде потока. Вставка преамбулу в начале байтового потока (например, в начале последовательности байтов для записи в файл) ответственность разработчика. <xref:System.Text.UnicodeEncoding.GetBytes%2A> Метод не добавить заголовок в начало последовательность закодированных байтов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).  
  
 - или -  
  
 <paramref name="bytes" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="charCount" /> или <paramref name="byteCount" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="chars" /> содержит недопустимую последовательность символов.  
  
 - или -  
  
 <paramref name="byteCount" /> меньше результирующего числа байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий набор кодируемых символов.</param>
        <param name="charIndex">Индекс первого кодируемого символа.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Массив байтов, в который будет помещена результирующая последовательность байтов.</param>
        <param name="byteIndex">Индекс, с которого начинается запись результирующей последовательности байтов.</param>
        <summary>Кодирует набор символов из заданного массива символов в указанный массив байтов.</summary>
        <returns>Фактическое число байтов, записанных в <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UnicodeEncoding.GetBytes%2A> для хранения полученные байты, вызов <xref:System.Text.UnicodeEncoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> метод. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Данные для преобразования, например чтение данных из потока, могут быть доступны только в виде последовательных блоков. В этом случае или если объем данных слишком велико, что необходимо разделить на более мелкие блоки, приложение должно использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.UnicodeEncoding.GetDecoder%2A> метода или <xref:System.Text.UnicodeEncoding.GetEncoder%2A> метода, соответственно.  
  
> [!NOTE]
>  Чтобы обеспечить правильное декодирование закодированных байтов когда они сохраняются в виде файла или потока, можно задать префикс закодированных байтов преамбулу в виде потока. Вставка преамбулу в начале байтового потока (например, в начале последовательности байтов для записи в файл) ответственность разработчика. <xref:System.Text.UnicodeEncoding.GetBytes%2A> Метод не добавить заголовок в начало последовательность закодированных байтов.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Text.UnicodeEncoding.GetBytes%2A> метод для кодирования диапазона символов из <xref:System.String> и сохранение закодированных байтов в диапазоне элементов в массиве байтов.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).  
  
 - или -  
  
 <paramref name="bytes" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="charIndex" />, <paramref name="charCount" /> или <paramref name="byteIndex" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="charIndex" /> и <paramref name="charCount" /> не указывают допустимый диапазон в <paramref name="chars" />.  
  
 - или -  
  
 Значение параметра <paramref name="byteIndex" /> не является допустимым индексом в <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="chars" /> содержит недопустимую последовательность символов.  
  
 - или -  
  
 Недостаточно емкости <paramref name="bytes" /> от <paramref name="byteIndex" /> до конца массива для размещения полученных байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая набор символов для кодирования.</param>
        <param name="charIndex">Индекс первого кодируемого символа.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Массив байтов, в который будет помещена результирующая последовательность байтов.</param>
        <param name="byteIndex">Индекс, с которого начинается запись результирующей последовательности байтов.</param>
        <summary>Кодирует набор символов из заданного объекта <see cref="T:System.String" /> в указанный массив байтов.</summary>
        <returns>Фактическое число байтов, записанных в <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UnicodeEncoding.GetBytes%2A> для хранения полученные байты, вызов <xref:System.Text.UnicodeEncoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> метод. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Данные для преобразования, например чтение данных из потока, могут быть доступны только в виде последовательных блоков. В этом случае или если объем данных слишком велико, что необходимо разделить на более мелкие блоки, приложение должно использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.UnicodeEncoding.GetDecoder%2A> метода или <xref:System.Text.UnicodeEncoding.GetEncoder%2A> метода, соответственно.  
  
> [!NOTE]
>  Чтобы обеспечить правильное декодирование закодированных байтов когда они сохраняются в виде файла или потока, можно задать префикс закодированных байтов преамбулу в виде потока. Вставка преамбулу в начале байтового потока (например, в начале последовательности байтов для записи в файл) ответственность разработчика. <xref:System.Text.UnicodeEncoding.GetBytes%2A> Метод не добавить заголовок в начало последовательность закодированных байтов.  
  
   
  
## Examples  
 Ниже приведен пример, как кодировать диапазон элементов из массива знаков Юникода и сохранение закодированных байтов в диапазоне элементов в массиве байтов.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="s" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 <paramref name="bytes" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="charIndex" />, <paramref name="charCount" /> или <paramref name="byteIndex" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="charIndex" /> и <paramref name="charCount" /> не указывают допустимый диапазон в <paramref name="chars" />.  
  
 - или -  
  
 Значение параметра <paramref name="byteIndex" /> не является допустимым индексом в <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="s" /> содержит недопустимую последовательность символов.  
  
 - или -  
  
 Недостаточно емкости <paramref name="bytes" /> от <paramref name="byteIndex" /> до конца массива для размещения полученных байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вычисляет количество символов, полученных при декодировании последовательности байтов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на первый декодируемый байт.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>Вычисляет количество символов, полученных при декодировании последовательности байтов начиная с заданного указателя байта.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления массиве точный размер, <xref:System.Text.UnicodeEncoding.GetChars%2A> требуется для хранения полученных символов, используемых приложением <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Чтобы вычислить максимальный размер массива, приложение должно использовать <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и параметр <paramref name="bytes" /> содержит недопустимую последовательность байтов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>Вычисляет количество символов, полученных при декодировании последовательности байтов из заданного массива байтов.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UnicodeEncoding.GetChars%2A> для хранения полученных символов, приложение использует <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Чтобы вычислить максимальный размер массива, приложение должно использовать <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Text.UnicodeEncoding.GetCharCount%2A> метод для возврата числа символов, полученных при декодировании диапазон элементов в массив байтов с помощью <xref:System.Text.UnicodeEncoding>.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.  
  
 - или -  
  
 Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и параметр <paramref name="bytes" /> содержит недопустимую последовательность байтов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Декодирует последовательность байтов в набор символов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на первый декодируемый байт.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <param name="chars">Указатель на положение, с которого начинается запись результирующего набора символов.</param>
        <param name="charCount">Наибольшее количество символов для записи.</param>
        <summary>Декодирует последовательность байтов, начало которой задается указателем байта, в набор символов, которые сохраняются начиная с заданного указателя символа.</summary>
        <returns>Фактическое число символов, записанных в местоположение, которое задано параметром <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления массиве точный размер, <xref:System.Text.UnicodeEncoding.GetChars%2A> требуется для хранения полученных символов, используемых приложением <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Чтобы вычислить максимальный размер массива, приложение должно использовать <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Если массив байтов был возвращен методом виду не Спецификации типа диапазона байтов для декодирования включает отметку порядка байтов (BOM), символ U + FFFE включается в массив символов, возвращаемый этим методом. Его можно удалить путем вызова <xref:System.String.TrimStart%2A?displayProperty=nameWithType> метод.  
  
 Данные для преобразования, например чтение данных из потока, могут быть доступны только в виде последовательных блоков. В этом случае или если объем данных слишком велико, что необходимо разделить на более мелкие блоки, приложение должно использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> объект, предоставляемый <xref:System.Text.UnicodeEncoding.GetDecoder%2A> или <xref:System.Text.UnicodeEncoding.GetEncoder%2A> метода, соответственно.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).  
  
 - или -  
  
 <paramref name="chars" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="byteCount" /> или <paramref name="charCount" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и параметр <paramref name="bytes" /> содержит недопустимую последовательность байтов.  
  
 - или -  
  
 <paramref name="charCount" /> меньше результирующего числа символов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="byteIndex">Индекс первого декодируемого байта.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <param name="chars">Массив символов, в который будет помещен результирующий набор символов.</param>
        <param name="charIndex">Индекс, с которого начинается запись результирующего набора символов.</param>
        <summary>Декодирует последовательность байтов из заданного массива байтов в указанный массив символов.</summary>
        <returns>Фактическое число символов, записанных в <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UnicodeEncoding.GetChars%2A> для хранения полученных символов, приложение использует <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Чтобы вычислить максимальный размер массива, приложение должно использовать <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Если массив байтов был возвращен методом виду не Спецификации типа диапазона байтов для декодирования включает отметку порядка байтов (BOM), символ U + FFFE включается в массив символов, возвращаемый этим методом. Его можно удалить путем вызова <xref:System.String.TrimStart%2A?displayProperty=nameWithType> метод.  
  
 Данные для преобразования, например чтение данных из потока, могут быть доступны только в виде последовательных блоков. В этом случае или если объем данных слишком велико, что необходимо разделить на более мелкие блоки, приложение должно использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> , предоставляемые <xref:System.Text.UnicodeEncoding.GetDecoder%2A> метода или <xref:System.Text.UnicodeEncoding.GetEncoder%2A> метода, соответственно.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Text.UnicodeEncoding.GetChars%2A> метод декодировать диапазон элементов в массиве байтов и сохраняет результат в массив символов.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).  
  
 - или -  
  
 <paramref name="chars" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="byteIndex" />, <paramref name="byteCount" /> или <paramref name="charIndex" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="byteindex" /> и <paramref name="byteCount" /> не указывают допустимый диапазон в <paramref name="bytes" />.  
  
 - или -  
  
 Значение параметра <paramref name="charIndex" /> не является допустимым индексом в <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и параметр <paramref name="bytes" /> содержит недопустимую последовательность байтов.  
  
 - или -  
  
 Недостаточно емкости <paramref name="chars" /> от <paramref name="charIndex" /> до конца массива для размещения полученных символов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает средство декодирования, преобразующее последовательность байтов в кодировке UTF-16 в последовательность символов Юникода.</summary>
        <returns>Объект <see cref="T:System.Text.Decoder" />, преобразующий последовательность байтов в кодировке UTF-16 в последовательность символов Юникода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Метод преобразует последовательные блоки байтов в последовательные блоки символов в так же, как <xref:System.Text.UnicodeEncoding.GetChars%2A>. Однако <xref:System.Text.Decoder> хранит сведения о состоянии между вызовами, что позволяет ему правильно декодировать последовательности байтов, охватывающие блоки. <xref:System.Text.Decoder> Также сохраняет замыкающие байты в конце блоков данных и использует конечные байты при следующей операции декодирования. Таким образом <xref:System.Text.UnicodeEncoding.GetDecoder%2A> и <xref:System.Text.UnicodeEncoding.GetEncoder%2A> полезны для передачи по сети и операции с файлами, так как эти операции часто работают с блоками данных, а не полные данные потока.  
  
 Если обнаружение ошибок включено, то есть `throwOnInvalidBytes` имеет значение параметра конструктора `true`, также включена функция обнаружения ошибок в <xref:System.Text.Decoder> возвращаемый этим методом. Если включена функция обнаружения ошибок и обнаружена недопустимая последовательность, состояние декодера является неопределенным и обработка должна быть остановлена.  
  
   
  
## Examples  
 В следующем примере кодировщик и декодер для кодирования строки в массив байтов и затем декодирования байтов в массив символов.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает средство кодирования, преобразующее последовательность символов Юникода в последовательность байтов в кодировке UTF-16.</summary>
        <returns>Объект <see cref="T:System.Text.Encoder" />, преобразующий последовательность символов Юникода в последовательность байтов в кодировке UTF-16.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> Метод преобразует последовательные блоки символов в последовательные блоки байтов в так же, как <xref:System.Text.UnicodeEncoding.GetBytes%2A> метода этого класса. Тем не менее <xref:System.Text.Encoder> сохраняет сведения о состоянии между вызовами, что позволяет ему правильно кодировать последовательности символов, охватывающие блоки. <xref:System.Text.Encoder> Объект также сохраняет замыкающие символы в конце блоков данных и использует замыкающие символы при выполнении следующей операции кодирования. Например может оказаться, что блок данных с несоответствиями старшим символом-заместителем и сопоставления младший символ-заместитель может находиться в следующем блоке данных. Таким образом <xref:System.Text.UnicodeEncoding.GetDecoder%2A> и <xref:System.Text.UnicodeEncoding.GetEncoder%2A> полезны для передачи по сети и операции с файлами, так как эти операции часто работают с блоками данных, а не полные данные потока.  
  
 Если обнаружение ошибок включено, то есть `throwOnInvalidBytes` имеет значение параметра конструктора `true`, также включена функция обнаружения ошибок в <xref:System.Text.Encoder> объект, возвращаемый этим методом. Если включена функция обнаружения ошибок и обнаружена недопустимая последовательность, состояние кодировщика является неопределенным и обработка должна быть остановлена.  
  
   
  
## Examples  
 В следующем примере кодировщик и декодер для кодирования строки в массив байтов и затем декодирования байтов в массив символов.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код текущего экземпляра.</summary>
        <returns>Хэш-код для текущего объекта <see cref="T:System.Text.UnicodeEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Число кодируемых символов.</param>
        <summary>Вычисляет максимальное количество байтов, полученных при кодировании заданного числа символов.</summary>
        <returns>Максимальное количество байтов, полученных при кодировании заданного количества символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UnicodeEncoding.GetBytes%2A> для хранения полученные байты, приложение использует <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, приложение должно использовать <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Извлекает худший номер, включая Наихудший случай для выбранного в данный момент <xref:System.Text.EncoderFallback>. Если выбран резервный вариант с потенциально длинной строкой <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> может возвращать большие значения.  
  
 В большинстве случаев этот метод извлекает адекватные числа для коротких строк. Для больших строк необходимо выбирать между использованием очень больших буферов и отслеживанием ошибок в тех редких случаях, более рационального буфера превышено. Может потребоваться использовать другой подход с использованием <xref:System.Text.UnicodeEncoding.GetByteCount%2A> или <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> не связан с <xref:System.Text.UnicodeEncoding.GetChars%2A>. Если приложению требуется подобная функция, для использования с <xref:System.Text.UnicodeEncoding.GetChars%2A>, следует использовать <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` не обязательно совпадает со значением `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> метода для возвращения максимальное число байтов, необходимых для кодирования указанное количество символов.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="charCount" /> меньше нуля.  
  
 - или -  
  
 Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Число байтов для декодирования.</param>
        <summary>Вычисляет максимальное количество символов, полученных при декодировании заданного числа байтов.</summary>
        <returns>Максимальное количество символов, полученных при декодировании заданного количества байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить размер точное массива, необходимого <xref:System.Text.UnicodeEncoding.GetChars%2A> для хранения полученных символов, приложение использует <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Чтобы вычислить максимальный размер массива, приложение должно использовать <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Метод обычно выделяет меньше памяти, пока <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Извлекает худший номер, включая Наихудший случай для выбранного в данный момент <xref:System.Text.DecoderFallback>. Если выбран резервный вариант с потенциально длинной строкой <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> извлекает большие значения.  
  
 В большинстве случаев этот метод извлекает адекватные числа для коротких строк. Для больших строк необходимо выбирать между использованием очень больших буферов и отслеживанием ошибок в тех редких случаях, более рационального буфера превышено. Может потребоваться использовать другой подход с использованием <xref:System.Text.UnicodeEncoding.GetCharCount%2A> или <xref:System.Text.Decoder.Convert%2A>.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> не связан с <xref:System.Text.UnicodeEncoding.GetBytes%2A>. Если приложению требуется подобная функция, для использования с <xref:System.Text.UnicodeEncoding.GetBytes%2A>, следует использовать <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` не обязательно совпадает со значением `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> метода для возвращения максимальное количество символов, полученных при декодировании заданного числа байтов.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="byteCount" /> меньше нуля.  
  
 - или -  
  
 Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает метку порядка байтов Юникода, закодированную в формате UTF-16, если конструктор данного экземпляра запрашивает метку порядка байтов.</summary>
        <returns>Массив байтов, содержащий метку порядка байтов Юникода, если объект <see cref="T:System.Text.UnicodeEncoding" /> настроен для его предоставления. В противном случае этот метод возвращает массив байтов нулевой длины.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding> Объект может предоставлять преамбулу, представляющую собой массив байтов, который может иметь префикс в последовательность байтов, полученных в результате кодирования. Предшествующим последовательность закодированных байтов с отметкой порядка байтов (кодовая точка U + FEFF) декодер может определить порядок байтов и формат преобразования или UTF. Метка порядка байтов (BOM) Юникода сериализуется следующим образом (в шестнадцатеричном формате):  
  
-   Обратный порядок байтов: FE FF  
  
-   Прямом порядке байтов: FF FE  
  
 Можно создать экземпляр <xref:System.Text.UnicodeEncoding> которого <xref:System.Text.UnicodeEncoding.GetPreamble%2A> метод возвращает допустимый Спецификации одним из следующих способов:  
  
-   Путем получения <xref:System.Text.UnicodeEncoding> объект, возвращаемый <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> или <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType> свойства.  
  
-   Путем вызова без параметров <xref:System.Text.UnicodeEncoding.%23ctor> конструктора для создания <xref:System.Text.UnicodeEncoding> объекта.  
  
-   Указав `true` в качестве значения `byteOrderMark` аргумент <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> или <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> конструкторы.  
  
 Рекомендуется использовать Спецификации, поскольку она обеспечивает почти точную идентификацию кодировки для файлов, которые в противном случае теряют ссылку для их кодировки, например без тегов или неправильно с тегами веб-данных или случайное текстовые файлы, сохраненные, когда организация не имеет расставленными. Часто возникающих пользователя избавить согласованных и правильных тегов в данных.  
  
 Для стандартов, предоставляющих тип кодировки метка BOM отчасти избыточный. Тем не менее он может использоваться, чтобы помочь серверу отправлять правильный заголовок кодировки. Кроме того он может использоваться как переход на резервный ресурс в случае, если кодировка, в противном случае не потеряны.  
  
 Есть некоторые недостатки использования метки порядка БАЙТОВ. Например сложно выбрать способы ограничения полей базы данных, используйте метки порядка БАЙТОВ. Объединение файлов может вызвать проблемы также, например, когда файлы сливаются таким образом, что необязательный символ может оказаться в центре данных. Несмотря на некоторые недостатки Однако использование спецификации настоятельно рекомендуется.  
  
> [!CAUTION]
>  Чтобы обеспечить правильное декодирование закодированных байтов, необходимо использовать перед начале потока закодированных байтов с начальной части. Обратите внимание, что <xref:System.Text.UnicodeEncoding.GetBytes%2A> метод не добавить метки порядка БАЙТОВ в последовательность закодированных байтов; BOM в начале соответствующие байтового потока является разработчик.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Text.UnicodeEncoding.GetPreamble%2A> метод для извлечения отметки порядка байтов Юникод с обратным порядком байтов или прямом порядке байтов для экземпляра <xref:System.Text.UnicodeEncoding>.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 В следующем примере создается два <xref:System.Text.UnicodeEncoding> объектов, в первом из которых не поддерживает Спецификации, а вторая какие не. Затем он вызывает <xref:System.Text.UnicodeEncoding.GetPreamble%2A> метод для записи BOM в файл перед записью строка в кодировке Юникод. Как показывают выходные данные из примера консоли, файла, содержащего байты из второй кодировщика имеет три большее число байтов, чем первый.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/cs/GetPreamble1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/vb/GetPreamble1.vb#1)]  
  
 Вы также можете сравнить файлы с помощью `fc` команду в окне консоли, или можно проверить файлы в текстовом редакторе, который включает режим шестнадцатеричное представление. Обратите внимание, что при открытии файла в редакторе, который поддерживает кодировку UTF-16 BOM не отображается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>Декодирует диапазон байтов из массива байтов в строку.</summary>
        <returns>Объект <see cref="T:System.String" />, содержащий результаты декодирования заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обнаружение ошибок, этот метод выдает исключение приводит недопустимую последовательность <xref:System.ArgumentException>. Без обнаружения ошибки недопустимые последовательности игнорируются, и исключение не возникает.  
  
 Если массив байтов был возвращен методом виду не Спецификации типа диапазона байтов для декодирования включает отметку порядка байтов (BOM), символ U + FFFE включается в массив символов, возвращаемый этим методом. Его можно удалить путем вызова <xref:System.String.TrimStart%2A?displayProperty=nameWithType> метод.  
  
 Данные для преобразования, например чтение данных из потока, могут быть доступны только в виде последовательных блоков. В этом случае или если объем данных слишком велико, что необходимо разделить на более мелкие блоки, приложение должно использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> объект, предоставляемый <xref:System.Text.UnicodeEncoding.GetDecoder%2A> или <xref:System.Text.UnicodeEncoding.GetEncoder%2A> метода, соответственно.  
  
   
  
## Examples  
 В следующем примере массив инициализируется путем вызова <xref:System.Text.UnicodeEncoding.GetByteCount%2A> метод, чтобы определить точно количество байтов перед зашифрованную строку, а затем добавив размер отметку порядка байтов (BOM). Затем в примере вызывается <xref:System.Text.UnicodeEncoding.GetPreamble%2A> для сохранения Спецификации массив до вызова метода <xref:System.Text.Encoding.GetBytes%2A> метод для хранения закодированных байтов в массив. Затем в примере вызывается <xref:System.Text.UnicodeEncoding.GetString%2A> метод Декодируемая строка.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Обратите внимание, что в этом случае декодированную строку отличается от исходной строки, так как он начинается с метки порядка байтов 16-разрядное U + FFFD. Это означает, что две строки будут неравны и, если строка является выходные данные, Спецификации отображается как замещающий символ «?». Чтобы удалить BOM в начале строки, можно вызвать <xref:System.String.TrimStart%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> имеет значение <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
 - или -  
  
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и параметр <paramref name="bytes" /> содержит недопустимую последовательность байтов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошла отработка отказа (см. полное объяснение в статье [Кодировка символов в .NET Framework](~/docs/standard/base-types/character-encoding.md))  
  
 - и -  
  
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>