<Type Name="ParallelLoopState" FullName="System.Threading.Tasks.ParallelLoopState">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3e4244160069333f5d930b81c7b54173c2ad6d6a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530218" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ParallelLoopState" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ParallelLoopState extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.ParallelLoopState" />
  <TypeSignature Language="VB.NET" Value="Public Class ParallelLoopState" />
  <TypeSignature Language="C++ CLI" Value="public ref class ParallelLoopState" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("ShouldExitCurrentIteration = {ShouldExitCurrentIteration}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Позволяет итерациям параллельных циклов взаимодействовать с другими итерациями. Экземпляр этого класса предоставляется каждому циклу классом <see cref="T:System.Threading.Tasks.Parallel" />; невозможно создавать экземпляры в коде.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что не удается создать экземпляр этого класса. Автоматически создается компилятором как аргумент в вызове <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> или <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> метод. Иллюстрация приведена в примере.  
  
 Конструкции, такие как `for` и `foreach` (в C#) и `For` и `For Each` (в Visual Basic) выполнять последовательно от наименьшего индекса и заканчивая самым верхним или из первого объекта в наборе на последнюю. Напротив <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> и <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> методов — нет. Поскольку отдельные итерации цикла выполняются параллельно, оно может начинается и заканчивается в любом порядке. <xref:System.Threading.Tasks.ParallelLoopState> Класс позволяет отдельных итерациям параллельных циклов взаимодействовать друг с другом. <xref:System.Threading.Tasks.ParallelLoopState> Класс позволяет:  
  
-   Выйти из текущей итерации и предотвратить любые дополнительных итераций запуститься путем вызова <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> метод. Это не влияет на итераций, которые уже начали выполнение.  
  
-   Предотвратить выполнение путем вызова любого итераций с индексом, больше, чем текущий индекс <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> метод. Это не влияет на итераций, которые уже начали выполнение.  
  
-   Определить, произошло ли исключение в какой-либо итерации цикла, получая значение <xref:System.Threading.Tasks.ParallelLoopState.IsExceptional%2A> свойства.  
  
-   Определить, вызвал ли какая-либо итерация цикла <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> метод, получая значение <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> свойства. Это свойство можно использовать для возврата из итераций цикла, которая запущена перед вызовом <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> метода, но по-прежнему выполняются.  
  
-   Определить, вызвал ли какая-либо итерация цикла <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> или <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> метода или создала исключение, получая значение <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> свойства.  
  
-   Выход из продолжительной итерации, индекс которого больше, чем индекс итерации, в которой был вызван метод Break, получая значение <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> свойства.  
  
   
  
## Examples  
 В следующем примере выполняется до 100 итераций цикла в параллельном режиме. Приостанавливает работу каждой итерации для произвольного интервал от 1 до 1000 миллисекунд. Случайное значение определяет, на какой итерации цикла <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> вызывается метод. Как видно в результатах показано в примере, нет итераций, индекс которого больше, чем <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> начальное значение свойства после вызова <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> метод.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Поскольку итерации цикла вряд ли по-прежнему выполняться, когда <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> вызывается метод, вызывает каждой итерации <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> свойство для проверки, вызвал ли другую итерацию <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> метод. Если свойство имеет значение `true`, итерации проверяет значение <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> свойства и, если больше, чем значение индекса текущей итерации, возвращается немедленно.  
  
 ]]></format>
    </remarks>
    <threadsafe>Объект <see cref="T:System.Threading.Tasks.ParallelLoopState" /> экземпляр предназначен для использования только в теле цикла, к которому был предоставлен экземпляр.  Не является безопасным для использования в предоставленный <see cref="T:System.Threading.Tasks.ParallelLoopState" /> экземпляра после связанного цикла заканчивается, и не безопасна явно передавать его другим потокам и предоставлять этим потокам доступ к нему в любое время.  Другой <see cref="T:System.Threading.Tasks.ParallelLoopState" /> экземпляр будет предоставляться для каждого потока, участвующие в цикле.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public void Break ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Break() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Break" />
      <MemberSignature Language="VB.NET" Value="Public Sub Break ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Break();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сообщает, что цикл <see cref="T:System.Threading.Tasks.Parallel" /> должен прекратить выполнение итераций после текущей в первый удобный для системы момент.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> Указывает, выполнение не итераций после текущей итерации. Фактически он отменяет любые дополнительные итерации цикла. Тем не менее любой итераций, которые уже начали выполнение не останавливается. Например если <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> вызывается из 100-й итерации параллельного цикла итерации от 0 до 1 000, все итерации меньше 100 следует по-прежнему выполняться, но итераций от 101 до 1000, еще не запущена, не выполнять.  
  
 Для длительных итераций, которые уже могут выполняться <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> задает <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> индекс текущей итерации, если текущий индекс меньше, чем текущее значение свойства <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>. Чтобы остановить, индекс которого больше, чем первую итерацию разрыв конкурирующих выполнения итераций, делать следующее:  
  
1.  Проверьте ли <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> свойство `true`.  
  
2.  Выйти из итерации, если его индекс больше <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> значение свойства.  
  
 Иллюстрация приведена в примере.  
  
 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> обычно принят на работу на основе поиска алгоритмы, где порядок, имеющиеся в источнике данных.  
  
   
  
## Examples  
 В следующем примере выполняется до 100 итераций цикла в параллельном режиме. Приостанавливает работу каждой итерации для произвольного интервал от 1 до 1000 миллисекунд. Случайное значение определяет, на какой итерации цикла <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> вызывается метод. Как видно в результатах показано в примере, нет итераций, индекс которого больше, чем <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> начальное значение свойства после вызова <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> метод.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Поскольку итерации цикла вряд ли по-прежнему выполняться, когда <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> вызывается метод, вызывает каждой итерации <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> свойство для проверки, вызвал ли другую итерацию <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> метод. Если свойство имеет значение `true`, итерации проверяет значение <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> свойства и, если больше, чем значение индекса текущей итерации, возвращается немедленно.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Был ранее вызван метод <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />. <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> и <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> не могут использоваться в сочетании итерациями одного и того же цикла.</exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      </Docs>
    </Member>
    <Member MemberName="IsExceptional">
      <MemberSignature Language="C#" Value="public bool IsExceptional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExceptional" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsExceptional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExceptional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExceptional { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, возникло ли в какой-либо итерации цикла исключение, не обработанное данной итерацией.</summary>
        <value>
          Значение <see langword="true" />, если было вызвано необработанное исключение; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStopped">
      <MemberSignature Language="C#" Value="public bool IsStopped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStopped" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStopped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStopped { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, вызывала ли какая-либо итерация цикла метод <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />.</summary>
        <value>
          Значение <see langword="true" />, если какая-либо итерация остановила цикл, вызвав метод <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для длительных итерации цикла, можно извлечь значение <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> свойства, чтобы определить ли все итерации цикла, начала выполнения перед вызовом <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> метод по-прежнему выполняются. Затем можно использовать значение <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> свойства, чтобы определить ли они немедленный возврат, или выполнение в обычном режиме.  
  
   
  
## Examples  
 В следующем примере выполняется до 10 000 итераций цикла в параллельном режиме. Приостанавливает работу каждой итерации для произвольного интервал от 1 до 1000 миллисекунд. Случайное значение определяет, на какой итерации цикла <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> вызывается метод. Поскольку итерации цикла вряд ли по-прежнему выполняться, когда <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> вызывается метод, лямбда-выражение вызывает <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> метод для проверки, вызвал ли другую итерацию <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> метод. Если он возвращает `true`, немедленно возвращает итерации.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LowestBreakIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;long&gt; LowestBreakIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int64&gt; LowestBreakIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LowestBreakIteration As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;long&gt; LowestBreakIteration { Nullable&lt;long&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает первую итерацию цикла, из которой был вызван метод <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" />.</summary>
        <value>Получает первую итерацию, из которой был вызван метод <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" />. В случае цикла <see cref="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" /> значение основано на внутренне создаваемом индексе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возможно несколько итераций параллельного цикла для вызова <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> метод. Если они есть, это значение равно наименьшего индекса итерации, который вызвал <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. При вызове без итерации цикла <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, это свойство возвращает `null`. Обратите внимание, что значение свойства не влияет на вызовы <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> метод.  
  
 В итерации долго выполняющихся всех итераций после итерации, который вызывает <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> нет необходимости использовать метод, <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> свойство используется для завершения итерации, начала выполнения перед вызовом <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> метод. Чтобы остановить, индекс которого больше, чем первую итерацию разрыв конкурирующих выполнения итераций, делать следующее:  
  
1.  Проверьте ли <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> свойство `true`.  
  
2.  Выйти из итерации, если его индекс больше <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> значение свойства.  
  
 Иллюстрация приведена в примере.  
  
   
  
## Examples  
 В следующем примере выполняется до 100 итераций цикла в параллельном режиме. Приостанавливает работу каждой итерации для произвольного интервал от 1 до 1000 миллисекунд. Случайное значение определяет, на какой итерации цикла <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> вызывается метод. Это предотвращает итераций, индекс которого больше, чем <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> значение свойства запуститься после вызова <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> метода, но он не влияет на все итерации, которые уже начал выполняться. Чтобы предотвратить их выполнение, вызывает каждой итерации <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> метод для проверки, вызвал ли другую итерацию <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> метод. Если Да, итерация проверяет значение <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> свойства и, если больше, чем значение индекса текущей итерации, возвращается немедленно.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Обратите внимание, что, поскольку <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> значение выходит за пределы области за пределами параллельного цикла, необходимо назначить переменной, которая отображается за пределами цикла, если вы хотите сохранить ее значение.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
      </Docs>
    </Member>
    <Member MemberName="ShouldExitCurrentIteration">
      <MemberSignature Language="C#" Value="public bool ShouldExitCurrentIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldExitCurrentIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShouldExitCurrentIteration As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShouldExitCurrentIteration { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, следует ли текущей итерации цикла завершить работу на основе запросов от этой или других итераций.</summary>
        <value>
          Значение <see langword="true" />, если текущая итерация должна завершать работу; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> Свойству `true` при выполнении любого из следующих условий:  
  
-   Итерации цикла вызовов <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> или <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>.  
  
-   Итерация цикла создает исключение.  
  
-   Цикл будет отменена.  
  
 Если этому свойству присвоено `true`, <xref:System.Threading.Tasks.Parallel> класс заранее попытается запретить запуск выполнения дополнительных итераций цикла. Тем не менее могут быть случаи, где не удается избежать дополнительных итераций запуститься.  
  
 Он также может быть так, что уже началось выполнение продолжительной итерации. В таких случаях итераций может явно не проверять <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> свойство и прекращает выполнение, если свойство возвращает `true`.  
  
   
  
## Examples  
 В следующем примере выполняется до 100 итераций цикла в параллельном режиме. Приостанавливает работу каждой итерации для произвольного интервал от 1 до 1000 миллисекунд. Случайное значение определяет, на какой итерации цикла <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> вызывается метод. Это предотвращает итераций, индекс которого больше, чем <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> значение свойства запуститься после вызова <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> метода, но он не влияет на все итерации, которые уже начал выполняться. Чтобы предотвратить их выполнение, вызывает каждой итерации <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> метод для проверки, вызвал ли другую итерацию <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> метод. Если Да, итерация проверяет значение <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> свойства и, если больше, чем значение индекса текущей итерации, возвращается немедленно.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сообщает, что цикл <see cref="T:System.Threading.Tasks.Parallel" /> должен прекратить выполнение в первый удобный для системы момент.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> метод показывает все итерации цикла, которые еще не были запущены запуска не требуется. Фактически он отменяет любые дополнительные итерации цикла. Тем не менее любой итераций, которые уже начали выполнение не останавливается.  
  
 Вызов <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> метода заставляет <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> возвращаемое свойство `true` для какой-либо итерации цикла, который все еще выполняется. Это особенно полезно для долго выполняющихся итераций, которые можно проверить <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> свойство и выйти раньше, если его значение равно `true`.  
  
 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> обычно работает в алгоритмах поиска, где после результирующего найдено, никакие другие итераций должны выполняться.  
  
   
  
## Examples  
 В следующем примере выполняется до 10 000 итераций цикла в параллельном режиме. Приостанавливает работу каждой итерации для произвольного интервал от 1 до 1000 миллисекунд. Случайное значение определяет, на какой итерации цикла <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> вызывается метод. Как показывают выходные данные примера, итерации не выполнить после вызова <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> метод.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 Поскольку итерации цикла вряд ли по-прежнему выполняться, когда <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> вызывается метод, вызывает каждой итерации <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> метод для проверки, вызвал ли другую итерацию <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> метод. Если он возвращает `true`, немедленно возвращает итерации.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> был вызван ранее. <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> и <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> не могут использоваться в сочетании итерациями одного и того же цикла.</exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
      </Docs>
    </Member>
  </Members>
</Type>