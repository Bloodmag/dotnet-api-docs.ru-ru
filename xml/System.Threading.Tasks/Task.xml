<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Task.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5d920b17ab80db20fab0e3101b745858eade81dd1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d920b17ab80db20fab0e3101b745858eade81dd1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Represents an asynchronous operation.</source>
          
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class represents a single operation that does not return a value and that usually executes asynchronously.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> Класса представляет одну операцию, которая не возвращает значение и обычно выполняется асинхронно.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objects are one of the central components of the  <bpt id="p1">[</bpt>task-based asynchronous pattern<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept> first introduced in the .NET Framework 4.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объекты — это одна из основных составляющих <bpt id="p1">[</bpt>асинхронная модель на основе задач<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept> впервые появился в платформе .NET Framework 4.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Because the work performed by a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object typically executes asynchronously on a thread pool thread rather than synchronously on the main application thread, you can use the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property, as well as the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> properties, to determine the   state of a task.</source>
          <target state="translated">Поскольку работа, выполняемые <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объект обычно выполняется асинхронно в потоке пула потоков, а не синхронно в потоке основного приложения, можно использовать <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> свойства, а также <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph>, и <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> свойства, чтобы определить состояние задачи.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Most commonly, a lambda expression is used to specify the work that the task is to perform.</source>
          <target state="translated">Чаще всего лямбда-выражение используется для указания работу, которую будет выполнять задача.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For operations that return values, you use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class.</source>
          <target state="translated">Используется для операций, которые возвращают значения, <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In this section:</source>
          <target state="translated">Содержание</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Task instantiation examples<ept id="p1">](#Instant)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Примеры создания экземпляра задачи<ept id="p1">](#Instant)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Creating and executing a task<ept id="p1">](#Creating)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Создание и выполнение задачи<ept id="p1">](#Creating)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Separating task creation and execution<ept id="p1">](#Separating)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Разделение задач создания и выполнения<ept id="p1">](#Separating)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Waiting for one or more tasks to complete<ept id="p1">](#WaitingForOne)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Ожидание завершения одного или нескольких задач<ept id="p1">](#WaitingForOne)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Tasks and culture<ept id="p1">](#Culture)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Задачи и языка и региональных параметров<ept id="p1">](#Culture)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>For debugger developers<ept id="p1">](#Debugger)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Для разработчиков отладчика<ept id="p1">](#Debugger)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task instantiation</source>
          <target state="translated">При создании экземпляра задачи</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example creates and executes four tasks.</source>
          <target state="translated">Следующий пример создает и выполняет четырех задач.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Three tasks execute an <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> delegate named <ph id="ph2">`action`</ph>, which accepts an argument of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">Три задачи выполняются <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> делегат с именем <ph id="ph2">`action`</ph>, который принимает аргумент типа <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>A fourth task executes a lambda expression (an <ph id="ph1">&lt;xref:System.Action&gt;</ph> delegate) that is defined inline in the call to the task creation method.</source>
          <target state="translated">Лямбда-выражение выполняет задачу четвертого ( <ph id="ph1">&lt;xref:System.Action&gt;</ph> делегировать), определен как встроенный в вызове метода создания задачи.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Each task is instantiated and run in a different way:</source>
          <target state="translated">Каждая задача создается и выполнить различными способами:</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t1`</ph> is instantiated by calling a Task class constructor, but is started by calling its <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Start&gt;</ph> method only after task <ph id="ph3">`t2`</ph> has started.</source>
          <target state="translated">Задача <ph id="ph1">`t1`</ph> создается путем вызова конструктора класса задачи, но запускается путем вызова его <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Start&gt;</ph> метод только после того, задача <ph id="ph3">`t2`</ph> начата.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t2`</ph> is instantiated and started in a single method call by calling the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Задача <ph id="ph1">`t2`</ph> создается и запущен в одном вызове метода с помощью вызова <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t3`</ph> is instantiated and started in a single method call by calling the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method.</source>
          <target state="translated">Задача <ph id="ph1">`t3`</ph> создается и запущен в одном вызове метода с помощью вызова <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t4`</ph> is executed synchronously on the main thread by calling the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> method.</source>
          <target state="translated">Задача <ph id="ph1">`t4`</ph> , выполняется синхронно в основном потоке путем вызова <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Because task <ph id="ph1">`t4`</ph> executes synchronously, it executes on the main application thread.</source>
          <target state="translated">Так как задача <ph id="ph1">`t4`</ph> выполняется синхронно, он выполняет для основного потока приложения.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The remaining tasks execute asynchronously typically on one or more thread pool threads.</source>
          <target state="translated">Остальные задачи выполняются асинхронно обычно один или несколько потоков в пуле потоков.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Creating and executing a task</source>
          <target state="translated">Создание и выполнение задачи</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances may be created in a variety of ways.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> экземпляры могут быть созданы в различными способами.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The most common approach, which is available starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, is to call the static <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method.</source>
          <target state="translated">Наиболее распространенным подходом, который доступен, начиная с <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, является вызов статических <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method provides a simple way to start a task using default values and without requiring additional parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> Метод обеспечивает простой способ запуска задачи, используя значения по умолчанию и не требует дополнительных параметров.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method to start a task that loops and then displays the number of loop iterations:</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> метод, чтобы запустить задачу, которая выполняет цикл, а затем отображает количество итераций цикла:</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>An alternative, and the most common method to start a task in <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, is the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Альтернативы и наиболее распространенный метод для запуска задачи в <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, имеет статический <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType&gt;</ph> Возвращает свойство <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method let you specify parameters to pass to the task creation options and a task scheduler.</source>
          <target state="translated">Перегруженные версии <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> метод позволяет задавать параметры для передачи параметров создания задачи и планировщик задач.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method to start a task.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> метода для запуска задачи.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>It is functionally equivalent to the code in the previous example.</source>
          <target state="translated">Это функционально эквивалентно коду в предыдущем примере.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For more complete examples, see <bpt id="p1">[</bpt>Task-based Asynchronous Programming<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept>.</source>
          <target state="translated">Более полные примеры см. в разделе <bpt id="p1">[</bpt>на основе задач асинхронное программирование<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Separating task creation and execution</source>
          <target state="translated">Разделение задач создания и выполнения</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class also provides constructors that initialize the task but that do not schedule it for execution.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> Класс также предоставляет конструкторы, которые инициализируют задачу, но не запланировать его выполнение.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For performance reasons, the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method is the preferred mechanism for creating and scheduling computational tasks, but for scenarios where creation and scheduling must be separated, you can use the constructors and then call the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType&gt;</ph> method to schedule the task for execution at a later time.</source>
          <target state="translated">Из соображений производительности <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> метод предпочтительный механизм для создания и планирования вычислительных задач, но для сценариев, где создание и планирование должны разделяться, можно использовать конструкторы и затем вызвать метод <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType&gt;</ph> для планирования задачи для выполнения в более позднее время.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Waiting for one or more tasks to complete</source>
          <target state="translated">Ожидание завершения одного или нескольких задач</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Because tasks typically run asynchronously on a thread pool thread, the thread that creates and starts the task continues execution as soon as the task has been instantiated.</source>
          <target state="translated">Поскольку задачи обычно выполняются асинхронно в потоке пула потоков, потока, который создает и запускает задачу в продолжает выполнение сразу после создания экземпляра задачи.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In some cases, when the calling thread is the main application thread, the app may terminate before any the task actually begins execution.</source>
          <target state="translated">В некоторых случаях при вызывающий поток является потоком основного приложения, приложение может завершить перед любым задачи фактически начинает выполнение.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In others,   your application's logic may require that the calling thread continue execution only when one or more tasks has completed execution.</source>
          <target state="translated">В других логику приложения может потребоваться, вызывающему потоку продолжить выполнение только после завершения выполнения одной или нескольких задач.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can synchronize the execution of the calling thread and the asynchronous tasks it launches by calling a <ph id="ph1">`Wait`</ph> method to wait for one or more tasks to complete.</source>
          <target state="translated">Вы можете синхронизировать выполнение вызывающего потока и асинхронной задачи она запускает путем вызова <ph id="ph1">`Wait`</ph> метод для ожидания завершения одного или нескольких задач.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>To wait for a single task to complete, you can call its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Чтобы дождаться завершения выполнения одной задачи, можно вызвать его <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>A call to the  <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method blocks the calling thread until the single class instance has completed execution.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> метод блокирует вызывающий поток до завершения выполнения экземпляра одного класса.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example calls the parameterless <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> method to wait unconditionally until a task completes.</source>
          <target state="translated">В следующем примере вызывается без параметров <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> метод безусловно дождаться завершения задачи.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The task simulates work by calling the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to sleep for two seconds.</source>
          <target state="translated">Задача имитирует рабочих путем вызова <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> метод в спящий режим на две секунды.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can also conditionally wait for a task to complete.</source>
          <target state="translated">Условно также может ожидать завершения задачи.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The  <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> methods block the calling thread until the task finishes or a timeout interval elapses, whichever comes first.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> И <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> методы блокирует вызывающий поток до завершения задачи или истечет время ожидания, что наступит раньше.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Since the following example launches a task that sleeps for two seconds but defines a one-second timeout value, the calling thread blocks until the timeout expires and before the task has completed execution.</source>
          <target state="translated">Так как следующий пример запускает задачу, которая определяет значение времени ожидания в секунду, вызывающий поток блокируется вплоть до истечения времени ожидания, но бездействует в течение двух секунд и до завершения выполнения задачи.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can also supply a cancellation token by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> and  <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> methods.</source>
          <target state="translated">Также можно использовать токен отмены, путем вызова <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> и <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>If the  token's <ph id="ph1">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> property is <ph id="ph2">`true`</ph>, the wait is cancelled; if it becomes true while the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method terminates.</source>
          <target state="translated">Если токен <ph id="ph1">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> свойство <ph id="ph2">`true`</ph>, отмены ожидания; если он становится значение true при <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> завершает метод.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In some cases, you may want to wait for the first of a series of executing tasks to complete, but don't care which task it is.</source>
          <target state="translated">В некоторых случаях может потребоваться подождать для первого ряда выполнение задач для выполнения, но они является следить за которой он задач.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For this purpose, you can call one of the overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Для этой цели можно вызвать одну из перегрузок <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example creates three tasks, each of which sleeps for an interval determine by a random number generator.</source>
          <target state="translated">В следующем примере создается три задачи, каждый из которых находится в спящем режиме, для определения интервала, генератор случайных чисел.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method waits for the first task to complete.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> Метод ожидает завершения первой задачи.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The example then displays information about the status of all three tasks.</source>
          <target state="translated">Затем пример отображает сведения о состоянии всех трех задач.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can also wait for all of a series of tasks to complete by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> method.</source>
          <target state="translated">Можно также подождать все последовательности задач, чтобы завершить путем вызова <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example creates ten tasks, waits for all ten to complete, and then displays their status.</source>
          <target state="translated">Следующий пример создает десять задач, ожидает всех десяти для завершения, а затем отображает их состояние.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Note that when you wait for one or more tasks to complete, any exceptions thrown in the running tasks are propagated on the thread that calls the <ph id="ph1">`Wait`</ph> method, as the following example shows.</source>
          <target state="translated">Обратите внимание, что при ожидании завершения одного или нескольких задач, все исключения, возникшие в задания, выполняющиеся распространяются на поток, который вызывает <ph id="ph1">`Wait`</ph> метода, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>It launches 12 tasks, three of which complete normally and three of which throw an exception.</source>
          <target state="translated">Он запускает 12 задачи, три из которых быть нормально завершен и три из которых выдал исключение.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Of the remaining six tasks, three are cancelled before the start, and three are cancelled while they executing.</source>
          <target state="translated">Оставшиеся шесть задач три будут отменены до ее начала, а три будут отменены при их выполнении.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Exceptions are thrown in the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> method call and are handled by a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Исключения создаются <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> обрабатывает вызов метода и являются <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> блока.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For more information on exception handling in task-based asynchronous operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об обработке исключений в асинхронных операциях на основе задач см. в разделе <bpt id="p1">[</bpt>обработка исключений<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Tasks and culture</source>
          <target state="translated">Задачи и языка и региональных параметров</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Starting with desktop apps that target the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, the culture of the thread that creates and invokes a task becomes part of the thread's context.</source>
          <target state="translated">Начиная с настольных приложений, ориентированных на <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, язык и региональные параметры потока, который создает и запускает задачу становится частью контекст потока.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>That is, regardless of the current culture of the thread on which the task executes, the current culture of the task is the culture of the calling thread.</source>
          <target state="translated">Независимо от текущего языка и региональных параметров потока, на котором выполняется в задаче, текущий язык и региональные параметры задачи является язык и региональные параметры вызывающего потока.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For apps that target versions of the .NET Framework prior to the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, the culture of the task is the culture of the thread on which the task executes.</source>
          <target state="translated">Для приложений, предназначенных для версий платформы .NET Framework до версии <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, язык и региональные параметры задачи является языком и региональными параметрами потока, на котором выполняется задача.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For more information, see the "Culture and task-based asynchronous operations" section in the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> topic.</source>
          <target state="translated">Дополнительные сведения см. в разделе «Язык и региональные параметры и асинхронные операции на основе задач» <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> раздела.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Store apps follow the Windows Runtime in setting and getting the default culture.</source>
          <target state="translated">Приложения для магазина выполните среды выполнения Windows в установку и получение культуры по умолчанию.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For debugger developers</source>
          <target state="translated">Для разработчиков отладчика</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For developers implementing custom debuggers, several internal and private members of task may be useful (these may change from release to release).</source>
          <target state="translated">Разработчикам реализации пользовательских отладчиков несколько внутренних и закрытых членов задачи могут пригодиться (они могут изменяться от выпуска к выпуску).</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">`m_taskId`</ph> field serves as the backing store for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> property, however accessing this field directly from a debugger may be more efficient than accessing the same value through the property's getter method (the <ph id="ph3">`s_taskIdCounter`</ph> counter is used to retrieve the next available ID for a task).</source>
          <target state="translated"><ph id="ph1">`m_taskId`</ph> Поле выступает в качестве резервного хранилища для <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> свойство, однако доступ к в этом поле прямо из отладчика может быть более эффективным, чем доступ и то же значение через метод считывания свойства ( <ph id="ph3">`s_taskIdCounter`</ph> счетчик используется для получения следующий доступный идентификатор задачи).</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Similarly, the <ph id="ph1">`m_stateFlags`</ph> field stores information about the current lifecycle stage of the task, information also accessible through the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">Аналогичным образом <ph id="ph1">`m_stateFlags`</ph> поле хранит сведения о текущий этап жизненного цикла задачи сведения также доступны через <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">`m_action`</ph> field stores a reference to the task's delegate, and the <ph id="ph2">`m_stateObject`</ph> field stores the async state passed to the task by the developer.</source>
          <target state="translated"><ph id="ph1">`m_action`</ph> Поле сохраняет ссылку на делегат задачи и <ph id="ph2">`m_stateObject`</ph> поле сохраняются асинхронное состояние, переданный в задачи разработчика.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Finally, for debuggers that parse stack frames, the <ph id="ph1">`InternalWait`</ph> method serves a potential marker for when a task is entering a wait operation.</source>
          <target state="translated">Наконец, для отладчиков разбора кадров стека <ph id="ph1">`InternalWait`</ph> метод служит потенциальным для при задача начинает операцию ожидания.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>All members of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, except for <ph id="ph2">&lt;see cref="M:System.Threading.Tasks.Task.Dispose" /&gt;</ph>, are thread-safe and may be used from multiple threads concurrently.</source>
          <target state="translated">Все члены <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, за исключением <ph id="ph2">&lt;see cref="M:System.Threading.Tasks.Task.Dispose" /&gt;</ph>, являются потокобезопасными и может использоваться несколькими потоками одновременно.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The delegate that represents the code to execute in the task.</source>
          
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action.</source>
          
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Вместо вызова этого конструктора, наиболее распространенным способом создания экземпляра <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объекта и запуск задачи — путем вызова статического <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType&gt;</ph> или <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Только преимущества, предоставляемые этот конструктор является то, что при создании экземпляра объекта должны разделяться после вызова задачи.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> constructor to create tasks that retrieve the filenames in specified directories.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> конструктор для создания задачи, которые получают имена файлов в указанных каталогах.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>All tasks write the file names to a single <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">Все задачи записи имен файлов в один <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">Затем в примере вызывается <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> метода убедитесь, что все задачи завершены и затем отображает число общее количество имен файлов, записанных на <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The following example is identical, except that it used the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method to instantiate and run the task in a single operation.</source>
          <target state="translated">Следующий пример идентичен, за исключением того, он используется <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> метод для создания экземпляра и запуска задачи в одной операции.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The method returns the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object that represents the task.</source>
          <target state="translated">Метод возвращает <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объект, представляющий задачу.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The delegate that represents the code to execute in the task.</source>
          
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that the new  task will observe.</source>
          
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and <ph id="ph2">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Вместо вызова этого конструктора, наиболее распространенным способом создания экземпляра <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объекта и запуск задачи — путем вызова статического <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> и <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Только преимущества, предоставляемые этот конструктор является то, что при создании экземпляра объекта должны разделяться после вызова задачи.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Parallelism (Task Parallel Library)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> and <bpt id="p2">[</bpt>Cancellation in Managed Threads<ept id="p2">](~/docs/standard/threading/cancellation-in-managed-threads.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>параллелизм задач (библиотека параллельных задач)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> и <bpt id="p2">[</bpt>Отмена в управляемых потоках<ept id="p2">](~/docs/standard/threading/cancellation-in-managed-threads.md)</ept>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> constructor to create a task that iterates the files in the C:\Windows\System32 directory.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> конструктор для создания задачи, которая выполняет итерацию файлы в каталог C:\Windows\System32.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The lambda expression calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> method to add information about each  file to a <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object.</source>
          <target state="translated">Лямбда-выражение вызывает <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы добавить сведения о каждом файле <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>Each detached nested task invoked by the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> loop checks the state of the cancellation token and, if cancellation is requested, calls the <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Каждый отсоединенной вложенной задачей, вызываемых <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> цикла проверяет состояние токена отмены и если запрос на отмену вызывает <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> exception that is handled in a <ph id="ph3">`catch`</ph> block when the calling thread calls the <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> Вызывает исключение <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> исключение, которое обрабатывается в <ph id="ph3">`catch`</ph> заблокировать, если вызывающий поток вызывает <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> method is then called to start the task.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> Затем вызывается метод для выполнения задачи.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and creation options.</source>
          
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Вместо вызова этого конструктора, наиболее распространенным способом создания экземпляра <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объекта и запуск задачи — путем вызова статического <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Только преимущества, предоставляемые этот конструктор является то, что при создании экземпляра объекта должны разделяться после вызова задачи.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The delegate that represents the code to execute in the task.</source>
          
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>An object representing data to be used by the action.</source>
          
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and state.</source>
          
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Вместо вызова этого конструктора, наиболее распространенным способом создания экземпляра <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объекта и запуск задачи — путем вызова статического <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Только преимущества, предоставляемые этот конструктор является то, что при создании экземпляра объекта должны разделяться после вызова задачи.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The following example defines an array of 6-letter words.</source>
          <target state="translated">В следующем примере определяется массив 6 букву слова.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>Each word is then passed as an argument to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29&gt;</ph> constructor, whose <ph id="ph2">&lt;xref:System.Action%601&gt;</ph> delegate scrambles the characters in the word, then displays the original word and its scrambled version.</source>
          <target state="translated">Каждое слово затем передается в качестве аргумента для <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29&gt;</ph> конструктор, которого <ph id="ph2">&lt;xref:System.Action%601&gt;</ph> делегат шифруется символов в слове, а затем отображает исходного слова и его версия искаженном виде.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that the new task will observe.</source>
          
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and creation options.</source>
          
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Вместо вызова этого конструктора, наиболее распространенным способом создания экземпляра <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объекта и запуск задачи — путем вызова статического <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Только преимущества, предоставляемые этот конструктор является то, что при создании экземпляра объекта должны разделяться после вызова задачи.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Parallelism (Task Parallel Library)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> and <bpt id="p2">[</bpt>Task Cancellation<ept id="p2">](~/docs/standard/parallel-programming/task-cancellation.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>параллелизм задач (библиотека параллельных задач)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> и <bpt id="p2">[</bpt>отмены задачи<ept id="p2">](~/docs/standard/parallel-programming/task-cancellation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The delegate that represents the code to execute in the task.</source>
          
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>An object representing data to be used by the action.</source>
          
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that that the new task will observe.</source>
          
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action, state, and options.</source>
          
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Вместо вызова этого конструктора, наиболее распространенным способом создания экземпляра <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объекта и запуск задачи — путем вызова статического <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Только преимущества, предоставляемые этот конструктор является то, что при создании экземпляра объекта должны разделяться после вызова задачи.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>An object representing data to be used by the action.</source>
          
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action, state, and options.</source>
          
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Вместо вызова этого конструктора, наиболее распространенным способом создания экземпляра <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объекта и запуск задачи — путем вызова статического <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Только преимущества, предоставляемые этот конструктор является то, что при создании экземпляра объекта должны разделяться после вызова задачи.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>An object representing data to be used by the action.</source>
          
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that that the new task will observe..</source>
          
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action, state, and options.</source>
          
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Вместо вызова этого конструктора, наиболее распространенным способом создания экземпляра <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объекта и запуск задачи — путем вызова статического <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Только преимущества, предоставляемые этот конструктор является то, что при создании экземпляра объекта должны разделяться после вызова задачи.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.AsyncState">
          <source>Gets the state object supplied when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> was created, or null if none was supplied.</source>
          
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.AsyncState">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that represents the state data that was passed in to the task when it was created.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>, представляющий данные о состоянии, переданные задаче на этапе создания.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.AsyncState">
          <source>Cast the object back to the original type to retrieve its data.</source>
          <target state="translated">Приведение объекта обратно в исходный тип для извлечения данных.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>Gets a task that has already completed successfully.</source>
          
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>The successfully completed task.</source>
          <target state="translated">Успешно завершенная задача.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>This property returns a task whose <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is set to <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>.</source>
          <target state="translated">Это свойство Возвращает задачу, <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> свойству <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>To create task that returns a value and runs to completion, call the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> method.</source>
          <target state="translated">Чтобы создать задачу, которая возвращает значение и выполняется до завершения, вызовите <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>Repeated attempts to retrieve this property value may not always return the same instance.</source>
          <target state="translated">Повторные попытки получить значение этого свойства могут не всегда возвращать тот же экземпляр.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to attempt to marshal the continuation back to the original context captured; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)">
          <source>Configures an awaiter used to await this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)">
          <source>An object used to await this task.</source>
          
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> не будет запланирован для выполнения до завершения выполнения текущей задачи, является ли он завершается из-за выполнение завершилась успешно, сбой из-за необработанного исключения или преждевременного из-за отмены.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>The following example defines a task that populates an array with 100 random date and time values.</source>
          <target state="translated">В следующем примере определяется задачу, которая заполняет массив 100 случайных значений даты и времени.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>It uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method to select the earliest and the latest date values once the array is fully populated.</source>
          <target state="translated">Она использует <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> метод для выбора самой ранней и последние значения даты, когда массив заполняется полностью.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>Because a console application may terminate before the continuation task executes, the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> method is called to ensure that the continuation finishes executing before the example ends.</source>
          <target state="translated">Так как консольное приложение может завершиться до задача продолжения выполняется, <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> для убедитесь, что продолжение завершается выполнение до окончания примере вызывается метод.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>For an additional example, see <bpt id="p1">[</bpt>Chaining Tasks by Using Continuation Tasks<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept>.</source>
          <target state="translated">Дополнительный пример, в разделе <bpt id="p1">[</bpt>создание цепочки задач с помощью задач продолжения<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>An action to run when the task completes.</source>
          
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>When run, the delegate is passed the completed task and a caller-supplied state object as arguments.</source>
          
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>An object representing data to be used by the continuation action.</source>
          
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>Creates a continuation that receives caller-supplied state information and executes when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>A new continuation task.</source>
          
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting early due to cancellation.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> не будет запланирован для выполнения до завершения выполнения текущей задачи, является ли он завершается из-за выполнение завершилась успешно, сбой из-за необработанного исключения или рано выходе из-за отмены.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>Creates a continuation that receives a cancellation token and executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> не будет запланирован для выполнения до завершения выполнения текущей задачи, является ли он завершается из-за выполнение завершилась успешно, сбой из-за необработанного исключения или преждевременного из-за отмены.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>An action to run according to the specified <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>.</source>
          
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that executes when the target task completes according to the specified <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> не планируется для выполнения до завершения выполнения текущей задачи.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">При указании условий продолжения с помощью <ph id="ph1">`continuationOptions`</ph> параметра не выполняются, задача продолжения будет отменено а не запланировано.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The following example demonstrates using <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskContinuationOptions&gt;</ph> to specify that a continuation task should run synchronously when the antecedent task completes.</source>
          <target state="translated">В следующем примере демонстрируется использование <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskContinuationOptions&gt;</ph> для указания, что задача продолжения должна выполняться синхронно при завершении предшествующей задачи.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>(If the specified task has already completed by the time <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph> is called, the synchronous continuation will run on the thread calling <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph>.)</source>
          <target state="translated">(Если указанное задание уже завершена, когда <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph> вызове синхронных продолжение будет выполняться в вызывающем потоке <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The continuation uses a specified scheduler.</source>
          
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> не будет запланирован для выполнения до завершения выполнения текущей задачи, является ли он завершается из-за выполнение завершилась успешно, сбой из-за необработанного исключения или преждевременного из-за отмены.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</source>
          
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>An object representing data to be used by the continuation action.</source>
          
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>Creates a continuation that receives caller-supplied state information and a cancellation token and that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> не будет запланирован для выполнения до завершения выполнения текущей задачи, является ли он завершается из-за выполнение завершилась успешно, сбой из-за необработанного исключения или преждевременного из-за отмены.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>An object representing data to be used by the continuation action.</source>
          
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that receives caller-supplied state information and executes when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The continuation executes based on a set of specified conditions.</source>
          
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> не планируется для выполнения до завершения выполнения текущей задачи.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">При указании условий продолжения с помощью <ph id="ph1">`continuationOptions`</ph> параметра не выполняются, задача продолжения будет отменено а не запланировано.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation action.</source>
          
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation uses a specified scheduler.</source>
          
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> не будет запланирован для выполнения до завершения выполнения текущей задачи, является ли он завершается из-за выполнение завершилась успешно, сбой из-за необработанного исключения или преждевременного из-за отмены.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An action to run according to the specified <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>.</source>
          
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes when the target task competes according to the specified <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation receives a cancellation token and uses a specified scheduler.</source>
          
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> не планируется для выполнения до завершения выполнения текущей задачи.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Если указать критерии с помощью <ph id="ph1">`continuationOptions`</ph> параметра не выполняются, задача продолжения будет отменено а не запланировано.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The following is an example of using ContinueWith to run work both in the background and on the user interface threads.</source>
          <target state="translated">Ниже приведен пример использования ContinueWith для выполнения работы в фоновом режиме и на пользователя потоки интерфейса.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation action.</source>
          
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its  execution.</source>
          
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that receives caller-supplied state information and a cancellation token and that executes when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation executes based on a set of specified conditions and uses a specified scheduler.</source>
          
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has  completed.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> не планируется для выполнения до завершения выполнения текущей задачи.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter  are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Если указать критерии с помощью <ph id="ph1">`continuationOptions`</ph> параметра не выполняются, задача продолжения будет отменено а не запланировано.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Тип результата, созданного продолжением.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> completes and returns a value.</source>
          
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>A new continuation task.</source>
          
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> не будет запланирован для выполнения до завершения выполнения текущей задачи, является ли он завершается из-за выполнение завершилась успешно, сбой из-за необработанного исключения или преждевременного из-за отмены.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The following example shows how to use the ContinueWith method:</source>
          <target state="translated">Следующий пример показывает, как с помощью метода ContinueWith:</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Тип результата, созданного продолжением.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</source>
          
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>An object representing data to be used by the continuation function.</source>
          
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> не будет запланирован для выполнения до завершения выполнения текущей задачи, является ли он завершается из-за выполнение завершилась успешно, сбой из-за необработанного исключения или преждевременного из-за отмены.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Тип результата, созданного продолжением.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The continuation receives a cancellation token.</source>
          
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> не будет запланирован для выполнения до завершения выполнения текущей задачи, является ли он завершается из-за выполнение завершилась успешно, сбой из-за необработанного исключения или преждевременного из-за отмены.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Тип результата, созданного продолжением.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>A function to run according to the condition specified in <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>.</source>
          
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that executes according to the specified continuation options and returns a value.</source>
          
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> не планируется для выполнения до завершения выполнения текущей задачи.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">При указании условий продолжения с помощью <ph id="ph1">`continuationOptions`</ph> параметра не выполняются, задача продолжения будет отменено а не запланировано.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Тип результата, созданного продолжением.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The continuation uses a specified scheduler.</source>
          
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> не будет запланирован для выполнения до завершения выполнения текущей задачи, является ли он завершается из-за выполнение завершилась успешно, сбой из-за необработанного исключения или преждевременного из-за отмены.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Тип результата, созданного продолжением.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>An object representing data to be used by the continuation function.</source>
          
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The continuation receives caller-supplied state information and a cancellation token.</source>
          
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> не будет запланирован для выполнения до завершения выполнения текущей задачи, является ли он завершается из-за выполнение завершилась успешно, сбой из-за необработанного исключения или преждевременного из-за отмены.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Тип результата, созданного продолжением.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>An object representing data to be used by the continuation function.</source>
          
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that executes based on the specified task continuation options when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The continuation receives caller-supplied state information.</source>
          
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> не планируется для выполнения до завершения выполнения текущей задачи.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">При указании условий продолжения с помощью <ph id="ph1">`continuationOptions`</ph> параметра не выполняются, задача продолжения будет отменено а не запланировано.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Тип результата, созданного продолжением.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation function.</source>
          
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation receives caller-supplied state information and uses a specified scheduler.</source>
          
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> не будет запланирован для выполнения до завершения выполнения текущей задачи, является ли он завершается из-за выполнение завершилась успешно, сбой из-за необработанного исключения или преждевременного из-за отмены.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Тип результата, созданного продолжением.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A function to run according to the specified <bpt id="p1">&lt;c&gt;</bpt>continuationOptions.<ept id="p1">&lt;/c&gt;</ept></source>
          
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes according to the specified continuation options and returns a value.</source>
          
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation is passed a cancellation token and uses a specified scheduler.</source>
          
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> не планируется для выполнения до завершения выполнения текущей задачи.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Если указать критерии с помощью <ph id="ph1">`continuationOptions`</ph> параметра не выполняются, задача продолжения будет отменено а не запланировано.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The following example shows how to use the ContinueWith method with continuation options:</source>
          <target state="translated">Следующий пример показывает, как с помощью метода ContinueWith с параметрами продолжения:</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Тип результата, созданного продолжением.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation function.</source>
          
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its  execution.</source>
          
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes based on the specified task continuation options when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation receives caller-supplied state information and a cancellation token and uses the specified scheduler.</source>
          
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed.</source>
          <target state="translated">Возвращенный <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> не планируется для выполнения до завершения выполнения текущей задачи.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter  are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Если указать критерии с помощью <ph id="ph1">`continuationOptions`</ph> параметра не выполняются, задача продолжения будет отменено а не запланировано.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.CreationOptions">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to create this task.</source>
          
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CreationOptions">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to create this task.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>, используемый для создания данной задачи.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>Returns the ID of the currently executing <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>An integer that was assigned by the system to the currently-executing task.</source>
          <target state="translated">Целое число, присвоенное системой выполняемой в настоящее время задаче.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> is a <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) property that is used to get the identifier of the currently executing task from the code that the task is executing.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> — <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> в Visual Basic) свойство, используемое для получения идентификатора текущей выполняемой задачи из кода, который выполняется задача.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>It differs from the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> property, which returns the identifier of a particular <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instance.</source>
          <target state="translated">Она отличается от <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> свойство, которое возвращает идентификатор конкретной <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>If you attempt to retrieve the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> value from outside the code that a task is executing, the property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">При попытке получить <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> свойство возвращает значение из внешний код, выполняемый задачей <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</source>
          <target state="translated">Обратите внимание, что несмотря на то, что конфликты встречаются очень редко, задача не гарантируется, что идентификаторы быть уникальным.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a task that will complete after a time delay.</source>
          
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</source>
          
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Creates a task that completes after a time delay.</source>
          
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>A task that represents the time delay.</source>
          
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method is typically used to delay the operation of all or part of a task for a specified time interval.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> Метод обычно используется для заданного интервала времени задержки всех или части задачи.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Most commonly, the time delay is introduced:</source>
          <target state="translated">Чаще всего вводится время задержки:</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>At the beginning of the task, as the following example shows.</source>
          <target state="translated">Показывает начало задачи, как приведенный ниже пример AT.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Sometime while the task is executing.</source>
          <target state="translated">Некоторое время, пока выполняется задача.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>In this case, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method executes as a child task within a task, as the following example shows.</source>
          <target state="translated">В этом случае вызов <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> метод выполняется как дочерняя задача внутри задачи, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Note that since the task that calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method executes asynchronously, the parent task must wait for it to complete by using the <ph id="ph2">`await`</ph> keyword.</source>
          <target state="translated">Обратите внимание, что с момента задачи, вызывает <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> метод выполняется асинхронно, в родительскую задачу, дождитесь ее завершения с помощью <ph id="ph2">`await`</ph> ключевое слово.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>After the specified time delay, the task is completed in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">После указанного времени задержки, завершения задачи в <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> состояние.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>This method depends on the system clock.</source>
          <target state="translated">Этот метод зависит от системных часов.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`millisecondsDelay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">Это означает, что время задержки будет приблизительно разрешения системных часов при <ph id="ph1">`millisecondsDelay`</ph> аргумент меньше, чем разрешения системных часов, являющийся примерно 15 миллисекунд в системах Windows.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The following example shows a simple use of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере показано простое использование <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="millisecondsDelay" /&gt;</ph> argument is less than -1.</source>
          
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>The time span to wait before completing the returned task, or <ph id="ph1">&lt;see langword="TimeSpan.FromMilliseconds(-1)" /&gt;</ph> to wait indefinitely.</source>
          
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>Creates a task that completes after a specified time interval.</source>
          
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>A task that represents the time delay.</source>
          
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>After the specified time delay, the task is completed in <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">После указанного времени задержки, завершения задачи в <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> состояние.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>For usage scenarios and additional examples, see the documentation for the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> overload.</source>
          <target state="translated">Сценарии использования и Дополнительные примеры см. в документации по <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> перегрузки.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>This method depends on the system clock.</source>
          <target state="translated">Этот метод зависит от системных часов.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`delay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">Это означает, что время задержки будет приблизительно разрешения системных часов при <ph id="ph1">`delay`</ph> аргумент меньше, чем разрешения системных часов, являющийся примерно 15 миллисекунд в системах Windows.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>The following example shows a simple use of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере показано простое использование <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="delay" /&gt;</ph> represents a negative time interval other than <ph id="ph2">&lt;see langword="TimeSpan.FromMillseconds(-1)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="delay" /&gt;</ph> argument's <ph id="ph2">&lt;see cref="P:System.TimeSpan.TotalMilliseconds" /&gt;</ph> property is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</source>
          
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The cancellation token that will be checked prior to completing the returned task.</source>
          
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>Creates a cancellable task that completes after a time delay.</source>
          
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the time delay.</source>
          
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>If the cancellation token is signaled before the specified time delay, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception results, and the task is completed in the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Если токен отмены получает сигнал до указанного времени задержки, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> создается исключение и эта задача выполняется в <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> состояние.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>Otherwise, the task is completed in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state once the specified time delay has elapsed.</source>
          <target state="translated">В противном случае, завершена ли задача в <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> состояние по истечении указанного времени задержки.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>For usage scenarios and additional examples, see the documentation for the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> overload.</source>
          <target state="translated">Сценарии использования и Дополнительные примеры см. в документации по <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> перегрузки.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>This method depends on the system clock.</source>
          <target state="translated">Этот метод зависит от системных часов.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`millisecondsDelay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">Это означает, что время задержки будет приблизительно разрешения системных часов при <ph id="ph1">`millisecondsDelay`</ph> аргумент меньше, чем разрешения системных часов, являющийся примерно 15 миллисекунд в системах Windows.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The following example launches a task that includes a call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> method with a one second delay.</source>
          <target state="translated">Следующий пример запускает задачу, которая включает вызов <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> метод с одной секунда.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>Before the delay interval elapses, the token is cancelled.</source>
          <target state="translated">До истечения интервала задержки, токена отмены.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The output from the example shows that, as a result, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> is thrown, and the tasks' <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is set to <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</source>
          <target state="translated">Выходные данные примера показано, что в результате, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> создается исключение и задач <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> свойству <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="millisecondsDelay" /&gt;</ph> argument is less than -1.</source>
          
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The time span to wait before completing the returned task, or <ph id="ph1">&lt;see langword="TimeSpan.FromMilliseconds(-1)" /&gt;</ph> to wait indefinitely.</source>
          
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The cancellation token that will be checked prior to completing the returned task.</source>
          
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Creates a cancellable task that completes after a specified time interval.</source>
          
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>A task that represents the time delay.</source>
          
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>If the cancellation token is signaled before the specified time delay, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception results, and the task is completed in the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Если токен отмены получает сигнал до указанного времени задержки, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> создается исключение и эта задача выполняется в <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> состояние.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Otherwise, the task is completed in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state once the specified time delay has elapsed.</source>
          <target state="translated">В противном случае, завершена ли задача в <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> состояние по истечении указанного времени задержки.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>For usage scenarios and additional examples, see the documentation for the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> overload.</source>
          <target state="translated">Сценарии использования и Дополнительные примеры см. в документации по <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> перегрузки.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>This method depends on the system clock.</source>
          <target state="translated">Этот метод зависит от системных часов.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`delay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">Это означает, что время задержки будет приблизительно разрешения системных часов при <ph id="ph1">`delay`</ph> аргумент меньше, чем разрешения системных часов, являющийся примерно 15 миллисекунд в системах Windows.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The following example launches a task that includes a call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> method with a one-and-a-half second delay.</source>
          <target state="translated">Следующий пример запускает задачу, которая включает вызов <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> метод с задержкой и a половина второй.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Before the delay interval elapses, the token is cancelled.</source>
          <target state="translated">До истечения интервала задержки, токена отмены.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The output from the example shows that, as a result, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> is thrown, and the tasks' <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is set to <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</source>
          <target state="translated">Выходные данные примера показано, что в результате, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> создается исключение и задач <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> свойству <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Note that this example includes a potential race condition: it depends on the task asynchronously executing the delay when the token is cancelled.</source>
          <target state="translated">Обратите внимание, в этом примере включает потенциальных гонки: зависит от задач, асинхронно задержки при отмене токена.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Although the 1.5 second delay from the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> method makes that assumption likely, it is nevertheless possible that the call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> method could return before the token is cancelled.</source>
          <target state="translated">Несмотря на то, что задержка 1,5 секунды из вызова <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> метод допущения, скорее всего, тем не менее это возможно, вызов <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> метод может вернуть до отмены токена.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>In that case, the example produces the following output:</source>
          <target state="translated">В этом примере выводятся следующие данные:</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="delay" /&gt;</ph> represents a negative time interval other than <ph id="ph2">&lt;see langword="TimeSpan.FromMillseconds(-1)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="delay" /&gt;</ph> argument's <ph id="ph2">&lt;see cref="P:System.TimeSpan.TotalMilliseconds" /&gt;</ph> property is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> class.</source>
          
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> class.</source>
          
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class implements the <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> interface because internally it uses resources that also implement <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> Класс реализует <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> интерфейс, так как внутренне оно использует ресурсы, которые также реализуют <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>However, particularly if your app targets the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or later, there is no need to call <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</source>
          <target state="translated">Тем не менее особенно если в вашем приложении предназначен <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> или более поздней версии, нет необходимости вызывать <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> Если производительность или масштабируемость тестирование показывает, что в на основе использования шаблонов, удалив задач бы повысить производительность приложения.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Do I need to dispose of Tasks?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>нужно ли удалять задачи?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> в параллельное программирование с блога .NET.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>The task is not in one of the final states: <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /&gt;</ph>, or <ph id="ph3">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>A Boolean value that indicates whether this method is being called due to a call to <ph id="ph1">&lt;see cref="M:System.Threading.Tasks.Task.Dispose" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>Disposes the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, releasing all of its unmanaged resources.</source>
          
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class implements the <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> interface because internally it uses resources that also implement <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> Класс реализует <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> интерфейс, так как внутренне оно использует ресурсы, которые также реализуют <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>However, particularly if your app targets the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or later, there is no need to call <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</source>
          <target state="translated">Тем не менее особенно если в вашем приложении предназначен <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> или более поздней версии, нет необходимости вызывать <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> Если производительность или масштабируемость тестирование показывает, что в на основе использования шаблонов, удалив задач бы повысить производительность приложения.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Do I need to dispose of Tasks?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>нужно ли удалять задачи?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> в параллельное программирование с блога .NET.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>The task is not in one of the final states: <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /&gt;</ph>, or <ph id="ph3">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>Unlike most of the members of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> class, this method is not thread-safe.</source>
          <target state="translated">В отличие от большинства элементов <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> класса, этот метод не является потокобезопасным.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Exception">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> that caused the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to end prematurely.</source>
          
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Exception">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed successfully or has not yet thrown any exceptions, this will return <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>The <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> that caused the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to end prematurely.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph>, который привел к преждевременному завершению задачи <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>Tasks that throw unhandled exceptions store the resulting exception and propagate it wrapped in a <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> in calls to <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> or in accesses to the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
          <target state="translated">Задачи, которые вызывает необработанные исключения хранения результирующее исключение и передать их в оболочку <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> в вызовах <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> или в доступов к <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>Any exceptions not observed by the time the task instance is garbage collected will be propagated on the finalizer thread.</source>
          <target state="translated">Любые исключения, не наблюдается, когда экземпляр задачи выполняет сборку мусора распространяется на поток метода завершения.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>For more information and an example, see <bpt id="p1">[</bpt>Exception Handling (Task Parallel Library)<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Дополнительные сведения и пример см. в разделе <bpt id="p1">[</bpt>обработка исключений (библиотека параллельных задач)<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Provides access to factory methods for creating and configuring <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> and <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> instances.</source>
          
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>A factory object that can create a variety of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> and <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> objects.</source>
          <target state="translated">Объект фабрики, который может создавать разнообразные объекты <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> и <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>This property returns a default instance of the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> class that is identical to the one created by calling the parameterless <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Это свойство возвращает экземпляр по умолчанию <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> класс, созданный при вызове без параметров идентичный <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>It has the following property values:</source>
          <target state="translated">Он имеет следующие значения:</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Value</source>
          <target state="translated">Значение</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source><ph id="ph1">`null`</ph>, or <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated"><ph id="ph1">`null`</ph>, или <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>The most common use of this property is to create and start a new task in a single call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Обычно это свойство используется для создания и запуска новой задачи в рамках одного вызова <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> method provides the easiest way to create a <ph id="ph3">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object with default configuration values.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> метод предоставляет простой способ создания <ph id="ph3">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объекта со значениями конфигурации по умолчанию.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>The following example uses the static <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A&gt;</ph> property to make two calls to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">В следующем примере используется статический <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A&gt;</ph> свойство для вызовов двух <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>The first populates an array with the names of files in the user's MyDocuments directory, while the second populates an array with the names of subdirectories of the user's MyDocuments directory.</source>
          <target state="translated">Первый заполняет массив имен файлов в каталоге Мои документы пользователя, пока второй заполняет массив имена подкаталогов каталога Мои документы пользователя.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType&gt;</ph> method, which displays information about the number of files and directories in the two arrays after the first two tasks have completed execution.</source>
          <target state="translated">Затем он вызывает <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType&gt;</ph> метод, который отображает сведения о количестве файлов и каталогов в двух массивах после окончания выполнения первых двух задач.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>The cancellation token with which to complete the task.</source>
          
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> that's completed due to cancellation with a specified cancellation token.</source>
          
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>The canceled task.</source>
          
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>Cancellation has not been requested for <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>; its <ph id="ph2">&lt;see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /&gt;</ph> property is <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>The type of the result returned by the task.</source>
          <target state="translated">Тип результата, возвращенного задачей.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>The cancellation token with which to complete the task.</source>
          
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> that's completed due to cancellation with a specified cancellation token.</source>
          
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>The canceled task.</source>
          
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>Cancellation has not been requested for <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>; its <ph id="ph2">&lt;see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /&gt;</ph> property is <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>The exception with which to complete the task.</source>
          
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> that has completed with a specified exception.</source>
          
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>The faulted task.</source>
          
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>This method creates a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> and whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property contains <ph id="ph5">`exception`</ph>.</source>
          <target state="translated">Этот метод создает <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> которого <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> свойство <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> и которого <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> свойство содержит <ph id="ph5">`exception`</ph>.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</source>
          <target state="translated">Метод обычно используется, когда известно сразу же, что работу, которую выполняет задача будет создано исключение перед выполнением более длинный путь кода.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>For an example, see the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> overload.</source>
          <target state="translated">Пример см. в разделе <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> перегрузки.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The type of the result returned by the task.</source>
          <target state="translated">Тип результата, возвращенного задачей.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The exception with which to complete the task.</source>
          
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> that's completed with a specified exception.</source>
          
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The faulted task.</source>
          
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>This method creates a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> and whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property contains <ph id="ph5">`exception`</ph>.</source>
          <target state="translated">Этот метод создает <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> которого <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> свойство <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> и которого <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> свойство содержит <ph id="ph5">`exception`</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</source>
          <target state="translated">Метод обычно используется, когда известно сразу же, что работу, которую выполняет задача будет создано исключение перед выполнением более длинный путь кода.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The example provides an illustration.</source>
          <target state="translated">Иллюстрация приведена в примере.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</source>
          <target state="translated">Следующий пример — программа командной строки, который вычисляет количество байтов в файлах в каждом каталоге, имя которого передается в качестве аргумента командной строки.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>Rather than executing a longer code path that instantiates a <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> object and retrieves the value of its <ph id="ph2">&lt;xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType&gt;</ph> property for each file in the directory, the example simply calls the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> method to create a faulted task if a particular subdirectory does not exist.</source>
          <target state="translated">Вместо выполнения более длинный путь кода, который создает экземпляры <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> объекта и возвращает значение его <ph id="ph2">&lt;xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType&gt;</ph> свойство для каждого файла в каталоге, в примере просто вызывается <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> метод для создания задачи, если определенный подкаталог не существует.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The type of the result returned by the task.</source>
          <target state="translated">Тип результата, возвращенного задачей.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The result to store into the completed task.</source>
          
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> that's completed successfully with the specified result.</source>
          
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The successfully completed task.</source>
          
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>This method creates a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property is <ph id="ph3">`result`</ph> and whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>.</source>
          <target state="translated">Этот метод создает <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> которого <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> свойство <ph id="ph3">`result`</ph> и которого <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> свойство <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The method is commonly used when the return value of a task is immediately known without executing a longer code path.</source>
          <target state="translated">Метод обычно используется, когда значение, возвращаемое при выполнении задачи немедленно известен без выполнения более длинный путь кода.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The example provides an illustration.</source>
          <target state="translated">Иллюстрация приведена в примере.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>To create a Task object that does not return a value, retrieve the Task object from the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CompletedTask%2A&gt;</ph> property.</source>
          <target state="translated">Чтобы создать объект задачи, которая не возвращает значение, получить объект задачи из <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CompletedTask%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</source>
          <target state="translated">Следующий пример — программа командной строки, который вычисляет количество байтов в файлах в каждом каталоге, имя которого передается в качестве аргумента командной строки.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>Rather than executing a longer code path that instantiates a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object and retrieves the value of its <ph id="ph2">&lt;xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType&gt;</ph> property for each file in the directory, the example simply calls the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> method to create a task whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property is zero (0) if a directory has no files.</source>
          <target state="translated">Вместо выполнения более длинный путь кода, который создает экземпляры <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> объекта и возвращает значение его <ph id="ph2">&lt;xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType&gt;</ph> свойство для каждого файла в каталоге, в примере просто вызывается <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> метод для создания задачи, <ph id="ph4">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> свойство равно нулю (0), если каталог не содержит файлов.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.GetAwaiter">
          <source>Gets an awaiter used to await this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.GetAwaiter">
          <source>An awaiter instance.</source>
          
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.GetAwaiter">
          <source>This method is intended for compiler use rather than for use in application code.</source>
          <target state="translated">Этот метод предназначен только для внутреннего использования, а не для использования в коде приложения.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Id">
          <source>Gets an ID for this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance.</source>
          
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>The identifier that is assigned by the system to this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance.</source>
          <target state="translated">Идентификатор, присвоенный системой данному экземпляру <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>Task IDs are assigned on-demand and do not necessarily represent the order in which task instances are created.</source>
          <target state="translated">Идентификаторы задач назначаются по требованию и не обязательно представляет порядок, в какие задачи создаются экземпляры.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</source>
          <target state="translated">Обратите внимание, что несмотря на то, что конфликты встречаются очень редко, задача не гарантируется, что идентификаторы быть уникальным.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>To get the task ID of the currently executing task from within code that that task is executing, use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> property.</source>
          <target state="translated">Чтобы получить идентификатор задачи, что текущая выполняющаяся задача в коде, который выполняет эту задачу, используйте <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>Gets whether this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has completed execution due to being canceled.</source>
          
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the task has completed due to being canceled; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если задача была завершена из-за отмены; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>A <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will complete in the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state under any of the following conditions:</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> завершится в <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> состояния при выполнении любого из следующих условий:</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> was marked for cancellation before the task started executing,</source>
          <target state="translated">Его <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> был помечен для отмены до начала выполнения задачи</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>The task acknowledged the cancellation request on its already signaled <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> by throwing an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> that bears the same <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>.</source>
          <target state="translated">Задача приняла запрос на отмену на уже сигнальное <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> путем создания исключения <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> , содержащим же <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>The task acknowledged the cancellation request on its already signaled <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> by calling the <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>.</source>
          <target state="translated">Задача приняла запрос на отмену на уже сигнальное <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> путем вызова <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A&gt;</ph> метод <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">Получение значения <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph> свойства не блокирует вызывающий поток до завершения задачи.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source>Gets whether this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has completed.</source>
          
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the task has completed; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если задача была завершена; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph> will return <ph id="ph2">`true`</ph> when the task is in one of the three final states: <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>, or <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph> Возвращает <ph id="ph2">`true`</ph> когда задача находится в одном из трех состояний окончательного: <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>, или <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">Получение значения <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType&gt;</ph> свойства не блокирует вызывающий поток до завершения задачи.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source>Gets whether the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed due to an unhandled exception.</source>
          
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the task has thrown an unhandled exception; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если задача создала необрабатываемое исключение; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> is <ph id="ph2">`true`</ph>, the task's <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> is equal to <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>, and its <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property will be non-null.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> — <ph id="ph2">`true`</ph>, задача <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> равен <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>и его <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> свойство будет иметь значение null.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">Получение значения <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType&gt;</ph> свойства не блокирует вызывающий поток до завершения задачи.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Queues the specified work to run on the ThreadPool and returns a task or <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> handle for that work.</source>
          
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method provides a set of overloads that make it easy to start a task by using default values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> Метод предоставляют несколько перегрузок, которые позволяют легко запустить задачу, используя значения по умолчанию.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>It is a lightweight alternative to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> overloads.</source>
          <target state="translated">Это упрощенная альтернатива <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> перегрузки.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The work to execute asynchronously</source>
          
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object that represents that work.</source>
          
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>A task that represents the work queued to execute in the ThreadPool.</source>
          
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method allows you to create and execute a task in a single method call and is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> Метод дает возможность создавать и выполнять задачи в одном вызове метода и является более простой альтернативой <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It creates a task with the following default values:</source>
          <target state="translated">Он создает задачу, со следующими значениями по умолчанию:</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Its cancellation token is <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Имеет свой токен отмены <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Его <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> значение свойства <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It uses the default task scheduler.</source>
          <target state="translated">Она использует планировщик задач по умолчанию.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Сведения об обработке исключений, вызванных операции задачи. в разделе <bpt id="p1">[</bpt>обработка исключений<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The following example defines a <ph id="ph1">`ShowThreadInfo`</ph> method  that displays the <ph id="ph2">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> of the current thread.</source>
          <target state="translated">В следующем примере определяется <ph id="ph1">`ShowThreadInfo`</ph> метод, отображающий <ph id="ph2">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> текущего потока.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It is called directly from the application thread, and is called from the <ph id="ph1">&lt;xref:System.Action&gt;</ph> delegate passed to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method.</source>
          <target state="translated">Он вызывается непосредственно из потока приложения и вызывается из <ph id="ph1">&lt;xref:System.Action&gt;</ph> делегат, переданный <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The following example is similar to the previous one, except that it uses a lambda expression to define the code that the task is to execute.</source>
          <target state="translated">Следующий пример аналогичен предыдущему, за исключением того, что лямбда-выражения используются для определения кода, которая будет выполнена задача.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The examples show that the asynchronous task executes on a different thread than the main application thread.</source>
          <target state="translated">В примерах, что асинхронная задача выполняется в другом потоке, чем основного потока приложения.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method ensures that the task completes and displays its output before the application ends.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> метод гарантирует, что задача завершается и отображение его выходных данных до окончания работы приложения.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Otherwise, it is possible that the <ph id="ph1">`Main`</ph> method will complete before the task finishes.</source>
          <target state="translated">В противном случае возможна ситуация, <ph id="ph1">`Main`</ph> метод будет выполнена до завершения задачи.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It defines an array of directory names and starts a separate task to retrieve the file names in each directory.</source>
          <target state="translated">Он определяет массив имен каталогов и запускает отдельную задачу, чтобы получить имена файлов в каждом каталоге.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>All tasks write the file names to a single <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">Все задачи записи имен файлов в один <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">Затем в примере вызывается <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> метода убедитесь, что все задачи завершены и затем отображает число общее количество имен файлов, записанных на <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>The work to execute asynchronously</source>
          
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the  task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>A task that represents a proxy for the task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Сведения об обработке исключений, вызванных операции задачи. в разделе <bpt id="p1">[</bpt>обработка исключений<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The work to execute asynchronously</source>
          
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>A cancellation token that can be used to cancel the work</source>
          
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object that represents that work.</source>
          
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>A cancellation token allows the work to be cancelled.</source>
          
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>A task that represents the work queued to execute in the thread pool.</source>
          
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>If cancellation is requested before the task begins execution, the task does not execute.</source>
          <target state="translated">При запросе отмены до выполнения начала задачи, задача не выполняется.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Instead it is set to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state and throws a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception.</source>
          <target state="translated">Вместо этого он становится равным <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> состояние и выдает исключение <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> method is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> Метода является более простой альтернативой <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>It creates a task with the following default values:</source>
          <target state="translated">Он создает задачу, со следующими значениями по умолчанию:</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Его <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> значение свойства <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>It uses the default task scheduler.</source>
          <target state="translated">Она использует планировщик задач по умолчанию.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Сведения об обработке исключений, вызванных операции задачи. в разделе <bpt id="p1">[</bpt>обработка исключений<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> method to create a task that iterates the files in the C:\Windows\System32 directory.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> метод для создания задачи, которая выполняет итерацию файлы в каталог C:\Windows\System32.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The lambda expression calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> method to add information about each  file to a <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object.</source>
          <target state="translated">Лямбда-выражение вызывает <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы добавить сведения о каждом файле <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Each detached nested task invoked by the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> loop checks the state of the cancellation token and, if cancellation is requested, calls the <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Каждый отсоединенной вложенной задачей, вызываемых <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> цикла проверяет состояние токена отмены и если запрос на отмену вызывает <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> exception that is handled in a <ph id="ph3">`catch`</ph> block when the calling thread calls the <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> Вызывает исключение <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> исключение, которое обрабатывается в <ph id="ph3">`catch`</ph> заблокировать, если вызывающий поток вызывает <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The work to execute asynchronously.</source>
          
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>A cancellation token that should be used to cancel the work.</source>
          
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>A task that represents a proxy for the task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Сведения об обработке исключений, вызванных операции задачи. в разделе <bpt id="p1">[</bpt>обработка исключений<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>The type of the result returned by the proxy task.</source>
          <target state="translated">Тип результата, возвращенного задачей прокси-сервера.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>The work to execute asynchronously</source>
          
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph2">&lt;paramref name="function" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>A <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> that represents a proxy for the <ph id="ph2">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph3">&lt;paramref name="function" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Сведения об обработке исключений, вызванных операции задачи. в разделе <bpt id="p1">[</bpt>обработка исключений<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The return type of the task.</source>
          <target state="translated">Тип возвращаемого значения задачи.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The work to execute asynchronously.</source>
          
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> object that represents that work.</source>
          
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>A task object that represents the work queued to execute in the thread pool.</source>
          
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> Метода является более простой альтернативой <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>It creates a task with the following default values:</source>
          <target state="translated">Он создает задачу, со следующими значениями по умолчанию:</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Its cancellation token is <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Имеет свой токен отмены <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Его <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> значение свойства <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>It uses the default task scheduler.</source>
          <target state="translated">Она использует планировщик задач по умолчанию.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Сведения об обработке исключений, вызванных операции задачи. в разделе <bpt id="p1">[</bpt>обработка исключений<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The following example counts the approximate number of words in text files that represent published books.</source>
          <target state="translated">В следующем примере подсчитывается приблизительное число слов в текстовых файлах, представляющие опубликованной книги.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Each task is responsible for opening a file, reading its entire contents asynchronously, and calculating the word count by using a regular expression.</source>
          <target state="translated">Каждая задача отвечает за открытие файла, асинхронного чтения всего его содержимого и подсчет слов с помощью регулярного выражения.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method is called to ensure that all tasks have completed before  displaying the word count of each book to the console.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> Будет вызван метод, убедитесь, что все задачи завершены перед отображением Статистика каждую книгу на консоль.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The regular expression <ph id="ph1">`\p{P}*\s+`</ph> matches zero, one, or more punctuation characters followed by one or more whitespace characters.</source>
          <target state="translated">Регулярное выражение <ph id="ph1">`\p{P}*\s+`</ph> заменяет ноль, один или несколько знаков препинания, за которыми следует один или несколько символов пробела.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>It assumes that the total number of matches equals the approximate word count.</source>
          <target state="translated">В примере предполагается, что общее количество совпадений равно приблизительные Статистика.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The type of the result returned by the proxy task.</source>
          <target state="translated">Тип результата, возвращенного задачей прокси-сервера.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The work to execute asynchronously</source>
          
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>A cancellation token that should be used to cancel the work</source>
          
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph2">&lt;paramref name="function" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> that represents a proxy for the <ph id="ph2">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph3">&lt;paramref name="function" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Сведения об обработке исключений, вызванных операции задачи. в разделе <bpt id="p1">[</bpt>обработка исключений<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The result type of the task.</source>
          <target state="translated">Тип результата задачи.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The work to execute asynchronously</source>
          
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>A cancellation token that should be used to cancel the work</source>
          
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> object that represents that work.</source>
          
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>A cancellation token allows the work to be cancelled.</source>
          
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> that represents the work queued to execute in the thread pool.</source>
          
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>If cancellation is requested before the task begins execution, the task does not execute.</source>
          <target state="translated">При запросе отмены до выполнения начала задачи, задача не выполняется.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Instead it is set to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state and throws a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception.</source>
          <target state="translated">Вместо этого он становится равным <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> состояние и выдает исключение <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> Метода является более простой альтернативой <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>It creates a task with the following default values:</source>
          <target state="translated">Он создает задачу, со следующими значениями по умолчанию:</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Его <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> значение свойства <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>It uses the default task scheduler.</source>
          <target state="translated">Она использует планировщик задач по умолчанию.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Сведения об обработке исключений, вызванных операции задачи. в разделе <bpt id="p1">[</bpt>обработка исключений<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</source>
          <target state="translated">В следующем примере создается 20 задачи, которые будут непрерывное значение счетчика увеличивается значение 2 миллионов.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</source>
          <target state="translated">По достижении 2 миллиона первые 10 задачи токен отмены отменяется и будут отменены все задачи, счетчики не достигли 2 миллионов.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The example shows possible output.</source>
          <target state="translated">В примере возможного выхода.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Instead of using the <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A&gt;</ph> property to   examine exceptions, the example iterates all tasks to determine which have completed successfully and which have been cancelled.</source>
          <target state="translated">Вместо использования <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A&gt;</ph> свойство для проверки исключений, в примере выполняется итерация все задачи, чтобы определить, которой была выполнена успешно и которого были отменены.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>For those that have completed, it displays the value returned by the task.</source>
          <target state="translated">Для тех, которые будут завершены он отображает значение, возвращенного задачей.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Because cancellation is cooperative, each task can decide how to respond to cancellation.</source>
          <target state="translated">Так как Отмена выполняется совместно, каждую задачу можно решить, как реагировать на отмену.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The following example is like the first, except that, once the token is cancelled, tasks return the number of iterations they've completed rather than throw an exception.</source>
          <target state="translated">Следующий пример аналогичен первому, за исключением того, что после токена отмены задач возвращают число итераций, они завершили вместо создания исключения.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The example still must handle the <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception,   since any tasks that have not started when cancellation is requested still throw an exception.</source>
          <target state="translated">Пример по-прежнему необходимо обрабатывать <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> исключения, поскольку все задачи, которые не были запущены при запросе отмены по-прежнему создаст исключение.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Runs the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> synchronously on the current <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Runs the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> synchronously on the current <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Ordinarily, tasks are executed asynchronously on a thread pool thread and do not block the calling thread.</source>
          <target state="translated">Как правило задачи выполняются асинхронно в потоке пула потоков и не блокирует вызывающий поток.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Tasks executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> method are associated with the current <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> and are run on the calling thread.</source>
          <target state="translated">Задачи выполняется путем вызова <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> метод связаны с текущим <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> и выполняются в вызывающем потоке.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>If the target scheduler does not support running this task on the calling thread, the task will be scheduled for execution on the scheduler, and the calling thread will block until the task has completed execution.</source>
          <target state="translated">Если целевой планировщик не поддерживает выполнение этой задачи в вызывающем потоке, задача будет запланирована для выполнения в планировщике и вызывающий поток будет заблокирован до завершения выполнения задачи.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Even though the task runs synchronously, the calling thread should still call <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> to handle any exceptions that the task might throw.</source>
          <target state="translated">Даже если задача выполняется синхронно, что вызывающий поток рекомендуется вызывать <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> для обработки исключений, которые могут создавать задачи.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>For more information on exception handling, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об обработке исключений см. в разделе <bpt id="p1">[</bpt>обработка исключений<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Tasks executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method are instantiated by calling a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class constructor.</source>
          <target state="translated">Задачи выполняется путем вызова <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> метод создаются путем вызова <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> или <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> конструктора класса.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The task to be run synchronously must be in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> state.</source>
          <target state="translated">Задание для синхронного запуска должно быть в <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> состояние.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>A task may be started and run only once.</source>
          <target state="translated">Задачи могут быть запущены и работают только один раз.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Any attempts to schedule a task a second time results in an exception.</source>
          <target state="translated">Любые попытки запланировать задачу второй времени приводит к исключению.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The following example compares a task executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method with one executed asynchronously.</source>
          <target state="translated">В следующем примере сравниваются задачи выполняется путем вызова <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> метод с одним асинхронное выполнение.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>In both cases, the tasks execute identical lambda expressions that display the task ID and the ID of the thread on which the task is running.</source>
          <target state="translated">В обоих случаях задачи выполнения идентичных лямбда-выражений, содержащих идентификатор задачи и идентификатор потока, на котором запущена задача.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The task calculates the sum of the integers between 1 and 1,000,000.</source>
          <target state="translated">Задача вычисляет сумму целые числа от 1 до 1 000 000.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>As the output from the example shows, the task executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method runs on the application thread, while the asynchronous task does not.</source>
          <target state="translated">Как показывают выходные данные примера, задача выполняется путем вызова <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> метод выполняется в потоке приложения во время асинхронной задачи — нет.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The scheduler on which to attempt to run this task inline.</source>
          
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Runs the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> synchronously on the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> provided.</source>
          
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Tasks executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method are instantiated by calling a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class constructor.</source>
          <target state="translated">Задачи выполняется путем вызова <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> метод создаются путем вызова <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> или <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> конструктора класса.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The task to be run synchronously must be in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> state.</source>
          <target state="translated">Задание для синхронного запуска должно быть в <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> состояние.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>A task may be started and run only once.</source>
          <target state="translated">Задачи могут быть запущены и работают только один раз.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Any attempts to schedule a task a second time results in an exception.</source>
          <target state="translated">Любые попытки запланировать задачу второй времени приводит к исключению.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>If the target scheduler does not support running this task on the current thread, the task will be scheduled for execution on the scheduler, and the current thread will block until the task has completed execution.</source>
          <target state="translated">Если целевой планировщик не поддерживает выполнение этой задачи в текущем потоке, задача будет запланирована для выполнения в планировщике, а текущий поток будет заблокирован до завершения выполнения задачи.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Because of this, the calling thread does not need to call a method such as <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> to ensure that the task has completed execution.</source>
          <target state="translated">По этой причине вызывающий поток не требуется вызывать метод, например <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> чтобы убедиться, что задача завершила выполнение.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>For more information on exception handling for task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о обработки исключений для операции задачи. в разделе <bpt id="p1">[</bpt>обработка исключений<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Starts the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>Starts the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, scheduling it for execution to the current <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>A task may be started and run only once.</source>
          <target state="translated">Задачи могут быть запущены и работают только один раз.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>Any attempts to schedule a task a second time will result in an exception.</source>
          <target state="translated">Любые попытки запланировать задачу во второй раз будет приведет к исключению.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> is used to execute a task that has been created by calling one of the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> constructors.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> Используется для выполнения задачи, которая создана путем вызова одного из <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> конструкторы.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>Typically, you do this when you need to separate the task's creation from its execution, such as when you conditionally execute tasks that you've created.</source>
          <target state="translated">Как правило это делается при необходимо отделить создания задачи из ее выполнения, например когда позволяет выполнять задачи, которые вы создали.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>For the more common case in which you don't need to separate  task instantiation from execution, we recommend that you call an overload of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Для более распространенный случай, в котором не требуется разделения задач при создании экземпляра выполнения, рекомендуется вызывать перегрузку <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Сведения об обработке исключений, вызванных операции задачи. в разделе <bpt id="p1">[</bpt>обработка исключений<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> constructor to instantiate a new <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object that displays its task ID and managed thread ID and then executes a loop.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> конструктор для создания нового <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объекта, который отображает своей задачи, идентификатор и идентификатор управляемого потока, а затем выполняет цикл.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> method to execute the task.</source>
          <target state="translated">Затем он вызывает <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> метод для выполнения задачи.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>Since this is a console app, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method is necessary to prevent the app from terminating before the task finishes execution.</source>
          <target state="translated">Так как это консольное приложение, вызов <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> метод необходим предотвратить приложение завершается до завершения выполнения задачи.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> with which to associate and execute this task.</source>
          
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>Starts the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, scheduling it for execution to the specified <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>A task may only be started and run only once.</source>
          <target state="translated">Задача может только работы и запустить только один раз.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>Any attempts to schedule a task a second time will result in an exception.</source>
          <target state="translated">Любые попытки запланировать задачу во второй раз будет приведет к исключению.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Сведения об обработке исключений, вызванных операции задачи. в разделе <bpt id="p1">[</bpt>обработка исключений<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The scheduler was unable to queue this task.</source>
          
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Status">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskStatus" /&gt;</ph> of this task.</source>
          
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskStatus" /&gt;</ph> of this task instance.</source>
          <target state="translated">Текущее состояние <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskStatus" /&gt;</ph> данного экземпляра задачи.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">Получение значения <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> свойства не блокирует вызывающий поток до завершения задачи.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>For more information and an example, see <bpt id="p1">[</bpt>Chaining Tasks by Using Continuation Tasks<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept> and <bpt id="p2">[</bpt>How to: Cancel a Task and Its Children<ept id="p2">](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)</ept>.</source>
          <target state="translated">Дополнительные сведения и пример см. в разделе <bpt id="p1">[</bpt>создание цепочки задач с помощью задач продолжения<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept> и <bpt id="p2">[</bpt>как: Отмена задачи и ее дочерних элементов<ept id="p2">](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)</ept>.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</source>
          <target state="translated">В следующем примере создается 20 задачи, которые будут непрерывное значение счетчика увеличивается значение 2 миллионов.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</source>
          <target state="translated">По достижении 2 миллиона первые 10 задачи токен отмены отменяется и будут отменены все задачи, счетчики не достигли 2 миллионов.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>The example then examines the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property of each task to indicate whether it completed successfully or was cancelled.</source>
          <target state="translated">Затем в примере рассматривается <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> свойства каждой задачи, чтобы показать его успешно завершена или отменена.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>For those that completed, it displays the value returned by the task.</source>
          <target state="translated">Для тех, которые выполнены отображается значение, возвращенного задачей.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> that can be used to wait for the task to complete.</source>
          
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> that can be used to wait for the task to complete.</source>
          <target state="translated">Дескриптор <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph>, который можно использовать для ожидания завершения задачи.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>Using the wait functionality provided by <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> is preferable to using <ph id="ph2">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> for similar functionality.</source>
          <target state="translated">С помощью функции ожидания <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> предпочтительным является использование <ph id="ph2">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> для аналогичные функциональные возможности.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>For more information, see the "Waiting on Tasks" section in <bpt id="p1">[</bpt>Task-based Asynchronous Programming<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> and <bpt id="p2">[</bpt>Using TPL with Other Asynchronous Patterns<ept id="p2">](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе «Ожидание на задачи» <bpt id="p1">[</bpt>на основе задач асинхронное программирование<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> и <bpt id="p2">[</bpt>с помощью TPL в другие асинхронные шаблоны<ept id="p2">](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md)</ept>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously">
          <source>Gets an indication of whether the operation completed synchronously.</source>
          
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation completed synchronously; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если операция завершилась синхронно, в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> is a synchronization method that causes the calling thread to wait until the current task has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> способ синхронизации, вызывающий поток ожидает завершения выполнения текущей задачи.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>If the current task has not started execution, the Wait method attempts to remove the task from the scheduler and execute it inline on the current thread.</source>
          <target state="translated">Если текущая задача не начато выполнение, ожидания метод пытается удалить задание из планировщика и выполняться встроено в текущем потоке.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>If it is unable to do that, or if the current task has already started execution, it blocks the calling thread until the task completes.</source>
          <target state="translated">Если это не удается сделать или началом выполнения текущей задачи, блокирует вызывающий поток до завершения задачи.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>For more information, see <bpt id="p1">[</bpt>Task.Wait and "Inlining"<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Task.Wait и «Встраивание»<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx)</ept> в параллельное программирование с блога .NET.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>For more information and an example, see <bpt id="p1">[</bpt>How to: Wait on One or More Tasks to Complete<ept id="p1">](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374)</ept>.</source>
          <target state="translated">Дополнительные сведения и пример см. в разделе <bpt id="p1">[</bpt>как: ожидание одной или нескольких задач, чтобы завершить<ept id="p1">](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374)</ept>.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The following example starts a task that generates one million random integers between 0 and 100 and computes their mean.</source>
          <target state="translated">В следующем примере запускается задача, которая создает один миллион случайных целых чисел от 0 до 100 и вычисляет их среднее.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method to ensure that the task completes before the application terminates.</source>
          <target state="translated">В этом примере <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> метод, чтобы гарантировать, что задача завершается перед завершением работы приложения.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>Otherwise, because this is a console application, the example would terminate before the task can compute and display the mean.</source>
          <target state="translated">В противном случае это консольное приложение, пример завершает работу, прежде чем задача может вычислений и отобразить среднее значение.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The task was canceled.</source>
          
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>An exception was thrown during the execution of the task.</source>
          
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution within a specified number of milliseconds.</source>
          
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> — Это метод синхронизации, который позволяет вызвавшему потоку ожидания для текущего экземпляра завершиться, пока не произойдет одно из следующих задач:</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The task completes successfully.</source>
          <target state="translated">Задача завершается успешно.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The task itself is canceled or throws an exception.</source>
          <target state="translated">Сама задача отменяется или создает исключение.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>In this case, you handle an <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</source>
          <target state="translated">В этом случае вы обрабатываете <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> property contains details about the exception or exceptions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> Свойство содержит информацию об исключении или исключения.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The interval defined by <ph id="ph1">`millisecondsTimeout`</ph> elapses.</source>
          <target state="translated">Интервал, заданный <ph id="ph1">`millisecondsTimeout`</ph> истекает.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>In this case, the current thread resumes execution and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">В этом случае текущий поток возобновляет выполнение, а метод возвращает <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</source>
          <target state="translated">В следующем примере запускается задача, которая приводит к возникновению ошибки 5 миллионов случайных целых чисел от 0 до 100 и вычисляет их среднее.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> method to wait for the application to complete within 150 milliseconds.</source>
          <target state="translated">В этом примере <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> метод для ожидания приложению завершиться до 150 миллисекунд.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</source>
          <target state="translated">Если приложение обычно завершает, задача отображается сумма и среднее значение случайных чисел, который его создал.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>If the timeout interval has elapsed, the example displays a message before it terminates.</source>
          <target state="translated">Если истечения интервала времени ожидания, выводится сообщение перед завершением.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The task was canceled.</source>
          
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>An exception was thrown during the execution of the task.</source>
          
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>A cancellation token to observe while waiting for the task to complete.</source>
          
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The wait terminates if a cancellation token is canceled before the task completes.</source>
          
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> method creates a cancelable wait; that is, it causes the current thread to wait until one of the following occurs:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> Метод создает отменяемого ожидания, то есть вызывает текущий поток, подождите, пока не произойдет одно из следующих действий:</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The task completes.</source>
          <target state="translated">Задача завершается.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The cancellation token is canceled.</source>
          <target state="translated">Токен отмены отменяется.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>In this case, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>.</source>
          <target state="translated">В этом случае вызов <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> вызывает исключение <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Canceling the <ph id="ph1">`cancellationToken`</ph> cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</source>
          <target state="translated">Отмена <ph id="ph1">`cancellationToken`</ph> токен отмены не оказывает влияния на выполняющееся задание, если только он также был передан токен отмены и готовы к обработке отмены.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Passing the <ph id="ph1">`cancellationToken`</ph> object to this method simply allows the wait to be canceled.</source>
          <target state="translated">Передача <ph id="ph1">`cancellationToken`</ph> объект в этот метод просто позволяет ожидания отменяется.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The following example illustrates the simple use of a cancellation token to cancel waiting for a task's completion.</source>
          <target state="translated">В следующем примере простое использование токена отмены для отмены время ожидания завершения задачи.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>A task is launched, calls the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> method to cancel any of the token source's cancellation tokens, and then delays for five seconds.</source>
          <target state="translated">Задача запускается, вызывает <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы отменить все токены отмены Источник токена и затем задержки пять секунд.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Note that the task itself has not been passed the cancellation token and is not cancelable.</source>
          <target state="translated">Обратите внимание, что сама задача не прошел токен отмены и не может быть отменен.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The application thread calls the task's <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method to wait for the task to complete, but the wait is canceled once the cancellation token is cancelled and an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> is thrown.</source>
          <target state="translated">Поток приложения вызывает задачу <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> метод для ожидания завершения задачи, но время ожидания будет отменена после отмены токена отмены и <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> возникает исключение.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The exception handler reports the exception and then sleeps for six seconds.</source>
          <target state="translated">Обработчик исключений выдает исключение и затем бездействует в течение шести секунд.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>As the output from the example shows, that delay allows the task to complete in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Как показывают выходные данные примера, что задержка позволяет задачи для выполнения в <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> состоянии.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The task has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The task was canceled.</source>
          
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of the task.</source>
          
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution within a specified time interval.</source>
          
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> — Это метод синхронизации, который позволяет вызвавшему потоку ожидания для текущего экземпляра завершиться, пока не произойдет одно из следующих задач:</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The task completes successfully.</source>
          <target state="translated">Задача завершается успешно.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The task itself is canceled or throws an exception.</source>
          <target state="translated">Сама задача отменяется или создает исключение.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>In this case, you handle an <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</source>
          <target state="translated">В этом случае вы обрабатываете <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> property contains details about the exception or exceptions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> Свойство содержит информацию об исключении или исключения.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The interval defined by <ph id="ph1">`timeout`</ph> elapses.</source>
          <target state="translated">Интервал, заданный <ph id="ph1">`timeout`</ph> истекает.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>In this case, the current thread resumes execution and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">В этом случае текущий поток возобновляет выполнение, а метод возвращает <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</source>
          <target state="translated">В следующем примере запускается задача, которая приводит к возникновению ошибки 5 миллионов случайных целых чисел от 0 до 100 и вычисляет их среднее.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> method to wait for the application to complete within 150 milliseconds.</source>
          <target state="translated">В этом примере <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> метод для ожидания приложению завершиться до 150 миллисекунд.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</source>
          <target state="translated">Если приложение обычно завершает, задача отображается сумма и среднее значение случайных чисел, который его создал.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>If the timeout interval has elapsed, the example displays a message before it terminates.</source>
          <target state="translated">Если истечения интервала времени ожидания, выводится сообщение перед завершением.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The task was canceled.</source>
          
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>An exception was thrown during the execution of the task.</source>
          
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe while waiting for the task to complete.</source>
          
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The wait terminates if a timeout interval elapses or a cancellation token is canceled before the task completes.</source>
          
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> — Это метод синхронизации, который позволяет вызвавшему потоку ожидания для текущего экземпляра завершиться, пока не произойдет одно из следующих задач:</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The task completes successfully.</source>
          <target state="translated">Задача завершается успешно.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The task itself is canceled or throws an exception.</source>
          <target state="translated">Сама задача отменяется или создает исключение.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>In this case, you handle an <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</source>
          <target state="translated">В этом случае вы обрабатываете <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> property contains details about the exception or exceptions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> Свойство содержит информацию об исключении или исключения.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">`cancellationToken`</ph> cancellation token is canceled.</source>
          <target state="translated"><ph id="ph1">`cancellationToken`</ph> Токен отмены отменяется.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>In this case, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>.</source>
          <target state="translated">В этом случае вызов <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> вызывает исключение <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The interval defined by <ph id="ph1">`millisecondsTimeout`</ph> elapses.</source>
          <target state="translated">Интервал, заданный <ph id="ph1">`millisecondsTimeout`</ph> истекает.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>In this case, the current thread resumes execution and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">В этом случае текущий поток возобновляет выполнение, а метод возвращает <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Canceling the <ph id="ph1">`cancellationToken`</ph> cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</source>
          <target state="translated">Отмена <ph id="ph1">`cancellationToken`</ph> токен отмены не оказывает влияния на выполняющееся задание, если только он также был передан токен отмены и готовы к обработке отмены.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Passing the <ph id="ph1">`cancellationToken`</ph> object to this method simply allows the wait to be canceled based on some condition.</source>
          <target state="translated">Передача <ph id="ph1">`cancellationToken`</ph> объект в этот метод просто позволяет ожидание, отмену на основе некоторых условий.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> method to provide both a timeout value and a cancellation token that can end the wait for a task's completion.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> метод, чтобы предоставить значение времени ожидания и отмену маркер, который можно завершить ожидания завершения задачи.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>A new thread is started and executes the <ph id="ph1">`CancelToken`</ph> method, which pauses and then calls the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> method to cancel the cancellation tokens.</source>
          <target state="translated">Новый поток запускается и выполняет <ph id="ph1">`CancelToken`</ph> метод, который приостанавливает и затем вызывает метод <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> метода для отмены токенов отмены.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>A task is then launched and delays for 5 seconds.</source>
          <target state="translated">Задачу, а затем запускается и откладывается на 5 секунд.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method is then called to wait for the task's completion and is provided both a brief timeout value and a cancellation token.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> Метод вызывается для ожидания завершения задач и предоставляется краткое время ожидания и токен отмены.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Note that the precise output from the example depends on whether the wait was canceled because of the cancellation token or because the timeout interval elapsed.</source>
          <target state="translated">Обратите внимание, что точный вывод примера зависит ли ожидание была отменена из-за токен отмены, или из-за интервал времени ожидания.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The task was canceled.</source>
          
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of the task.</source>
          
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The following example starts 10 tasks, each of which is passed an index as a state object.</source>
          <target state="translated">В следующем примере запускается 10 задач, каждая из которых передается индекс как объект состояния.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>Tasks with an index from two to five throw exceptions.</source>
          <target state="translated">Задачи с индексом от двух до пяти вызывать исключения.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> method wraps all exceptions in an <ph id="ph2">&lt;xref:System.AggregateException&gt;</ph> object and propagates it to the calling thread.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> метод создает оболочку для всех исключений в <ph id="ph2">&lt;xref:System.AggregateException&gt;</ph> объекта и распространяет его в вызывающий поток.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> exception contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> exception in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds.</source>
          
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if all of the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for the tasks to complete.</source>
          
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution unless the wait is cancelled.</source>
          
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">`cancellationToken`</ph> argument is used to cancel the wait operation.</source>
          <target state="translated"><ph id="ph1">`cancellationToken`</ph> Аргумент используется для отмены операции ожидания.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>Cancellation of the tasks is a distinct operation, and is signaled by the <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> as noted above.</source>
          <target state="translated">Отмена задач — это отдельная операция и получает сигнал посредством <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> как указано выше.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>Waits for all of the provided cancellable <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified time interval.</source>
          
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if all of the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for the tasks to complete.</source>
          
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds or until the wait is cancelled.</source>
          
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if all of the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">`cancellationToken`</ph> argument is used to cancel the wait operation.</source>
          <target state="translated"><ph id="ph1">`cancellationToken`</ph> Аргумент используется для отмены операции ожидания.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>Cancellation of the tasks is a distinct operation, and is signaled by the <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> noted above.</source>
          <target state="translated">Отмена задач — это отдельная операция и получает сигнал посредством <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> указанных выше.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The index of the completed <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object in the <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> array.</source>
          
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The following example launches five tasks, each of which sleeps for a minimum of 50 milliseconds or a maximum of 1,050 milliseconds.</source>
          <target state="translated">Следующий пример запускает пять задач, каждая из которых находится в неактивном состоянии как минимум 50 мс или более 1,050 миллисекунд.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%2A&gt;</ph> method then waits for any of the tasks to complete.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%2A&gt;</ph> Метод ждет задач для выполнения.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The example displays the task ID of the task that ended the wait, as well as the current status of all the tasks.</source>
          <target state="translated">В примере отображается идентификатор задачи ожидания завершения задачи, а также текущее состояние всех задач.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds.</source>
          
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument, or -1 if the timeout occurred.</source>
          
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for a task to complete.</source>
          
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution unless the wait is cancelled.</source>
          
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument.</source>
          
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified time interval.</source>
          
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument, or -1 if the timeout occurred.</source>
          
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for a task to complete.</source>
          
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds or until a cancellation token is cancelled.</source>
          
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument, or -1 if the timeout occurred.</source>
          
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a task that will complete when all of the supplied tasks have completed.</source>
          
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The tasks to wait on for completion.</source>
          
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in an enumerable collection have completed.</source>
          
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method that return a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</source>
          <target state="translated">Перегруженные версии <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> метода, который возвращает <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объекта вызываются обычно в том случае, когда вы заинтересованы в состояние набор задач или исключения, вызываемые набора задач.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> метод не блокирует вызывающий поток.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state,  where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">Если любой из предоставленных задач завершается в состоянии сбоя, возвращенная задача завершится в также <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> состояния, где его исключения будет содержать агрегат набор оболочку исключений из всех предоставленных задач.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Если ни один из предоставленных задач в состоянии faulted, но по крайней мере один из них было отменено, возвращаемая задача будет помещен в <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> состояние.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Если ни одна из задач в состоянии сбоя, и ни одна из задач были отменены, результирующая задача завершается в <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> состояние.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">При предоставленного массива или перечисления не содержит задач, возвращаемая задача будет сразу же перейти к <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> прежде, чем он возвращается вызывающему объекту.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The following example creates a set of tasks that ping the URLs in an array.</source>
          <target state="translated">В следующем примере создается набор задач, которые проверить связь с URL-адреса в массиве.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The tasks are stored in a <ph id="ph1">`List&lt;Task&gt;`</ph> collection that is passed to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method.</source>
          <target state="translated">Задания хранятся в <ph id="ph1">`List&lt;Task&gt;`</ph> коллекции, передаваемое <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>After the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method ensures that all threads have completed, the example examines the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> property to determine whether any tasks have faulted.</source>
          <target state="translated">После вызова <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> метод гарантирует, что выполнены все потоки, в примере рассматривается <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> свойства, чтобы определить, ли все задачи в состоянии faulted.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> collection contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          
        </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The tasks to wait on for completion.</source>
          
        </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in an array have completed.</source>
          
        </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          
        </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method that return a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</source>
          <target state="translated">Перегруженные версии <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> метода, который возвращает <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объекта вызываются обычно в том случае, когда вы заинтересованы в состояние набор задач или исключения, вызываемые набора задач.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> метод не блокирует вызывающий поток.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">Если любой из предоставленных задач завершается в состоянии сбоя, возвращенная задача завершится в также <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> состояния, где его исключения будет содержать агрегат набор оболочку исключений из всех предоставленных задач.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Если ни один из предоставленных задач в состоянии faulted, но по крайней мере один из них было отменено, возвращаемая задача будет помещен в <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> состояние.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Если ни одна из задач в состоянии сбоя, и ни одна из задач были отменены, результирующая задача завершается в <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> состояние.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">При предоставленного массива или перечисления не содержит задач, возвращаемая задача будет сразу же перейти к <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> прежде, чем он возвращается вызывающему объекту.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The following example creates a set of tasks that ping the URLs in an array.</source>
          <target state="translated">В следующем примере создается набор задач, которые проверить связь с URL-адреса в массиве.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The tasks are stored in a <ph id="ph1">`List&lt;Task&gt;`</ph> collection that is converted to an array and passed to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method.</source>
          <target state="translated">Задания хранятся в <ph id="ph1">`List&lt;Task&gt;`</ph> коллекцию, которая преобразуется в массив и передается в <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>After the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method ensures that all threads have completed, the example examines the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> property to determine whether any tasks have faulted.</source>
          <target state="translated">После вызова <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> метод гарантирует, что выполнены все потоки, в примере рассматривается <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> свойства, чтобы определить, ли все задачи в состоянии faulted.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          
        </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The type of the completed task.</source>
          <target state="translated">Тип завершенной задачи.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The tasks to wait on for completion.</source>
          
        </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> objects in an enumerable collection have completed.</source>
          
        </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          
        </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29&gt;</ph> метод не блокирует вызывающий поток.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>However, a call to the returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> property does block the calling thread.</source>
          <target state="translated">Тем не менее вызов возвращаемый <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> свойство блокирует вызывающий поток.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">Если любой из предоставленных задач завершается в состоянии сбоя, возвращенная задача завершится в также <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> состояния, где его исключения будет содержать агрегат набор оболочку исключений из всех предоставленных задач.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Если ни один из предоставленных задач в состоянии faulted, но по крайней мере один из них было отменено, возвращаемая задача будет помещен в <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> состояние.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Если ни одна из задач в состоянии сбоя, и ни одна из задач были отменены, результирующая задача завершается в <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> состояние.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output task's <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property will return an <ph id="ph3">`TResult[]`</ph> where <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> Свойства возвращаемой задачи будет присвоено массив, содержащий все результаты из предоставленных задач в том же порядке, как они были указаны (например, если входные данные задачи в массиве t1, t2, t3, выходная задача <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> свойство будет возвращать <ph id="ph3">`TResult[]`</ph> где <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If the <ph id="ph1">`tasks`</ph> argument contains no tasks, the returned task will immediately transition to a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">Если <ph id="ph1">`tasks`</ph> содержат ни одна задача, возвращаемая задача немедленно перейдет <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> прежде, чем он возвращается вызывающему объекту.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The returned <ph id="ph1">`TResult[]`</ph> will be an array of 0 elements.</source>
          <target state="translated">Возвращенный <ph id="ph1">`TResult[]`</ph> будет массивом 0 элементов.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</source>
          <target state="translated">В следующем примере создается десять задач, каждая из которых создает генератора случайных чисел, который создает 1 000 случайных чисел от 1 до 1000 и вычисляет их среднее.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> Метод используется для задержки при создании экземпляра генераторов случайных чисел, чтобы они не были созданы одинаковые начальные значения.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method then returns an <ph id="ph2">&lt;xref:System.Int64&gt;</ph> array that contains the mean computed by each task.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> метод затем возвращает <ph id="ph2">&lt;xref:System.Int64&gt;</ph> массив, содержащий среднее вычисляется по каждой задаче.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>These are then used to calculate the overall mean.</source>
          <target state="translated">Затем эти значения используются для вычисления общее среднее.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>In this case, the ten individual tasks are stored in a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object.</source>
          <target state="translated">В этом случае десяти отдельных задач хранятся в <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface.</source>
          <target state="translated">Класс <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> реализует интерфейс списка <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> collection contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The type of the completed task.</source>
          <target state="translated">Тип завершенной задачи.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The tasks to wait on for completion.</source>
          
        </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> objects in an array have completed.</source>
          
        </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          
        </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29&gt;</ph> метод не блокирует вызывающий поток.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>However, a call to the returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> property does block the calling thread.</source>
          <target state="translated">Тем не менее вызов возвращаемый <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> свойство блокирует вызывающий поток.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">Если любой из предоставленных задач завершается в состоянии сбоя, возвращенная задача завершится в также <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> состояния, где его исключения будет содержать агрегат набор оболочку исключений из всех предоставленных задач.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Если ни один из предоставленных задач в состоянии faulted, но по крайней мере один из них было отменено, возвращаемая задача будет помещен в <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> состояние.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Если ни одна из задач в состоянии сбоя, и ни одна из задач были отменены, результирующая задача завершается в <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> состояние.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output   task's <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> will return an <ph id="ph3">`TResult[]`</ph> where <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> Возвращаемой задачи будет присвоено массив, содержащий все результаты из предоставленных задач в том же порядке, как они были указаны (например, если входные данные задачи в массиве t1, t2, t3, выходная задача <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> вернет <ph id="ph3">`TResult[]`</ph> где <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">При предоставленного массива или перечисления не содержит задач, возвращаемая задача будет сразу же перейти к <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> прежде, чем он возвращается вызывающему объекту.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The returned <ph id="ph1">`TResult[]`</ph> will be an array of 0 elements.</source>
          <target state="translated">Возвращенный <ph id="ph1">`TResult[]`</ph> будет массивом 0 элементов.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</source>
          <target state="translated">В следующем примере создается десять задач, каждая из которых создает генератора случайных чисел, который создает 1 000 случайных чисел от 1 до 1000 и вычисляет их среднее.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>In this case, the ten individual tasks are stored in a <ph id="ph1">`Task&lt;Int64&gt;`</ph> array.</source>
          <target state="translated">В этом случае десяти отдельных задач хранятся в <ph id="ph1">`Task&lt;Int64&gt;`</ph> массива.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> Метод используется для задержки при создании экземпляра генераторов случайных чисел, чтобы они не были созданы одинаковые начальные значения.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method then returns an <ph id="ph2">&lt;xref:System.Int64&gt;</ph> array that contains the mean computed by each task.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> метод затем возвращает <ph id="ph2">&lt;xref:System.Int64&gt;</ph> массив, содержащий среднее вычисляется по каждой задаче.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>These are then used to calculate the overall mean.</source>
          <target state="translated">Затем эти значения используются для вычисления общее среднее.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          
        </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          
        </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The tasks to wait on for completion.</source>
          
        </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          
        </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          
        </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The return task's Result is the task that completed.</source>
          
        </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">Возвращаемая задача будет выполнена, когда завершения какой-либо из предоставленных задач.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The returned task will always end in the <ph id="ph1">`RanToCompletion`</ph> state  with its Result set to the first task to complete.</source>
          <target state="translated">Возвращаемая задача всегда будет заканчиваться <ph id="ph1">`RanToCompletion`</ph> с результирующий набор для первой задачи для выполнения.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>This is true even if the first task to complete ended in the <ph id="ph1">`Canceled`</ph> or <ph id="ph2">`Faulted`</ph> state.</source>
          <target state="translated">Это верно, даже если завершился первую задачу для завершения <ph id="ph1">`Canceled`</ph> или <ph id="ph2">`Faulted`</ph> состояния.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          
        </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The tasks to wait on for completion.</source>
          
        </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          
        </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          
        </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The return task's Result is the task that completed.</source>
          
        </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">Возвращаемая задача будет выполнена, когда завершения какой-либо из предоставленных задач.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The returned task will always end in the <ph id="ph1">`RanToCompletion`</ph> state   with its <ph id="ph2">`Result`</ph> set to the first task to complete.</source>
          <target state="translated">Возвращаемая задача всегда будет заканчиваться <ph id="ph1">`RanToCompletion`</ph> с его <ph id="ph2">`Result`</ph> присвоено первой задачи для выполнения.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>This is true even if the first task to complete ended in the <ph id="ph1">`Canceled`</ph> or <ph id="ph2">`Faulted`</ph> state.</source>
          <target state="translated">Это верно, даже если завершился первую задачу для завершения <ph id="ph1">`Canceled`</ph> или <ph id="ph2">`Faulted`</ph> состояния.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was null.</source>
          
        </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          
        </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The type of the completed task.</source>
          <target state="translated">Тип завершенной задачи.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The tasks to wait on for completion.</source>
          
        </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          
        </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          
        </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The return task's Result is the task that completed.</source>
          
        </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">Возвращаемая задача будет выполнена, когда завершения какой-либо из предоставленных задач.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</source>
          <target state="translated">Возвращаемая задача всегда заканчивается в состоянии RanToCompletion результирующий набор для первой задачи для выполнения.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>This is true even if the first task to complete ended in the Canceled or Faulted state.</source>
          <target state="translated">Это верно, даже если окончания завершения первой задачи в состояние Canceled или Faulted.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          
        </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The type of the completed task.</source>
          <target state="translated">Тип завершенной задачи.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The tasks to wait on for completion.</source>
          
        </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          
        </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          
        </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The return task's Result is the task that completed.</source>
          
        </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">Возвращаемая задача будет выполнена, когда завершения какой-либо из предоставленных задач.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</source>
          <target state="translated">Возвращаемая задача всегда заканчивается в состоянии RanToCompletion результирующий набор для первой задачи для выполнения.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>This is true even if the first task to complete ended in the Canceled or Faulted state.</source>
          <target state="translated">Это верно, даже если окончания завершения первой задачи в состояние Canceled или Faulted.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was null.</source>
          
        </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          
        </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>Creates an awaitable task that asynchronously yields back to the current context when awaited.</source>
          
        </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>A context that, when awaited, will asynchronously transition back into the current context at the time of the await.</source>
          
        </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>If the current <ph id="ph1">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph> is non-null, it is treated as the current context.</source>
          
        </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>Otherwise, the task scheduler that is associated with the currently executing task is treated as the current context.</source>
          
        </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>You can use <ph id="ph1">`await Task.Yield();`</ph> in an asynchronous method to force the method to complete asynchronously.</source>
          <target state="translated">Можно использовать <ph id="ph1">`await Task.Yield();`</ph> в асинхронном методе для принудительного метод асинхронного завершения.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>If there is a current synchronization context (<ph id="ph1">&lt;xref:System.Threading.SynchronizationContext&gt;</ph> object), this will post the remainder of the method’s execution back to that context.</source>
          <target state="translated">Если текущий контекст синхронизации (<ph id="ph1">&lt;xref:System.Threading.SynchronizationContext&gt;</ph> объекта), это будут отправлены в конце выполнения метода обратно в этом контексте.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>However, the context will decide how to prioritize this work relative to other work that may be pending.</source>
          <target state="translated">Однако контекст будет решить, как приоритет этой работы относительно другие операции, может быть отложена.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>The synchronization context that is present on a UI thread in most UI environments will often prioritize work posted to the context higher than input and rendering work.</source>
          <target state="translated">Контекст синхронизации, который присутствует в потоке пользовательского интерфейса в большинстве сред пользовательского интерфейса будет часто определения приоритета работы, учтена в контекст больше входных данных и подготовки отчетов работа.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>For this reason, do not rely on <ph id="ph1">`await Task.Yield();`</ph> to keep a UI responsive.</source>
          <target state="translated">По этой причине не следует полагаться на <ph id="ph1">`await Task.Yield();`</ph> для обеспечения быстрого реагирования пользовательского интерфейса.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>For more information, see the entry <bpt id="p1">[</bpt>Useful Abstractions Enabled with ContinueWith<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">Дополнительные сведения см. в записи <bpt id="p1">[</bpt>полезные абстракции с включенными ContinueWith<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx)</ept> в параллельное программирование с блога .NET.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>