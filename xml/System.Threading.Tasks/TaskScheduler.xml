<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4d9adf13c8a7e851e5512c4b8b0e6ada78afa563" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407624" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет объект, обрабатывающий низкоуровневую постановку задач в очередь на потоки.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр <xref:System.Threading.Tasks.TaskScheduler> класс представляет планировщика задач. Планировщик задач гарантирует, что работа над задачей в итоге будет выполнена.  
  
 Планировщик заданий по умолчанию основан на пуле потоков .NET Framework 4, который обеспечивает перехват работы для балансировки нагрузки, вставку/удаление потока для максимальной пропускной способности и общее повышение производительности. Его должно быть достаточно для большинства сценариев.  
  
 <xref:System.Threading.Tasks.TaskScheduler> Класс также служит точка расширения для всех настраиваемых логики планирования.  Это включает механизмы, такие как отладчики предоставления способ планирования задачи для выполнения и запланированных задач. Если требуются специальные функциональные возможности, можно создать пользовательский планировщик и включить его для определенных задач или запросов.  
  
 В этом разделе.  
[Планировщик задач по умолчанию и пула потоков](#Default)  
 [Очереди глобальные и локальные очереди](#Queues)  
 [Перехват работы](#Stealing)  
 [Длительно выполняемых задач](#LongRunning)  
 [Встраивание задачи](#Inlining)  
[Указание контекста синхронизации](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a>Планировщик задач по умолчанию и пула потоков  
 Планировщик по умолчанию для библиотеки параллельных задач и PLINQ использует пул потоков .NET Framework, которое представляется <xref:System.Threading.ThreadPool> класса, чтобы очередь и выполнения работы. Пул потоков использует сведения, предоставляемые <xref:System.Threading.Tasks.Task> тип для эффективной поддержки точного параллелизма (кратковременных единиц работы), часто представляют параллельные задачи и запросы.  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a>Очереди глобальные и локальные очереди  
 Пул потоков обслуживает очередь глобальные FIFO (первым поступил — первым обслужен) для потоков в каждом домене приложения. Каждый раз, когда программа вызывает <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (или <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) метода, работа поместить в этой общей очереди и в конечном итоге отменяется помещенных в очередь в следующий поток, который становится доступным. Начиная с .NET Framework 4, эта очередь была улучшена для использования алгоритма без блокировки, похожа на <xref:System.Collections.Concurrent.ConcurrentQueue%601> класса. Используя эту свободную от блокировок реализацию, пул потоков требуется меньше времени при его построении очереди и рабочие элементы. Такое преимущество в производительности доступно для всех программ, использующих пул потоков.  
  
 Задачи верхнего уровня, которые являются задачами, не созданными в контексте других задач, помещаются в глобальную очередь так же, как и другие рабочие элементы. Однако вложенные или дочерние задачи, создаваемые в контексте других задач, обрабатываются по-другому. Дочерняя или вложенная задача помещается в локальную очередь, относящуюся к потоку, в котором выполняется родительская задача. Родительская задача может быть задачей верхнего уровня или дочерней задачей другой задачи. Когда этот поток готов для дополнительной работы, сначала он выполняет поиск в локальной очереди. Если в ней существует ожидающие рабочие элементы, к ним возможен быстрый доступ. Локальные очереди осуществляется в последним поступил — первым обслужен (LIFO) для сохранения локальности кэша и снизить вероятность возникновения конфликтов. Дополнительные сведения о дочерних и вложенных задачах см. в разделе [присоединенные и отсоединенные дочерние задачи](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).  
  
 Использование локальных очередей не только снижает нагрузку на глобальную очередь, но также использует преимущества локальности данных. Рабочие элементы в локальной очереди часто ссылаются на структуры данных, находящихся рядом друг с другом в памяти. В этих случаях данные уже находятся в кэше после выполнения первой задачи был выполнен и возможен быстрый. Оба [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) и <xref:System.Threading.Tasks.Parallel> класса широко используют вложенные и дочерние задачи и получают значительное увеличение скорости с помощью локальных рабочих очередей.  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a>Перехват работы  
 Начиная с .NET Framework 4, пул потоков также отражает алгоритм перехвата работы, чтобы убедиться, что одни потоки простаивают простоя во время в очередях других потоков имеется работа. Когда поток из пула потоков готов для дополнительной работы, сначала он выполняет поиск в своей локальной очереди, далее в глобальной очереди, а затем в локальных очередях других потоков. При обнаружении рабочего элемента в локальной очереди другого потока он сначала применяет эвристику, чтобы убедиться, что он может эффективно выполнить эту работу. Если это возможно, он выводит из очереди рабочий элемент с конца (в порядке FIFO). Это уменьшает конкуренцию внутри каждой из локальных очередей и сохраняет локальность данных. Эта архитектура позволяет потоков пула-Балансировка нагрузки работает более эффективно, чем в предыдущих версиях.  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a>Длительно выполняемых задач  
 Может потребоваться явно запретить помещение задачи в локальную очередь. Например, вы знаете, что определенный рабочий элемент будет выполняться довольно долго и может заблокировать другие рабочие элементы в локальной очереди. В таком случае можно указать параметр <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>, который подсказывает планировщику, что для задачи может потребоваться дополнительный поток, чтобы она не блокировала дальнейший ход работы других потоков или рабочих элементов в локальной очереди. При использовании этого параметра позволяет избежать пул потоков полностью, включая глобальные и локальные очереди.  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a>Встраивание задачи  
 В некоторых случаях, когда <xref:System.Threading.Tasks.Task> ожидает, она может быть выполнена синхронно в потоке, который выполняет операцию ожидания. Это повышает производительность, устраняет необходимость в дополнительном потоке и вместо использования существующего потока, который в противном случае может быть заблокирован. Во избежание ошибок из-за повторного входа Встраивание задачи происходит только при обнаружении цели ожидания, в локальной очереди соответствующего потока.  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a>Указание контекста синхронизации  
 С помощью метода <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> можно указать, что задачу необходимо планировать для запуска в определенном потоке. Это полезно на платформах, например Windows Forms и Windows Presentation Foundation, где доступ к объектам пользовательского интерфейса часто ограничен кодом, выполняемым в том же потоке, в котором был создан этот объект пользовательского интерфейса.  
  
 В следующем примере используется <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> метода в приложении Windows Presentation Foundation (WPF) для планирования задачи, в том же потоке, созданный пользовательский элемент управления пользовательского интерфейса.   В примере создается мозаика из изображений, которые выбираются случайным образом из указанного каталога. Для загрузки и изменения размеров изображения используются объекты WPF. Необработанные пиксели передаются задаче, которая использует <xref:System.Threading.Tasks.Parallel.For%2A> цикле для записи в большой массив однобайтовых точек данных. Синхронизация не требуется, так как нет две плитки занимать одинаковые элементы массива. Плитки также могут записываться в любом порядке, так как их расположение рассчитывается независимо друг от друга. Затем большой массив передается задачу, которая выполняется в потоке пользовательского интерфейса, где точки данных загружается в элемент управления Image.  
  
 Пример перемещает данные из потока пользовательского интерфейса, изменяет его с помощью параллельных циклов и <xref:System.Threading.Tasks.Task> объектов, а затем передает его задачу, которая выполняется в потоке пользовательского интерфейса. Этот подход полезен, если необходимо использовать библиотеку параллельных задач для выполнения операций, которые не поддерживаются WPF API или работают недостаточно быстро. Другой способ создания мозаики из изображения в WPF является использование <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> управления и добавление изображений в него. <xref:System.Windows.Controls.WrapPanel> Выполняет работу по расположению элементов мозаики. Однако эта работа может выполняться только в потоке пользовательского интерфейса.  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 Для создания примера, создайте проект приложения WPF в Visual Studio и назначьте ему имя по своему усмотрению. Затем выполните следующие действия.  
  
1.  В представлении конструктора перетащите <xref:System.Windows.Controls.Image> управления из **элементов** в область конструктора. В представлении XAML укажите горизонтального выравнивания как «Левый». Размер не имеет значения, так как элемент управления изменяется динамически во время выполнения. Примите имя по умолчанию, «изображение».  
  
2.  Перетащите <xref:System.Windows.Controls.Button> управления из **элементов** в левой нижней части окна приложения. Дважды щелкните кнопку, чтобы добавить <xref:System.Windows.Controls.Primitives.ButtonBase.Click> обработчика событий. В представлении XAML задайте <xref:System.Windows.Controls.ContentControl.Content%2A> свойства кнопки, как «Обеспечить мозаики» и задайте значение горизонтального выравнивания как «Левый». Примите имя по умолчанию, «button».  
  
3.  Замените все содержимое файла MainWindow.xaml.cs или MainWindow.xaml.vb код из этого примера. Убедитесь, что имя рабочей области, совпадает с именем проекта.  
  
4.  В примере читается JPEG-изображения из каталога с именем изображения C:\Users\Public\Pictures\Sample\\. Создать каталог и поместите в него некоторые рисунки либо измените путь, чтобы ссылаться на другие каталоги, содержащее изображения.  
  
 В этом примере имеет некоторые ограничения. Например поддерживаются только 32-бит на точку изображений; изображения в других форматах повреждены <xref:System.Windows.Media.Imaging.BitmapImage> объекта во время операции изменения размера. Кроме того исходные изображения должны задаваться больше, чем размер плитки. В качестве дополнительного упражнения можно добавить возможности по обработке различных форматов пикселей и размер файла.  
  
   
  
## Examples  
 Следующий пример взят из [примеры параллельного программирования в .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717) в коллекции кода MSDN веб-сайта.  Он создает пользовательский планировщик задач, ограничивающая количество потоков, используемых в приложении. Затем он запускает два набора задач и отображает сведения о задаче и потоке, на котором выполняется задача.  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 Кроме того, некоторые планировщики задач образец доступны в коллекции исходных кодов: [примеры параллельного программирования в .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717).  
  
 ]]></format>
    </remarks>
    <threadsafe>Все члены абстрактного <see cref="T:System.Threading.Tasks.TaskScheduler" /> типа являются потокобезопасными и может использоваться несколькими потоками одновременно.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует объект <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Threading.Tasks.TaskScheduler" />, связанный с выполняемой в настоящий момент задачей.</summary>
        <value>Возвращает объект <see cref="T:System.Threading.Tasks.TaskScheduler" />, связанный с выполняемой в настоящий момент задачей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не вызывается из задачи, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> вернет <xref:System.Threading.Tasks.TaskScheduler.Default%2A> планировщика.  
  
 Дополнительные сведения см. в разделе <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает экземпляр <see cref="T:System.Threading.Tasks.TaskScheduler" /> по умолчанию, предоставляемый платформой .NET Framework.</summary>
        <value>Возвращает экземпляр <see cref="T:System.Threading.Tasks.TaskScheduler" /> по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [планировщики задач](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает <see cref="T:System.Threading.Tasks.TaskScheduler" /> для связывания с текущим элементом <see cref="T:System.Threading.SynchronizationContext" />.</summary>
        <returns>
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> для связывания с текущим элементом <see cref="T:System.Threading.SynchronizationContext" />, как определено в <see cref="P:System.Threading.SynchronizationContext.Current" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все <xref:System.Threading.Tasks.Task> экземпляров в очереди на возвращаемый планировщика выполняется посредством вызова <xref:System.Threading.SynchronizationContext.Post%2A> метод в этом контексте.  
  
 Дополнительные сведения см. в разделе [планировщики задач](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий SynchronizationContext нельзя использовать как TaskScheduler.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает перечисляемый объект экземпляров <see cref="T:System.Threading.Tasks.Task" />, которые в настоящее время находятся в очереди планировщика, ожидая выполнения (только для поддержки отладки).</summary>
        <returns>Перечисляемый объект, позволяющий отладчику перемещаться по задачам, которые находятся в очереди данного планировщика.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс, производный от <xref:System.Threading.Tasks.TaskScheduler> реализует этот метод для поддержки интеграции с отладчики. Этот метод будет вызван только в .NET Framework, когда отладчик запрашивает доступ к данным. Возвращенное перечислимое значение будет обработано служебными программами отладчика для доступа к задачам в настоящее время в очереди на данном планировщике Включение отладчика для представления данных в пользовательском интерфейсе.  
  
 Важно отметить, что при вызове этого метода все потоки в процессе, будут зафиксированы. Поэтому очень важно избегать синхронизации с другими потоками, которые могут привести к блокировке. Если синхронизация не требуется и не удается получить блокировку в этом методе, должно создавать исключения, чтобы отладчик не завис. В примере показан один из возможных в C#:  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 Кроме того этот метод и возвращаемое перечислимое значение не следует изменять любые состояния, видимые глобально.  
  
 Возвращаемое перечислимое никогда не должен иметь значение null. Если в настоящий момент нет задач в очереди, должны возвращаться перечислимые пустой.  
  
 Разработчиками, реализующими пользовательских отладчики не следует вызывать этот метод непосредственно, но следует использовать метод внутренней оболочки `GetScheduledTasksForDebugger` вместо: `internal Task[] GetScheduledTasksForDebugger()`. Этот метод-оболочку возвращает массив задач вместо перечислимый объект. Получить список активных планировщики с помощью внутреннего метода `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`. Этот статический метод возвращает массив всех активных <xref:System.Threading.Tasks.TaskScheduler> экземпляров. Затем можно использовать `GetScheduledTasksForDebugger` на каждый экземпляр планировщика для получения списка запланированных заданий.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этому планировщику не удается создать список находящихся в данный момент в очереди задач.</exception>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает уникальный идентификатор данного объекта <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <value>Возвращает уникальный идентификатор для данного объекта <see cref="T:System.Threading.Tasks.TaskScheduler" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [планировщики задач](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает максимальный уровень параллелизма, который может поддерживаться данным планировщиком <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <value>Возвращает целое число, представляющее максимальный уровень параллелизма. Планировщик по умолчанию возвращает значение свойства <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [планировщики задач](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Помещаемый в очередь объект <see cref="T:System.Threading.Tasks.Task" />.</param>
        <summary>Ставит объект <see cref="T:System.Threading.Tasks.Task" /> в очередь планировщика.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс, производный от <xref:System.Threading.Tasks.TaskScheduler> реализует этот метод для принятия задачи, выполнение которого запланировано на планировщик.  
  
 Типичная реализация должна сохранить задачу в внутреннюю структуру данных, который будет обслуживаться потоками, которые будут выполнять эти задачи в некоторый момент в будущем.  
  
 Этот метод предназначен только для вызывается платформой .NET Framework и не должен вызываться непосредственно производным классом. Это необходимо для поддержания целостности системы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="task" /> имеет значение NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Объект <see cref="T:System.Threading.Tasks.Task" /> для удаления из очереди.</param>
        <summary>Пытается удалить из очереди задачу <see cref="T:System.Threading.Tasks.Task" />, ранее поставленную в очередь данного планировщика.</summary>
        <returns>Логическое значение, указывающее, был ли аргумент <paramref name="task" /> успешно удален из очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [планировщики задач](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 Этот метод может выполняться в блок finally. Поэтому он должен возвращать как можно быстрее таким образом, любые ресурсы, такие как <xref:System.Threading.CancellationTokenRegistration> удаления объектов из своевременно.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="task" /> имеет значение NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Выполняемая задача <see cref="T:System.Threading.Tasks.Task" />.</param>
        <summary>Пытается выполнить предоставленную задачу <see cref="T:System.Threading.Tasks.Task" /> в этом планировщике.</summary>
        <returns>Логическое значение true, если задача <paramref name="task" /> успешно выполнена; в противном случае — значение false. Общая причина ошибки выполнения состоит в том, что задача выполнялась ранее или выполняется другим потоком.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Планировщик реализации предоставляются с <xref:System.Threading.Tasks.Task> экземпляров для выполнения с помощью либо <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> метода или <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> метод. Если планировщик рассматривается соответствующим для запуска предоставленной задачи <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> для этого следует использовать. TryExecuteTask обрабатывает все аспекты выполнения задач, включая вызов действия, обработку исключений, управление состоянием и управления жизненным циклом.  
  
 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> должна использоваться только для задачи, описанные в данном планировщике инфраструктурой платформы .NET Framework. Он не должен использоваться для выполнения произвольных задач, полученных через пользовательские механизмы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="task" /> не связана с данным планировщиком.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">Выполняемый объект <see cref="T:System.Threading.Tasks.Task" />.</param>
        <param name="taskWasPreviouslyQueued">Логическое значение, указывающее, была ли задача ранее поставлена в очередь. Если этот параметр имеет значение True, задача могла ранее быть в очереди; если он имеет значение False, задача не была поставлена в очередь, а данный вызов совершается для выполнения задачи на месте без постановки в очередь.</param>
        <summary>Определяет, можно ли выполнить предоставленную задачу <see cref="T:System.Threading.Tasks.Task" /> в этом вызове синхронно, и если возможно, выполняет ее.</summary>
        <returns>Логическое значение, определяющее, была ли задача выполнена на месте.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс, производный от <xref:System.Threading.Tasks.TaskScheduler> реализует эту функцию для поддержки встроенного выполнения задачи в потоке, который инициирует ожидания для этого объекта задачи. Встроенного выполнения является необязательным, и запрос может быть отклонен, вернув значение false. Однако несколько задач, может быть встроен, тем лучше планировщик. На самом деле планировщик, встраивает слишком мало может быть вероятность возникновения взаимоблокировок. Правильная реализация должна гарантировать, что запроса, выполняющегося при политиках, обеспечиваемых планировщиком можно успешно встроенной. Например если планировщик использует выделенный поток для выполнения задач, любые запросы встраивания из этого потока должны выполняться успешно.  
  
 Если для выполнения встроенной решает планировщика, оно должно делать это при вызове для базового TaskScheduler <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> метод с объектом предоставленной задачи, распространение возвращаемое значение. Он также может подходить для планировщика удаления встроенных задач из его внутренние структуры данных, если он решает учитывают встраивания запрос. Обратите внимание, что в некоторых случаях планировщик может появиться запрос на встроенный задачу, которая не был предоставлен ранее с помощью <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> метод.  
  
 Производный Планировщик отвечает за убедившись, что вызывающий поток подходил для выполнения данной задачи собственное расписание и касается политики выполнения.  
  
 Дополнительные сведения см. в разделе [планировщики задач](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="task" /> имеет значение NULL.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="task" /> уже выполнена.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создается при активации политики эскалации исключений из-за непредвиденного исключения задачи, завершившейся сбоем. По умолчанию из-за этой политики процесс будет прерван.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие уровня домена приложения предоставляет механизм для предотвращения политики эскалации исключений (которая по умолчанию прерывает процесс) срабатывания.  
  
 Чтобы упростить разработчикам в создании асинхронного кода на основе задач, [!INCLUDE[net_v45](~/includes/net-v45-md.md)] изменяет поведение по умолчанию исключений для исключений, непредвиденное. Хотя синтаксические непредвиденное исключений по-прежнему <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> исключения, процесс не завершается по умолчанию. Вместо этого исключение обработано средой выполнения после возникновения события независимо от того, обнаруживает ли обработчик событий, исключение. Это поведение может быть настроено. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], элемент конфигурации можно использовать для возврата к поведению [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] и завершить процесс:  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>