<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TaskScheduler.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5ddd94061f594e353cba8674c76ffcb77a643ddb1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ddd94061f594e353cba8674c76ffcb77a643ddb1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Represents an object that handles the low-level work of queuing tasks onto threads.</source>
          <target state="translated">Представляет объект, обрабатывающий низкоуровневую постановку задач в очередь на потоки.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> class represents a task scheduler.</source>
          <target state="translated">Экземпляр <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> класс представляет планировщика задач.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>A task scheduler ensures that the work of a task is eventually executed.</source>
          <target state="translated">Планировщик задач гарантирует, что работа над задачей в итоге будет выполнена.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</source>
          <target state="translated">Планировщик заданий по умолчанию основан на пуле потоков .NET Framework 4, который обеспечивает перехват работы для балансировки нагрузки, вставку/удаление потока для максимальной пропускной способности и общее повышение производительности.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>It should be sufficient for most scenarios.</source>
          <target state="translated">Его должно быть достаточно для большинства сценариев.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> class also serves as the extension point for all customizable scheduling logic.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> Класс также служит точка расширения для всех настраиваемых логики планирования.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</source>
          <target state="translated">Это включает механизмы, такие как отладчики предоставления способ планирования задачи для выполнения и запланированных задач.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</source>
          <target state="translated">Если требуются специальные функциональные возможности, можно создать пользовательский планировщик и включить его для определенных задач или запросов.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In this topic:</source>
          <target state="translated">В этом разделе.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>The default task scheduler and the thread pool<ept id="p1">](#Default)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Планировщик задач по умолчанию и пула потоков<ept id="p1">](#Default)</ept></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>The global queue vs. local queues<ept id="p1">](#Queues)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Очереди глобальные и локальные очереди<ept id="p1">](#Queues)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Work stealing<ept id="p1">](#Stealing)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Перехват работы<ept id="p1">](#Stealing)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Long-running tasks<ept id="p1">](#LongRunning)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Длительно выполняемых задач<ept id="p1">](#LongRunning)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Task inlining<ept id="p1">](#Inlining)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Встраивание задачи<ept id="p1">](#Inlining)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Specifying a synchronization context<ept id="p1">](#Sync)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Указание контекста синхронизации<ept id="p1">](#Sync)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The default task scheduler and the thread pool</source>
          <target state="translated">Планировщик задач по умолчанию и пула потоков</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class, to queue and execute work.</source>
          <target state="translated">Планировщик по умолчанию для библиотеки параллельных задач и PLINQ использует пул потоков .NET Framework, которое представляется <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> класса, чтобы очередь и выполнения работы.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The thread pool uses the information that is provided by the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</source>
          <target state="translated">Пул потоков использует сведения, предоставляемые <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> тип для эффективной поддержки точного параллелизма (кратковременных единиц работы), часто представляют параллельные задачи и запросы.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The global queue vs. local queues</source>
          <target state="translated">Очереди глобальные и локальные очереди</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</source>
          <target state="translated">Пул потоков обслуживает очередь глобальные FIFO (первым поступил — первым обслужен) для потоков в каждом домене приложения.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Whenever a program calls the <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph> (or <ph id="ph2">&lt;xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</source>
          <target state="translated">Каждый раз, когда программа вызывает <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph> (или <ph id="ph2">&lt;xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph>) метода, работа поместить в этой общей очереди и в конечном итоге отменяется помещенных в очередь в следующий поток, который становится доступным.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> class.</source>
          <target state="translated">Начиная с .NET Framework 4, эта очередь была улучшена для использования алгоритма без блокировки, похожа на <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</source>
          <target state="translated">Используя эту свободную от блокировок реализацию, пул потоков требуется меньше времени при его построении очереди и рабочие элементы.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This performance benefit is available to all programs that use the thread pool.</source>
          <target state="translated">Такое преимущество в производительности доступно для всех программ, использующих пул потоков.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</source>
          <target state="translated">Задачи верхнего уровня, которые являются задачами, не созданными в контексте других задач, помещаются в глобальную очередь так же, как и другие рабочие элементы.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>However, nested or child tasks, which are created in the context of another task, are handled quite differently.</source>
          <target state="translated">Однако вложенные или дочерние задачи, создаваемые в контексте других задач, обрабатываются по-другому.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</source>
          <target state="translated">Дочерняя или вложенная задача помещается в локальную очередь, относящуюся к потоку, в котором выполняется родительская задача.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The parent task may be a top-level task or it also may be the child of another task.</source>
          <target state="translated">Родительская задача может быть задачей верхнего уровня или дочерней задачей другой задачи.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>When this thread is ready for more work, it first looks in the local queue.</source>
          <target state="translated">Когда этот поток готов для дополнительной работы, сначала он выполняет поиск в локальной очереди.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If work items are waiting there, they can be accessed quickly.</source>
          <target state="translated">Если в ней существует ожидающие рабочие элементы, к ним возможен быстрый доступ.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</source>
          <target state="translated">Локальные очереди осуществляется в последним поступил — первым обслужен (LIFO) для сохранения локальности кэша и снизить вероятность возникновения конфликтов.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>For more information about child tasks and nested tasks, see <bpt id="p1">[</bpt>Attached and Detached Child Tasks<ept id="p1">](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о дочерних и вложенных задачах см. в разделе <bpt id="p1">[</bpt>присоединенные и отсоединенные дочерние задачи<ept id="p1">](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</source>
          <target state="translated">Использование локальных очередей не только снижает нагрузку на глобальную очередь, но также использует преимущества локальности данных.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Work items in the local queue frequently reference data structures that are physically near one another in memory.</source>
          <target state="translated">Рабочие элементы в локальной очереди часто ссылаются на структуры данных, находящихся рядом друг с другом в памяти.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</source>
          <target state="translated">В этих случаях данные уже находятся в кэше после выполнения первой задачи был выполнен и возможен быстрый.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Both <bpt id="p1">[</bpt>Parallel LINQ (PLINQ)<ept id="p1">](~/docs/standard/parallel-programming/parallel-linq-plinq.md)</ept> and the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel&gt;</ph> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</source>
          <target state="translated">Оба <bpt id="p1">[</bpt>Parallel LINQ (PLINQ)<ept id="p1">](~/docs/standard/parallel-programming/parallel-linq-plinq.md)</ept> и <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel&gt;</ph> класса широко используют вложенные и дочерние задачи и получают значительное увеличение скорости с помощью локальных рабочих очередей.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Work stealing</source>
          <target state="translated">Перехват работы</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</source>
          <target state="translated">Начиная с .NET Framework 4, пул потоков также отражает алгоритм перехвата работы, чтобы убедиться, что одни потоки простаивают простоя во время в очередях других потоков имеется работа.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</source>
          <target state="translated">Когда поток из пула потоков готов для дополнительной работы, сначала он выполняет поиск в своей локальной очереди, далее в глобальной очереди, а затем в локальных очередях других потоков.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</source>
          <target state="translated">При обнаружении рабочего элемента в локальной очереди другого потока он сначала применяет эвристику, чтобы убедиться, что он может эффективно выполнить эту работу.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If it can, it de-queues the work item from the tail (in FIFO order).</source>
          <target state="translated">Если это возможно, он выводит из очереди рабочий элемент с конца (в порядке FIFO).</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This reduces contention on each local queue and preserves data locality.</source>
          <target state="translated">Это уменьшает конкуренцию внутри каждой из локальных очередей и сохраняет локальность данных.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This architecture helps the  thread pool load-balance work more efficiently than past versions did.</source>
          <target state="translated">Эта архитектура позволяет потоков пула-Балансировка нагрузки работает более эффективно, чем в предыдущих версиях.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Long-running tasks</source>
          <target state="translated">Длительно выполняемых задач</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>You may want to explicitly prevent a task from being put on a local queue.</source>
          <target state="translated">Может потребоваться явно запретить помещение задачи в локальную очередь.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</source>
          <target state="translated">Например, вы знаете, что определенный рабочий элемент будет выполняться довольно долго и может заблокировать другие рабочие элементы в локальной очереди.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In this case, you can specify the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType&gt;</ph> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</source>
          <target state="translated">В таком случае можно указать параметр <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType&gt;</ph>, который подсказывает планировщику, что для задачи может потребоваться дополнительный поток, чтобы она не блокировала дальнейший ход работы других потоков или рабочих элементов в локальной очереди.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>By using this option you avoid the thread pool completely, including the global and local queues.</source>
          <target state="translated">При использовании этого параметра позволяет избежать пул потоков полностью, включая глобальные и локальные очереди.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Task inlining</source>
          <target state="translated">Встраивание задачи</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In some cases when a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</source>
          <target state="translated">В некоторых случаях, когда <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> ожидает, она может быть выполнена синхронно в потоке, который выполняет операцию ожидания.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</source>
          <target state="translated">Это повышает производительность, устраняет необходимость в дополнительном потоке и вместо использования существующего потока, который в противном случае может быть заблокирован.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</source>
          <target state="translated">Во избежание ошибок из-за повторного входа Встраивание задачи происходит только при обнаружении цели ожидания, в локальной очереди соответствующего потока.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Specifying a synchronization context</source>
          <target state="translated">Указание контекста синхронизации</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> method to specify that a task should be scheduled to run on a particular thread.</source>
          <target state="translated">С помощью метода <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> можно указать, что задачу необходимо планировать для запуска в определенном потоке.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</source>
          <target state="translated">Это полезно на платформах, например Windows Forms и Windows Presentation Foundation, где доступ к объектам пользовательского интерфейса часто ограничен кодом, выполняемым в том же потоке, в котором был создан этот объект пользовательского интерфейса.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> метода в приложении Windows Presentation Foundation (WPF) для планирования задачи, в том же потоке, созданный пользовательский элемент управления пользовательского интерфейса.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The example creates a mosaic of images that are randomly selected from a specified directory.</source>
          <target state="translated">В примере создается мозаика из изображений, которые выбираются случайным образом из указанного каталога.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The WPF objects are used to load and resize the images.</source>
          <target state="translated">Для загрузки и изменения размеров изображения используются объекты WPF.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The raw pixels are then passed to a task that uses a <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.For%2A&gt;</ph> loop to write the pixel data into a large single-byte array.</source>
          <target state="translated">Необработанные пиксели передаются задаче, которая использует <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.For%2A&gt;</ph> цикле для записи в большой массив однобайтовых точек данных.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>No synchronization is required because no two tiles occupy the same array elements.</source>
          <target state="translated">Синхронизация не требуется, так как нет две плитки занимать одинаковые элементы массива.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The tiles can also be written in any order because their position is calculated independently of any other tile.</source>
          <target state="translated">Плитки также могут записываться в любом порядке, так как их расположение рассчитывается независимо друг от друга.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</source>
          <target state="translated">Затем большой массив передается задачу, которая выполняется в потоке пользовательского интерфейса, где точки данных загружается в элемент управления Image.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The example moves data off the UI thread, modifies it by using parallel loops and <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objects, and then passes it back to a task that runs on the UI thread.</source>
          <target state="translated">Пример перемещает данные из потока пользовательского интерфейса, изменяет его с помощью параллельных циклов и <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объектов, а затем передает его задачу, которая выполняется в потоке пользовательского интерфейса.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</source>
          <target state="translated">Этот подход полезен, если необходимо использовать библиотеку параллельных задач для выполнения операций, которые не поддерживаются WPF API или работают недостаточно быстро.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Another way to create an image mosaic in WPF is to use a <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType&gt;</ph> control and add images to it.</source>
          <target state="translated">Другой способ создания мозаики из изображения в WPF является использование <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType&gt;</ph> управления и добавление изображений в него.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel&gt;</ph> handles the work of positioning the tiles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel&gt;</ph> Выполняет работу по расположению элементов мозаики.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>However, this work can only be performed on the UI thread.</source>
          <target state="translated">Однако эта работа может выполняться только в потоке пользовательского интерфейса.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>To create the example, create a WPF application project in Visual Studio and assign it a name of your choice.</source>
          <target state="translated">Для создания примера, создайте проект приложения WPF в Visual Studio и назначьте ему имя по своему усмотрению.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Then do the following:</source>
          <target state="translated">Затем выполните следующие действия.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In design view, drag an <ph id="ph1">&lt;xref:System.Windows.Controls.Image&gt;</ph> control from the <bpt id="p1">**</bpt>Toolbox<ept id="p1">**</ept> to the design surface.</source>
          <target state="translated">В представлении конструктора перетащите <ph id="ph1">&lt;xref:System.Windows.Controls.Image&gt;</ph> управления из <bpt id="p1">**</bpt>элементов<ept id="p1">**</ept> в область конструктора.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In XAML view, specify the horizontal alignment as "Left."</source>
          <target state="translated">В представлении XAML укажите горизонтального выравнивания как «Левый».</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The size does not matter because the control is be dynamically resized at run time.</source>
          <target state="translated">Размер не имеет значения, так как элемент управления изменяется динамически во время выполнения.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Accept the default name, "image".</source>
          <target state="translated">Примите имя по умолчанию, «изображение».</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Drag a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> control from the <bpt id="p1">**</bpt>Toolbox<ept id="p1">**</ept> to the lower left part of the application window.</source>
          <target state="translated">Перетащите <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> управления из <bpt id="p1">**</bpt>элементов<ept id="p1">**</ept> в левой нижней части окна приложения.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Double-click the button to add a <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event handler.</source>
          <target state="translated">Дважды щелкните кнопку, чтобы добавить <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> обработчика событий.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In XAML view, specify the <ph id="ph1">&lt;xref:System.Windows.Controls.ContentControl.Content%2A&gt;</ph> property of the button as "Make a Mosaic" and specify its horizontal alignment as "Left".</source>
          <target state="translated">В представлении XAML задайте <ph id="ph1">&lt;xref:System.Windows.Controls.ContentControl.Content%2A&gt;</ph> свойства кнопки, как «Обеспечить мозаики» и задайте значение горизонтального выравнивания как «Левый».</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Accept the default name, "button".</source>
          <target state="translated">Примите имя по умолчанию, «button».</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</source>
          <target state="translated">Замените все содержимое файла MainWindow.xaml.cs или MainWindow.xaml.vb код из этого примера.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Make sure that the name of the workspace matches the project name.</source>
          <target state="translated">Убедитесь, что имя рабочей области, совпадает с именем проекта.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures<ph id="ph1">\\</ph>.</source>
          <target state="translated">В примере читается JPEG-изображения из каталога с именем изображения C:\Users\Public\Pictures\Sample<ph id="ph1">\\</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</source>
          <target state="translated">Создать каталог и поместите в него некоторые рисунки либо измените путь, чтобы ссылаться на другие каталоги, содержащее изображения.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This example has some limitations.</source>
          <target state="translated">В этом примере имеет некоторые ограничения.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <ph id="ph1">&lt;xref:System.Windows.Media.Imaging.BitmapImage&gt;</ph> object during the resizing operation.</source>
          <target state="translated">Например поддерживаются только 32-бит на точку изображений; изображения в других форматах повреждены <ph id="ph1">&lt;xref:System.Windows.Media.Imaging.BitmapImage&gt;</ph> объекта во время операции изменения размера.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Also, the source images must all be larger than the tile size.</source>
          <target state="translated">Кроме того исходные изображения должны задаваться больше, чем размер плитки.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</source>
          <target state="translated">В качестве дополнительного упражнения можно добавить возможности по обработке различных форматов пикселей и размер файла.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The following example is taken from the <bpt id="p1">[</bpt>Samples for Parallel Programming with the .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept> on the MSDN Code Gallery Web site.</source>
          <target state="translated">Следующий пример взят из <bpt id="p1">[</bpt>примеры параллельного программирования в .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept> в коллекции кода MSDN веб-сайта.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>It creates a custom task scheduler that limits the number of threads used by the app.</source>
          <target state="translated">Он создает пользовательский планировщик задач, ограничивающая количество потоков, используемых в приложении.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</source>
          <target state="translated">Затем он запускает два набора задач и отображает сведения о задаче и потоке, на котором выполняется задача.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In addition, several sample task schedulers are available on Code Gallery: <bpt id="p1">[</bpt>Samples for Parallel Programming with the .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept>.</source>
          <target state="translated">Кроме того, некоторые планировщики задач образец доступны в коллекции исходных кодов: <bpt id="p1">[</bpt>примеры параллельного программирования в .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>All members of the abstract <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> type are thread-safe and may be used from multiple threads concurrently.</source>
          <target state="translated">Все члены абстрактного <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> типа являются потокобезопасными и может использоваться несколькими потоками одновременно.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.#ctor">
          <source>Initializes the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Инициализирует объект <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the currently executing task.</source>
          <target state="translated">Получает объект <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>, связанный с выполняемой в настоящий момент задачей.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the currently executing task.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>, связанный с выполняемой в настоящий момент задачей.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>When not called from within a task, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A&gt;</ph> will return the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Default%2A&gt;</ph> scheduler.</source>
          <target state="translated">Если не вызывается из задачи, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A&gt;</ph> вернет <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Default%2A&gt;</ph> планировщика.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.Default">
          <source>Gets the default <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> instance that is provided by the .NET Framework.</source>
          <target state="translated">Получает экземпляр <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> по умолчанию, предоставляемый платформой .NET Framework.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Default">
          <source>Returns the default <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> instance.</source>
          <target state="translated">Возвращает экземпляр <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> по умолчанию.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Default">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>планировщики задач<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the current <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph>.</source>
          <target state="translated">Создает <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> для связывания с текущим элементом <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the current <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph>, as determined by <ph id="ph3">&lt;see cref="P:System.Threading.SynchronizationContext.Current" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> для связывания с текущим элементом <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph>, как определено в <ph id="ph3">&lt;see cref="P:System.Threading.SynchronizationContext.Current" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>All <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances queued to the returned scheduler will be executed through a call to the <ph id="ph2">&lt;xref:System.Threading.SynchronizationContext.Post%2A&gt;</ph> method on that context.</source>
          <target state="translated">Все <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> экземпляров в очереди на возвращаемый планировщика выполняется посредством вызова <ph id="ph2">&lt;xref:System.Threading.SynchronizationContext.Post%2A&gt;</ph> метод в этом контексте.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>планировщики задач<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>The current SynchronizationContext may not be used as a TaskScheduler.</source>
          <target state="translated">Текущий SynchronizationContext нельзя использовать как TaskScheduler.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>For debugger support only, generates an enumerable of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances currently queued to the scheduler waiting to be executed.</source>
          <target state="translated">Создает перечисляемый объект экземпляров <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, которые в настоящее время находятся в очереди планировщика, ожидая выполнения (только для поддержки отладки).</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</source>
          <target state="translated">Перечисляемый объект, позволяющий отладчику перемещаться по задачам, которые находятся в очереди данного планировщика.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>A class derived from <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this method in order to support integration with debuggers.</source>
          <target state="translated">Класс, производный от <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> реализует этот метод для поддержки интеграции с отладчики.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This method will only be invoked by the .NET Framework when the debugger requests access to the data.</source>
          <target state="translated">Этот метод будет вызван только в .NET Framework, когда отладчик запрашивает доступ к данным.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</source>
          <target state="translated">Возвращенное перечислимое значение будет обработано служебными программами отладчика для доступа к задачам в настоящее время в очереди на данном планировщике Включение отладчика для представления данных в пользовательском интерфейсе.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>It is important to note that, when this method is called, all other threads in the process will be frozen.</source>
          <target state="translated">Важно отметить, что при вызове этого метода все потоки в процессе, будут зафиксированы.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</source>
          <target state="translated">Поэтому очень важно избегать синхронизации с другими потоками, которые могут привести к блокировке.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang.</source>
          <target state="translated">Если синхронизация не требуется и не удается получить блокировку в этом методе, должно создавать исключения, чтобы отладчик не завис.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>The following example shows one possible approach in C#:</source>
          <target state="translated">В примере показан один из возможных в C#:</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>Additionally, this method and the enumerable returned must not modify any globally visible state.</source>
          <target state="translated">Кроме того этот метод и возвращаемое перечислимое значение не следует изменять любые состояния, видимые глобально.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>The returned enumerable should never be null.</source>
          <target state="translated">Возвращаемое перечислимое никогда не должен иметь значение null.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>If there are currently no queued tasks, an empty enumerable should be returned instead.</source>
          <target state="translated">Если в настоящий момент нет задач в очереди, должны возвращаться перечислимые пустой.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method <ph id="ph1">`GetScheduledTasksForDebugger`</ph> instead: <ph id="ph2">`internal Task[] GetScheduledTasksForDebugger()`</ph>.</source>
          <target state="translated">Разработчиками, реализующими пользовательских отладчики не следует вызывать этот метод непосредственно, но следует использовать метод внутренней оболочки <ph id="ph1">`GetScheduledTasksForDebugger`</ph> вместо: <ph id="ph2">`internal Task[] GetScheduledTasksForDebugger()`</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This wrapper method returns an array of tasks instead of an enumerable.</source>
          <target state="translated">Этот метод-оболочку возвращает массив задач вместо перечислимый объект.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>To retrieve a list of active schedulers, use the internal method <ph id="ph1">`internal static TaskScheduler[] GetTaskSchedulersForDebugger()`</ph>.</source>
          <target state="translated">Получить список активных планировщики с помощью внутреннего метода <ph id="ph1">`internal static TaskScheduler[] GetTaskSchedulersForDebugger()`</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This static method returns an array of all active <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> instances.</source>
          <target state="translated">Этот статический метод возвращает массив всех активных <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> экземпляров.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>You can then use <ph id="ph1">`GetScheduledTasksForDebugger`</ph> on each scheduler instance to retrieve its list of scheduled tasks.</source>
          <target state="translated">Затем можно использовать <ph id="ph1">`GetScheduledTasksForDebugger`</ph> на каждый экземпляр планировщика для получения списка запланированных заданий.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This scheduler is unable to generate a list of queued tasks at this time.</source>
          <target state="translated">Этому планировщику не удается создать список находящихся в данный момент в очереди задач.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.Id">
          <source>Gets the unique ID for this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Получает уникальный идентификатор данного объекта <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Id">
          <source>Returns the unique ID for this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Возвращает уникальный идентификатор для данного объекта <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Id">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>планировщики задач<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>Indicates the maximum concurrency level this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> is able to support.</source>
          <target state="translated">Указывает максимальный уровень параллелизма, который может поддерживаться данным планировщиком <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>Returns an integer that represents the maximum concurrency level.</source>
          <target state="translated">Возвращает целое число, представляющее максимальный уровень параллелизма.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>The default scheduler returns <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Планировщик по умолчанию возвращает значение свойства <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>планировщики задач<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to be queued.</source>
          <target state="translated">Помещаемый в очередь объект <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>Queues a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to the scheduler.</source>
          <target state="translated">Ставит объект <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> в очередь планировщика.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>A class derived from <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this method to accept tasks being scheduled on the scheduler.</source>
          <target state="translated">Класс, производный от <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> реализует этот метод для принятия задачи, выполнение которого запланировано на планировщик.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</source>
          <target state="translated">Типичная реализация должна сохранить задачу в внутреннюю структуру данных, который будет обслуживаться потоками, которые будут выполнять эти задачи в некоторый момент в будущем.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</source>
          <target state="translated">Этот метод предназначен только для вызывается платформой .NET Framework и не должен вызываться непосредственно производным классом.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>This is necessary for maintaining the consistency of the system.</source>
          <target state="translated">Это необходимо для поддержания целостности системы.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument is null.</source>
          <target state="translated">Аргумент <ph id="ph1">&lt;paramref name="task" /&gt;</ph> имеет значение NULL.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to be dequeued.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> для удаления из очереди.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>Attempts to dequeue a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> that was previously queued to this scheduler.</source>
          <target state="translated">Пытается удалить из очереди задачу <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, ранее поставленную в очередь данного планировщика.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>A Boolean denoting whether the <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument was successfully dequeued.</source>
          <target state="translated">Логическое значение, указывающее, был ли аргумент <ph id="ph1">&lt;paramref name="task" /&gt;</ph> успешно удален из очереди.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>планировщики задач<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <ph id="ph1">&lt;xref:System.Threading.CancellationTokenRegistration&gt;</ph> objects can be disposed of in a timely manner.</source>
          <target state="translated">Этот метод может выполняться в блок finally. Поэтому он должен возвращать как можно быстрее таким образом, любые ресурсы, такие как <ph id="ph1">&lt;xref:System.Threading.CancellationTokenRegistration&gt;</ph> удаления объектов из своевременно.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument is null.</source>
          <target state="translated">Аргумент <ph id="ph1">&lt;paramref name="task" /&gt;</ph> имеет значение NULL.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object to be executed.</source>
          <target state="translated">Выполняемая задача <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>Attempts to execute the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> on this scheduler.</source>
          <target state="translated">Пытается выполнить предоставленную задачу <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> в этом планировщике.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>A Boolean that is true if <ph id="ph1">&lt;paramref name="task" /&gt;</ph> was successfully executed, false if it was not.</source>
          <target state="translated">Логическое значение true, если задача <ph id="ph1">&lt;paramref name="task" /&gt;</ph> успешно выполнена; в противном случае — значение false.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</source>
          <target state="translated">Общая причина ошибки выполнения состоит в том, что задача выполнялась ранее или выполняется другим потоком.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>Scheduler implementations are provided with <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances to be executed through either the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> method or the <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A&gt;</ph> method.</source>
          <target state="translated">Планировщик реализации предоставляются с <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> экземпляров для выполнения с помощью либо <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> метода или <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>When the scheduler deems it appropriate to run the provided task, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> should be used to do so.</source>
          <target state="translated">Если планировщик рассматривается соответствующим для запуска предоставленной задачи <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> для этого следует использовать.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</source>
          <target state="translated">TryExecuteTask обрабатывает все аспекты выполнения задач, включая вызов действия, обработку исключений, управление состоянием и управления жизненным циклом.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> должна использоваться только для задачи, описанные в данном планировщике инфраструктурой платформы .NET Framework.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>It should not be used to execute arbitrary tasks obtained through custom mechanisms.</source>
          <target state="translated">Он не должен использоваться для выполнения произвольных задач, полученных через пользовательские механизмы.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> is not associated with this scheduler.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="task" /&gt;</ph> не связана с данным планировщиком.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to be executed.</source>
          <target state="translated">Выполняемый объект <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A Boolean denoting whether or not task has previously been queued.</source>
          <target state="translated">Логическое значение, указывающее, была ли задача ранее поставлена в очередь.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</source>
          <target state="translated">Если этот параметр имеет значение True, задача могла ранее быть в очереди; если он имеет значение False, задача не была поставлена в очередь, а данный вызов совершается для выполнения задачи на месте без постановки в очередь.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>Determines whether the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> can be executed synchronously in this call, and if it can, executes it.</source>
          <target state="translated">Определяет, можно ли выполнить предоставленную задачу <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> в этом вызове синхронно, и если возможно, выполняет ее.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A Boolean value indicating whether the task was executed inline.</source>
          <target state="translated">Логическое значение, определяющее, была ли задача выполнена на месте.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A class derived from <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</source>
          <target state="translated">Класс, производный от <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> реализует эту функцию для поддержки встроенного выполнения задачи в потоке, который инициирует ожидания для этого объекта задачи.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>Inline execution is optional, and the request may be rejected by returning false.</source>
          <target state="translated">Встроенного выполнения является необязательным, и запрос может быть отклонен, вернув значение false.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>However, the more tasks that can be inlined, the better the scheduler will scale.</source>
          <target state="translated">Однако несколько задач, может быть встроен, тем лучше планировщик.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>In fact, a scheduler that inlines too little may be prone to deadlocks.</source>
          <target state="translated">На самом деле планировщик, встраивает слишком мало может быть вероятность возникновения взаимоблокировок.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</source>
          <target state="translated">Правильная реализация должна гарантировать, что запроса, выполняющегося при политиках, обеспечиваемых планировщиком можно успешно встроенной.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</source>
          <target state="translated">Например если планировщик использует выделенный поток для выполнения задач, любые запросы встраивания из этого потока должны выполняться успешно.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> method with the provided task object, propagating the return value.</source>
          <target state="translated">Если для выполнения встроенной решает планировщика, оно должно делать это при вызове для базового TaskScheduler <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> метод с объектом предоставленной задачи, распространение возвращаемое значение.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</source>
          <target state="translated">Он также может подходить для планировщика удаления встроенных задач из его внутренние структуры данных, если он решает учитывают встраивания запрос.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> method.</source>
          <target state="translated">Обратите внимание, что в некоторых случаях планировщик может появиться запрос на встроенный задачу, которая не был предоставлен ранее с помощью <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</source>
          <target state="translated">Производный Планировщик отвечает за убедившись, что вызывающий поток подходил для выполнения данной задачи собственное расписание и касается политики выполнения.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>планировщики задач<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument is null.</source>
          <target state="translated">Аргумент <ph id="ph1">&lt;paramref name="task" /&gt;</ph> имеет значение NULL.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> was already executed.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="task" /&gt;</ph> уже выполнена.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</source>
          <target state="translated">Создается при активации политики эскалации исключений из-за непредвиденного исключения задачи, завершившейся сбоем. По умолчанию из-за этой политики процесс будет прерван.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</source>
          <target state="translated">Это событие уровня домена приложения предоставляет механизм для предотвращения политики эскалации исключений (которая по умолчанию прерывает процесс) срабатывания.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>To make it easier for developers to write asynchronous code based on tasks, the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> changes the default exception behavior for unobserved exceptions.</source>
          <target state="translated">Чтобы упростить разработчикам в создании асинхронного кода на основе задач, <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> изменяет поведение по умолчанию исключений для исключений, непредвиденное.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Although unobserved exceptions still raise the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException&gt;</ph> exception, the process does not terminate by default.</source>
          <target state="translated">Хотя синтаксические непредвиденное исключений по-прежнему <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException&gt;</ph> исключения, процесс не завершается по умолчанию.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</source>
          <target state="translated">Вместо этого исключение обработано средой выполнения после возникновения события независимо от того, обнаруживает ли обработчик событий, исключение.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>This behavior can be configured.</source>
          <target state="translated">Это поведение может быть настроено.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, you can use the  configuration element to revert to the behavior of the <ph id="ph2">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> and terminate the process:</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, элемент конфигурации можно использовать для возврата к поведению <ph id="ph2">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> и завершить процесс:</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>