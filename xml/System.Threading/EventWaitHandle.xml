<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="EventWaitHandle.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac504ca1c444cfd772670659b4609b267628b38c728.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04ca1c444cfd772670659b4609b267628b38c728</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Represents a thread synchronization event.</source>
          <target state="translated">Представляет событие синхронизации потока.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class allows threads to communicate with each other by signaling.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> Класс позволяет потокам взаимодействовать друг с другом путем передачи сигналов.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Typically, one or more threads block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> until an unblocked thread calls the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method, releasing one or more of the blocked threads.</source>
          <target state="translated">Как правило, один или несколько потоков блокируются на <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> до как незаблокированный поток вызовет <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> метод, освобождая один или несколько заблокированных потоков.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>A thread can signal an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> and then block on it, by calling the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Поток может сообщить <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> и затем заблокировать, путем вызова <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> в Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class provides access to named system synchronization events.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> Класс предоставляет доступ к под названием system события синхронизации.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The behavior of an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> that has been signaled depends on its reset mode.</source>
          <target state="translated">Поведение <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> , было сообщено зависит от режима его сброса.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>An <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag resets automatically when signaled, after releasing a single waiting thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> С <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> флаг сбрасывается автоматически при получении сигнала после освобождения одного ожидающего потока.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>An <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag remains signaled until its <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> С <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> флаг получает сигнал до его <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> вызывается метод.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Automatic reset events provide exclusive access to a resource.</source>
          <target state="translated">События автоматического сброса предоставления монопольного доступа к ресурсу.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</source>
          <target state="translated">Если событие с автоматическим сбросом создается при отсутствии потоков в состоянии ожидания, оно сохраняет свой статус, пока не получит обращение от потока.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The event releases the thread and immediately resets, blocking subsequent threads.</source>
          <target state="translated">Тогда событие освобождает поток и немедленно сбрасывается, блокируя следующие потоки.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Manual reset events are like gates.</source>
          <target state="translated">События, как шлюзы ручного сброса.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>When the event is not signaled, threads that wait on it will block.</source>
          <target state="translated">Когда событие не сигнализирует, блокирует потоки, ожидающие.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated">Если событие сигнализирует, все ожидающие потоки освобождаются и событие получает сигнал (то есть последующие не блокируется) до его <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> вызывается метод.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Manual reset events are useful when one thread must complete an activity before other threads can proceed.</source>
          <target state="translated">Ручной Сброс событий полезны, когда один поток должен завершить действие перед продолжением других потоков.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objects can be used with the <ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> объекты, которые могут использоваться с <ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph> в Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>For more information about thread synchronization mechanisms, see <bpt id="p1">[</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id="p1">](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о механизмах синхронизации потоков см. в разделе <bpt id="p1">[</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id="p1">](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</source>
          <target state="translated">Следующий пример кода использует <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> перегрузка метода, чтобы разрешить основной поток отправлять сигнал заблокированный поток и подождите, пока поток завершает задачу.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The example starts five threads and allows them to block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag, then releases one thread each time the user presses the ENTER key.</source>
          <target state="translated">В примере запускается пять потоков и их можно заблокировать на <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> с <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> флаг, а затем время один поток выпуски, пользователь нажимает клавишу ВВОД.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The example then queues another five threads and releases them all using an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Затем помещает в очередь другой пять потоков и освобождает их с помощью <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> с <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>This type is thread safe.</source>
          <target state="translated">Данный тип потокобезопасен.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> для задания начального состояния сигнальным; <ph id="ph2">&lt;see langword="false" /&gt;</ph> для задания несигнального начального состояния.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">Одно из значений <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph>, которое определяет, выполняется ли сброс события автоматически или вручную.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</source>
          <target state="translated">Выполняет инициализацию нового экземпляра класса <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>, определяя, получает ли сигнал, ожидающий дескриптор, и производится ли сброс автоматически или вручную.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">Если начальное состояние события является несигнальным, потоки, которые ожидают события будет заблокирована.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">Если начальное состояние сигнальное и <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> флаг указан для <ph id="ph2">`mode`</ph>, потоки, которые ожидают события не будет блокирована.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">Если начальное состояние сигнальное, и <ph id="ph1">`mode`</ph> — <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, первый поток, ожидающий события, немедленно освобождается, после чего событие сбрасывается, и последующие потоки блокируются.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</source>
          <target state="translated">Следующий пример кода использует <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> перегрузка метода, чтобы разрешить основной поток отправлять сигнал заблокированный поток и подождите, пока поток завершает задачу.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>The example starts five threads and allows them to block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag, then releases one thread each time the user presses ENTER key.</source>
          <target state="translated">В примере запускается пять потоков и их можно заблокировать на <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> с <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> флаг, а затем время один поток выпуски, пользователь нажимает клавишу ВВОД.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>The example then queues another five threads and releases them all using an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Затем помещает в очередь другой пять потоков и освобождает их с помощью <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> с <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> обозначает, что именованное событие получит исходное сигнальное состояние, если такое событие создается в результате этого вызова; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph> устанавливает несигнальное состояние.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">Одно из значений <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph>, которое определяет, выполняется ли сброс события автоматически или вручную.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>The name of a system-wide synchronization event.</source>
          <target state="translated">Имя события синхронизации на уровне системы.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</source>
          <target state="translated">Выполняет инициализацию нового экземпляра класса <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>, определяющего получает ли сигнал дескриптор ожидания, если он был создан в результате данного вызова, сбрасывается ли он автоматически или вручную, а также имя системного события синхронизации.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If <ph id="ph1">`name`</ph> is <ph id="ph2">`null`</ph> or an empty string, a local <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> is created.</source>
          <target state="translated">Если <ph id="ph1">`name`</ph> — <ph id="ph2">`null`</ph> или является пустой строкой, локальный <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> создается.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If a system event with the name specified for the <ph id="ph1">`name`</ph> parameter already exists, the <ph id="ph2">`initialState`</ph> parameter is ignored.</source>
          <target state="translated">Если системное событие с именем, указанным для <ph id="ph1">`name`</ph> уже существует параметр <ph id="ph2">`initialState`</ph> параметр учитывается.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>When using this constructor for named system events, specify <ph id="ph1">`false`</ph> for <ph id="ph2">`initialState`</ph>.</source>
          <target state="translated">При использовании этого конструктора для именованного системного события, укажите <ph id="ph1">`false`</ph> для <ph id="ph2">`initialState`</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.</source>
          <target state="translated">Этот конструктор не предоставляет способ определить, был ли создан именованное системное событие, поэтому нельзя делать никаких предположений о состоянии именованного события.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>To determine whether a named event was created, use the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor or the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29&gt;</ph> constructor.</source>
          <target state="translated">Чтобы определить, был ли создан события с заданным именем, используйте <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> конструктор или <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">Если начальное состояние события является несигнальным, потоки, которые ожидают события будет заблокирована.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">Если начальное состояние сигнальное и <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> флаг указан для <ph id="ph2">`mode`</ph>, потоки, которые ожидают события не будет блокирована.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">Если начальное состояние сигнальное, и <ph id="ph1">`mode`</ph> — <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, первый поток, ожидающий события, немедленно освобождается, после чего событие сбрасывается, и последующие потоки блокируются.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Произошла ошибка Win32.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>The named event exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">Именованное событие уже существует и имеет настройки управления доступом, но пользователь не имеет прав <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Именованное событие нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated">Длина значения параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> превышает 260 символов.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> обозначает, что именованное событие получит исходное сигнальное состояние, если такое событие создается в результате этого вызова; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph> устанавливает несигнальное состояние.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">Одно из значений <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph>, которое определяет, выполняется ли сброс события автоматически или вручную.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>The name of a system-wide synchronization event.</source>
          <target state="translated">Имя события синхронизации на уровне системы.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local event was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system event was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system event already existed.</source>
          <target state="translated">При завершении работы метода содержит значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если было создано локальное событие (то есть если параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph> или содержит пустую строку) или заданное именованное системное событие; или значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>, если указанное именованное событие уже существовало.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Этот параметр передается неинициализированным.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> и указывает следующие сведения: передавать ли сигнал в дескриптор ожидания при первичном запуске в результате этого вызова; выполнять ли сброс автоматически или вручную; имя системного события синхронизации; логическая переменная для сохранения информации о том, было ли создано именованное системное событие.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If a system event with the name specified for the <ph id="ph1">`name`</ph> parameter already exists, the <ph id="ph2">`initialState`</ph> parameter is ignored.</source>
          <target state="translated">Если системное событие с именем, указанным для <ph id="ph1">`name`</ph> уже существует параметр <ph id="ph2">`initialState`</ph> параметр учитывается.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>After calling this constructor, use the value in the variable specified for the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> parameter in Visual Basic)<ph id="ph3">`createdNew`</ph> to determine whether the named system event already existed or was created.</source>
          <target state="translated">После вызова этого конструктора, используйте значение в переменной, указанной для <ph id="ph1">`ref`</ph> параметра (<ph id="ph2">`ByRef`</ph> в Visual Basic)<ph id="ph3">`createdNew`</ph> для определения именованного системного события уже существует или был создан.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">Если начальное состояние события является несигнальным, потоки, которые ожидают события будет заблокирована.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">Если начальное состояние сигнальное и <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> флаг указан для <ph id="ph2">`mode`</ph>, потоки, которые ожидают события не будет блокирована.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">Если начальное состояние сигнальное, и <ph id="ph1">`mode`</ph> — <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, первый поток, ожидающий события, немедленно освобождается, после чего событие сбрасывается, и последующие потоки блокируются.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Произошла ошибка Win32.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>The named event exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">Именованное событие уже существует и имеет настройки управления доступом, но пользователь не имеет прав <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Именованное событие нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated">Длина значения параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> превышает 260 символов.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> обозначает, что именованное событие получит исходное сигнальное состояние, если такое событие создается в результате этого вызова; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph> устанавливает несигнальное состояние.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">Одно из значений <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph>, которое определяет, выполняется ли сброс события автоматически или вручную.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The name of a system-wide synchronization event.</source>
          <target state="translated">Имя события синхронизации на уровне системы.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local event was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system event was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system event already existed.</source>
          <target state="translated">При завершении работы метода содержит значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если было создано локальное событие (то есть если параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph> или содержит пустую строку) или заданное именованное системное событие; или значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>, если указанное именованное событие уже существовало.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Этот параметр передается неинициализированным.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system event.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph>, определяющий настройки управления доступом для применения к именованному системному событию.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> с указанием следующих сведений: передавать ли сигнал в дескриптор ожидания при первичном запуске в результате этого вызова, выполнять ли сброс автоматически или вручную, имя системного события синхронизации, логическая переменная для сохранения информации о том, было ли создано именованное системное событие, правила управления доступом для именованного события, если оно создается.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.</source>
          <target state="translated">Этот конструктор используется для применения безопасности управления доступом для именованного системного события при его создании, чтобы предотвратить возможность управления событием другого кода.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>This constructor initializes an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object that represents a system event.</source>
          <target state="translated">Этот конструктор инициализирует <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> , представляющий событие системы.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objects that represent the same system event.</source>
          <target state="translated">Можно создать несколько <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> объекты, которые представляют одно и то же событие системы.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the system event does not exist, it is created with the specified access control security.</source>
          <target state="translated">Если системное событие не существует, он создается с указанными управления доступом.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the event exists, the specified access control security is ignored.</source>
          <target state="translated">Если событие существует, указанные настройки управления доступом учитывается.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object even if <ph id="ph2">`eventSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
          <target state="translated">Вызывающий оператор имеет полный контроль над только что созданный <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> объект, даже если <ph id="ph2">`eventSecurity`</ph> запрещает или не может предоставить некоторые права доступа для текущего пользователя.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object to represent the same named event, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
          <target state="translated">Тем не менее если текущий пользователь пытается получить другой <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> объекта представляют одинаковую меру с именем события, с помощью конструктора или <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> метод применяется безопасность управления доступом Windows.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If a system event with the name specified for the <ph id="ph1">`name`</ph> parameter already exists, the <ph id="ph2">`initialState`</ph> parameter is ignored.</source>
          <target state="translated">Если системное событие с именем, указанным для <ph id="ph1">`name`</ph> уже существует параметр <ph id="ph2">`initialState`</ph> параметр учитывается.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>After calling this constructor, use the value in the variable specified for the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> parameter in Visual Basic) <ph id="ph3">`createdNew`</ph> to determine whether the named system event already existed or was created.</source>
          <target state="translated">После вызова этого конструктора, используйте значение в переменной, указанной для <ph id="ph1">`ref`</ph> параметра (<ph id="ph2">`ByRef`</ph> в Visual Basic) <ph id="ph3">`createdNew`</ph> для определения именованного системного события уже существует или был создан.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">Если начальное состояние события является несигнальным, потоки, которые ожидают события будет заблокирована.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">Если начальное состояние сигнальное и <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> флаг указан для <ph id="ph2">`mode`</ph>, потоки, которые ожидают события не будет блокирована.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">Если начальное состояние сигнальное, и <ph id="ph1">`mode`</ph> — <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, первый поток, ожидающий события, немедленно освобождается, после чего событие сбрасывается, и последующие потоки блокируются.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">В следующем примере кода демонстрируется поведение между процессами именованного системного события с безопасность управления доступом.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">В этом примере <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> перегрузка метода для проверки на наличие события с заданным именем.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">Если событие не существует, она создается с изначального владения и управления доступом, запрещают текущему пользователю использовать событие, но предоставляет право на чтение и изменение разрешений на событие.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">Исключение перехватывается, а в примере используется <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> перегрузка метода для ожидания события с права, необходимые для чтения и изменения разрешений.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">После изменения разрешений, событие открывается с права, необходимые для ожидания и сигнал.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">При запуске скомпилированный пример в третьем командном окне, в этом примере запускается с помощью новых разрешений.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Произошла ошибка Win32.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The named event exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">Именованное событие уже существует и имеет настройки управления доступом, но пользователь не имеет прав <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Именованное событие нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated">Длина значения параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> превышает 260 символов.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security for the named system event represented by the current <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph>, представляющий управление доступом для именованного системного события, представленного объектом <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security for the named system event.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph>, представляющий управление доступом для именованного системного события.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> Метод используется комбинация следующих (объединены с помощью битовой операции OR) флагов для поиска для разрешения: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, и <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the event must have been opened with the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Пользователь должен иметь <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> правами для вызова этого метода и события должен быть открыт с <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">В следующем примере кода демонстрируется поведение между процессами именованного системного события с безопасность управления доступом.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">В этом примере <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> перегрузка метода для проверки на наличие события с заданным именем.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">Если событие не существует, она создается с изначального владения и управления доступом, запрещают текущему пользователю использовать событие, но предоставляет право на чтение и изменение разрешений на событие.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">Исключение перехватывается, а в примере используется <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> перегрузка метода для ожидания события с права, необходимые для чтения и изменения разрешений.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>After the permissions have been read, using the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> method, and changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">После разрешения были прочитаны с помощью <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> метод, и изменения, событие открывается с права, необходимые для ожидания и сигнал.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">При запуске скомпилированный пример в третьем командном окне, в этом примере запускается с помощью новых разрешений.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object represents a named system event, and the user does not have <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">Текущий объект <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> представляет именованное системное событие, а пользователь не имеет прав <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object represents a named system event, and was not opened with <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">Текущий объект <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> представляет именованное системное событие, но оно не было открыто с правами <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Не поддерживается для Windows 98 или Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated">Для данного объекта <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> ранее вызывался метод <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Opens a specified named synchronization event, if it already exists.</source>
          <target state="translated">Открывает указанное именованное событие синхронизации, если оно уже существует.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">Имя системного события синхронизации, которое нужно открыть.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Opens the specified named synchronization event, if it already exists.</source>
          <target state="translated">Открывает указанное именованное событие синхронизации, если оно уже существует.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>An  object that represents the named system event.</source>
          <target state="translated">Объект, представляющий именованное системное событие.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method tries to open the specified named system event.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> Метод пытается открыть указанного именованного системного события.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If the system event does not exist, this method throws an exception instead of creating the system event.</source>
          <target state="translated">Если системное событие не существует, этот метод выдает исключение вместо создания системного события.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Чтобы создать системное событие, если он еще не существует, используйте один из <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> конструкторы, которые имеет <ph id="ph2">`name`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">Несколько вызовов этого метода, используйте то же значение для <ph id="ph1">`name`</ph> необязательно возвратят же <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> объекта, несмотря на то, что объекты, возвращаемые представляют того же именованного системного события.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Эта перегрузка метода эквивалентен вызову <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> перегруженный метод и указывая <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> и <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> прав, объединяются с помощью битовой операции или.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the named system event, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated">Указание <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> флаг позволяет потоку ожидать на именованного системного события и указав <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> флаг позволяет потоку для вызова <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> и <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">В следующем примере кода демонстрируется поведение между процессами именованного системного события с безопасность управления доступом.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">В этом примере <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> перегрузка метода для проверки на наличие события с заданным именем.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">Если событие не существует, она создается с изначального владения и управления доступом, запрещают текущему пользователю использовать событие, но предоставляет право на чтение и изменение разрешений на событие.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">Исключение перехватывается, а в примере используется <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> перегрузка метода для ожидания события с права, необходимые для чтения и изменения разрешений.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">После изменения разрешений, событие открывается с права, необходимые для ожидания и сигнал.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">При запуске скомпилированный пример в третьем командном окне, в этом примере запускается с помощью новых разрешений.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равен пустой строке.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated">Длина значения параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> превышает 260 символов.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The named system event does not exist.</source>
          <target state="translated">Именованное системное событие не существует.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Произошла ошибка Win32.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The named event exists, but the user does not have the security access required to use it.</source>
          <target state="translated">Именованное событие существует, но у пользователя нет необходимых для его использования прав доступа.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">Имя системного события синхронизации, которое нужно открыть.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>Opens the specified named synchronization event, if it already exists, with the desired security access.</source>
          <target state="translated">Открывает указанное именованное событие синхронизации, если оно уже существует, с требуемыми правами доступа.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>An object that represents the named system event.</source>
          <target state="translated">Объект, представляющий именованное системное событие.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the event, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated"><ph id="ph1">`rights`</ph> Необходимо включить параметр <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> флаг для освобождения потоков ожидают события и <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> флаг, чтобы разрешить потоков для вызова <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> и <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method tries to open an existing named system event.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> Метод пытается открыть существующего именованного системного события.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If the system event does not exist, this method throws an exception instead of creating the system event.</source>
          <target state="translated">Если системное событие не существует, этот метод выдает исключение вместо создания системного события.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Чтобы создать системное событие, если он еще не существует, используйте один из <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> конструкторы, которые имеет <ph id="ph2">`name`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">Несколько вызовов этого метода, используйте то же значение для <ph id="ph1">`name`</ph> необязательно возвратят же <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> объекта, несмотря на то, что объекты, возвращаемые представляют того же именованного системного события.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">В следующем примере кода демонстрируется поведение между процессами именованного системного события с безопасность управления доступом.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">В этом примере <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> перегрузка метода для проверки на наличие события с заданным именем.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">Если событие не существует, она создается с изначального владения и управления доступом, запрещают текущему пользователю использовать событие, но предоставляет право на чтение и изменение разрешений на событие.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">Исключение перехватывается, а в примере используется <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> перегрузка метода для ожидания события с права, необходимые для чтения и изменения разрешений.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">После изменения разрешений, событие открывается с права, необходимые для ожидания и сигнал.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">При запуске скомпилированный пример в третьем командном окне, в этом примере запускается с помощью новых разрешений.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равен пустой строке.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated">Длина значения параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> превышает 260 символов.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The named system event does not exist.</source>
          <target state="translated">Именованное системное событие не существует.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Произошла ошибка Win32.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The named event exists, but the user does not have the desired security access.</source>
          <target state="translated">Именованное событие уже существует, но пользователь не имеет требуемых прав для безопасного доступа.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Reset">
          <source>Sets the state of the event to nonsignaled, causing threads to block.</source>
          <target state="translated">Задает несигнальное состояние события, вызывая блокирование потоков.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Reset">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation succeeds; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если операция прошла успешно; в противном случае — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Reset">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated">Для данного объекта <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> ранее вызывался метод <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Set">
          <source>Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</source>
          <target state="translated">Устанавливает сигнальное состояние события, что позволяет продолжить выполнение одному или нескольким ожидающим потокам.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Set">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation succeeds; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если операция прошла успешно; в противном случае — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>For an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> with <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> (including <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>), the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method releases a single thread.</source>
          <target state="translated">Для <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> с <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> (включая <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>), <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> метод освобождает один поток.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated">Если нет ожидающих потоков, дескриптор ожидания остается сигнальным, пока поток попытается ожидать на нем или до его <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> вызывается метод.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>There is no guarantee that every call to the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method will release a thread from an <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> whose reset mode is <ph id="ph3">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Нет никакой гарантии, каждый вызов <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> метод освобождает поток из <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> чей режим сброса <ph id="ph3">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</source>
          <target state="translated">Если два вызова находятся слишком близко друг к другу, что второй вызов происходит до выпустила потока, освобождается только один поток.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>It is as if the second call did not happen.</source>
          <target state="translated">Это, как если бы второй вызов не произошло.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>Also, if <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> is called when there are no threads waiting and the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> is already signaled, the call has no effect.</source>
          <target state="translated">Кроме того Если <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> вызывается, когда нет ожидающих потоков и <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> уже есть сигнал, вызов не оказывает влияния.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>For an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> with <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> (including <ph id="ph3">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>), calling the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method leaves the wait handle in a signaled state until its <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated">Для <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> с <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> (включая <ph id="ph3">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>), что вызов <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> метод оставляет дескриптора ожидания в сигнальном состоянии до ее <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> вызывается метод.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</source>
          <target state="translated">Следующий пример кода использует <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> перегрузка метода, чтобы разрешить основной поток отправлять сигнал заблокированный поток и подождите, пока поток завершает задачу.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The example starts five threads and allows them to block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag, then releases one thread each time the user presses the ENTER key.</source>
          <target state="translated">В примере запускается пять потоков и их можно заблокировать на <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> с <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> флаг, а затем время один поток выпуски, пользователь нажимает клавишу ВВОД.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The example then queues another five threads and releases them all using an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Затем помещает в очередь другой пять потоков и освобождает их с помощью <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> с <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated">Для данного объекта <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> ранее вызывался метод <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system event.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph>, определяющий настройки управления доступом для применения к именованному системному событию.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Sets the access control security for a named system event.</source>
          <target state="translated">Задает защиту управления доступом для именованного системного события.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the event must have been opened with the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Пользователь должен иметь <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> правами для вызова этого метода и события должен быть открыт с <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">В следующем примере кода демонстрируется поведение между процессами именованного системного события с безопасность управления доступом.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">В этом примере <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> перегрузка метода для проверки на наличие события с заданным именем.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">Если событие не существует, она создается с изначального владения и управления доступом, запрещают текущему пользователю использовать событие, но предоставляет право на чтение и изменение разрешений на событие.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">Исключение перехватывается, а в примере используется <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> перегрузка метода для ожидания события с права, необходимые для чтения и изменения разрешений.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>After the permissions are changed, using the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.SetAccessControl%2A&gt;</ph> method, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">После изменения разрешений, с помощью <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.SetAccessControl%2A&gt;</ph> метод событие открывается с права, необходимые для ожидания и сигнал.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">При запуске скомпилированный пример в третьем командном окне, в этом примере запускается с помощью новых разрешений.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source><ph id="ph1">&lt;paramref name="eventSecurity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="eventSecurity" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">Пользователь не имеет <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The event was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">Событие не было открыто с <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object does not represent a named system event.</source>
          <target state="translated">Текущий объект <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> не представляет именованное системное событие.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated">Для данного объекта <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> ранее вызывался метод <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Открывает указанное именованное событие синхронизации, если оно уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">Имя системного события синхронизации, которое нужно открыть.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object that represents the named synchronization event if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">При возврате этого метода содержит объект <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>, представляющий именованное событие синхронизации, если вызов завершился успешно, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если вызов завершился неудачно.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Этот параметр обрабатывается как неинициализированный.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Открывает указанное именованное событие синхронизации, если оно уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named synchronization event was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если именованное событие синхронизации открылось успешно. В противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>If the named synchronization event does not exist, this method does not create it.</source>
          <target state="translated">Если именованное событие не существует, этот метод не создает его.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Чтобы создать системное событие, если он еще не существует, используйте один из <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> конструкторы, которые имеет <ph id="ph2">`name`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>If you are uncertain whether a named synchronization event exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the synchronization event does not exist.</source>
          <target state="translated">Если неизвестно, существует ли именованное событие, используйте перегрузку этого метода, а не <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> перегрузка метода, который создает исключение, если событие синхронизации не существует.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Эта перегрузка метода эквивалентен вызову <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29&gt;</ph> перегруженный метод и указывая <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> и <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> прав, объединяются с помощью битовой операции или.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the named system event, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated">Указание <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> флаг позволяет потоку ожидать на именованного системного события и указав <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> флаг позволяет потоку для вызова <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> и <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">Несколько вызовов этого метода, используйте то же значение для <ph id="ph1">`name`</ph> необязательно возвратят же <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> объекта, несмотря на то, что объекты, возвращаемые представляют того же именованного системного события.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равен пустой строке.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated">Длина значения параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> превышает 260 символов.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Произошла ошибка Win32.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>The named event exists, but the user does not have the desired security access.</source>
          <target state="translated">Именованное событие уже существует, но пользователь не имеет требуемых прав для безопасного доступа.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">Имя системного события синхронизации, которое нужно открыть.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object that represents the named synchronization event if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">При возврате этого метода содержит объект <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>, представляющий именованное событие синхронизации, если вызов завершился успешно, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если вызов завершился неудачно.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Этот параметр обрабатывается как неинициализированный.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Открывает заданное именованное событие синхронизации, если оно уже существует, с требуемыми правами доступа и возвращает значение, указывающее, успешно ли выполнена операция.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named synchronization event was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если именованное событие синхронизации открылось успешно. В противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>If the named synchronization event does not exist, this method does not create it.</source>
          <target state="translated">Если именованное событие не существует, этот метод не создает его.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Чтобы создать системное событие, если он еще не существует, используйте один из <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> конструкторы, которые имеет <ph id="ph2">`name`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>If you are uncertain whether a named synchronization event exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload, which throws an exception if the synchronization event does not exist.</source>
          <target state="translated">Если неизвестно, существует ли именованное событие, используйте перегрузку этого метода, а не <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> перегрузка метода, который создает исключение, если событие синхронизации не существует.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the event, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated"><ph id="ph1">`rights`</ph> Необходимо включить параметр <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> флаг для освобождения потоков ожидают события и <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> флаг, чтобы разрешить потоков для вызова <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> и <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">Несколько вызовов этого метода, используйте то же значение для <ph id="ph1">`name`</ph> необязательно возвратят же <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> объекта, несмотря на то, что объекты, возвращаемые представляют того же именованного системного события.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равен пустой строке.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated">Длина значения параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> превышает 260 символов.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Произошла ошибка Win32.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>The named event exists, but the user does not have the desired security access.</source>
          <target state="translated">Именованное событие уже существует, но пользователь не имеет требуемых прав для безопасного доступа.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>