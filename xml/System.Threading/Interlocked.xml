<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="883047e940a7b189bf8c52c13e9ba85d0fb9bf82" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Interlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class Interlocked" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="cc7b4-101">Предоставляет атомарные операции для переменных, общедоступных нескольким потокам.</span>
      <span class="sxs-lookup">
        <span data-stu-id="cc7b4-101">Provides atomic operations for variables that are shared by multiple threads.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-102">Методы этого класса защиты от ошибок, которые могут возникнуть при переключении контекстов планировщиком, пока поток обновляет переменную, доступную из других потоков или при параллельном выполнении двух потоков на отдельных процессорах.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-102">The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors.</span></span> <span data-ttu-id="cc7b4-103">Члены этого класса не вызывают исключений.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-103">The members of this class do not throw exceptions.</span></span>  
  
 <span data-ttu-id="cc7b4-104"><xref:System.Threading.Interlocked.Increment%2A> И <xref:System.Threading.Interlocked.Decrement%2A> методов увеличения или уменьшения переменной и его сохранить полученное значение в одной операции.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-104">The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation.</span></span> <span data-ttu-id="cc7b4-105">На большинстве компьютеров увеличение значения переменной не является атомарной операцией, требует следующих шагов:</span><span class="sxs-lookup"><span data-stu-id="cc7b4-105">On most computers, incrementing a variable is not an atomic operation, requiring the following steps:</span></span>  
  
1.  <span data-ttu-id="cc7b4-106">Загрузить значение из переменной экземпляра в регистр.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-106">Load a value from an instance variable into a register.</span></span>  
  
2.  <span data-ttu-id="cc7b4-107">Увеличить или уменьшить значение.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-107">Increment or decrement the value.</span></span>  
  
3.  <span data-ttu-id="cc7b4-108">Сохранение значения в переменной экземпляра.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-108">Store the value in the instance variable.</span></span>  
  
 <span data-ttu-id="cc7b4-109">Если вы не используете <xref:System.Threading.Interlocked.Increment%2A> и <xref:System.Threading.Interlocked.Decrement%2A>, поток может быть прерван после выполнения первых двух шагов.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-109">If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps.</span></span> <span data-ttu-id="cc7b4-110">Другой поток может затем выполнить все три шага.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-110">Another thread can then execute all three steps.</span></span> <span data-ttu-id="cc7b4-111">Когда первый поток возобновляет выполнение, он переопределяет значение в переменной экземпляра и эффект инкремент или декремент выполняется вторым потоком теряется.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-111">When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.</span></span>  
  
 <span data-ttu-id="cc7b4-112"><xref:System.Threading.Interlocked.Exchange%2A> Метод атомарным образом меняет местами значения указанных переменных.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-112">The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables.</span></span> <span data-ttu-id="cc7b4-113"><xref:System.Threading.Interlocked.CompareExchange%2A> Метод объединяет две операции: сравнение двух значений и сохранение третьего значения в одной из переменных, в зависимости от результата сравнения.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-113">The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.</span></span> <span data-ttu-id="cc7b4-114">Операции сравнения и обмена выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-114">The compare and exchange operations are performed as an atomic operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc7b4-115">В следующем примере кода показан механизм блокировки ресурсов потокобезопасным.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-115">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="cc7b4-116">Данный тип потокобезопасен.</span>
      <span class="sxs-lookup">
        <span data-stu-id="cc7b4-116">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cc7b4-117">Добавляет два целых числа и заменяет первое число на сумму (атомарная операция).</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-117">Adds two integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Add(int % location1, int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="cc7b4-118">Переменная, содержащая первое добавляемое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-118">A variable containing the first value to be added.</span>
          </span>
          <span data-ttu-id="cc7b4-119">Сумма двух значений сохраняется в <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-119">The sum of the two values is stored in <c>location1</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-120">Значение, добавляемое к целому в <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-120">The value to be added to the integer at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-121">Добавляет два 32-разрядных целых числа и заменяет первое число на сумму в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-121">Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-122">Новое значение сохраняется в <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-122">The new value stored at <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-123">Этот метод обрабатывает условие, заключив: Если значение по `location1` — <xref:System.Int32.MaxValue?displayProperty=nameWithType> и `value` -1, в результате <xref:System.Int32.MinValue?displayProperty=nameWithType>; Если `value` -2, в результате (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); и т. д.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-123">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int32.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int32.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="cc7b4-124">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-124">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="cc7b4-125">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-125">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Add(long % location1, long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="cc7b4-126">Переменная, содержащая первое добавляемое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-126">A variable containing the first value to be added.</span>
          </span>
          <span data-ttu-id="cc7b4-127">Сумма двух значений сохраняется в <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-127">The sum of the two values is stored in <c>location1</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-128">Значение, добавляемое к целому в <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-128">The value to be added to the integer at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-129">Добавляет два 64-разрядных целых числа и заменяет первое число на сумму в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-129">Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-130">Новое значение сохраняется в <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-130">The new value stored at <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-131">Этот метод обрабатывает условие, заключив: Если значение по `location1` — <xref:System.Int64.MaxValue?displayProperty=nameWithType> и `value` -1, в результате <xref:System.Int64.MinValue?displayProperty=nameWithType>; Если `value` -2, в результате (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); и т. д.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-131">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int64.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int64.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="cc7b4-132">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-132">No exception is thrown.</span></span>  
  
 <span data-ttu-id="cc7b4-133"><xref:System.Threading.Interlocked.Read%2A> Метод и 64-разрядных перегрузки <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, и <xref:System.Threading.Interlocked.Add%2A> методы атомарны действительно только в системах, где <xref:System.IntPtr?displayProperty=nameWithType> long 64 бита.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-133">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="cc7b4-134">В других системах эти методы являются атомарными по отношению друг к другу, но не по отношению к другим способом доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-134">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="cc7b4-135">Таким образом, чтобы быть поточно-ориентированным на 32-разрядных системах, доступ к 64-разрядное значение необходимо вносить с помощью члены <xref:System.Threading.Interlocked> класса.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-135">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="cc7b4-136">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-136">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareExchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cc7b4-137">Сравнивает два значения на равенство и, если они равны, заменяет первое.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-137">Compares two values for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64&amp; location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Double, value As Double, comparand As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CompareExchange(double % location1, double value, double comparand);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="comparand" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="cc7b4-138">Целевой объект, значение которого сравнивается с объектом <c>comparand</c> и может быть заменено.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-138">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-139">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-139">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="cc7b4-140">Значение, которое сравнивается со значением в позиции <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-140">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-141">Сравнивает два числа с плавающей запятой двойной точности на равенство и, если они равны, заменяет первое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-141">Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-142">Исходное значение в позиции <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-142">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-143">Если `comparand` и значения в `location1` равны, то `value` хранится в `location1`.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-143">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="cc7b4-144">В противном случае операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-144">Otherwise, no operation is performed.</span></span> <span data-ttu-id="cc7b4-145">Операции сравнения и обмена выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-145">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="cc7b4-146">Возвращаемое значение <xref:System.Threading.Interlocked.CompareExchange%2A> представляет собой исходное значение в `location1`, независимо от того, имеется ли осуществления обмена.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-146">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc7b4-147">В следующем примере кода показан метод потокобезопасна, который собирает промежуточных итогов по <xref:System.Double> значения.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-147">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Double> values.</span></span> <span data-ttu-id="cc7b4-148">Два потока добавляет ряд <xref:System.Double> значения с помощью поточно-метод и обычное суммирование, и затем потоки сравненные суммы.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-148">Two threads add a series of <xref:System.Double> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="cc7b4-149">На компьютере с двумя процессорами есть существенные различия в итоги.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-149">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="cc7b4-150">В методе поточно ориентированного сохраняется исходное значение промежуточных итогов, а затем <xref:System.Threading.Interlocked.CompareExchange%2A> метод используется для обмена вновь вычисляемый итог с общей старого.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-150">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="cc7b4-151">Если возвращаемое значение не равно сохраненному значению промежуточных итогов, выберите другой поток обновляет в то же время.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-151">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="cc7b4-152">В этом случае необходимо повторить попытка обновить промежуточных итогов.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-152">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="cc7b4-153">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-153">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32&amp; location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Integer, value As Integer, comparand As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareExchange(int % location1, int value, int comparand);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="cc7b4-154">Целевой объект, значение которого сравнивается с объектом <c>comparand</c> и может быть заменено.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-154">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-155">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-155">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="cc7b4-156">Значение, которое сравнивается со значением в позиции <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-156">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-157">Сравнивает два 32-разрядных целых числа со знаком на равенство и, если они равны, заменяет первое.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-157">Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-158">Исходное значение в позиции <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-158">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-159">Если `comparand` и значения в `location1` равны, то `value` хранится в `location1`.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-159">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="cc7b4-160">В противном случае операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-160">Otherwise, no operation is performed.</span></span> <span data-ttu-id="cc7b4-161">Операции сравнения и обмена выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-161">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="cc7b4-162">Возвращаемое значение <xref:System.Threading.Interlocked.CompareExchange%2A> представляет собой исходное значение в `location1`, независимо от того, имеется ли осуществления обмена.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-162">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc7b4-163">В следующем примере кода демонстрируется метод потокобезопасна, накапливает промежуточных итогов.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-163">The following code example demonstrates a thread-safe method that accumulates a running total.</span></span> <span data-ttu-id="cc7b4-164">Начальное значение промежуточных итогов сохраняется, а затем <xref:System.Threading.Interlocked.CompareExchange%2A> метод используется для обмена вновь вычисляемый итог с общей старого.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-164">The initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="cc7b4-165">Если возвращаемое значение не равно сохраненному значению промежуточных итогов, выберите другой поток обновляет в то же время.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-165">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="cc7b4-166">В этом случае необходимо повторить попытка обновить промежуточных итогов.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-166">In that case, the attempt to update the running total must be repeated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc7b4-167"><xref:System.Threading.Interlocked.Add%2A> Метод, появившиеся в .NET Framework версии 2.0 предоставляет более удобный накопить поточно ориентированного промежуточных итогов для целых чисел.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-167">The <xref:System.Threading.Interlocked.Add%2A> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="cc7b4-168">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-168">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64&amp; location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Long, value As Long, comparand As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long CompareExchange(long % location1, long value, long comparand);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="comparand" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="cc7b4-169">Целевой объект, значение которого сравнивается с объектом <c>comparand</c> и может быть заменено.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-169">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-170">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-170">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="cc7b4-171">Значение, которое сравнивается со значением в позиции <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-171">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-172">Сравнивает два 64-разрядных целых числа со знаком на равенство и, если они равны, заменяет первое.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-172">Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-173">Исходное значение в позиции <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-173">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-174">Если `comparand` и значения в `location1` равны, то `value` хранится в `location1`.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-174">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="cc7b4-175">В противном случае операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-175">Otherwise, no operation is performed.</span></span> <span data-ttu-id="cc7b4-176">Операции сравнения и обмена выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-176">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="cc7b4-177">Возвращаемое значение <xref:System.Threading.Interlocked.CompareExchange%2A> представляет собой исходное значение в `location1`, независимо от того, имеется ли осуществления обмена.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-177">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="cc7b4-178">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-178">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int&amp; location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As IntPtr, value As IntPtr, comparand As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CompareExchange(IntPtr % location1, IntPtr value, IntPtr comparand);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
        <Parameter Name="comparand" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="cc7b4-179">Целевое значение <see cref="T:System.IntPtr" />, которое будет сравниваться со значением параметра <c>comparand</c> и, возможно, будет заменено <c>value</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-179">The destination <see cref="T:System.IntPtr" />, whose value is compared with the value of <c>comparand</c> and possibly replaced by <c>value</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-180">Значение <see cref="T:System.IntPtr" />, которое заменит целевое значение, если результатом сравнения будет равенство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-180">The <see cref="T:System.IntPtr" /> that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="cc7b4-181">Значение <see cref="T:System.IntPtr" />, которое сравнивается со значением в <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-181">The <see cref="T:System.IntPtr" /> that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-182">Сравнивает два зависящих от платформы обработчика или указателя на равенство и, если они равны, заменяет первое из значений.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-182">Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-183">Исходное значение в позиции <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-183">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-184">Если `comparand` и значения в `location1` равны, то `value` хранится в `location1`.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-184">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="cc7b4-185">В противном случае операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-185">Otherwise, no operation is performed.</span></span> <span data-ttu-id="cc7b4-186">Операции сравнения и обмена выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-186">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="cc7b4-187">Возвращаемое значение метода представляет собой исходное значение в `location1`, независимо от того, имеется ли осуществления обмена.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-187">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc7b4-188"><xref:System.IntPtr> — Это тип конкретную платформу.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-188"><xref:System.IntPtr> is a platform-specific type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="cc7b4-189">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-189">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object&amp; location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Object, value As Object, comparand As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CompareExchange(System::Object ^ % location1, System::Object ^ value, System::Object ^ comparand);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="cc7b4-190">Целевой объект, который будет сравниваться со значением параметра <c>comparand</c> и, возможно, будет заменен.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-190">The destination object that is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-191">Объект, который заменит целевой объект, если результатом сравнения будет равенство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-191">The object that replaces the destination object if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="cc7b4-192">Объект, который сравнивается с объектом в <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-192">The object that is compared to the object at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-193">Сравнивает два объекта на равенство ссылок и, если они равны, заменяет первый объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-193">Compares two objects for reference equality and, if they are equal, replaces the first object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-194">Исходное значение в позиции <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-194">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-195">Если `comparand` и объект в `location1` равны, то `value` хранится в `location1`.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-195">If `comparand` and the object in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="cc7b4-196">В противном случае операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-196">Otherwise, no operation is performed.</span></span> <span data-ttu-id="cc7b4-197">Операции сравнения и обмена выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-197">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="cc7b4-198">Возвращаемое значение <xref:System.Threading.Interlocked.CompareExchange%2A> представляет собой исходное значение в `location1`, независимо от того, имеется ли осуществления обмена.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-198">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 <span data-ttu-id="cc7b4-199">Начиная с .NET Framework версии 2.0, <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> перегрузка метода предоставляет типобезопасной альтернативой для ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-199">Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc7b4-200">Объекты сравниваются на предмет равенства ссылок, а не <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-200">The objects are compared for reference equality, rather than <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="cc7b4-201">В результате два упакованных экземпляра одной и той же тип значения (например, целое число 3) всегда могут оказаться неэквивалентными и операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-201">As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed.</span></span> <span data-ttu-id="cc7b4-202">Не используйте эту перегрузку с типами значений.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-202">Do not use this overload with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cc7b4-203">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-203">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32&amp; location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Single, value As Single, comparand As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CompareExchange(float % location1, float value, float comparand);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="cc7b4-204">Целевой объект, значение которого сравнивается с объектом <c>comparand</c> и может быть заменено.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-204">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-205">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-205">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="cc7b4-206">Значение, которое сравнивается со значением в позиции <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-206">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-207">Сравнивает два числа с плавающей запятой с обычной точностью на равенство и, если они равны, заменяет первое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-207">Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-208">Исходное значение в позиции <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-208">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-209">Если `comparand` и значения в `location1` равны, то `value` хранится в `location1`.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-209">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="cc7b4-210">В противном случае операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-210">Otherwise, no operation is performed.</span></span> <span data-ttu-id="cc7b4-211">Операции сравнения и обмена выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-211">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="cc7b4-212">Возвращаемое значение <xref:System.Threading.Interlocked.CompareExchange%2A> представляет собой исходное значение в `location1`, независимо от того, имеется ли осуществления обмена.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-212">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc7b4-213">В следующем примере кода показан метод потокобезопасна, который собирает промежуточных итогов по <xref:System.Single> значения.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-213">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Single> values.</span></span> <span data-ttu-id="cc7b4-214">Два потока добавляет ряд <xref:System.Single> значения с помощью поточно-метод и обычное суммирование, и затем потоки сравненные суммы.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-214">Two threads add a series of <xref:System.Single> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="cc7b4-215">На компьютере с двумя процессорами есть существенные различия в итоги.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-215">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="cc7b4-216">В методе поточно ориентированного сохраняется исходное значение промежуточных итогов, а затем <xref:System.Threading.Interlocked.CompareExchange%2A> метод используется для обмена вновь вычисляемый итог с общей старого.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-216">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="cc7b4-217">Если возвращаемое значение не равно сохраненному значению промежуточных итогов, выберите другой поток обновляет в то же время.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-217">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="cc7b4-218">В этом случае необходимо повторить попытка обновить промежуточных итогов.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-218">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="cc7b4-219">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-219">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T&amp; location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange(Of T As Class) (ByRef location1 As T, value As T, comparand As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T CompareExchange(T % location1, T value, T comparand);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T&amp;" RefType="ref" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparand" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="cc7b4-220">Тип, используемый для <c>location1</c>, <c>значение</c>, и <c>сравниваемый операнд</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-220">The type to be used for <c>location1</c>, <c>value</c>, and <c>comparand</c>.</span>
          </span>
          <span data-ttu-id="cc7b4-221">Этот тип должен быть ссылочным типом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-221">This type must be a reference type.</span>
          </span>
        </typeparam>
        <param name="location1">
          <span data-ttu-id="cc7b4-222">Целевой объект, значение которого сравнивается с объектом <c>comparand</c> и может быть заменено.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-222">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
          <span data-ttu-id="cc7b4-223">Это ссылочный параметр (<see langword="ref" /> в C#, <see langword="ByRef" /> в Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-223">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-224">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-224">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="cc7b4-225">Значение, которое сравнивается со значением в позиции <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-225">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-226">Сравнивает два экземпляра указанного ссылочного типа <paramref name="T" /> на равенство и, если это так, заменяет один из них.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-226">Compares two instances of the specified reference type <paramref name="T" /> for equality and, if they are equal, replaces the first one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-227">Исходное значение в позиции <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-227">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-228">Если `comparand` и значения в `location1` равны, то `value` хранится в `location1`.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-228">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="cc7b4-229">В противном случае операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-229">Otherwise, no operation is performed.</span></span> <span data-ttu-id="cc7b4-230">Сравнение и обмен выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-230">The comparison and the exchange are performed as an atomic operation.</span></span> <span data-ttu-id="cc7b4-231">Возвращаемое значение метода представляет собой исходное значение в `location1`, независимо от того, имеется ли осуществления обмена.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-231">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 <span data-ttu-id="cc7b4-232">Этот метод поддерживает только ссылочные типы.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-232">This method only supports reference types.</span></span> <span data-ttu-id="cc7b4-233">Существуют перегрузки <xref:System.Threading.Interlocked.CompareExchange%2A> метод для типов значений <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, и <xref:System.Double>, но не поддерживается для других типов значений.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-233">There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc7b4-234">Эта перегрузка метода является более предпочтительным, чем <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> перегрузку метода, так как последний требуется целевой объект должен осуществляться позднего связывания.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-234">This method overload is preferable to the <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> method overload, because the latter requires the destination object to be accessed late-bound.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="cc7b4-235">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-235">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cc7b4-236">Уменьшает значение заданной переменной и сохраняет результат в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-236">Decrements a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Decrement(int % location);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="cc7b4-237">Переменная, у которой уменьшается значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-237">The variable whose value is to be decremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-238">Уменьшает значение заданной переменной и сохраняет результат в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-238">Decrements a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-239">Уменьшаемое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-239">The decremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-240">Этот метод обрабатывает условие, заключив: Если `location`  =  <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-240">This method handles an overflow condition by wrapping: If `location` = <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="cc7b4-241">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-241">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc7b4-242">В следующем примере определяется, необходимые для создания 1 000 случайных чисел с среднее значение количества случайных чисел в диапазоне от 0 до 1000.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-242">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="cc7b4-243">Для отслеживания числа значений середины, переменной, `midpointCount`, набор равно 1000 и уменьшается на единицу при каждом генератора случайных чисел возвращает среднее значение.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-243">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value.</span></span> <span data-ttu-id="cc7b4-244">Так как три потока создания случайных чисел, <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> метод вызывается, чтобы убедиться, что несколько потоков не обновлять `midpointCount` одновременно.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-244">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="cc7b4-245">Обратите внимание, что блокировка также используется для защиты генератора случайных чисел и что <xref:System.Threading.CountdownEvent> объект используется для убедитесь, что `Main` метод завершается выполнение перед три потока.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-245">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 <span data-ttu-id="cc7b4-246">Следующий пример похож на предыдущий, за исключением того, что он использует вместо поток процедуру, чтобы сформировать 50 000 середины случайных целых чисел.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-246">The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="cc7b4-247">В этом примере лямбда-выражение заменяет `GenerateNumbers` процедуры потока и вызова <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> метод исключает необходимость в <xref:System.Threading.CountdownEvent> объекта.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-247">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cc7b4-248">Адрес <paramref name="location" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-248">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Decrement(long % location);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="cc7b4-249">Переменная, у которой уменьшается значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-249">The variable whose value is to be decremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-250">Уменьшает значение заданной переменной и сохраняет результат в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-250">Decrements the specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-251">Уменьшаемое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-251">The decremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-252">Этот метод обрабатывает условие, заключив: Если `location`  =  <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-252">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="cc7b4-253">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-253">No exception is thrown.</span></span>  
  
 <span data-ttu-id="cc7b4-254"><xref:System.Threading.Interlocked.Read%2A> Метод и 64-разрядных перегрузки <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, и <xref:System.Threading.Interlocked.Add%2A> методы атомарны действительно только в системах, где <xref:System.IntPtr?displayProperty=nameWithType> long 64 бита.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-254">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="cc7b4-255">В других системах эти методы являются атомарными по отношению друг к другу, но не по отношению к другим способом доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-255">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="cc7b4-256">Таким образом, чтобы быть поточно-ориентированным на 32-разрядных системах, доступ к 64-разрядное значение необходимо вносить с помощью члены <xref:System.Threading.Interlocked> класса.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-256">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cc7b4-257">Адрес <paramref name="location" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-257">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cc7b4-258">Задает переменную указанным значением в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-258">Sets a variable to a specified value as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64&amp; location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Double, value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exchange(double % location1, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="cc7b4-259">Переменная, которая задается указанным значением.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-259">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-260">Значение, которое принимает параметр <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-260">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-261">Задает число с плавающей запятой с двойной точностью указанным значением в виде атомарной операции и возвращает исходное значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-261">Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-262">Исходное значение <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-262">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="cc7b4-263">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-263">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Exchange(int % location1, int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="cc7b4-264">Переменная, которая задается указанным значением.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-264">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-265">Значение, которое принимает параметр <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-265">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-266">Присваивает 32-разрядному целому числу со знаком заданное значение и возвращает исходное значение в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-266">Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-267">Исходное значение <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-267">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="cc7b4-268">В следующем примере кода показан механизм блокировки ресурсов потокобезопасным.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-268">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cc7b4-269">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-269">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Exchange(long % location1, long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="cc7b4-270">Переменная, которая задается указанным значением.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-270">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-271">Значение, которое принимает параметр <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-271">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-272">Присваивает 64-разрядному целому числу со знаком заданное значение и возвращает исходное значение в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-272">Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-273">Исходное значение <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-273">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="cc7b4-274">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-274">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int&amp; location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As IntPtr, value As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Exchange(IntPtr % location1, IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="cc7b4-275">Переменная, которая задается указанным значением.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-275">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-276">Значение, которое принимает параметр <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-276">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-277">Задает указатель или обработчик, зависящий от платформы в виде атомарной операции, и возвращает ссылку на исходное значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-277">Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-278">Исходное значение <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-278">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="cc7b4-279">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-279">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object&amp; location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Object, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Exchange(System::Object ^ % location1, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="cc7b4-280">Переменная, которая задается указанным значением.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-280">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-281">Значение, которое принимает параметр <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-281">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-282">Задает объект указанным значением в виде атомарной операции и возвращает ссылку на исходный объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-282">Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-283">Исходное значение <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-283">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-284">Начиная с .NET Framework версии 2.0, <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> перегрузка метода предоставляет типобезопасной альтернативой для ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-284">Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc7b4-285">В следующем примере кода показан синтаксис для использования `Exchange` с любым объектом типа ссылки.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-285">The following code example shows the syntax for using `Exchange` with any reference type object.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cc7b4-286">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-286">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32&amp; location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Single, value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exchange(float % location1, float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="cc7b4-287">Переменная, которая задается указанным значением.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-287">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-288">Значение, которое принимает параметр <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-288">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-289">Задает число с плавающей запятой с одинарной точностью указанным значением в виде атомарной операции и возвращает исходное значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-289">Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-290">Исходное значение <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-290">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="cc7b4-291">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-291">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T&amp; location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange(Of T As Class) (ByRef location1 As T, value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T Exchange(T % location1, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T&amp;" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="cc7b4-292">Тип, используемый для <c>location1</c> и <c>значение</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-292">The type to be used for <c>location1</c> and <c>value</c>.</span>
          </span>
          <span data-ttu-id="cc7b4-293">Этот тип должен быть ссылочным типом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-293">This type must be a reference type.</span>
          </span>
        </typeparam>
        <param name="location1">
          <span data-ttu-id="cc7b4-294">Переменная, которая задается указанным значением.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-294">The variable to set to the specified value.</span>
          </span>
          <span data-ttu-id="cc7b4-295">Это ссылочный параметр (<see langword="ref" /> в C#, <see langword="ByRef" /> в Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-295">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="cc7b4-296">Значение, которое принимает параметр <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-296">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-297">Задает определенное значение для переменной указанного типа <paramref name="T" /> и возвращает исходное значение (атомарная операция).</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-297">Sets a variable of the specified type <paramref name="T" /> to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-298">Исходное значение <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-298">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-299">Этот метод поддерживает только ссылочные типы.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-299">This method only supports reference types.</span></span> <span data-ttu-id="cc7b4-300">Существуют перегрузки <xref:System.Threading.Interlocked.Exchange%2A> метод <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, и <xref:System.Double> типы значений, но не поддерживается для других типов значений.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-300">There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc7b4-301">Эта перегрузка метода является более предпочтительным, чем <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> перегрузку метода, так как последний требуется доступ с поздней привязкой в целевой объект.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-301">This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late-bound access to the destination object .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc7b4-302">Следующий пример запускает десять задач, каждая из которых приводит к возникновению ошибки 100 номеров частей десяти символов.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-302">The following example launches ten tasks, each of which generates  100 ten-character part numbers.</span></span> <span data-ttu-id="cc7b4-303">Затем этот номер части, который является первым в алфавитном порядке.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-303">It then the part number that is first alphabetically.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Exchange#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/CS/Exchange5.cs#2)]
 [!code-vb[System.Threading.Interlocked.Exchange#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/VB/Exchange5.vb#2)]  
  
 <span data-ttu-id="cc7b4-304">В этом примере `firstWidget` переменной для хранения идентификатора, выполняемое первым в порядке сортировки.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-304">The example uses the `firstWidget` variable to store the ID that occurs first in the sort order.</span></span> <span data-ttu-id="cc7b4-305">Она сравнивает каждый идентификатор, который создается с `firstWidget` значение.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-305">It compares each ID that it generates with the `firstWidget` value.</span></span>  <span data-ttu-id="cc7b4-306">Если новое значение предшествует текущее значение `firstWidget` в порядке сортировки, в примере вызывается <xref:System.Threading.Interlocked.Exchange%2A> метод, чтобы присвоить новое значение для `firstWidget`.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-306">If the new value precedes the current value of `firstWidget` in the sort order, the example calls the <xref:System.Threading.Interlocked.Exchange%2A> method to assign the new value to `firstWidget`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="cc7b4-307">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-307">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cc7b4-308">Увеличивает значение заданной переменной и сохраняет результат в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-308">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Increment(int % location);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="cc7b4-309">Переменная, значение которой должно увеличиваться.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-309">The variable whose value is to be incremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-310">Увеличивает значение заданной переменной и сохраняет результат в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-310">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-311">Увеличиваемое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-311">The incremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-312">Этот метод обрабатывает условие, заключив: Если `location`  =  <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-312">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="cc7b4-313">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-313">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc7b4-314">В следующем примере определяется, необходимые для создания 1 000 случайных чисел с среднее значение количества случайных чисел в диапазоне от 0 до 1000.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-314">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="cc7b4-315">Для отслеживания числа значений середины, переменной, `midpointCount`, равным 0 и увеличивается на единицу при каждом генератора случайных чисел возвращает среднее значение, пока не достигнет 10 000.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-315">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000.</span></span> <span data-ttu-id="cc7b4-316">Так как три потока создания случайных чисел, <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> метод вызывается, чтобы убедиться, что несколько потоков не обновлять `midpointCount` одновременно.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-316">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="cc7b4-317">Обратите внимание, что блокировка также используется для защиты генератора случайных чисел и что <xref:System.Threading.CountdownEvent> объект используется для убедитесь, что `Main` метод завершается выполнение перед три потока.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-317">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 <span data-ttu-id="cc7b4-318">Следующий пример похож на предыдущий, за исключением того, что он использует вместо поток процедуру, чтобы сформировать 50 000 середины случайных целых чисел.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-318">The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="cc7b4-319">В этом примере лямбда-выражение заменяет `GenerateNumbers` процедуры потока и вызова <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> метод исключает необходимость в <xref:System.Threading.CountdownEvent> объекта.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-319">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="cc7b4-320">Адрес <paramref name="location" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-320">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Increment(long % location);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="cc7b4-321">Переменная, значение которой должно увеличиваться.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-321">The variable whose value is to be incremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-322">Увеличивает значение заданной переменной и сохраняет результат в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-322">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-323">Увеличиваемое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-323">The incremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-324">Этот метод обрабатывает условие, заключив: Если `location`  =  <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-324">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="cc7b4-325">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-325">No exception is thrown.</span></span>  
  
 <span data-ttu-id="cc7b4-326"><xref:System.Threading.Interlocked.Read%2A> Метод и 64-разрядных перегрузки <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, и <xref:System.Threading.Interlocked.Add%2A> методы атомарны действительно только в системах, где <xref:System.IntPtr?displayProperty=nameWithType> long 64 бита.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-326">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="cc7b4-327">В других системах эти методы являются атомарными по отношению друг к другу, но не по отношению к другим способом доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-327">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="cc7b4-328">Таким образом, чтобы быть поточно-ориентированным на 32-разрядных системах, доступ к 64-разрядное значение необходимо вносить с помощью члены <xref:System.Threading.Interlocked> класса.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-328">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="cc7b4-329">Адрес <paramref name="location" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-329">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cc7b4-330">Синхронизирует доступ к памяти следующим образом: процессор, выполняющий текущий поток, не способен упорядочить инструкции так, чтобы обращения к памяти до вызова метода <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> выполнялись после обращений к памяти, следующих за вызовом метода <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-330">Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-331">Этот метод добавлен для <xref:System.Threading.Interlocked> класса в [!INCLUDE[net_v45](~/includes/net-v45-md.md)] для удобства; он является оболочкой для <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-331">This method was added to the <xref:System.Threading.Interlocked> class in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] as a convenience; it's a wrapper for the <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="cc7b4-332"><xref:System.Threading.Interlocked.MemoryBarrier%2A> требуется только в многопроцессорных системах, которые имеют слабые память порядок (например, системы, который использует несколько процессоров Intel Itanium).</span><span class="sxs-lookup"><span data-stu-id="cc7b4-332"><xref:System.Threading.Interlocked.MemoryBarrier%2A> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="cc7b4-333">Для большинства целей, C# `lock` оператор, Visual Basic `SyncLock` инструкции или <xref:System.Threading.Monitor> класса предоставляют более простые способы синхронизации данных.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-333">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrierProcessWide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrierProcessWide();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Read(long % location);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="cc7b4-334">Загружаемое 64-разрядное значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-334">The 64-bit value to be loaded.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cc7b4-335">Возвращает 64-разрядное значение, загруженное в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-335">Returns a 64-bit value, loaded as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cc7b4-336">Загруженное значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cc7b4-336">The loaded value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc7b4-337"><xref:System.Threading.Interlocked.Read%2A> Метод необязателен в 64-разрядных системах, так как 64-разрядной операции чтения уже являются атомарными.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-337">The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic.</span></span> <span data-ttu-id="cc7b4-338">В 32-разрядных системах, операций чтения для 64-разрядных не являются атомарными, если не выполнить с помощью <xref:System.Threading.Interlocked.Read%2A>.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-338">On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>.</span></span>  
  
 <span data-ttu-id="cc7b4-339"><xref:System.Threading.Interlocked.Read%2A> Метод и 64-разрядных перегрузки <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, и <xref:System.Threading.Interlocked.Add%2A> методы атомарны действительно только в системах, где <xref:System.IntPtr?displayProperty=nameWithType> long 64 бита.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-339">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="cc7b4-340">В других системах эти методы являются атомарными по отношению друг к другу, но не по отношению к другим способом доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-340">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="cc7b4-341">Таким образом, чтобы быть поточно-ориентированным на 32-разрядных системах, доступ к 64-разрядное значение необходимо вносить с помощью члены <xref:System.Threading.Interlocked> класса.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-341">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc7b4-342"><xref:System.IntPtr> — Это тип конкретную платформу.</span><span class="sxs-lookup"><span data-stu-id="cc7b4-342"><xref:System.IntPtr> is a platform-specific type.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
      </Docs>
    </Member>
  </Members>
</Type>