<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e93505153afa01898f1c40d9df002f7c8da16b5e" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609174" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Interlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class Interlocked" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked abstract sealed" />
  <TypeSignature Language="F#" Value="type Interlocked = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="31b35-101">Предоставляет атомарные операции для переменных, общедоступных нескольким потокам.</span>
      <span class="sxs-lookup">
        <span data-stu-id="31b35-101">Provides atomic operations for variables that are shared by multiple threads.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-102">Методы этого класса защиты от ошибок, которые могут возникнуть при переключении контекстов планировщиком, пока поток обновляет переменную, которая может быть доступна другим потокам, или при параллельном выполнении двух потоков на отдельных процессорах.</span><span class="sxs-lookup"><span data-stu-id="31b35-102">The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors.</span></span> <span data-ttu-id="31b35-103">Члены этого класса не вызывают исключений.</span><span class="sxs-lookup"><span data-stu-id="31b35-103">The members of this class do not throw exceptions.</span></span>  
  
 <span data-ttu-id="31b35-104"><xref:System.Threading.Interlocked.Increment%2A> И <xref:System.Threading.Interlocked.Decrement%2A> методы увеличения значения или уменьшают переменную и сохраняют результат в рамках одной операции.</span><span class="sxs-lookup"><span data-stu-id="31b35-104">The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation.</span></span> <span data-ttu-id="31b35-105">На большинстве компьютеров увеличение значения переменной не является атомарной операцией, требует следующих шагов:</span><span class="sxs-lookup"><span data-stu-id="31b35-105">On most computers, incrementing a variable is not an atomic operation, requiring the following steps:</span></span>  
  
1.  <span data-ttu-id="31b35-106">Загрузите значение из переменной экземпляра в регистр.</span><span class="sxs-lookup"><span data-stu-id="31b35-106">Load a value from an instance variable into a register.</span></span>  
  
2.  <span data-ttu-id="31b35-107">Увеличить или уменьшить значение.</span><span class="sxs-lookup"><span data-stu-id="31b35-107">Increment or decrement the value.</span></span>  
  
3.  <span data-ttu-id="31b35-108">Store значение в переменной экземпляра.</span><span class="sxs-lookup"><span data-stu-id="31b35-108">Store the value in the instance variable.</span></span>  
  
 <span data-ttu-id="31b35-109">Если вы не используете <xref:System.Threading.Interlocked.Increment%2A> и <xref:System.Threading.Interlocked.Decrement%2A>, поток может быть вытеснен после выполнения первых двух шагов.</span><span class="sxs-lookup"><span data-stu-id="31b35-109">If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps.</span></span> <span data-ttu-id="31b35-110">Другой поток, затем можно выполнить все три шага.</span><span class="sxs-lookup"><span data-stu-id="31b35-110">Another thread can then execute all three steps.</span></span> <span data-ttu-id="31b35-111">Когда первый поток возобновляет выполнение, он переопределяет значение в переменной экземпляра, и последствия инкремент или декремент выполняется вторым потоком теряется.</span><span class="sxs-lookup"><span data-stu-id="31b35-111">When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.</span></span>  
  
 <span data-ttu-id="31b35-112"><xref:System.Threading.Interlocked.Exchange%2A> Метод атомарным образом меняет местами значения указанных переменных.</span><span class="sxs-lookup"><span data-stu-id="31b35-112">The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables.</span></span> <span data-ttu-id="31b35-113"><xref:System.Threading.Interlocked.CompareExchange%2A> Метод объединяет две операции: сравнение двух значений и сохранение третьего значения в одной из переменных, на основе результата сравнения.</span><span class="sxs-lookup"><span data-stu-id="31b35-113">The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.</span></span> <span data-ttu-id="31b35-114">Операции сравнения и обмена выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="31b35-114">The compare and exchange operations are performed as an atomic operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31b35-115">В следующем примере кода показан механизм блокировки ресурсов поточно ориентированными.</span><span class="sxs-lookup"><span data-stu-id="31b35-115">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="31b35-116">Данный тип потокобезопасен.</span>
      <span class="sxs-lookup">
        <span data-stu-id="31b35-116">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="31b35-117">Добавляет два целых числа и заменяет первое число на сумму (атомарная операция).</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-117">Adds two integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Add(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int -&gt; int" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="31b35-118">Переменная, содержащая первое добавляемое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-118">A variable containing the first value to be added.</span>
          </span>
          <span data-ttu-id="31b35-119">Сумма двух значений сохраняется в <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-119">The sum of the two values is stored in <c>location1</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-120">Значение, добавляемое к целому в <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-120">The value to be added to the integer at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-121">Добавляет два 32-разрядных целых числа и заменяет первое число на сумму в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-121">Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-122">Новое значение сохраняется в <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-122">The new value stored at <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-123">Этот метод обрабатывает условие, заключая: Если значение в `location1` — <xref:System.Int32.MaxValue?displayProperty=nameWithType> и `value` равно 1, в результате <xref:System.Int32.MinValue?displayProperty=nameWithType>; Если `value` равно 2, в результате (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); и т. д.</span><span class="sxs-lookup"><span data-stu-id="31b35-123">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int32.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int32.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="31b35-124">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="31b35-124">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31b35-125">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-125">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Add(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="31b35-126">Переменная, содержащая первое добавляемое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-126">A variable containing the first value to be added.</span>
          </span>
          <span data-ttu-id="31b35-127">Сумма двух значений сохраняется в <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-127">The sum of the two values is stored in <c>location1</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-128">Значение, добавляемое к целому в <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-128">The value to be added to the integer at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-129">Добавляет два 64-разрядных целых числа и заменяет первое число на сумму в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-129">Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-130">Новое значение сохраняется в <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-130">The new value stored at <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-131">Этот метод обрабатывает условие, заключая: Если значение в `location1` — <xref:System.Int64.MaxValue?displayProperty=nameWithType> и `value` равно 1, в результате <xref:System.Int64.MinValue?displayProperty=nameWithType>; Если `value` равно 2, в результате (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); и т. д.</span><span class="sxs-lookup"><span data-stu-id="31b35-131">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int64.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int64.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="31b35-132">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="31b35-132">No exception is thrown.</span></span>  
  
 <span data-ttu-id="31b35-133"><xref:System.Threading.Interlocked.Read%2A> Метод и 64-разрядных перегрузок <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, и <xref:System.Threading.Interlocked.Add%2A> методы атомарны действительно только в системах, где <xref:System.IntPtr?displayProperty=nameWithType> 64 бита.</span><span class="sxs-lookup"><span data-stu-id="31b35-133">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="31b35-134">В других системах эти методы являются атомарными по отношению друг к другу, но не по отношению к другими способами доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="31b35-134">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="31b35-135">Таким образом, чтобы быть поточно-ориентированным на 32-разрядных системах, доступа к 64-разрядное значение необходимо устанавливать с помощью членами <xref:System.Threading.Interlocked> класса.</span><span class="sxs-lookup"><span data-stu-id="31b35-135">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31b35-136">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-136">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareExchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="31b35-137">Сравнивает два значения на равенство и, если они равны, заменяет первое.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-137">Compares two values for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64&amp; location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Double, value As Double, comparand As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CompareExchange(double % location1, double value, double comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * double * double -&gt; double" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="comparand" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="31b35-138">Целевой объект, значение которого сравнивается с объектом <c>comparand</c> и может быть заменено.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-138">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-139">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-139">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="31b35-140">Значение, которое сравнивается со значением в позиции <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-140">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-141">Сравнивает два числа с плавающей запятой двойной точности на равенство и, если они равны, заменяет первое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-141">Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-142">Исходное значение в позиции <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-142">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-143">Если `comparand` и значение в `location1` равны, то `value` хранится в `location1`.</span><span class="sxs-lookup"><span data-stu-id="31b35-143">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="31b35-144">В противном случае операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="31b35-144">Otherwise, no operation is performed.</span></span> <span data-ttu-id="31b35-145">Операции сравнения и обмена выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="31b35-145">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="31b35-146">Возвращаемое значение <xref:System.Threading.Interlocked.CompareExchange%2A> собой исходное значение в `location1`независимо от того, имеет место обмен или нет.</span><span class="sxs-lookup"><span data-stu-id="31b35-146">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31b35-147">В следующем примере кода демонстрируется метод поточно ориентированными, который накапливает промежуточных итогов по <xref:System.Double> значения.</span><span class="sxs-lookup"><span data-stu-id="31b35-147">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Double> values.</span></span> <span data-ttu-id="31b35-148">Два потока добавляет ряд <xref:System.Double> значения, используя метод поточно ориентированными и обычные сложение, и затем потоки итоговые значения сравниваются.</span><span class="sxs-lookup"><span data-stu-id="31b35-148">Two threads add a series of <xref:System.Double> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="31b35-149">На компьютере, два двухъядерных процессора есть значительная разница в итоги.</span><span class="sxs-lookup"><span data-stu-id="31b35-149">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="31b35-150">В методе поточно ориентированные сохраняется исходное значение нарастающего итога, а затем <xref:System.Threading.Interlocked.CompareExchange%2A> метод используется для обмена новым вычисленным всего с помощью старого общего количества.</span><span class="sxs-lookup"><span data-stu-id="31b35-150">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="31b35-151">Если возвращаемое значение не равно сохраненному значению промежуточной суммы, то другой поток обновляет в то же время.</span><span class="sxs-lookup"><span data-stu-id="31b35-151">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="31b35-152">В этом случае необходимо повторить попытку обновить нарастающий итог.</span><span class="sxs-lookup"><span data-stu-id="31b35-152">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31b35-153">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-153">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32&amp; location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Integer, value As Integer, comparand As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareExchange(int % location1, int value, int comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int * int -&gt; int" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="31b35-154">Целевой объект, значение которого сравнивается с объектом <c>comparand</c> и может быть заменено.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-154">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-155">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-155">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="31b35-156">Значение, которое сравнивается со значением в позиции <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-156">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-157">Сравнивает два 32-разрядных целых числа со знаком на равенство и, если они равны, заменяет первое.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-157">Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-158">Исходное значение в позиции <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-158">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-159">Если `comparand` и значение в `location1` равны, то `value` хранится в `location1`.</span><span class="sxs-lookup"><span data-stu-id="31b35-159">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="31b35-160">В противном случае операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="31b35-160">Otherwise, no operation is performed.</span></span> <span data-ttu-id="31b35-161">Операции сравнения и обмена выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="31b35-161">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="31b35-162">Возвращаемое значение <xref:System.Threading.Interlocked.CompareExchange%2A> собой исходное значение в `location1`независимо от того, имеет место обмен или нет.</span><span class="sxs-lookup"><span data-stu-id="31b35-162">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31b35-163">В следующем примере кода демонстрируется метод поточно ориентированными, который накапливает промежуточных итогов.</span><span class="sxs-lookup"><span data-stu-id="31b35-163">The following code example demonstrates a thread-safe method that accumulates a running total.</span></span> <span data-ttu-id="31b35-164">Начальное значение нарастающего итога сохраняется, а затем <xref:System.Threading.Interlocked.CompareExchange%2A> метод используется для обмена новым вычисленным всего с помощью старого общего количества.</span><span class="sxs-lookup"><span data-stu-id="31b35-164">The initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="31b35-165">Если возвращаемое значение не равно сохраненному значению промежуточной суммы, то другой поток обновляет в то же время.</span><span class="sxs-lookup"><span data-stu-id="31b35-165">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="31b35-166">В этом случае необходимо повторить попытку обновить нарастающий итог.</span><span class="sxs-lookup"><span data-stu-id="31b35-166">In that case, the attempt to update the running total must be repeated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31b35-167"><xref:System.Threading.Interlocked.Add%2A> Метод, появившихся в версии 2.0 платформы .NET Framework, обеспечивает более удобный способ накапливать поточно ориентированные промежуточных итогов для целых чисел.</span><span class="sxs-lookup"><span data-stu-id="31b35-167">The <xref:System.Threading.Interlocked.Add%2A> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31b35-168">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-168">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64&amp; location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Long, value As Long, comparand As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long CompareExchange(long % location1, long value, long comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="comparand" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="31b35-169">Целевой объект, значение которого сравнивается с объектом <c>comparand</c> и может быть заменено.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-169">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-170">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-170">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="31b35-171">Значение, которое сравнивается со значением в позиции <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-171">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-172">Сравнивает два 64-разрядных целых числа со знаком на равенство и, если они равны, заменяет первое.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-172">Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-173">Исходное значение в позиции <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-173">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-174">Если `comparand` и значение в `location1` равны, то `value` хранится в `location1`.</span><span class="sxs-lookup"><span data-stu-id="31b35-174">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="31b35-175">В противном случае операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="31b35-175">Otherwise, no operation is performed.</span></span> <span data-ttu-id="31b35-176">Операции сравнения и обмена выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="31b35-176">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="31b35-177">Возвращаемое значение <xref:System.Threading.Interlocked.CompareExchange%2A> собой исходное значение в `location1`независимо от того, имеет место обмен или нет.</span><span class="sxs-lookup"><span data-stu-id="31b35-177">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31b35-178">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-178">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int&amp; location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As IntPtr, value As IntPtr, comparand As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CompareExchange(IntPtr % location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
        <Parameter Name="comparand" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="31b35-179">Целевое значение <see cref="T:System.IntPtr" />, которое будет сравниваться со значением параметра <c>comparand</c> и, возможно, будет заменено <c>value</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-179">The destination <see cref="T:System.IntPtr" />, whose value is compared with the value of <c>comparand</c> and possibly replaced by <c>value</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-180">Значение <see cref="T:System.IntPtr" />, которое заменит целевое значение, если результатом сравнения будет равенство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-180">The <see cref="T:System.IntPtr" /> that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="31b35-181">Значение <see cref="T:System.IntPtr" />, которое сравнивается со значением в <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-181">The <see cref="T:System.IntPtr" /> that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-182">Сравнивает два зависящих от платформы обработчика или указателя на равенство и, если они равны, заменяет первое из значений.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-182">Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-183">Исходное значение в позиции <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-183">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-184">Если `comparand` и значение в `location1` равны, то `value` хранится в `location1`.</span><span class="sxs-lookup"><span data-stu-id="31b35-184">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="31b35-185">В противном случае операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="31b35-185">Otherwise, no operation is performed.</span></span> <span data-ttu-id="31b35-186">Операции сравнения и обмена выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="31b35-186">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="31b35-187">Этот метод возвращается исходное значение в `location1`независимо от того, имеет место обмен или нет.</span><span class="sxs-lookup"><span data-stu-id="31b35-187">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31b35-188"><xref:System.IntPtr> — Это тип платформы.</span><span class="sxs-lookup"><span data-stu-id="31b35-188"><xref:System.IntPtr> is a platform-specific type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31b35-189">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-189">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object&amp; location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Object, value As Object, comparand As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CompareExchange(System::Object ^ % location1, System::Object ^ value, System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * obj * obj -&gt; obj" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="31b35-190">Целевой объект, который будет сравниваться со значением параметра <c>comparand</c> и, возможно, будет заменен.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-190">The destination object that is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-191">Объект, который заменит целевой объект, если результатом сравнения будет равенство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-191">The object that replaces the destination object if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="31b35-192">Объект, который сравнивается с объектом в <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-192">The object that is compared to the object at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-193">Сравнивает два объекта на равенство ссылок и, если они равны, заменяет первый объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-193">Compares two objects for reference equality and, if they are equal, replaces the first object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-194">Исходное значение в позиции <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-194">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-195">Если `comparand` и объект в `location1` равны, то `value` хранится в `location1`.</span><span class="sxs-lookup"><span data-stu-id="31b35-195">If `comparand` and the object in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="31b35-196">В противном случае операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="31b35-196">Otherwise, no operation is performed.</span></span> <span data-ttu-id="31b35-197">Операции сравнения и обмена выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="31b35-197">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="31b35-198">Возвращаемое значение <xref:System.Threading.Interlocked.CompareExchange%2A> собой исходное значение в `location1`независимо от того, имеет место обмен или нет.</span><span class="sxs-lookup"><span data-stu-id="31b35-198">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 <span data-ttu-id="31b35-199">Начиная с .NET Framework версии 2.0, <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> перегрузку метода предоставляет типобезопасной альтернативой для ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="31b35-199">Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31b35-200">Объекты сравниваются на равенство ссылок, а не <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="31b35-200">The objects are compared for reference equality, rather than <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="31b35-201">В результате два упакованных экземпляра одной и той же тип значения (например, целочисленное значение 3) всегда могут быть не равны, и операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="31b35-201">As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed.</span></span> <span data-ttu-id="31b35-202">Не используйте эту перегрузку с типами значений.</span><span class="sxs-lookup"><span data-stu-id="31b35-202">Do not use this overload with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31b35-203">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-203">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32&amp; location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Single, value As Single, comparand As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CompareExchange(float % location1, float value, float comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * single * single -&gt; single" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="31b35-204">Целевой объект, значение которого сравнивается с объектом <c>comparand</c> и может быть заменено.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-204">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-205">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-205">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="31b35-206">Значение, которое сравнивается со значением в позиции <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-206">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-207">Сравнивает два числа с плавающей запятой с обычной точностью на равенство и, если они равны, заменяет первое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-207">Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-208">Исходное значение в позиции <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-208">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-209">Если `comparand` и значение в `location1` равны, то `value` хранится в `location1`.</span><span class="sxs-lookup"><span data-stu-id="31b35-209">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="31b35-210">В противном случае операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="31b35-210">Otherwise, no operation is performed.</span></span> <span data-ttu-id="31b35-211">Операции сравнения и обмена выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="31b35-211">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="31b35-212">Возвращаемое значение <xref:System.Threading.Interlocked.CompareExchange%2A> собой исходное значение в `location1`независимо от того, имеет место обмен или нет.</span><span class="sxs-lookup"><span data-stu-id="31b35-212">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31b35-213">В следующем примере кода демонстрируется метод поточно ориентированными, который накапливает промежуточных итогов по <xref:System.Single> значения.</span><span class="sxs-lookup"><span data-stu-id="31b35-213">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Single> values.</span></span> <span data-ttu-id="31b35-214">Два потока добавляет ряд <xref:System.Single> значения, используя метод поточно ориентированными и обычные сложение, и затем потоки итоговые значения сравниваются.</span><span class="sxs-lookup"><span data-stu-id="31b35-214">Two threads add a series of <xref:System.Single> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="31b35-215">На компьютере, два двухъядерных процессора есть значительная разница в итоги.</span><span class="sxs-lookup"><span data-stu-id="31b35-215">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="31b35-216">В методе поточно ориентированные сохраняется исходное значение нарастающего итога, а затем <xref:System.Threading.Interlocked.CompareExchange%2A> метод используется для обмена новым вычисленным всего с помощью старого общего количества.</span><span class="sxs-lookup"><span data-stu-id="31b35-216">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="31b35-217">Если возвращаемое значение не равно сохраненному значению промежуточной суммы, то другой поток обновляет в то же время.</span><span class="sxs-lookup"><span data-stu-id="31b35-217">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="31b35-218">В этом случае необходимо повторить попытку обновить нарастающий итог.</span><span class="sxs-lookup"><span data-stu-id="31b35-218">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31b35-219">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-219">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T&amp; location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange(Of T As Class) (ByRef location1 As T, value As T, comparand As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T CompareExchange(T % location1, T value, T comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T&amp;" RefType="ref" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparand" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="31b35-220">Тип, используемый для <c>location1</c>, <c>значение</c>, и <c>comparand</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-220">The type to be used for <c>location1</c>, <c>value</c>, and <c>comparand</c>.</span>
          </span>
          <span data-ttu-id="31b35-221">Этот тип должен быть ссылочным типом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-221">This type must be a reference type.</span>
          </span>
        </typeparam>
        <param name="location1">
          <span data-ttu-id="31b35-222">Целевой объект, значение которого сравнивается с объектом <c>comparand</c> и может быть заменено.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-222">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
          <span data-ttu-id="31b35-223">Это ссылочный параметр (<see langword="ref" /> в C#, <see langword="ByRef" /> в Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-223">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-224">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-224">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="31b35-225">Значение, которое сравнивается со значением в позиции <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-225">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-226">Сравнивает два экземпляра указанного ссылочного типа <paramref name="T" /> на равенство и, если это так, заменяет один из них.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-226">Compares two instances of the specified reference type <paramref name="T" /> for equality and, if they are equal, replaces the first one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-227">Исходное значение в позиции <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-227">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-228">Если `comparand` и значение в `location1` равны, то `value` хранится в `location1`.</span><span class="sxs-lookup"><span data-stu-id="31b35-228">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="31b35-229">В противном случае операция не выполняется.</span><span class="sxs-lookup"><span data-stu-id="31b35-229">Otherwise, no operation is performed.</span></span> <span data-ttu-id="31b35-230">Сравнение и обмен выполняются в виде атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="31b35-230">The comparison and the exchange are performed as an atomic operation.</span></span> <span data-ttu-id="31b35-231">Этот метод возвращается исходное значение в `location1`независимо от того, имеет место обмен или нет.</span><span class="sxs-lookup"><span data-stu-id="31b35-231">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 <span data-ttu-id="31b35-232">Этот метод поддерживает только ссылочные типы.</span><span class="sxs-lookup"><span data-stu-id="31b35-232">This method only supports reference types.</span></span> <span data-ttu-id="31b35-233">Существуют перегрузки <xref:System.Threading.Interlocked.CompareExchange%2A> метод для типов значений <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, и <xref:System.Double>, но не поддерживается для других типов значений.</span><span class="sxs-lookup"><span data-stu-id="31b35-233">There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31b35-234">Эта перегрузка метода является более предпочтительным, чем <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> перегрузку метода, так как последнее требует, чтобы получить доступ с поздним связыванием объект назначения.</span><span class="sxs-lookup"><span data-stu-id="31b35-234">This method overload is preferable to the <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> method overload, because the latter requires the destination object to be accessed late-bound.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31b35-235">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-235">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="31b35-236">Уменьшает значение заданной переменной и сохраняет результат в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-236">Decrements a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Decrement(int % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="31b35-237">Переменная, у которой уменьшается значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-237">The variable whose value is to be decremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-238">Уменьшает значение заданной переменной и сохраняет результат в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-238">Decrements a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-239">Уменьшаемое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-239">The decremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-240">Этот метод обрабатывает условие, заключая: Если `location`  =  <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="31b35-240">This method handles an overflow condition by wrapping: If `location` = <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="31b35-241">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="31b35-241">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31b35-242">В следующем примере определяется, какое количество случайных чисел в диапазоне от 0 до 1000, должны создавать 1000 случайных чисел с среднего значения.</span><span class="sxs-lookup"><span data-stu-id="31b35-242">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="31b35-243">Чтобы отслеживать количество средние значения, переменной, `midpointCount`, — это значение равно 1000 и уменьшается на единицу каждый раз, когда генератора случайных чисел возвращает среднее значение.</span><span class="sxs-lookup"><span data-stu-id="31b35-243">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value.</span></span> <span data-ttu-id="31b35-244">Так как три потока создания случайных чисел, <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> вызывается метод, чтобы убедиться, что несколько потоков не обновлять `midpointCount` одновременно.</span><span class="sxs-lookup"><span data-stu-id="31b35-244">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="31b35-245">Обратите внимание, что блокировка также используется для защиты генератора случайных чисел и что <xref:System.Threading.CountdownEvent> объект используется для убедитесь, что `Main` метод не завершить выполнение перед три потока.</span><span class="sxs-lookup"><span data-stu-id="31b35-245">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 <span data-ttu-id="31b35-246">Следующий пример похож на предыдущий, за исключением того, что она использует вместо процедуре потока для создания 50 000 случайных средней точки целых чисел.</span><span class="sxs-lookup"><span data-stu-id="31b35-246">The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="31b35-247">В этом примере лямбда-выражение заменяет `GenerateNumbers` процедуру потока, а при вызове <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> метод устраняет потребность в <xref:System.Threading.CountdownEvent> объекта.</span><span class="sxs-lookup"><span data-stu-id="31b35-247">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31b35-248">Адрес <paramref name="location" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-248">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Decrement(long % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int64" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="31b35-249">Переменная, у которой уменьшается значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-249">The variable whose value is to be decremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-250">Уменьшает значение заданной переменной и сохраняет результат в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-250">Decrements the specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-251">Уменьшаемое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-251">The decremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-252">Этот метод обрабатывает условие, заключая: Если `location`  =  <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="31b35-252">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="31b35-253">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="31b35-253">No exception is thrown.</span></span>  
  
 <span data-ttu-id="31b35-254"><xref:System.Threading.Interlocked.Read%2A> Метод и 64-разрядных перегрузок <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, и <xref:System.Threading.Interlocked.Add%2A> методы атомарны действительно только в системах, где <xref:System.IntPtr?displayProperty=nameWithType> 64 бита.</span><span class="sxs-lookup"><span data-stu-id="31b35-254">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="31b35-255">В других системах эти методы являются атомарными по отношению друг к другу, но не по отношению к другими способами доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="31b35-255">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="31b35-256">Таким образом, чтобы быть поточно-ориентированным на 32-разрядных системах, доступа к 64-разрядное значение необходимо устанавливать с помощью членами <xref:System.Threading.Interlocked> класса.</span><span class="sxs-lookup"><span data-stu-id="31b35-256">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31b35-257">Адрес <paramref name="location" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-257">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="31b35-258">Задает переменную указанным значением в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-258">Sets a variable to a specified value as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64&amp; location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Double, value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exchange(double % location1, double value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * double -&gt; double" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="31b35-259">Переменная, которая задается указанным значением.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-259">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-260">Значение, которое принимает параметр <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-260">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-261">Задает число с плавающей запятой с двойной точностью указанным значением в виде атомарной операции и возвращает исходное значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-261">Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-262">Исходное значение <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-262">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31b35-263">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-263">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Exchange(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int -&gt; int" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="31b35-264">Переменная, которая задается указанным значением.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-264">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-265">Значение, которое принимает параметр <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-265">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-266">Присваивает 32-разрядному целому числу со знаком заданное значение и возвращает исходное значение в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-266">Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-267">Исходное значение <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-267">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="31b35-268">В следующем примере кода показан механизм блокировки ресурсов поточно ориентированными.</span><span class="sxs-lookup"><span data-stu-id="31b35-268">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31b35-269">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-269">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Exchange(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="31b35-270">Переменная, которая задается указанным значением.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-270">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-271">Значение, которое принимает параметр <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-271">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-272">Присваивает 64-разрядному целому числу со знаком заданное значение и возвращает исходное значение в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-272">Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-273">Исходное значение <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-273">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31b35-274">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-274">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int&amp; location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As IntPtr, value As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Exchange(IntPtr % location1, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="31b35-275">Переменная, которая задается указанным значением.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-275">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-276">Значение, которое принимает параметр <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-276">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-277">Задает указатель или обработчик, зависящий от платформы в виде атомарной операции, и возвращает ссылку на исходное значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-277">Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-278">Исходное значение <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-278">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31b35-279">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-279">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object&amp; location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Object, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Exchange(System::Object ^ % location1, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * obj -&gt; obj" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="31b35-280">Переменная, которая задается указанным значением.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-280">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-281">Значение, которое принимает параметр <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-281">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-282">Задает объект указанным значением в виде атомарной операции и возвращает ссылку на исходный объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-282">Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-283">Исходное значение <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-283">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!NOTE]
> <span data-ttu-id="31b35-284">Начиная с .NET Framework версии 2.0, <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> перегрузку метода предоставляет типобезопасной альтернативой для ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="31b35-284">Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span>  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31b35-285">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-285">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32&amp; location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Single, value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exchange(float % location1, float value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * single -&gt; single" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="31b35-286">Переменная, которая задается указанным значением.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-286">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-287">Значение, которое принимает параметр <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-287">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-288">Задает число с плавающей запятой с одинарной точностью указанным значением в виде атомарной операции и возвращает исходное значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-288">Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-289">Исходное значение <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-289">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31b35-290">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-290">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T&amp; location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange(Of T As Class) (ByRef location1 As T, value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T Exchange(T % location1, T value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T&amp;" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="31b35-291">Тип, используемый для <c>location1</c> и <c>значение</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-291">The type to be used for <c>location1</c> and <c>value</c>.</span>
          </span>
          <span data-ttu-id="31b35-292">Этот тип должен быть ссылочным типом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-292">This type must be a reference type.</span>
          </span>
        </typeparam>
        <param name="location1">
          <span data-ttu-id="31b35-293">Переменная, которая задается указанным значением.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-293">The variable to set to the specified value.</span>
          </span>
          <span data-ttu-id="31b35-294">Это ссылочный параметр (<see langword="ref" /> в C#, <see langword="ByRef" /> в Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-294">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="31b35-295">Значение, которое принимает параметр <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-295">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-296">Задает определенное значение для переменной указанного типа <paramref name="T" /> и возвращает исходное значение (атомарная операция).</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-296">Sets a variable of the specified type <paramref name="T" /> to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-297">Исходное значение <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-297">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-298">Этот метод поддерживает только ссылочные типы.</span><span class="sxs-lookup"><span data-stu-id="31b35-298">This method only supports reference types.</span></span> <span data-ttu-id="31b35-299">Существуют перегрузки <xref:System.Threading.Interlocked.Exchange%2A> метод <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, и <xref:System.Double> типы значений, но не поддерживается для других типов значений.</span><span class="sxs-lookup"><span data-stu-id="31b35-299">There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31b35-300">Эта перегрузка метода является более предпочтительным, чем <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> перегрузку метода, так как последнее требует доступ с поздним связыванием в целевой объект.</span><span class="sxs-lookup"><span data-stu-id="31b35-300">This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late-bound access to the destination object .</span></span>  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31b35-301">Адрес <paramref name="location1" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-301">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="31b35-302">Увеличивает значение заданной переменной и сохраняет результат в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-302">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Increment(int % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="31b35-303">Переменная, значение которой должно увеличиваться.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-303">The variable whose value is to be incremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-304">Увеличивает значение заданной переменной и сохраняет результат в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-304">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-305">Увеличиваемое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-305">The incremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-306">Этот метод обрабатывает условие, заключая: Если `location`  =  <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="31b35-306">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="31b35-307">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="31b35-307">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31b35-308">В следующем примере определяется, какое количество случайных чисел в диапазоне от 0 до 1000, должны создавать 1000 случайных чисел с среднего значения.</span><span class="sxs-lookup"><span data-stu-id="31b35-308">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="31b35-309">Чтобы отслеживать количество средние значения, переменной, `midpointCount`, равным 0 и увеличивается каждый раз, когда генератора случайных чисел возвращает среднее значение, пока не достигнет 10 000.</span><span class="sxs-lookup"><span data-stu-id="31b35-309">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000.</span></span> <span data-ttu-id="31b35-310">Так как три потока создания случайных чисел, <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> вызывается метод, чтобы убедиться, что несколько потоков не обновлять `midpointCount` одновременно.</span><span class="sxs-lookup"><span data-stu-id="31b35-310">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="31b35-311">Обратите внимание, что блокировка также используется для защиты генератора случайных чисел и что <xref:System.Threading.CountdownEvent> объект используется для убедитесь, что `Main` метод не завершить выполнение перед три потока.</span><span class="sxs-lookup"><span data-stu-id="31b35-311">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 <span data-ttu-id="31b35-312">Следующий пример похож на предыдущий, за исключением того, что она использует вместо процедуре потока для создания 50 000 случайных средней точки целых чисел.</span><span class="sxs-lookup"><span data-stu-id="31b35-312">The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="31b35-313">В этом примере лямбда-выражение заменяет `GenerateNumbers` процедуру потока, а при вызове <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> метод устраняет потребность в <xref:System.Threading.CountdownEvent> объекта.</span><span class="sxs-lookup"><span data-stu-id="31b35-313">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31b35-314">Адрес <paramref name="location" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-314">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Increment(long % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int64" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="31b35-315">Переменная, значение которой должно увеличиваться.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-315">The variable whose value is to be incremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-316">Увеличивает значение заданной переменной и сохраняет результат в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-316">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-317">Увеличиваемое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-317">The incremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-318">Этот метод обрабатывает условие, заключая: Если `location`  =  <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="31b35-318">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="31b35-319">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="31b35-319">No exception is thrown.</span></span>  
  
 <span data-ttu-id="31b35-320"><xref:System.Threading.Interlocked.Read%2A> Метод и 64-разрядных перегрузок <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, и <xref:System.Threading.Interlocked.Add%2A> методы атомарны действительно только в системах, где <xref:System.IntPtr?displayProperty=nameWithType> 64 бита.</span><span class="sxs-lookup"><span data-stu-id="31b35-320">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="31b35-321">В других системах эти методы являются атомарными по отношению друг к другу, но не по отношению к другими способами доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="31b35-321">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="31b35-322">Таким образом, чтобы быть поточно-ориентированным на 32-разрядных системах, доступа к 64-разрядное значение необходимо устанавливать с помощью членами <xref:System.Threading.Interlocked> класса.</span><span class="sxs-lookup"><span data-stu-id="31b35-322">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31b35-323">Адрес <paramref name="location" /> является пустым указателем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-323">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="31b35-324">Синхронизирует доступ к памяти следующим образом: процессор, выполняющий текущий поток, не способен упорядочить инструкции так, чтобы обращения к памяти до вызова метода <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> выполнялись после обращений к памяти, следующих за вызовом метода <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-324">Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-325">Этот метод был добавлен к <xref:System.Threading.Interlocked> в класс [!INCLUDE[net_v45](~/includes/net-v45-md.md)] удобства; он является оболочкой для <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="31b35-325">This method was added to the <xref:System.Threading.Interlocked> class in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] as a convenience; it's a wrapper for the <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="31b35-326"><xref:System.Threading.Interlocked.MemoryBarrier%2A> требуется только в многопроцессорных системах, которые имеют слабые памяти упорядочение (например, система, в которых используются несколько процессоров Intel Itanium).</span><span class="sxs-lookup"><span data-stu-id="31b35-326"><xref:System.Threading.Interlocked.MemoryBarrier%2A> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="31b35-327">Для большинства целей, C# `lock` инструкции, Visual Basic `SyncLock` инструкции или <xref:System.Threading.Monitor> класса предоставляют более простые способы синхронизации данных.</span><span class="sxs-lookup"><span data-stu-id="31b35-327">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrierProcessWide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrierProcessWide();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrierProcessWide : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrierProcessWide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Read(long % location);" />
      <MemberSignature Language="F#" Value="static member Read :  -&gt; int64" Usage="System.Threading.Interlocked.Read location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="31b35-328">Загружаемое 64-разрядное значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-328">The 64-bit value to be loaded.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31b35-329">Возвращает 64-разрядное значение, загруженное в виде атомарной операции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-329">Returns a 64-bit value, loaded as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31b35-330">Загруженное значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31b35-330">The loaded value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31b35-331"><xref:System.Threading.Interlocked.Read%2A> Метод необязателен в 64-разрядных системах, так как 64-разрядной операции чтения уже являются атомарными.</span><span class="sxs-lookup"><span data-stu-id="31b35-331">The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic.</span></span> <span data-ttu-id="31b35-332">В 32-разрядных системах, 64-разрядной операции чтения не являются атомарными, пока не будет выполнена с помощью <xref:System.Threading.Interlocked.Read%2A>.</span><span class="sxs-lookup"><span data-stu-id="31b35-332">On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>.</span></span>  
  
 <span data-ttu-id="31b35-333"><xref:System.Threading.Interlocked.Read%2A> Метод и 64-разрядных перегрузок <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, и <xref:System.Threading.Interlocked.Add%2A> методы атомарны действительно только в системах, где <xref:System.IntPtr?displayProperty=nameWithType> 64 бита.</span><span class="sxs-lookup"><span data-stu-id="31b35-333">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="31b35-334">В других системах эти методы являются атомарными по отношению друг к другу, но не по отношению к другими способами доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="31b35-334">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="31b35-335">Таким образом, чтобы быть поточно-ориентированным на 32-разрядных системах, доступа к 64-разрядное значение необходимо устанавливать с помощью членами <xref:System.Threading.Interlocked> класса.</span><span class="sxs-lookup"><span data-stu-id="31b35-335">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31b35-336"><xref:System.IntPtr> — Это тип платформы.</span><span class="sxs-lookup"><span data-stu-id="31b35-336"><xref:System.IntPtr> is a platform-specific type.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
      </Docs>
    </Member>
  </Members>
</Type>