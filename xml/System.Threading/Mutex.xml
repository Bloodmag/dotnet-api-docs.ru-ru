<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6bce0feaf14f66f8608164cfa777620d7f3b329f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530998" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Примитив синхронизации, который также может использоваться в межпроцессорной синхронизации.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда два или более потоков требуется доступ к общему ресурсу одновременно, системе необходим механизм синхронизации, чтобы гарантировать, что только один поток одновременно используется ресурс. <xref:System.Threading.Mutex> — Это синхронизации примитив, который предоставляет монопольный доступ к общему ресурсу, чтобы только один поток. Если поток получает семафор, второй поток, желающий получить этот семафор приостанавливается, пока первый поток освобождает объект взаимного исключения.  
  
> [!IMPORTANT]
>  Этот тип реализует <xref:System.IDisposable> интерфейса. После завершения с помощью типа следует освободить его прямо или косвенно. Для удаления типа непосредственно вызвать его <xref:System.IDisposable.Dispose%2A> метод в `try` / `catch` блока. Чтобы удалить ее косвенно, использовать языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <xref:System.IDisposable> разделе интерфейса.  
  
 Можно использовать <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> метода, который запросит владение мьютексом. Вызывающий поток блокируется, пока не произойдет одно из следующих событий:  
  
-   Чтобы указать, что он не принадлежит сигнализирует мьютекса. В этом случае <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает `true`, и вызывающий поток принимает на себя владение мьютексом и получает доступ к ресурсу, защищенные объектом mutex. После завершения доступ к ресурсу, поток должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод для освобождения владения мьютексом. В первом примере в разделе «примеры» показано этот шаблон.  
  
-   Интервал времени ожидания, указанный в вызове <xref:System.Threading.WaitHandle.WaitOne%2A> метода, имеющего `millisecondsTimeout` или `timeout` параметре. В этом случае <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает `false`, и что вызывающий поток не предпринимает дальнейших получения прав на владение мьютексом. В этом случае следует структурировать код таким образом, чтобы доступ к ресурсу, защищенные объектом mutex запрещен в вызывающий поток. Так как поток никогда не получить права владения мьютексом, его не следует вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод. Во втором примере в разделе «примеры» показан этот шаблон.  
  
 <xref:System.Threading.Mutex> Класс выполняет идентификацию потоков, поэтому мьютекс может быть освобожден только потоком, получившим его. В отличие от этого <xref:System.Threading.Semaphore> класса не обеспечивают идентификацию потоков. Мьютекс могут также передаваться через границы домена приложения.  
  
 Поток, который владеет мьютекс может запрашивать его в повторяющихся вызовах <xref:System.Threading.WaitHandle.WaitOne%2A> не прерывая выполнения. Однако поток должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод же количество раз для снятия владение мьютексом.  
  
 Поскольку <xref:System.Threading.Mutex> класс наследует от <xref:System.Threading.WaitHandle>, вы также можете вызвать статический <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> и <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> методы для синхронизации доступа к защищенному ресурсу.  
  
 Владея мьютексом завершения потока, мьютекс называется прерыванию. Состояние мьютекса перевести в сигнальное состояние, и следующий ожидающий поток получает во владение. Начиная с .NET Framework версии 2.0 <xref:System.Threading.AbandonedMutexException> вызывается в следующий поток, который получает Брошенный mutex. До .NET Framework версии 2.0 не возникло исключение.  
  
> [!CAUTION]
>  Брошенный mutex обычно признаком серьезной ошибки в коде. Когда поток завершает работу без освобождения объекта mutex, структуры данных, защищенные объектом mutex, не может быть в согласованном состоянии. Следующий поток, который запросит владение объектом Mutex можно обработать это исключение и продолжить работу, если можно удостовериться в целостности структуры данных.  
  
 В случае системного мьютекса брошенный мьютекс может указывать на то, что работа приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).  
  
 Мьютексы бывают двух типов: локальные мьютексы неименованные и именованные системные мьютексы. Локальный мьютекс существует только в вашем процессе. Он может использоваться любым потоком в процессе, имеющим ссылку на <xref:System.Threading.Mutex> , представляющий объект взаимного исключения. Каждый неименованный <xref:System.Threading.Mutex> представляет отдельный Локальный мьютекс.  
  
 Именованные системные мьютексы доступны в пределах всей операционной системы и может использоваться для синхронизации действий процессов. Можно создать <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс, используя конструктор, который принимает имя. Объект операционной системы может быть создан в то же время, или он может существовать до создания <xref:System.Threading.Mutex> объекта. Вы можете создать сразу несколько объектов <xref:System.Threading.Mutex>, представляющих один и тот именованный системный мьютекс, а также открывать именованный системный мьютекс с помощью метода <xref:System.Threading.Mutex.OpenExisting%2A>.  
  
> [!NOTE]
>  На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса «локальный\\«, мьютекс является видимым только в сеансе сервера терминалов, где он был создан. В этом случае отдельный мьютекс с тем же именем может существовать в каждом из других сеансов сервера терминалов на сервере. Если при создании именованного мьютекса префикс не задан, он принимает префикс «локальный\\». В ходе сеанса сервера терминалов два мьютекса, имена которых отличаются только префиксами, являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов. Имя префикса «Global\\» и «локального\\"описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 В этом примере показано, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу. Поскольку каждый вызывающий поток блокируется, пока не получит права владения мьютексом, он должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод для освобождения владения потока.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 В следующем примере каждый поток вызывает <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> метод, чтобы получить объект взаимного исключения. Если истекает время ожидания, метод возвращает `false`, и поток получает семафор ни получает доступ к ресурсу, который защищает мьютекса. <xref:System.Threading.Mutex.ReleaseMutex%2A> Метод вызывается только поток, который получает объект взаимного исключения.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> стандартными свойствами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого перегруженного конструктора является таким же, как вызов <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> перегрузку конструктора и указав `false` для изначальным владельцем мьютекса. То есть вызывающий поток не является владельцем мьютекса.  
  
   
  
## Examples  
 Ниже показан пример как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу. Поток, создающий объект взаимного исключения не владеет его изначально.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения мьютексом; в противном случае — <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ниже показан пример как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу. Поток, создающий <xref:System.Threading.Mutex> ответственного за изначально.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае — значение <see langword="false" />.</param>
        <param name="name">Имя <see cref="T:System.Threading.Mutex" />. Если значение равно <see langword="null" />, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса, а также иметь строку, являющуюся именем мьютекса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `name` не `null` и `initiallyOwned` — `true`, вызывающий поток владеет мьютексом, только в том случае, если именованный системный мьютекс создан данным вызовом. Так как отсутствует механизм для определения, был ли создан именованный системный мьютекс, лучше указывать `false` для `initiallyOwned` при вызове перегрузки конструктора. Можно использовать <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> конструктор, если необходимо определить изначальное владение.  
  
 Этот конструктор инициализирует <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс. Можно создать несколько <xref:System.Threading.Mutex> объекты, представляющие же именованный системный мьютекс.  
  
 Если именованный мьютекс уже создана с помощью управления доступом, а вызывающий объект не имеет <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, создается исключение. Чтобы открыть существующий именованный мьютекс только с необходимыми для синхронизации действий потоков, в разделе <xref:System.Threading.Mutex.OpenExisting%2A> метод.  
  
 При указании `null` или пустую строку для `name`, создан локальный мьютекс, как если бы метод <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> конструктор. В этом случае `createdNew` всегда `true`.  
  
 Поскольку это системная именованными мьютексами можно использовать для координирования использования ресурсов разными процессами.  
  
> [!NOTE]
>  На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса «локальный\\«, мьютекс является видимым только в сеансе сервера терминалов, где он был создан. В этом случае отдельный мьютекс с тем же именем может существовать в каждом из других сеансов сервера терминалов на сервере. Если при создании именованного мьютекса префикс не задан, он принимает префикс «локальный\\». В ходе сеанса сервера терминалов два мьютекса, имена которых отличаются только префиксами, являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов. Имя префикса «Global\\» и «локального\\"описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 Следующий пример показывает использование именованного мьютекса для передачи сигналов между потоками, выполняющимися в двух разных процессах.  
  
 Запустите эту программу из двух или более команд windows. Каждый процесс создает <xref:System.Threading.Mutex> , представляющий именованный мьютекс `MyMutex`. Именованный мьютекс является системным объектом, время существования которых ограничено временем жизни <xref:System.Threading.Mutex> объекты, представляющие его. Именованный мьютекс создается, когда первый процесс создает его <xref:System.Threading.Mutex> объекта; в этом примере именованный мьютекс владельцем является первый процесс, выполняющий программу. Именованный мьютекс уничтожается при всех <xref:System.Threading.Mutex> объекты, представляющие его освобождения.  
  
 Перегрузка конструктора, используемая в этом примере не может сообщить вызывающему потоку, предоставлен ли изначальное владение мьютексом. Не следует использовать этот конструктор для запроса изначального владения, если только вы можете быть уверены, что поток создаст именованный мьютекс.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, имеет безопасность управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <exception cref="T:System.ArgumentException">
          Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае — значение <see langword="false" />.</param>
        <param name="name">Имя <see cref="T:System.Threading.Mutex" />. Если значение равно <see langword="null" />, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</param>
        <param name="createdNew">При возврате из метода содержит логическое значение <see langword="true" />, если был создан локальный мьютекс (то есть если параметр <c>name</c> имеет значение <see langword="null" /> или содержит пустую строку) или был создан именованный системный мьютекс; значение <see langword="false" />, если указанный именованный системный мьютекс уже существует. Этот параметр передается неинициализированным.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса, иметь строку, являющуюся именем мьютекса, и логическое значение, которое при возврате метода показывает, предоставлено ли вызывающему потоку изначальное владение мьютексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `name` не `null` и `initiallyOwned` — `true`, только если именованный мьютекс, которому принадлежит вызывающий поток `createdNew` — `true` после вызова метода. В противном случае поток может запросить объект взаимного исключения путем вызова <xref:System.Threading.WaitHandle.WaitOne%2A> метод.  
  
 Этот конструктор инициализирует <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс. Можно создать несколько <xref:System.Threading.Mutex> объекты, представляющие же именованный системный мьютекс.  
  
 Если именованный мьютекс уже создана с помощью управления доступом, а вызывающий объект не имеет <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> прав, создается исключение. Чтобы открыть существующий именованный мьютекс только с необходимыми для синхронизации действий потоков, в разделе <xref:System.Threading.Mutex.OpenExisting%2A> метод.  
  
 При указании `null` или пустую строку для `name`, создан локальный мьютекс, как если бы метод <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> конструктор. В этом случае `createdNew` всегда `true`.  
  
 Поскольку это системная именованными мьютексами можно использовать для координирования использования ресурсов разными процессами.  
  
> [!NOTE]
>  На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса «локальный\\«, мьютекс является видимым только в сеансе сервера терминалов, где он был создан. В этом случае отдельный мьютекс с тем же именем может существовать в каждом из других сеансов сервера терминалов на сервере. Если при создании именованного мьютекса префикс не задан, он принимает префикс «локальный\\». В ходе сеанса сервера терминалов два мьютекса, имена которых отличаются только префиксами, являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов. Имя префикса «Global\\» и «локального\\"описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 В следующем примере кода показано, как используется именованный мьютекс сигнала между потоками или процессами. Запустите эту программу из двух или более команд windows. Каждый процесс создает <xref:System.Threading.Mutex> , представляющий именованный мьютекс «MyMutex». Именованный мьютекс является системным объектом. В этом примере его время жизни ограничено временем жизни <xref:System.Threading.Mutex> объекты, представляющие его. Именованный мьютекс создается, когда первый процесс создает ее локальных <xref:System.Threading.Mutex> объекта и удаляются, когда все <xref:System.Threading.Mutex> объекты, представляющие его освобождения. Именованный мьютекс изначально принадлежит первый процесс. Второй и все последующие процессы ожидать более ранних процессы для освобождения именованного мьютекса.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, имеет безопасность управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <exception cref="T:System.ArgumentException">
          Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае — значение <see langword="false" />.</param>
        <param name="name">Имя системного мьютекса. Если значение равно <see langword="null" />, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</param>
        <param name="createdNew">При возврате из метода содержит логическое значение <see langword="true" />, если был создан локальный мьютекс (то есть если параметр <c>name</c> имеет значение <see langword="null" /> или содержит пустую строку) или был создан именованный системный мьютекс; значение <see langword="false" />, если указанный именованный системный мьютекс уже существует. Этот параметр передается неинициализированным.</param>
        <param name="mutexSecurity">Объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для применения к именованному системному мьютексу.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса, иметь строку, являющуюся именем мьютекса, и логическое значение, которое при возврате метода показывает, предоставлено ли вызывающему потоку изначальное владение мьютексом, а также безопасность управления доступом для применения к именованному мьютексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `name` не `null` и `initiallyOwned` — `true`, только если именованный мьютекс, которому принадлежит вызывающий поток `createdNew` — `true` после вызова метода. В противном случае поток может запросить объект взаимного исключения путем вызова <xref:System.Threading.WaitHandle.WaitOne%2A> метод.  
  
 Этот конструктор используется, чтобы применить безопасность управления доступом для именованного системного мьютекса, при его создании, чтобы предотвратить возможность управления мьютексом другого кода.  
  
 Этот конструктор инициализирует <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс. Можно создать несколько <xref:System.Threading.Mutex> объекты, представляющие же именованный системный мьютекс.  
  
 Если именованный системный мьютекс не существует, он создается с указанными управления доступом. Если именованный мьютекс существует, указанные настройки управления доступом учитывается.  
  
> [!NOTE]
>  Вызывающий оператор имеет полный контроль над только что созданный <xref:System.Threading.Mutex> объект, даже если `mutexSecurity` запрещает или не может предоставить некоторые права доступа для текущего пользователя. Тем не менее если текущий пользователь пытается получить другой <xref:System.Threading.Mutex> объекта для представления же именованный мьютекс, с помощью конструктора или <xref:System.Threading.Mutex.OpenExisting%2A> метод применяется безопасность управления доступом Windows.  
  
 Если именованный мьютекс уже создана с помощью управления доступом, а вызывающий объект не имеет <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, создается исключение. Чтобы открыть существующий именованный мьютекс только с необходимыми для синхронизации действий потоков, в разделе <xref:System.Threading.Mutex.OpenExisting%2A> метод.  
  
 При указании `null` или пустую строку для `name`, создан локальный мьютекс, как если бы метод <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> конструктор. В этом случае `createdNew` всегда `true`.  
  
 Поскольку это системная именованными мьютексами можно использовать для координирования использования ресурсов разными процессами.  
  
> [!NOTE]
>  На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса «локальный\\«, мьютекс является видимым только в сеансе сервера терминалов, где он был создан. В этом случае отдельный мьютекс с тем же именем может существовать в каждом из других сеансов сервера терминалов на сервере. Если при создании именованного мьютекса префикс не задан, он принимает префикс «локальный\\». В ходе сеанса сервера терминалов два мьютекса, имена которых отличаются только префиксами, являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов. Имя префикса «Global\\» и «локального\\"описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом. В этом примере <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегрузка метода для проверки на существование именованного мьютекса.  
  
 Если мьютекс не существует, он создается с исходным владением и управления доступом, который запрещает пользователю право на использование мьютекса, но предоставляет право на чтение и изменение разрешений на объект взаимного исключения.  
  
 При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Исключение перехватывается, а в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузка метода, чтобы открыть объект взаимного исключения с права, необходимые для чтения и изменения разрешений.  
  
 После изменения разрешений мьютекс открывается с права, необходимые для ввода и освободите его. Если запустить скомпилированный пример в третьем командном окне, запускается с помощью новых разрешений.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, имеет безопасность управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <exception cref="T:System.ArgumentException">
          Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для именованного мьютекса.</summary>
        <returns>Объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для именованного мьютекса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.GetAccessControl%2A> Метод используется комбинация следующих (объединены с помощью битовой операции OR) флагов для поиска для разрешения: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, и <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Пользователь должен иметь <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> для вызова этого метода и объект взаимного исключения должен быть открыт с <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом. В этом примере <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегрузка метода для проверки на существование именованного мьютекса.  
  
 Если мьютекс не существует, он создается с исходным владением и управления доступом, который запрещает пользователю право на использование мьютекса, но предоставляет право на чтение и изменение разрешений на объект взаимного исключения.  
  
 При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Исключение перехватывается, а в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузка метода, чтобы открыть объект взаимного исключения с права, необходимые для чтения и изменения разрешений, с помощью <xref:System.Threading.Mutex.GetAccessControl%2A> и <xref:System.Threading.Mutex.SetAccessControl%2A> методы.  
  
 После изменения разрешений мьютекс открывается с права, необходимые для ввода и освободите его. Если запустить скомпилированный пример в третьем командном окне, запускается с помощью новых разрешений.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Текущий объект <see cref="T:System.Threading.Mutex" /> представляет именованный системный мьютекс, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  
  
 - или -  
  
 Текущий объект <see cref="T:System.Threading.Mutex" /> представляет именованный системный мьютекс, но он не был открыт с правами <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Не поддерживается для Windows 98 или Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает указанный именованный мьютекс, если он уже существует.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного мьютекса для открытия.</param>
        <summary>Открывает указанный именованный мьютекс, если он уже существует.</summary>
        <returns>Объект, представляющий именованный системный мьютекс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.OpenExisting%2A> Метод пытается открыть указанный именованный системный мьютекс. Если системный мьютекс не существует, этот метод выдает исключение вместо создания системного объекта. Чтобы создать системного мьютекса, если он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` необязательно возвратят же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод и указывая <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> прав, объединяются с помощью битовой операции или.  
  
 Указание <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг позволяет потоку ожидать для мьютекса и указав <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг позволяет потоку для вызова <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.  
  
 Этот метод не запрашивает владение мьютексом.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом. В этом примере <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегрузка метода для проверки на существование именованного мьютекса.  
  
 Если мьютекс не существует, он создается с исходным владением и управления доступом, который запрещает пользователю право на использование мьютекса, но предоставляет право на чтение и изменение разрешений на объект взаимного исключения.  
  
 При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Исключение перехватывается, а в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузка метода, чтобы открыть объект взаимного исключения с права, необходимые для чтения и изменения разрешений.  
  
 После изменения разрешений мьютекс открывается с права, необходимые для ввода и освободите его. Если запустить скомпилированный пример в третьем командном окне, запускается с помощью новых разрешений.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="name" /> равен пустой строке.  
  
 - или -  
  
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс не существует.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного мьютекса для открытия.</param>
        <param name="rights">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</param>
        <summary>Открывает указанный именованный мьютекс, если он уже существует, с требуемыми правами доступа.</summary>
        <returns>Объект, представляющий именованный системный мьютекс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` Необходимо включить параметр <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг, чтобы разрешить потоков для ожидания семафора и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг, чтобы разрешить потоков для вызова <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.  
  
 <xref:System.Threading.Mutex.OpenExisting%2A> Метод пытается открыть существующий именованный мьютекс. Если системный мьютекс не существует, этот метод выдает исключение вместо создания системного объекта. Чтобы создать системного мьютекса, если он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` необязательно возвратят же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.  
  
 Этот метод не запрашивает владение мьютексом.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом. В этом примере <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегрузка метода для проверки на существование именованного мьютекса.  
  
 Если мьютекс не существует, он создается с исходным владением и управления доступом, который запрещает пользователю право на использование мьютекса, но предоставляет право на чтение и изменение разрешений на объект взаимного исключения.  
  
 При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Исключение перехватывается, а в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузка метода, чтобы открыть объект взаимного исключения с права, необходимые для чтения и изменения разрешений.  
  
 После изменения разрешений мьютекс открывается с права, необходимые для ввода и освободите его. Если запустить скомпилированный пример в третьем командном окне, запускается с помощью новых разрешений.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="name" /> равен пустой строке.  
  
 - или -  
  
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс не существует.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет необходимой безопасности доступа.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает объект <see cref="T:System.Threading.Mutex" /> один раз.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый раз, когда поток получает семафор (например, путем вызова его <xref:System.Threading.WaitHandle.WaitOne%2A> метод), он должен вызвать впоследствии <xref:System.Threading.Mutex.ReleaseMutex%2A> передать права владения мьютексом и разблокировать другими потоками, которые пытаются получить права владения мьютексом. Если происходит сбой попытки получить права владения мьютексом (например, при вызове <xref:System.Threading.WaitHandle.WaitOne%2A> метод с `millisecondsTimeout` или `timeout` параметр возвращает `false` из-за времени ожидания запроса), поток не следует вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A>, в этом случае поток должен также быть запрещен доступ к ресурсу, защищенные объектом mutex, как показано в следующем примере.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 Поток, владеющий мьютексом можно задавать его в повторяющихся вызовах функции ожидания, не прерывая выполнения. Число вызовов хранится в среде CLR. Поток должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> же количество раз для снятия владение мьютексом.  
  
 Владея мьютексом завершения потока, мьютекс называется прерыванию. Состояние мьютекса задается сигнальным, и следующий ожидающий поток получает. Если не является владельцем мьютекса, сообщает о состоянии семафора. Начиная с .NET Framework версии 2.0 <xref:System.Threading.AbandonedMutexException> вызывается в следующий поток, который получает объект взаимного исключения. До .NET Framework версии 2.0 не возникло исключение.  
  
> [!CAUTION]
>  Брошенный mutex обычно признаком серьезной ошибки в коде. Когда поток завершает работу без освобождения объекта mutex, структуры данных, защищенные объектом mutex, не может быть в согласованном состоянии. Следующий поток, который запросит владение объектом Mutex можно обработать это исключение и продолжить работу, если можно удостовериться в целостности структуры данных.  
  
 В случае системного мьютекса брошенный мьютекс может указывать на то, что работа приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).  
  
   
  
## Examples  
 В следующем примере показано, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу. Поток, создающий объект взаимного исключения не владеет его изначально. <xref:System.Threading.Mutex.ReleaseMutex%2A> Метод используется для освобождения объект взаимного исключения, когда он больше не нужен.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Вызывающий поток не является владельцем мьютекса.</exception>
        <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">Объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для применения к именованному системному мьютексу.</param>
        <summary>Задает безопасность управления доступом для именованного системного мьютекса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пользователь должен иметь <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> правами для вызова этого метода и объект взаимного исключения должен быть открыт с <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом. В этом примере <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегрузка метода для проверки на существование именованного мьютекса.  
  
 Если мьютекс не существует, он создается с исходным владением и управления доступом, который запрещает пользователю право на использование мьютекса, но предоставляет право на чтение и изменение разрешений на объект взаимного исключения.  
  
 При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Исключение перехватывается, а в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузка метода, чтобы открыть объект взаимного исключения с права, необходимые для чтения и изменения разрешений, с помощью <xref:System.Threading.Mutex.GetAccessControl%2A> и <xref:System.Threading.Mutex.SetAccessControl%2A> методы.  
  
 После изменения разрешений мьютекс открывается с права, необходимые для ввода и освободите его. Если запустить скомпилированный пример в третьем командном окне, запускается с помощью новых разрешений.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="mutexSecurity" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  
  
 - или -  
  
 Мьютекс не был открыт с <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">Текущий объект <see cref="T:System.Threading.Mutex" /> не представляет именованный системный мьютекс.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает указанный именованный мьютекс, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного мьютекса для открытия.</param>
        <param name="result">Когда выполнение этого метода завершается, содержит объект <see cref="T:System.Threading.Mutex" />, представляющий именованный мьютекс, если вызов завершился успешно, или значение <see langword="null" />, если произошел сбой вызова. Этот параметр обрабатывается как неинициализированный.</param>
        <summary>Открывает указанный именованный мьютекс, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
        <returns>
          Значение <see langword="true" />, если именованный мьютекс был успешно открыт; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованный мьютекс существует, этот метод не создает его. Чтобы создать системного мьютекса, если он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Если вы не уверены, является ли именованный мьютекс существует, используйте перегрузку этого метода, а не <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегрузка метода, который создает исключение, если мьютекс не существует.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` необязательно возвратят же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> перегруженный метод и указывая <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> прав, объединяются с помощью битовой операции или. Указание <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг позволяет потоку ожидать для мьютекса и указав <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг позволяет потоку для вызова <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.  
  
 Этот метод не запрашивает владение мьютексом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="name" /> равен пустой строке.  
  
 - или -  
  
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного мьютекса для открытия.</param>
        <param name="rights">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</param>
        <param name="result">Когда выполнение этого метода завершается, содержит объект <see cref="T:System.Threading.Mutex" />, представляющий именованный мьютекс, если вызов завершился успешно, или значение <see langword="null" />, если произошел сбой вызова. Этот параметр обрабатывается как неинициализированный.</param>
        <summary>Открывает указанный именованный мьютекс, если он уже существует, с требуемыми правами доступа, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
        <returns>
          Значение <see langword="true" />, если именованный мьютекс был успешно открыт; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованный мьютекс существует, этот метод не создает его. Чтобы создать системного мьютекса, если он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Если вы не уверены, является ли именованный мьютекс существует, используйте перегрузку этого метода, а не <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузка метода, который создает исключение, если мьютекс не существует.  
  
 `rights` Необходимо включить параметр <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг, чтобы разрешить потоков для ожидания семафора и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг, чтобы разрешить потоков для вызова <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` необязательно возвратят же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.  
  
 Этот метод не запрашивает владение мьютексом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="name" /> равен пустой строке.  
  
 - или -  
  
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
  </Members>
</Type>