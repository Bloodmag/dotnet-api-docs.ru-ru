<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Mutex.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac56bce0feaf14f66f8608164cfa777620d7f3b329f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6bce0feaf14f66f8608164cfa777620d7f3b329f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>A synchronization primitive that can also be used for interprocess synchronization.</source>
          
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.</source>
          <target state="translated">Когда два или более потоков требуется доступ к общему ресурсу одновременно, системе необходим механизм синхронизации, чтобы гарантировать, что только один поток одновременно используется ресурс.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source><ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> — Это синхронизации примитив, который предоставляет монопольный доступ к общему ресурсу, чтобы только один поток.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.</source>
          <target state="translated">Если поток получает семафор, второй поток, желающий получить этот семафор приостанавливается, пока первый поток освобождает объект взаимного исключения.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Этот тип реализует <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> интерфейса.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">После завершения с помощью типа следует освободить его прямо или косвенно.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Для удаления типа непосредственно вызвать его <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> метод в <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> блока.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Чтобы удалить ее косвенно, использовать языковой конструкции, такие как <ph id="ph1">`using`</ph> (в C#) или <ph id="ph2">`Using`</ph> (в Visual Basic).</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> разделе интерфейса.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method to request ownership of a mutex.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> метода, который запросит владение мьютексом.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The calling thread blocks until one of the following occurs:</source>
          <target state="translated">Вызывающий поток блокируется, пока не произойдет одно из следующих событий:</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The mutex is signaled to indicate that it is not owned.</source>
          <target state="translated">Чтобы указать, что он не принадлежит сигнализирует мьютекса.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When this happens, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id="ph2">`true`</ph>, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.</source>
          <target state="translated">В этом случае <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> возвращает <ph id="ph2">`true`</ph>, и вызывающий поток принимает на себя владение мьютексом и получает доступ к ресурсу, защищенные объектом mutex.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When it has finished accessing the resource, the thread must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method to release ownership of the mutex.</source>
          <target state="translated">После завершения доступ к ресурсу, поток должен вызвать <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> метод для освобождения владения мьютексом.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The first example in the Examples section illustrates this pattern.</source>
          <target state="translated">В первом примере в разделе «примеры» показано этот шаблон.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The time-out interval specified in the call to a <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method that has a <ph id="ph2">`millisecondsTimeout`</ph> or <ph id="ph3">`timeout`</ph> parameter has elapsed.</source>
          <target state="translated">Интервал времени ожидания, указанный в вызове <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> метода, имеющего <ph id="ph2">`millisecondsTimeout`</ph> или <ph id="ph3">`timeout`</ph> параметре.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When this happens, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id="ph2">`false`</ph>, and the calling thread makes no further attempt to acquire ownership of the mutex.</source>
          <target state="translated">В этом случае <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> возвращает <ph id="ph2">`false`</ph>, и что вызывающий поток не предпринимает дальнейших получения прав на владение мьютексом.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.</source>
          <target state="translated">В этом случае следует структурировать код таким образом, чтобы доступ к ресурсу, защищенные объектом mutex запрещен в вызывающий поток.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Because the thread never acquired ownership of the mutex, it must not call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">Так как поток никогда не получить права владения мьютексом, его не следует вызывать <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The second example in the Examples section illustrates this pattern.</source>
          <target state="translated">Во втором примере в разделе «примеры» показан этот шаблон.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> class enforces thread identity, so a mutex can be released only by the thread that acquired it.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Класс выполняет идентификацию потоков, поэтому мьютекс может быть освобожден только потоком, получившим его.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>By contrast, the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class does not enforce thread identity.</source>
          <target state="translated">В отличие от этого <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> класса не обеспечивают идентификацию потоков.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>A mutex can also be passed across application domain boundaries.</source>
          <target state="translated">Мьютекс могут также передаваться через границы домена приложения.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The thread that owns a mutex can request the same mutex in repeated calls to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> without blocking its execution.</source>
          <target state="translated">Поток, который владеет мьютекс может запрашивать его в повторяющихся вызовах <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> не прерывая выполнения.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>However, the thread must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method the same number of times to release ownership of the mutex.</source>
          <target state="translated">Однако поток должен вызвать <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> метод же количество раз для снятия владение мьютексом.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> class inherits from <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph>, you can also call the static <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> methods to synchronize access to a protected resource.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> класс наследует от <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph>, вы также можете вызвать статический <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> методы для синхронизации доступа к защищенному ресурсу.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If a thread terminates while owning a mutex, the mutex is said to be abandoned.</source>
          <target state="translated">Владея мьютексом завершения потока, мьютекс называется прерыванию.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The state of the mutex is set to signaled, and the next waiting thread gets ownership.</source>
          <target state="translated">Состояние мьютекса перевести в сигнальное состояние, и следующий ожидающий поток получает во владение.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Beginning in version 2.0 of the .NET Framework, an <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is thrown in the next thread that acquires the abandoned mutex.</source>
          <target state="translated">Начиная с .NET Framework версии 2.0 <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> вызывается в следующий поток, который получает Брошенный mutex.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Before version 2.0 of the .NET Framework, no exception was thrown.</source>
          <target state="translated">До .NET Framework версии 2.0 не возникло исключение.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>An abandoned mutex often indicates a serious error in the code.</source>
          <target state="translated">Брошенный mutex обычно признаком серьезной ошибки в коде.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</source>
          <target state="translated">Когда поток завершает работу без освобождения объекта mutex, структуры данных, защищенные объектом mutex, не может быть в согласованном состоянии.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</source>
          <target state="translated">Следующий поток, который запросит владение объектом Mutex можно обработать это исключение и продолжить работу, если можно удостовериться в целостности структуры данных.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">В случае системного мьютекса брошенный мьютекс может указывать на то, что работа приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.</source>
          <target state="translated">Мьютексы бывают двух типов: локальные мьютексы неименованные и именованные системные мьютексы.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>A local mutex exists only within your process.</source>
          <target state="translated">Локальный мьютекс существует только в вашем процессе.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>It can be used by any thread in your process that has a reference to the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the mutex.</source>
          <target state="translated">Он может использоваться любым потоком в процессе, имеющим ссылку на <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> , представляющий объект взаимного исключения.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Each unnamed <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object represents a separate local mutex.</source>
          <target state="translated">Каждый неименованный <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> представляет отдельный Локальный мьютекс.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.</source>
          <target state="translated">Именованные системные мьютексы доступны в пределах всей операционной системы и может использоваться для синхронизации действий процессов.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>You can create a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex by using a constructor that accepts a name.</source>
          <target state="translated">Можно создать <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> , представляющий именованный системный мьютекс, используя конструктор, который принимает имя.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The operating-system object can be created at the same time, or it can exist before the creation of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object.</source>
          <target state="translated">Объект операционной системы может быть создан в то же время, или он может существовать до создания <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex, and you can use the <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method to open an existing named system mutex.</source>
          <target state="translated">Вы можете создать сразу несколько объектов <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph>, представляющих один и тот именованный системный мьютекс, а также открывать именованный системный мьютекс с помощью метода <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Если его имя начинается с префикса «Global<ph id="ph1">\\</ph>«, мьютекс является видимым во всех сеансах сервера терминалов.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Если его имя начинается с префикса «локальный<ph id="ph1">\\</ph>«, мьютекс является видимым только в сеансе сервера терминалов, где он был создан.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">В этом случае отдельный мьютекс с тем же именем может существовать в каждом из других сеансов сервера терминалов на сервере.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Если при создании именованного мьютекса префикс не задан, он принимает префикс «локальный<ph id="ph1">\\</ph>».</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">В ходе сеанса сервера терминалов два мьютекса, имена которых отличаются только префиксами, являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">Имя префикса «Global<ph id="ph1">\\</ph>» и «локального<ph id="ph2">\\</ph>"описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>This example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">В этом примере показано, как локальный <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> объект используется для синхронизации доступа к защищенному ресурсу.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method to release ownership of the thread.</source>
          <target state="translated">Поскольку каждый вызывающий поток блокируется, пока не получит права владения мьютексом, он должен вызвать <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> метод для освобождения владения потока.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In the following example, each thread calls the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29&gt;</ph> method to acquire the mutex.</source>
          <target state="translated">В следующем примере каждый поток вызывает <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29&gt;</ph> метод, чтобы получить объект взаимного исключения.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If the time-out interval elapses, the method returns <ph id="ph1">`false`</ph>, and the thread neither acquires the mutex nor gains access to the resource the mutex protects.</source>
          <target state="translated">Если истекает время ожидания, метод возвращает <ph id="ph1">`false`</ph>, и поток получает семафор ни получает доступ к ресурсу, который защищает мьютекса.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method is called only by the thread that acquires the mutex.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> Метод вызывается только поток, который получает объект взаимного исключения.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>This type is thread safe.</source>
          <target state="translated">Данный тип потокобезопасен.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class.</source>
          
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with default properties.</source>
          
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>Calling this constructor overload is the same as calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor overload and specifying <ph id="ph2">`false`</ph> for initial ownership of the mutex.</source>
          <target state="translated">Вызов этого перегруженного конструктора является таким же, как вызов <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> перегрузку конструктора и указав <ph id="ph2">`false`</ph> для изначальным владельцем мьютекса.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>That is, the calling thread does not own the mutex.</source>
          <target state="translated">То есть вызывающий поток не является владельцем мьютекса.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>The following code example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">Ниже показан пример как локальный <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> объект используется для синхронизации доступа к защищенному ресурсу.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>The thread that creates the mutex does not own it initially.</source>
          <target state="translated">Поток, создающий объект взаимного исключения не владеет его изначально.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the mutex; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</source>
          
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source>The following code example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">Ниже показан пример как локальный <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> объект используется для синхронизации доступа к защищенному ресурсу.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source>The thread that creates the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> owns it initially.</source>
          <target state="translated">Поток, создающий <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> ответственного за изначально.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> is unnamed.</source>
          
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</source>
          
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the mutex only if the named system mutex was created as a result of this call.</source>
          <target state="translated">Если <ph id="ph1">`name`</ph> не <ph id="ph2">`null`</ph> и <ph id="ph3">`initiallyOwned`</ph> — <ph id="ph4">`true`</ph>, вызывающий поток владеет мьютексом, только в том случае, если именованный системный мьютекс создан данным вызовом.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Since there is no mechanism for determining whether the named system mutex was created, it is better to specify <ph id="ph1">`false`</ph> for <ph id="ph2">`initiallyOwned`</ph> when calling this constructor overload.</source>
          <target state="translated">Так как отсутствует механизм для определения, был ли создан именованный системный мьютекс, лучше указывать <ph id="ph1">`false`</ph> для <ph id="ph2">`initiallyOwned`</ph> при вызове перегрузки конструктора.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor if you need to determine initial ownership.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> конструктор, если необходимо определить изначальное владение.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
          <target state="translated">Этот конструктор инициализирует <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> , представляющий именованный системный мьютекс.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
          <target state="translated">Можно создать несколько <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> объекты, представляющие же именованный системный мьютекс.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, an exception is thrown.</source>
          <target state="translated">Если именованный мьютекс уже создана с помощью управления доступом, а вызывающий объект не имеет <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, создается исключение.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">Чтобы открыть существующий именованный мьютекс только с необходимыми для синхронизации действий потоков, в разделе <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">При указании <ph id="ph1">`null`</ph> или пустую строку для <ph id="ph2">`name`</ph>, создан локальный мьютекс, как если бы метод <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">В этом случае <ph id="ph1">`createdNew`</ph> всегда <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Поскольку это системная именованными мьютексами можно использовать для координирования использования ресурсов разными процессами.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Если его имя начинается с префикса «Global<ph id="ph1">\\</ph>«, мьютекс является видимым во всех сеансах сервера терминалов.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Если его имя начинается с префикса «локальный<ph id="ph1">\\</ph>«, мьютекс является видимым только в сеансе сервера терминалов, где он был создан.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">В этом случае отдельный мьютекс с тем же именем может существовать в каждом из других сеансов сервера терминалов на сервере.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Если при создании именованного мьютекса префикс не задан, он принимает префикс «локальный<ph id="ph1">\\</ph>».</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">В ходе сеанса сервера терминалов два мьютекса, имена которых отличаются только префиксами, являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">Имя префикса «Global<ph id="ph1">\\</ph>» и «локального<ph id="ph2">\\</ph>"описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The following example shows how a named mutex is used to signal between threads running in two separate processes.</source>
          <target state="translated">Следующий пример показывает использование именованного мьютекса для передачи сигналов между потоками, выполняющимися в двух разных процессах.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Run this program from two or more command windows.</source>
          <target state="translated">Запустите эту программу из двух или более команд windows.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Each process creates a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the named mutex <ph id="ph2">`MyMutex`</ph>.</source>
          <target state="translated">Каждый процесс создает <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> , представляющий именованный мьютекс <ph id="ph2">`MyMutex`</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex is a system object whose lifetime is bounded by the lifetimes of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it.</source>
          <target state="translated">Именованный мьютекс является системным объектом, время существования которых ограничено временем жизни <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> объекты, представляющие его.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex is created when the first process creates its <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object; in this example, the named mutex is owned by the first process that runs the program.</source>
          <target state="translated">Именованный мьютекс создается, когда первый процесс создает его <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> объекта; в этом примере именованный мьютекс владельцем является первый процесс, выполняющий программу.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex is destroyed when all the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it have been released.</source>
          <target state="translated">Именованный мьютекс уничтожается при всех <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> объекты, представляющие его освобождения.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted.</source>
          <target state="translated">Перегрузка конструктора, используемая в этом примере не может сообщить вызывающему потоку, предоставлен ли изначальное владение мьютексом.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.</source>
          <target state="translated">Не следует использовать этот конструктор для запроса изначального владения, если только вы можете быть уверены, что поток создаст именованный мьютекс.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>A Win32 error occurred.</source>
          
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> is unnamed.</source>
          
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>When this method returns, contains a Boolean that is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local mutex was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system mutex was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system mutex already existed.</source>
          
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</source>
          
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the named mutex only if <ph id="ph5">`createdNew`</ph> is <ph id="ph6">`true`</ph> after the call.</source>
          <target state="translated">Если <ph id="ph1">`name`</ph> не <ph id="ph2">`null`</ph> и <ph id="ph3">`initiallyOwned`</ph> — <ph id="ph4">`true`</ph>, только если именованный мьютекс, которому принадлежит вызывающий поток <ph id="ph5">`createdNew`</ph> — <ph id="ph6">`true`</ph> после вызова метода.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Otherwise the thread can request the mutex by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">В противном случае поток может запросить объект взаимного исключения путем вызова <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
          <target state="translated">Этот конструктор инициализирует <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> , представляющий именованный системный мьютекс.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
          <target state="translated">Можно создать несколько <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> объекты, представляющие же именованный системный мьютекс.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph> rights, an exception is thrown.</source>
          <target state="translated">Если именованный мьютекс уже создана с помощью управления доступом, а вызывающий объект не имеет <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph> прав, создается исключение.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">Чтобы открыть существующий именованный мьютекс только с необходимыми для синхронизации действий потоков, в разделе <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">При указании <ph id="ph1">`null`</ph> или пустую строку для <ph id="ph2">`name`</ph>, создан локальный мьютекс, как если бы метод <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">В этом случае <ph id="ph1">`createdNew`</ph> всегда <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Поскольку это системная именованными мьютексами можно использовать для координирования использования ресурсов разными процессами.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Если его имя начинается с префикса «Global<ph id="ph1">\\</ph>«, мьютекс является видимым во всех сеансах сервера терминалов.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Если его имя начинается с префикса «локальный<ph id="ph1">\\</ph>«, мьютекс является видимым только в сеансе сервера терминалов, где он был создан.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">В этом случае отдельный мьютекс с тем же именем может существовать в каждом из других сеансов сервера терминалов на сервере.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Если при создании именованного мьютекса префикс не задан, он принимает префикс «локальный<ph id="ph1">\\</ph>».</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">В ходе сеанса сервера терминалов два мьютекса, имена которых отличаются только префиксами, являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">Имя префикса «Global<ph id="ph1">\\</ph>» и «локального<ph id="ph2">\\</ph>"описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The following code example shows how a named mutex is used to signal between processes or threads.</source>
          <target state="translated">В следующем примере кода показано, как используется именованный мьютекс сигнала между потоками или процессами.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Run this program from two or more command windows.</source>
          <target state="translated">Запустите эту программу из двух или более команд windows.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Each process creates a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the named mutex "MyMutex".</source>
          <target state="translated">Каждый процесс создает <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> , представляющий именованный мьютекс «MyMutex».</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex is a system object.</source>
          <target state="translated">Именованный мьютекс является системным объектом.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>In this example, its lifetime is bounded by the lifetimes of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it.</source>
          <target state="translated">В этом примере его время жизни ограничено временем жизни <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> объекты, представляющие его.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex is created when the first process creates its local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object, and destroyed when all the <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it have been released.</source>
          <target state="translated">Именованный мьютекс создается, когда первый процесс создает ее локальных <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> объекта и удаляются, когда все <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> объекты, представляющие его освобождения.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex is initially owned by the first process.</source>
          <target state="translated">Именованный мьютекс изначально принадлежит первый процесс.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The second process and any subsequent processes wait for earlier processes to release the named mutex.</source>
          <target state="translated">Второй и все последующие процессы ожидать более ранних процессы для освобождения именованного мьютекса.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>A Win32 error occurred.</source>
          
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The name of the system mutex.</source>
          
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> is unnamed.</source>
          
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>When this method returns, contains a Boolean that is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local mutex was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system mutex was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system mutex already existed.</source>
          
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>This parameter is passed uninitialized.</source>
          
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system mutex.</source>
          
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</source>
          
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the named mutex only if <ph id="ph5">`createdNew`</ph> is <ph id="ph6">`true`</ph> after the call.</source>
          <target state="translated">Если <ph id="ph1">`name`</ph> не <ph id="ph2">`null`</ph> и <ph id="ph3">`initiallyOwned`</ph> — <ph id="ph4">`true`</ph>, только если именованный мьютекс, которому принадлежит вызывающий поток <ph id="ph5">`createdNew`</ph> — <ph id="ph6">`true`</ph> после вызова метода.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Otherwise the thread can request the mutex by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">В противном случае поток может запросить объект взаимного исключения путем вызова <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.</source>
          <target state="translated">Этот конструктор используется, чтобы применить безопасность управления доступом для именованного системного мьютекса, при его создании, чтобы предотвратить возможность управления мьютексом другого кода.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
          <target state="translated">Этот конструктор инициализирует <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> , представляющий именованный системный мьютекс.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
          <target state="translated">Можно создать несколько <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> объекты, представляющие же именованный системный мьютекс.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the named system mutex does not exist, it is created with the specified access control security.</source>
          <target state="translated">Если именованный системный мьютекс не существует, он создается с указанными управления доступом.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the named mutex exists, the specified access control security is ignored.</source>
          <target state="translated">Если именованный мьютекс существует, указанные настройки управления доступом учитывается.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object even if <ph id="ph2">`mutexSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
          <target state="translated">Вызывающий оператор имеет полный контроль над только что созданный <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> объект, даже если <ph id="ph2">`mutexSecurity`</ph> запрещает или не может предоставить некоторые права доступа для текущего пользователя.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object to represent the same named mutex, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
          <target state="translated">Тем не менее если текущий пользователь пытается получить другой <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> объекта для представления же именованный мьютекс, с помощью конструктора или <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> метод применяется безопасность управления доступом Windows.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, an exception is thrown.</source>
          <target state="translated">Если именованный мьютекс уже создана с помощью управления доступом, а вызывающий объект не имеет <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, создается исключение.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">Чтобы открыть существующий именованный мьютекс только с необходимыми для синхронизации действий потоков, в разделе <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">При указании <ph id="ph1">`null`</ph> или пустую строку для <ph id="ph2">`name`</ph>, создан локальный мьютекс, как если бы метод <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">В этом случае <ph id="ph1">`createdNew`</ph> всегда <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Поскольку это системная именованными мьютексами можно использовать для координирования использования ресурсов разными процессами.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Если его имя начинается с префикса «Global<ph id="ph1">\\</ph>«, мьютекс является видимым во всех сеансах сервера терминалов.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Если его имя начинается с префикса «локальный<ph id="ph1">\\</ph>«, мьютекс является видимым только в сеансе сервера терминалов, где он был создан.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">В этом случае отдельный мьютекс с тем же именем может существовать в каждом из других сеансов сервера терминалов на сервере.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Если при создании именованного мьютекса префикс не задан, он принимает префикс «локальный<ph id="ph1">\\</ph>».</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">В ходе сеанса сервера терминалов два мьютекса, имена которых отличаются только префиксами, являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">Имя префикса «Global<ph id="ph1">\\</ph>» и «локального<ph id="ph2">\\</ph>"описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">В этом примере <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> перегрузка метода для проверки на существование именованного мьютекса.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Если мьютекс не существует, он создается с исходным владением и управления доступом, который запрещает пользователю право на использование мьютекса, но предоставляет право на чтение и изменение разрешений на объект взаимного исключения.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions.</source>
          <target state="translated">Исключение перехватывается, а в примере используется <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> перегрузка метода, чтобы открыть объект взаимного исключения с права, необходимые для чтения и изменения разрешений.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">После изменения разрешений мьютекс открывается с права, необходимые для ввода и освободите его.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Если запустить скомпилированный пример в третьем командном окне, запускается с помощью новых разрешений.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>A Win32 error occurred.</source>
          
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security for the named mutex.</source>
          
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security for the named mutex.</source>
          
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> Метод используется комбинация следующих (объединены с помощью битовой операции OR) флагов для поиска для разрешения: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, и <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> to call this method, and the mutex must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Пользователь должен иметь <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> для вызова этого метода и объект взаимного исключения должен быть открыт с <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">В этом примере <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> перегрузка метода для проверки на существование именованного мьютекса.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Если мьютекс не существует, он создается с исходным владением и управления доступом, который запрещает пользователю право на использование мьютекса, но предоставляет право на чтение и изменение разрешений на объект взаимного исключения.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions, using the <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">Исключение перехватывается, а в примере используется <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> перегрузка метода, чтобы открыть объект взаимного исключения с права, необходимые для чтения и изменения разрешений, с помощью <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> и <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">После изменения разрешений мьютекс открывается с права, необходимые для ввода и освободите его.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Если запустить скомпилированный пример в третьем командном окне, запускается с помощью новых разрешений.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object represents a named system mutex, but the user does not have <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object represents a named system mutex, and was not opened with <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
          
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>Opens a specified named mutex, if it already exists.</source>
          
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The name of the system mutex to open.</source>
          
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Opens the specified named mutex, if it already exists.</source>
          
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>An object that represents the named system mutex.</source>
          
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method tries to open the specified named system mutex.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> Метод пытается открыть указанный именованный системный мьютекс.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If the system mutex does not exist, this method throws an exception instead of creating the system object.</source>
          <target state="translated">Если системный мьютекс не существует, этот метод выдает исключение вместо создания системного объекта.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Чтобы создать системного мьютекса, если он еще не существует, используйте один из <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> конструкторы, которые имеет <ph id="ph2">`name`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Несколько вызовов этого метода, используйте то же значение для <ph id="ph1">`name`</ph> необязательно возвратят же <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Эта перегрузка метода эквивалентен вызову <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> перегруженный метод и указывая <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> и <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> прав, объединяются с помощью битовой операции или.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the mutex, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">Указание <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> флаг позволяет потоку ожидать для мьютекса и указав <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> флаг позволяет потоку для вызова <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Этот метод не запрашивает владение мьютексом.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">В этом примере <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> перегрузка метода для проверки на существование именованного мьютекса.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Если мьютекс не существует, он создается с исходным владением и управления доступом, который запрещает пользователю право на использование мьютекса, но предоставляет право на чтение и изменение разрешений на объект взаимного исключения.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions.</source>
          <target state="translated">Исключение перехватывается, а в примере используется <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> перегрузка метода, чтобы открыть объект взаимного исключения с права, необходимые для чтения и изменения разрешений.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">После изменения разрешений мьютекс открывается с права, необходимые для ввода и освободите его.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Если запустить скомпилированный пример в третьем командном окне, запускается с помощью новых разрешений.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The named mutex does not exist.</source>
          
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>A Win32 error occurred.</source>
          
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
          
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The name of the system mutex to open.</source>
          
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>Opens the specified named mutex, if it already exists, with the desired security access.</source>
          
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>An object that represents the named system mutex.</source>
          
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the mutex, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`rights`</ph> Необходимо включить параметр <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> флаг, чтобы разрешить потоков для ожидания семафора и <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> флаг, чтобы разрешить потоков для вызова <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method tries to open an existing named mutex.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> Метод пытается открыть существующий именованный мьютекс.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If the system mutex does not exist, this method throws an exception instead of creating the system object.</source>
          <target state="translated">Если системный мьютекс не существует, этот метод выдает исключение вместо создания системного объекта.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Чтобы создать системного мьютекса, если он еще не существует, используйте один из <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> конструкторы, которые имеет <ph id="ph2">`name`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Несколько вызовов этого метода, используйте то же значение для <ph id="ph1">`name`</ph> необязательно возвратят же <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Этот метод не запрашивает владение мьютексом.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">В этом примере <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> перегрузка метода для проверки на существование именованного мьютекса.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Если мьютекс не существует, он создается с исходным владением и управления доступом, который запрещает пользователю право на использование мьютекса, но предоставляет право на чтение и изменение разрешений на объект взаимного исключения.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions.</source>
          <target state="translated">Исключение перехватывается, а в примере используется <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> перегрузка метода, чтобы открыть объект взаимного исключения с права, необходимые для чтения и изменения разрешений.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">После изменения разрешений мьютекс открывается с права, необходимые для ввода и освободите его.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Если запустить скомпилированный пример в третьем командном окне, запускается с помощью новых разрешений.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The named mutex does not exist.</source>
          
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>A Win32 error occurred.</source>
          
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The named mutex exists, but the user does not have the desired security access.</source>
          
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Releases the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> once.</source>
          
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Whenever a thread acquires a mutex (for example, by calling its <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method), it must subsequently call <ph id="ph2">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.</source>
          <target state="translated">Каждый раз, когда поток получает семафор (например, путем вызова его <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> метод), он должен вызвать впоследствии <ph id="ph2">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> передать права владения мьютексом и разблокировать другими потоками, которые пытаются получить права владения мьютексом.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>If the attempt to get ownership of the mutex fails (for example, when a call to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method with a <ph id="ph2">`millisecondsTimeout`</ph> or a <ph id="ph3">`timeout`</ph> parameter returns <ph id="ph4">`false`</ph> because the request times out), the thread shouldn't call <ph id="ph5">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.</source>
          <target state="translated">Если происходит сбой попытки получить права владения мьютексом (например, при вызове <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> метод с <ph id="ph2">`millisecondsTimeout`</ph> или <ph id="ph3">`timeout`</ph> параметр возвращает <ph id="ph4">`false`</ph> из-за времени ожидания запроса), поток не следует вызывать <ph id="ph5">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph>, в этом случае поток должен также быть запрещен доступ к ресурсу, защищенные объектом mutex, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.</source>
          <target state="translated">Поток, владеющий мьютексом можно задавать его в повторяющихся вызовах функции ожидания, не прерывая выполнения.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The number of calls is kept by the common language runtime.</source>
          <target state="translated">Число вызовов хранится в среде CLR.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The thread must call <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> the same number of times to release ownership of the mutex.</source>
          <target state="translated">Поток должен вызвать <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> же количество раз для снятия владение мьютексом.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>If a thread terminates while owning a mutex, the mutex is said to be abandoned.</source>
          <target state="translated">Владея мьютексом завершения потока, мьютекс называется прерыванию.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The state of the mutex is set to signaled and the next waiting thread gets ownership.</source>
          <target state="translated">Состояние мьютекса задается сигнальным, и следующий ожидающий поток получает.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>If no one owns the mutex, the state of the mutex is signaled.</source>
          <target state="translated">Если не является владельцем мьютекса, сообщает о состоянии семафора.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Beginning in version 2.0 of the .NET Framework, an <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is thrown in the next thread that acquires the mutex.</source>
          <target state="translated">Начиная с .NET Framework версии 2.0 <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> вызывается в следующий поток, который получает объект взаимного исключения.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Prior to version 2.0 of the .NET Framework, no exception was thrown.</source>
          <target state="translated">До .NET Framework версии 2.0 не возникло исключение.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>An abandoned mutex often indicates a serious error in the code.</source>
          <target state="translated">Брошенный mutex обычно признаком серьезной ошибки в коде.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</source>
          <target state="translated">Когда поток завершает работу без освобождения объекта mutex, структуры данных, защищенные объектом mutex, не может быть в согласованном состоянии.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</source>
          <target state="translated">Следующий поток, который запросит владение объектом Mutex можно обработать это исключение и продолжить работу, если можно удостовериться в целостности структуры данных.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">В случае системного мьютекса брошенный мьютекс может указывать на то, что работа приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The following example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">В следующем примере показано, как локальный <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> объект используется для синхронизации доступа к защищенному ресурсу.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The thread that creates the mutex does not own it initially.</source>
          <target state="translated">Поток, создающий объект взаимного исключения не владеет его изначально.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method is used to release the mutex when it is no longer needed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> Метод используется для освобождения объект взаимного исключения, когда он больше не нужен.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The calling thread does not own the mutex.</source>
          
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The current instance has already been disposed.</source>
          
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system mutex.</source>
          
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>Sets the access control security for a named system mutex.</source>
          
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the mutex must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Пользователь должен иметь <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> правами для вызова этого метода и объект взаимного исключения должен быть открыт с <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">В этом примере <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> перегрузка метода для проверки на существование именованного мьютекса.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Если мьютекс не существует, он создается с исходным владением и управления доступом, который запрещает пользователю право на использование мьютекса, но предоставляет право на чтение и изменение разрешений на объект взаимного исключения.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions, using the <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">Исключение перехватывается, а в примере используется <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> перегрузка метода, чтобы открыть объект взаимного исключения с права, необходимые для чтения и изменения разрешений, с помощью <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> и <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">После изменения разрешений мьютекс открывается с права, необходимые для ввода и освободите его.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Если запустить скомпилированный пример в третьем командном окне, запускается с помощью новых разрешений.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source><ph id="ph1">&lt;paramref name="mutexSecurity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The mutex was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object does not represent a named system mutex.</source>
          
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>The name of the system mutex to open.</source>
          
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object that represents the named mutex if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This parameter is treated as uninitialized.</source>
          
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named mutex was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>If the named mutex does not exist, this method does not create it.</source>
          <target state="translated">Если именованный мьютекс существует, этот метод не создает его.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Чтобы создать системного мьютекса, если он еще не существует, используйте один из <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> конструкторы, которые имеет <ph id="ph2">`name`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>If you are uncertain whether a named mutex exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the mutex does not exist.</source>
          <target state="translated">Если вы не уверены, является ли именованный мьютекс существует, используйте перегрузку этого метода, а не <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> перегрузка метода, который создает исключение, если мьютекс не существует.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Несколько вызовов этого метода, используйте то же значение для <ph id="ph1">`name`</ph> необязательно возвратят же <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Эта перегрузка метода эквивалентен вызову <ph id="ph1">&lt;xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29&gt;</ph> перегруженный метод и указывая <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> и <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> прав, объединяются с помощью битовой операции или.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the mutex, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">Указание <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> флаг позволяет потоку ожидать для мьютекса и указав <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> флаг позволяет потоку для вызова <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Этот метод не запрашивает владение мьютексом.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>A Win32 error occurred.</source>
          
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
          
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>The name of the system mutex to open.</source>
          
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object that represents the named mutex if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>This parameter is treated as uninitialized.</source>
          
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
          
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named mutex was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>If the named mutex does not exist, this method does not create it.</source>
          <target state="translated">Если именованный мьютекс существует, этот метод не создает его.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Чтобы создать системного мьютекса, если он еще не существует, используйте один из <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> конструкторы, которые имеет <ph id="ph2">`name`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>If you are uncertain whether a named mutex exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload, which throws an exception if the mutex does not exist.</source>
          <target state="translated">Если вы не уверены, является ли именованный мьютекс существует, используйте перегрузку этого метода, а не <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> перегрузка метода, который создает исключение, если мьютекс не существует.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the mutex, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`rights`</ph> Необходимо включить параметр <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> флаг, чтобы разрешить потоков для ожидания семафора и <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> флаг, чтобы разрешить потоков для вызова <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Несколько вызовов этого метода, используйте то же значение для <ph id="ph1">`name`</ph> необязательно возвратят же <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Этот метод не запрашивает владение мьютексом.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>A Win32 error occurred.</source>
          
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
          
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>