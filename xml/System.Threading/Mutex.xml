<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cd4c660e875cb947efe1e1b0158a6ea434c2734a" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609151" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A synchronization primitive that can also be used for interprocess synchronization.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда два или больше потоков требуется доступ к общему ресурсу одновременно, системе необходим механизм синхронизации, чтобы убедиться, что только один поток за раз использует ресурс. <xref:System.Threading.Mutex> — Это синхронизации примитив, который предоставляет эксклюзивный доступ к общему ресурсу, чтобы только один поток. Если поток получает семафор, второй поток, желающий получить этот мьютекс приостанавливается, пока первый поток освобождает мьютекс.  
  
> [!IMPORTANT]
>  Этот тип реализует <xref:System.IDisposable> интерфейс. Когда вы закончите, используя тип, следует освободить его прямо или косвенно. Чтобы удалить тип напрямую, вызовите его <xref:System.IDisposable.Dispose%2A> метод в `try` / `catch` блока. Чтобы избавиться от его косвенно, используйте языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует IDisposable» <xref:System.IDisposable> разделу интерфейса.  
  
 Можно использовать <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> метод, который запросит владение мьютексом. Вызывающий поток блокируется, пока не произойдет одно из следующих событий:  
  
-   Чтобы указать, что он не принадлежит получает сигнал мьютекса. В этом случае <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `true`, и вызывающий поток принимает на себя владение мьютексом и получает доступ к ресурсу, защищенные объектом mutex. После завершения доступ к ресурсу, поток должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод для освобождения владения мьютексом. В первом примере в разделе «примеры» показан этот шаблон.  
  
-   Интервал времени ожидания, указанное в вызове <xref:System.Threading.WaitHandle.WaitOne%2A> метод, который имеет `millisecondsTimeout` или `timeout` параметре. В этом случае <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `false`, и вызывающий поток не предпринимает дальнейших получить права владельца мьютекса. В этом случае следует структурировать код таким образом, чтобы доступ к ресурсу, защищенные объектом mutex запрещен в вызывающий поток. Так как поток никогда не получить права владельца мьютекса, он не должен вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод. В разделе «примеры» во втором примере показана схема работы.  
  
 <xref:System.Threading.Mutex> Класс выполняет идентификацию потоков, поэтому мьютекс может быть освобожден только тем потоком, который получил его. Напротив <xref:System.Threading.Semaphore> класса не обеспечивают идентификацию потоков. Мьютекс также могут передаваться через границы домена приложения.  
  
 Поток, который владеет мьютекс может запросить его в повторные вызовы <xref:System.Threading.WaitHandle.WaitOne%2A> не прерывая выполнение. Тем не менее, необходимо вызвать поток <xref:System.Threading.Mutex.ReleaseMutex%2A> метод такое же количество раз, чтобы освободить права владения мьютексом.  
  
 Так как <xref:System.Threading.Mutex> класс наследует от <xref:System.Threading.WaitHandle>, также можно вызвать статический <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> и <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> методы для синхронизации доступа к защищенному ресурсу.  
  
 Если поток завершается владея мьютексом, мьютекс считается брошенным. Состояние мьютекса задается сигнальным и получает следующий ожидающий поток. Начиная с версии 2.0 платформы .NET Framework, <xref:System.Threading.AbandonedMutexException> создается в следующем потоке, который получает Брошенный мьютекс. До версии 2.0 платформы .NET Framework исключение не создано.  
  
> [!CAUTION]
>  Брошенный мьютекс часто является признаком серьезной ошибки в коде. Когда поток завершает работу без освобождения объекта mutex, структуры данных, защищенные объектом mutex, возможно в согласованном состоянии. Следующий поток, который запросит владение мьютексом может обработать это исключение и продолжить работу, если можно удостовериться в целостности структуры данных.  
  
 В случае системного мьютекса брошенный мьютекс может указывать на то, что работа приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).  
  
 Мьютексы бывают двух типов: локальные мьютексы неименованные и именованные системные мьютексы. Локальный мьютекс существует только в вашем процессе. Он может использоваться любой поток в вашем процессе, имеющий ссылку на <xref:System.Threading.Mutex> объект, представляющий мьютекс. Каждый неименованный <xref:System.Threading.Mutex> объект представляет собой отдельный Локальный мьютекс.  
  
 Именованные системные мьютексы доступны во всей операционной системы и может использоваться для синхронизации действий процессов. Можно создать <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс с помощью конструктора, который принимает имя. Объект операционной системы может быть создан в то же время, или он может существовать до создания <xref:System.Threading.Mutex> объекта. Вы можете создать сразу несколько объектов <xref:System.Threading.Mutex>, представляющих один и тот именованный системный мьютекс, а также открывать именованный системный мьютекс с помощью метода <xref:System.Threading.Mutex.OpenExisting%2A>.  
  
> [!NOTE]
>  На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса «локальный\\«, мьютекс отображается только в сеанса сервера терминалов, в котором он был создан. В этом случае в каждой из других сеансов сервера терминалов на сервере может существовать отдельный мьютекс с тем же именем. Если при создании именованного мьютекса префикс не указан, функция принимает префикс «локальный\\«. В рамках сеанса сервера терминалов два мьютекса, имена которых отличаются только по их префиксы являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов. То есть имена префикс «Global\\"и «локальные\\" описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 В этом примере показано, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу. Поскольку каждый вызывающий поток блокируется, пока не получит права владельца мьютекса, он должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод для освобождения владения потока.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 В следующем примере каждый поток вызывает <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> способ занять объект взаимного исключения. Если по истечении интервала времени ожидания, метод возвращает `false`, и поток не завладеет этим мьютексом и не получает доступ к ресурсу, позволяет защитить мьютексом. <xref:System.Threading.Mutex.ReleaseMutex%2A> Метод вызывается только тем потоком, который получает мьютекс.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with default properties.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого перегруженного конструктора — равносилен вызову метода <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> перегрузку конструктора и указав `false` для изначальным владельцем мьютекса. То есть вызывающий поток не имеет собственного мьютекса.  
  
   
  
## Examples  
 В следующем коде показано в примере, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу. Поток, создающий мьютексом не владеет его изначально.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the mutex; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем коде показано в примере, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу. Поток, создающий <xref:System.Threading.Mutex> изначально им владеет.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</param>
        <param name="name">The name of the <see cref="T:System.Threading.Mutex" />. If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `name` не `null` и `initiallyOwned` является `true`, вызывающий поток является владельцем мьютекса только в том случае, если именованный системный мьютекс был создан в результате этого вызова. Так как отсутствует механизм для определения, был ли создан именованный системный мьютекс, рекомендуется указать `false` для `initiallyOwned` при вызове перегрузки конструктора. Можно использовать <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> конструктор, если вам нужно определить изначальным владельцем.  
  
 Этот конструктор инициализирует <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс. Вы можете создать несколько <xref:System.Threading.Mutex> объекты, которые представляют одинаковую меру именованный системный мьютекс.  
  
 Если именованный мьютекс уже создан с помощью управления доступом, а вызывающий объект не имеет <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, создается исключение. Чтобы открыть существующий именованный мьютекс с помощью только те разрешения, необходимые для синхронизации потоков, см. в разделе <xref:System.Threading.Mutex.OpenExisting%2A> метод.  
  
 Если указать `null` или пустую строку для `name`, создан локальный мьютекс, как если бы Вы вызвали <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> конструктор. В этом случае `createdNew` всегда `true`.  
  
 Так как они системные именованными мьютексами может использоваться для координирования использования ресурсов через границы процессов.  
  
> [!NOTE]
>  На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса «локальный\\«, мьютекс отображается только в сеанса сервера терминалов, в котором он был создан. В этом случае в каждой из других сеансов сервера терминалов на сервере может существовать отдельный мьютекс с тем же именем. Если при создании именованного мьютекса префикс не указан, функция принимает префикс «локальный\\«. В рамках сеанса сервера терминалов два мьютекса, имена которых отличаются только по их префиксы являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов. То есть имена префикс «Global\\"и «локальные\\" описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 Следующий пример показывает использование именованного мьютекса для передачи сигналов между потоками, выполняющимися в два отдельных процесса.  
  
 Запустите эту программу из двух или нескольких команд windows. Каждый процесс создает <xref:System.Threading.Mutex> , представляющий именованный мьютекс `MyMutex`. Именованный мьютекс является системным объектом, время существования которых ограничивается временем жизни <xref:System.Threading.Mutex> объекты, представляющие его. Именованный мьютекс создается в том случае, когда первый процесс создает его <xref:System.Threading.Mutex> объект; в этом примере мьютексом владеет первый процесс, выполняющий программу. Именованный мьютекс уничтожается при всех <xref:System.Threading.Mutex> объекты, представляющие его были выпущены.  
  
 Перегрузку конструктора, используемый в этом примере не может определить вызывающий поток, предоставлен ли изначальное владение мьютексом. Этот конструктор не следует использовать для запроса изначальным владельцем, если только вы можете быть уверены, что поток будет создавать именованный мьютекс.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</param>
        <param name="name">The name of the <see cref="T:System.Threading.Mutex" />. If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</param>
        <param name="createdNew">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed. This parameter is passed uninitialized.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `name` не `null` и `initiallyOwned` — `true`, только если именованный мьютекс, которому принадлежит вызывающий поток `createdNew` является `true` после вызова метода. В противном случае поток может запросить мьютексом, вызвав <xref:System.Threading.WaitHandle.WaitOne%2A> метод.  
  
 Этот конструктор инициализирует <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс. Вы можете создать несколько <xref:System.Threading.Mutex> объекты, которые представляют одинаковую меру именованный системный мьютекс.  
  
 Если именованный мьютекс уже создан с помощью управления доступом, а вызывающий объект не имеет <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> прав, возникает исключение. Чтобы открыть существующий именованный мьютекс с помощью только те разрешения, необходимые для синхронизации потоков, см. в разделе <xref:System.Threading.Mutex.OpenExisting%2A> метод.  
  
 Если указать `null` или пустую строку для `name`, создан локальный мьютекс, как если бы Вы вызвали <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> конструктор. В этом случае `createdNew` всегда `true`.  
  
 Так как они системные именованными мьютексами может использоваться для координирования использования ресурсов через границы процессов.  
  
> [!NOTE]
>  На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса «локальный\\«, мьютекс отображается только в сеанса сервера терминалов, в котором он был создан. В этом случае в каждой из других сеансов сервера терминалов на сервере может существовать отдельный мьютекс с тем же именем. Если при создании именованного мьютекса префикс не указан, функция принимает префикс «локальный\\«. В рамках сеанса сервера терминалов два мьютекса, имена которых отличаются только по их префиксы являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов. То есть имена префикс «Global\\"и «локальные\\" описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 В следующем примере кода показано использование именованного мьютекса для сигнала между потоками или процессами. Запустите эту программу из двух или нескольких команд windows. Каждый процесс создает <xref:System.Threading.Mutex> , представляющий именованный мьютекс «MyMutex». Именованный мьютекс является системным объектом. В этом примере его время жизни ограничено временем жизни <xref:System.Threading.Mutex> объекты, представляющие его. Именованный мьютекс создается в том случае, когда первый процесс создает ее локальных <xref:System.Threading.Mutex> объекта и уничтожается при всех <xref:System.Threading.Mutex> объекты, представляющие его были выпущены. Именованный мьютекс изначально принадлежит первый процесс. Второй и все последующие процессы ожидания для более ранних процессов для освобождения именованного мьютекса.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</param>
        <param name="name">The name of the system mutex. If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</param>
        <param name="createdNew">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed. This parameter is passed uninitialized.</param>
        <param name="mutexSecurity">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `name` не `null` и `initiallyOwned` — `true`, только если именованный мьютекс, которому принадлежит вызывающий поток `createdNew` является `true` после вызова метода. В противном случае поток может запросить мьютексом, вызвав <xref:System.Threading.WaitHandle.WaitOne%2A> метод.  
  
 Этот конструктор используется для применения управления доступом к именованному системному мьютексу при его создании, чтобы предотвратить возможность управления мьютексом другой код.  
  
 Этот конструктор инициализирует <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс. Вы можете создать несколько <xref:System.Threading.Mutex> объекты, которые представляют одинаковую меру именованный системный мьютекс.  
  
 Если именованный системный мьютекс не существует, он создается с указанного элемента управления доступом. Если именованный мьютекс существует, указанный управления доступом учитывается.  
  
> [!NOTE]
>  Вызывающий объект имеет полный контроль над только что созданный <xref:System.Threading.Mutex> объект, даже если `mutexSecurity` запрещает или не удалось предоставить некоторые права доступа для текущего пользователя. Тем не менее если текущий пользователь пытается получить другой <xref:System.Threading.Mutex> объекта представляют одинаковую меру с именем мьютекса, с помощью конструктора или <xref:System.Threading.Mutex.OpenExisting%2A> метод применения управления доступом Windows.  
  
 Если именованный мьютекс уже создан с помощью управления доступом, а вызывающий объект не имеет <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, создается исключение. Чтобы открыть существующий именованный мьютекс с помощью только те разрешения, необходимые для синхронизации потоков, см. в разделе <xref:System.Threading.Mutex.OpenExisting%2A> метод.  
  
 Если указать `null` или пустую строку для `name`, создан локальный мьютекс, как если бы Вы вызвали <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> конструктор. В этом случае `createdNew` всегда `true`.  
  
 Так как они системные именованными мьютексами может использоваться для координирования использования ресурсов через границы процессов.  
  
> [!NOTE]
>  На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса «локальный\\«, мьютекс отображается только в сеанса сервера терминалов, в котором он был создан. В этом случае в каждой из других сеансов сервера терминалов на сервере может существовать отдельный мьютекс с тем же именем. Если при создании именованного мьютекса префикс не указан, функция принимает префикс «локальный\\«. В рамках сеанса сервера терминалов два мьютекса, имена которых отличаются только по их префиксы являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов. То есть имена префикс «Global\\"и «локальные\\" описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом. В примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного мьютекса.  
  
 Если мьютекс не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает текущий пользователь право на использование мьютексом, но не дает право на чтение и изменение разрешений для мьютекса.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Порождено исключение, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод, чтобы открыть мьютекс с помощью прав, необходимых для чтения и изменить разрешения.  
  
 После изменения разрешений, мьютекс открывается с права, необходимые для ввода и освободите его. При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.GetAccessControl%2A> Методе используется комбинация флагов (в сочетании с помощью побитовой операции OR) для поиска для разрешения: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, и <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Пользователь должен иметь <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> для вызова этого метода и мьютекс должен быть открыт с <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом. В примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного мьютекса.  
  
 Если мьютекс не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает текущий пользователь право на использование мьютексом, но не дает право на чтение и изменение разрешений для мьютекса.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Порождено исключение, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод, чтобы открыть мьютекс с помощью прав, необходимых для чтения и изменить разрешения, с помощью <xref:System.Threading.Mutex.GetAccessControl%2A> и <xref:System.Threading.Mutex.SetAccessControl%2A> методы.  
  
 После изменения разрешений, мьютекс открывается с права, необходимые для ввода и освободите его. При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  -or-  The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, and was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Not supported for Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named mutex, if it already exists.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <summary>Opens the specified named mutex, if it already exists.</summary>
        <returns>An object that represents the named system mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.OpenExisting%2A> Метод пытается открыть указанный именованный системный мьютекс. Если системный мьютекс не существует, этот метод вызывает исключение вместо создания системным объектом. Для создания системного мьютекса, когда он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузку метода с указанием <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> права, объединяются с помощью побитовой операции или.  
  
 Указание <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг позволяет потоку ожидать на мьютекс и указав <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг позволяет потоку на вызов метода <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.  
  
 Этот метод не требует владения мьютексом.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом. В примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного мьютекса.  
  
 Если мьютекс не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает текущий пользователь право на использование мьютексом, но не дает право на чтение и изменение разрешений для мьютекса.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Порождено исключение, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод, чтобы открыть мьютекс с помощью прав, необходимых для чтения и изменить разрешения.  
  
 После изменения разрешений, мьютекс открывается с права, необходимые для ввода и освободите его. При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <summary>Opens the specified named mutex, if it already exists, with the desired security access.</summary>
        <returns>An object that represents the named system mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` Параметр должен содержать <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг, чтобы разрешить потоков для ожидания семафора и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг, чтобы разрешить потокам вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.  
  
 <xref:System.Threading.Mutex.OpenExisting%2A> Метод пытается открыть существующий именованный мьютекс. Если системный мьютекс не существует, этот метод вызывает исключение вместо создания системным объектом. Для создания системного мьютекса, когда он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.  
  
 Этот метод не требует владения мьютексом.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом. В примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного мьютекса.  
  
 Если мьютекс не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает текущий пользователь право на использование мьютексом, но не дает право на чтение и изменение разрешений для мьютекса.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Порождено исключение, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод, чтобы открыть мьютекс с помощью прав, необходимых для чтения и изменить разрешения.  
  
 После изменения разрешений, мьютекс открывается с права, необходимые для ввода и освободите его. При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the desired security access.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases the <see cref="T:System.Threading.Mutex" /> once.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый раз, когда поток получает семафор (например, путем вызова его <xref:System.Threading.WaitHandle.WaitOne%2A> метод), он должен впоследствии вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> передать владение мьютексом и разблокировать другие потоки, которые пытаются получить права владельца мьютекса. Если произошел сбой попытки получить права владельца мьютекса (например, когда вызов <xref:System.Threading.WaitHandle.WaitOne%2A> метод с `millisecondsTimeout` или `timeout` параметр возвращает `false` из-за тайм-аута запроса), поток не должен вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A>, в этом регистр, поток также не должны получить доступ к ресурсу, защищенные объектом mutex, как показано в следующем примере.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 Поток, который является владельцем мьютекса можно указать его в повторных вызовах функции ожидания, не прерывая выполнение. Число вызовов хранится в среде CLR. Поток должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> такое же количество раз, чтобы освободить права владения мьютексом.  
  
 Если поток завершается владея мьютексом, мьютекс считается брошенным. Состояние мьютекса задается сигнальным, и получает следующий ожидающий поток. Если никто не является владельцем мьютекса, состояние мьютекса переводится в сигнальное состояние. Начиная с версии 2.0 платформы .NET Framework, <xref:System.Threading.AbandonedMutexException> создается в следующем потоке, который завладеет этим мьютексом. До версии 2.0 платформы .NET Framework исключение не создано.  
  
> [!CAUTION]
>  Брошенный мьютекс часто является признаком серьезной ошибки в коде. Когда поток завершает работу без освобождения объекта mutex, структуры данных, защищенные объектом mutex, возможно в согласованном состоянии. Следующий поток, который запросит владение мьютексом может обработать это исключение и продолжить работу, если можно удостовериться в целостности структуры данных.  
  
 В случае системного мьютекса брошенный мьютекс может указывать на то, что работа приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).  
  
   
  
## Examples  
 В следующем примере показано, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу. Поток, создающий мьютексом не владеет его изначально. <xref:System.Threading.Mutex.ReleaseMutex%2A> Метод позволяет освободить мьютекс, когда он больше не нужен.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">The calling thread does not own the mutex.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</param>
        <summary>Sets the access control security for a named system mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пользователь должен иметь <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> права для вызова этого метода и мьютекс должен быть открыт с <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом. В примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного мьютекса.  
  
 Если мьютекс не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает текущий пользователь право на использование мьютексом, но не дает право на чтение и изменение разрешений для мьютекса.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Порождено исключение, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод, чтобы открыть мьютекс с помощью прав, необходимых для чтения и изменить разрешения, с помощью <xref:System.Threading.Mutex.GetAccessControl%2A> и <xref:System.Threading.Mutex.SetAccessControl%2A> методы.  
  
 После изменения разрешений, мьютекс открывается с права, необходимые для ввода и освободите его. При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mutexSecurity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  -or-  The mutex was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">The current <see cref="T:System.Threading.Mutex" /> object does not represent a named system mutex.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованный мьютекс существует, этот метод не создает его. Для создания системного мьютекса, когда он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Если вы не уверены, является ли именованный мьютекс существует, используйте эту перегрузку метода вместо <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегрузку метода, который создает исключение, если мьютекс не существует.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> перегрузку метода с указанием <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> права, объединяются с помощью побитовой операции или. Указание <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг позволяет потоку ожидать на мьютекс и указав <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг позволяет потоку на вызов метода <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.  
  
 Этот метод не требует владения мьютексом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованный мьютекс существует, этот метод не создает его. Для создания системного мьютекса, когда он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Если вы не уверены, является ли именованный мьютекс существует, используйте эту перегрузку метода вместо <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузку метода, который создает исключение, если мьютекс не существует.  
  
 `rights` Параметр должен содержать <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг, чтобы разрешить потоков для ожидания семафора и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг, чтобы разрешить потокам вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.  
  
 Этот метод не требует владения мьютексом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
  </Members>
</Type>