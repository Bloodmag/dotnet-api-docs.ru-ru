<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ReaderWriterLockSlim.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac52ff770bb9446d6ebe71649784ebe115f60734cc0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2ff770bb9446d6ebe71649784ebe115f60734cc0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</source>
          <target state="translated">Представляет блокировку, используемую для управления доступом к ресурсу, которая позволяет нескольким потокам производить считывание или получать монопольный доступ на запись.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> to protect a resource that is read by multiple threads and written to by one thread at a time.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> для защиты ресурса, считываемых из нескольких потоков и записи по одному потоку за раз.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> позволяет нескольким потокам находиться в режиме чтения, одному потоку в режиме записи с монопольного доступа блокировки и позволяет одному потоку, который имеет доступ на чтение в обновляемом режиме чтения, откуда поток может перейти в режим записи без необходимости отказываться от его s разрешение на чтение к ресурсу.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is similar to <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> действует так же, как и <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, но с более простыми правилами рекурсии и изменения состояния блокировки.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> avoids many cases of potential deadlock.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> позволяет избежать многих ситуаций взаимоблокировки.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>In addition, the performance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is significantly better than <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</source>
          <target state="translated">Кроме того, производительность <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> значительно выше, чем у <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is recommended for all new development.</source>
          <target state="translated">Мы рекомендуем применять <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> при любых новых разработках.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>By default, new instances of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> are created with the <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> flag and do not allow recursion.</source>
          <target state="translated">По умолчанию новые экземпляры <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> создаются с <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> флаг и не допускает рекурсии.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</source>
          <target state="translated">Эта политика по умолчанию рекомендуется для всех новых разработках, поскольку рекурсия приводит ненужные сложности и повышает вероятность возникновения взаимоблокировок в вашем коде.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To simplify migration from existing projects that use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, you can use the <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> flag to create instances of <ph id="ph4">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that allow recursion.</source>
          <target state="translated">Чтобы упростить миграцию с существующие проекты, использующие <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> или <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, можно использовать <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> флаг для создания экземпляров <ph id="ph4">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> , которые позволяют рекурсии.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</source>
          <target state="translated">Поток может войти в блокировку в трех режимах: режим, режим записи и обновляемый режим чтения.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter <ph id="ph1">`x`</ph> mode" is used in preference to the longer phrase "enter the lock in <ph id="ph2">`x`</ph> mode".)</source>
          <target state="translated">(В остальной части этого раздела, «обновляемый режим чтения» называется «обновляемый режим» и фразу «введите <ph id="ph1">`x`</ph> режим» используется вместо более длинной фразы «войти в блокировку в <ph id="ph2">`x`</ph> режим».)</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Regardless of recursion policy, only one thread can be in write mode at any time.</source>
          <target state="translated">Независимо от политики рекурсии только один поток может находиться в режиме записи в любое время.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When a thread is in write mode, no other thread can enter the lock in any mode.</source>
          <target state="translated">Когда поток находится в режиме записи, ни один поток может войти в блокировку в любом режиме.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Only one thread can be in upgradeable mode at any time.</source>
          <target state="translated">Только один поток может находиться в обновляемом режиме, в любое время.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Может быть любое количество потоков в режиме чтения, и может быть один поток в обновляемом режиме, пока другие потоки находятся в режиме чтения.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Этот тип реализует <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> интерфейса.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">После завершения с помощью типа следует освободить его прямо или косвенно.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Для удаления типа непосредственно вызвать его <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> метод в <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> блока.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Чтобы удалить ее косвенно, использовать языковой конструкции, такие как <ph id="ph1">`using`</ph> (в C#) или <ph id="ph2">`Using`</ph> (в Visual Basic).</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> разделе интерфейса.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> has managed thread affinity; that is, each <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> object must make its own method calls to enter and exit lock modes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> управляемого сходство потоков; то есть каждый <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> объекта должны вызывать свой собственный метод войти и выйти из режима блокировки.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>No thread can change the mode of another thread.</source>
          <target state="translated">Ни один поток может изменить режим другого потока.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> не допускает рекурсию, поток можно заблокировать, пытается войти в блокировку по следующим причинам:</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</source>
          <target state="translated">Поток, который пытается войти в режим чтения блокируется, если количество потоков, ожидающих входа в режим записи или, если один поток в режиме записи в.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Blocking new readers when writers are queued is a lock fairness policy that favors writers.</source>
          <target state="translated">Блокировка новых модулей чтения при записи помещаются в очередь — политика распределение ресурсов блокировок, дает преимущества потокам записи.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</source>
          <target state="translated">Распределяет доступ для чтения и записи, для обеспечения оптимальной производительности в наиболее распространенных сценариев между текущей политики распределение ресурсов.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Future versions of the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> may introduce new fairness policies.</source>
          <target state="translated">Будущие версии <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> может вызвать новые политики распределение ресурсов.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</source>
          <target state="translated">Поток, который пытается войти в обновляемый режим блокируется, если уже существует поток в обновляемом режиме, если количество потоков, ожидающих входа в режим записи, или если существует один поток в режиме записи.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</source>
          <target state="translated">Поток, который пытается войти в режим записи блокируется, существует ли поток в любом из трех режимов.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgrading and Downgrading Locks</source>
          <target state="translated">Повышение и понижение уровня блокировки</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</source>
          <target state="translated">Обновляемый режим предназначен для ситуаций, где обычно считывает поток из защищенного ресурса, но может потребоваться записать в него, если какое-либо условие.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that has entered a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> methods.</source>
          <target state="translated">Поток, который <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> в обновляемом режиме имеет доступ на чтение к защищенному ресурсу и можно перейти в режим записи путем вызова <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> или <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</source>
          <target state="translated">Поскольку может существовать только один поток в обновляемом режиме одновременно, обновление до режима записи не может создать ситуацию взаимоблокировки при рекурсии не разрешено, при которой — политика по умолчанию.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</source>
          <target state="translated">Независимо от политики рекурсии поток, первоначально введенное чтения режим не разрешен для обновления до обновляемого режима или режима записи, так как этот шаблон создает большую вероятность возникновения взаимоблокировок.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>For example, if two threads in read mode both try to enter write mode, they will deadlock.</source>
          <target state="translated">Например если два потока в режиме чтения, которые попытаются войти в режим записи, они будут взаимоблокировка.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgradeable mode is designed to avoid such deadlocks.</source>
          <target state="translated">Обновляемый режим предназначена для предотвращения такой взаимоблокировки.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If there are other threads in read mode, the thread that is upgrading blocks.</source>
          <target state="translated">Если имеются другие потоки в режиме чтения, поток, который повышает уровень блокировки.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>While the thread is blocked, other threads that try to enter read mode are blocked.</source>
          <target state="translated">Пока поток заблокирован, блокируются другие потоки, которые пытаются войти в режим чтения.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</source>
          <target state="translated">Если все потоки вышли из режима чтения, заблокированный обновляемый поток входит в режим записи.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</source>
          <target state="translated">Если нет других потоков, ожидающих входа в режим записи, они остаются заблокированными, так как один поток, который находится в обновляемом режиме не дает им получить монопольный доступ к ресурсу.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</source>
          <target state="translated">Когда поток в обновляемом режиме выходит из режима записи, других потоков, ожидающих вхождения в режим чтения можно сделать, только при наличии потоков, ожидающих входа в режим записи.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</source>
          <target state="translated">Поток в обновляемом режиме можно обновить и понизить неопределенно долгое время, поскольку он является единственным потоком, который записывает к защищенному ресурсу.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</source>
          <target state="translated">Если разрешить несколько потоков ввести запись режиме или в обновляемом режиме, не должно допускать один поток монополизировать обновляемый режим.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</source>
          <target state="translated">В противном случае потоки, которые пытаются войти записи режим напрямую, будут заблокированы бесконечно, а пока они блокируются, другие потоки не сможет войти в режим чтения.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in upgradeable mode can downgrade to read mode by first calling the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method and then calling the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method.</source>
          <target state="translated">Поток в обновляемом режиме можно понизить до режима чтения путем вызова метода <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> и затем вызвать метод <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This downgrade pattern is allowed for all lock recursion policies, even <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion&gt;</ph>.</source>
          <target state="translated">Этот шаблон переход к более раннему допустим для всех политик рекурсии блокировки, даже <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</source>
          <target state="translated">После понижения до режима чтения потока невозможно повторно войти в обновляемом режиме, пока он выйдет из режима чтения.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Entering the Lock Recursively</source>
          <target state="translated">Рекурсивный вход в блокировку</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>You can create a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that supports recursive lock entry by using the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29&gt;</ph> constructor that specifies lock policy, and specifying <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Можно создать <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> с поддержкой рекурсивная запись блокировки с помощью <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29&gt;</ph> конструктор, который задает политику блокировки, а также указать <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</source>
          <target state="translated">Использование рекурсии для новых разработок не рекомендуется, поскольку он вводит ненужные сложности и повышает вероятность возникновения взаимоблокировок в вашем коде.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>For a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that allows recursion, the following can be said about the modes a thread can enter:</source>
          <target state="translated">Для <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> , позволяющий рекурсии, о режимах, поток может войти можно назвать следующие:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</source>
          <target state="translated">Поток в режиме чтения, может войти в режим чтения рекурсивно, но не может войти в режим записи или обновляемый режим.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If it tries to do this, a <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown.</source>
          <target state="translated">При попытке сделать это, <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> возникает исключение.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</source>
          <target state="translated">Ввод считывать режим и введя в режим записи или обновляемый режим — это шаблон, с большой вероятностью взаимоблокировок, поэтому он не разрешен.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</source>
          <target state="translated">Как было сказано ранее, обновляемый режим предназначен для случаев, где это необходимо повысить уровень блокировки.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</source>
          <target state="translated">Поток в обновляемом режиме можно указать режим записи или чтения и можно ввести любой из трех режимов рекурсивно.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>However, an attempt to enter write mode blocks if there are other threads in read mode.</source>
          <target state="translated">Однако попытка входа режим записи блокируется, если существуют другие потоки в режиме чтения.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</source>
          <target state="translated">Поток в режиме записи можно ввести в режиме чтения и/или в обновляемый режим и можно ввести любой из трех режимов рекурсивно.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that has not entered the lock can enter any mode.</source>
          <target state="translated">Поток, который не входил в блокировку можно ввести любой режим.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</source>
          <target state="translated">Эта попытка может заблокировать по тем же причинам, попытка войти в блокировку нерекурсивного.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</source>
          <target state="translated">Поток может выйти из режимов, которые он вошел в любом порядке, при условии, что он выходит из каждого режима ровно столько раз, сколько он вошел в этот режим.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> is thrown.</source>
          <target state="translated">Если поток пытается выйти из режима слишком много раз или выйти из режима, не вошел, <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> возникает исключение.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Lock States</source>
          <target state="translated">Состояния блокировки</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>You may find it useful to think of the lock in terms of its states.</source>
          <target state="translated">Могут оказаться полезными представлять блокировки в терминах его состояний.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> can be in one of four states: not entered, read, upgrade, and write.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> может находиться в одном из четырех состояний: не указан, чтение, обновление и записи.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</source>
          <target state="translated">Не введены: В этом состоянии нет потоков, вошедших в блокировку (или все потоки вышли из блокировки).</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Read: In this state, one or more threads have entered the lock for read access to the protected resource.</source>
          <target state="translated">Ознакомьтесь с разделом В этом состоянии один или несколько потоков вошедших в блокировку для доступа на чтение к защищенному ресурсу.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread can enter the lock in read mode by using the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> methods, or by downgrading from upgradeable mode.</source>
          <target state="translated">Поток может войти в блокировку в режиме чтения с помощью <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> методов, или при переходе из обновляемого режима.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</source>
          <target state="translated">Обновление: В этом состоянии один поток вошел в блокировку для доступа на чтение с возможностью повышения уровня доступа на запись (то есть в обновляемом режиме), и нуль или более потоков, вошедших в блокировку для доступа на чтение.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</source>
          <target state="translated">Не более одного потока в каждый момент может войти в блокировку с возможностью обновления; Дополнительные потоки, пытающиеся войти в обновляемый режим, блокируются.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Write: In this state, one thread has entered the lock for write access to the protected resource.</source>
          <target state="translated">Записи: В этом состоянии один поток вошел в блокировку для доступа на запись к защищенному ресурсу.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>That thread has exclusive possession of the lock.</source>
          <target state="translated">Этот поток, обладает монопольная блокировка.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Any other thread that tries to enter the lock for any reason is blocked.</source>
          <target state="translated">Другой поток, который пытается войти в блокировку по любой причине блокируется.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread <ph id="ph1">`t`</ph> takes the action described in the leftmost column.</source>
          <target state="translated">В следующей таблице описаны переходы между состояниями для блокировок, не допускающих рекурсии, когда поток <ph id="ph1">`t`</ph> выполняет действие, приведенное в левом столбце.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>At the time it takes the action, <ph id="ph1">`t`</ph> has no mode.</source>
          <target state="translated">Во время он выполняет действие, <ph id="ph1">`t`</ph> имеет без режима.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>(The special case where <ph id="ph1">`t`</ph> is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</source>
          <target state="translated">(Особый случай где <ph id="ph1">`t`</ph> в обновляемый режим описан в таблице сноски.) В верхней строке указано начальное состояние блокировки.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The cells describe what happens to the thread, and show changes to the lock state in parentheses.</source>
          <target state="translated">Ячейки выполняются в поток и отображать изменения в состоянии блокировки в круглых скобках.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Not entered (N)</source>
          <target state="translated">Нет входов (N)</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Read (R)</source>
          <target state="translated">Read (R)</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgrade (U)</source>
          <target state="translated">Обновления (U)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Write (W)</source>
          <target state="translated">Записи (W)</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters read mode</source>
          <target state="translated"><ph id="ph1">`t`</ph> входит в режим чтения</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters (R).</source>
          <target state="translated"><ph id="ph1">`t`</ph> вводит (R).</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks if threads are waiting for write mode; otherwise, <ph id="ph2">`t`</ph> enters.</source>
          <target state="translated"><ph id="ph1">`t`</ph> блокируется, если потоки ожидают режим записи; в противном случае <ph id="ph2">`t`</ph> вводит.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks if threads are waiting for write mode; otherwise, <ph id="ph2">`t`</ph> enters.<bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept></source>
          <target state="translated"><ph id="ph1">`t`</ph> блокируется, если потоки ожидают режим записи; в противном случае <ph id="ph2">`t`</ph> вводит.<bpt id="p1">&lt;sup&gt;</bpt> 1<ept id="p1">&lt;/sup&gt;</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> блокирует вызывающий поток.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters upgradeable mode</source>
          <target state="translated"><ph id="ph1">`t`</ph> входит в обновляемый режим</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters (U).</source>
          <target state="translated"><ph id="ph1">`t`</ph> вводит (U).</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks if threads are waiting for write mode or upgrade mode; otherwise, <ph id="ph2">`t`</ph> enters (U).</source>
          <target state="translated"><ph id="ph1">`t`</ph> блокируется, если потоки ожидают режим записи или обновляемый режим; в противном случае <ph id="ph2">`t`</ph> вводит (U).</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> блокирует вызывающий поток.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> блокирует вызывающий поток.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters write mode</source>
          <target state="translated"><ph id="ph1">`t`</ph> входит в режим записи</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters (W).</source>
          <target state="translated"><ph id="ph1">`t`</ph> вводит (W).</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> блокирует вызывающий поток.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept></source>
          <target state="translated"><ph id="ph1">`t`</ph> блокирует вызывающий поток. <bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept></target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> блокирует вызывающий поток.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept> If <ph id="ph1">`t`</ph> starts out in upgradeable mode, it enters read mode.</source>
          <target state="translated"><bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept> Если <ph id="ph1">`t`</ph> запускает помещает в обновляемом режиме, он входит в режим чтения.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This action never blocks.</source>
          <target state="translated">Это действие никогда не блокируется.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The lock state does not change.</source>
          <target state="translated">Состояние блокировки не изменяется.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</source>
          <target state="translated">(Поток может завершить понижение уровня блокировки для режима чтения, выполнив выход из обновляемого режима.)</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept> If <ph id="ph1">`t`</ph> starts out in upgradeable mode, it blocks if there are threads in read mode.</source>
          <target state="translated"><bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept> Если <ph id="ph1">`t`</ph> запускается в обновляемом режиме, он блокируется, если существуют потоки в режиме чтения.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Otherwise it upgrades to write mode.</source>
          <target state="translated">В противном случае он обновляет режим записи.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The lock state changes to Write (W).</source>
          <target state="translated">Изменения состояния блокировки записи (W).</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If <ph id="ph1">`t`</ph> blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</source>
          <target state="translated">Если <ph id="ph1">`t`</ph> блокируется из-за потоков в режиме чтения, он входит в режим записи, как только последний поток выходит из режима чтения, даже при наличии потоков, ожидающих входа в режим записи.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</source>
          <target state="translated">Когда происходит изменение состояния, так как поток завершает работу блокировку, следующий поток активируемый выбран следующим образом:</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</source>
          <target state="translated">Во-первых поток, который ожидает режим записи и уже находится в обновляемом режиме (может существовать не более одного потока).</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Failing that, a thread that is waiting for write mode.</source>
          <target state="translated">Сбой, поток, который ожидает режим записи.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Failing that, a thread that is waiting for upgradeable mode.</source>
          <target state="translated">Сбой, поток, который ожидает в обновляемом режиме.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Failing that, all threads that are waiting for read mode.</source>
          <target state="translated">Произошел сбой, всех потоков, ожидающих в режиме чтения.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</source>
          <target state="translated">Состояние блокировки всегда находится запись (W) в первых двух случаях и обновления (U) в третьем, независимо от состояния блокировки, при выходе из нее потока, вызвавшего изменение состояния.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</source>
          <target state="translated">В последнем случае состояние блокировки — обновления (U) при наличии поток в обновляемом режиме после изменения состояния и Read (R) в противном случае, независимо от предыдущего состояния.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The following example shows a simple synchronized cache that holds strings with integer keys.</source>
          <target state="translated">В следующем примере показано простого синхронизированного кэша, содержащего строки с целочисленных ключей.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>An instance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is used to synchronize access to the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> that serves as the inner cache.</source>
          <target state="translated">Экземпляр <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> используется для синхронизации доступа к <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> , служит в качестве внутреннего кэша.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</source>
          <target state="translated">Пример содержит простые методы для добавления в кэш, удаления из кэша и считано из кэша.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</source>
          <target state="translated">Чтобы продемонстрировать истечение времени ожидания, в примере содержит метод, который добавляет в кэш только в том случае, если это можно сделать в течение заданного времени ожидания.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Чтобы продемонстрировать обновляемый режим, в примере включает метод, который возвращает значение, связанное с ключом и сравнивает его с новым значением.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Если значение остается неизменным, метод возвращает состояние, указывающее без изменений.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Оно не найдено значение для ключа, вставляется пара ключ значение.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Если значение изменилось, она обновляется.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</source>
          <target state="translated">Обновляемый режим позволяет потоку для обновления от чтения доступа на запись без риска возникновения взаимоблокировок.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</source>
          <target state="translated">Пример включает вложенное перечисление, определяющее возвращаемые значения для метода, который демонстрирует обновляемом режиме.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">В примере используется конструктор по умолчанию для создания блокировки, поэтому рекурсия не допускается.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Программирование <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> стало проще и менее подвержены возникновению ошибок, когда блокировка не допускает рекурсии.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The following code then uses the <ph id="ph1">`SynchronizedCache`</ph> object to store a dictionary of vegetable names.</source>
          <target state="translated">В следующем коде используется затем <ph id="ph1">`SynchronizedCache`</ph> объект для сохранения словаря овощной имен.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>It creates three tasks.</source>
          <target state="translated">Он создает три задачи.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The first writes the names of vegetables stored in an array to a <ph id="ph1">`SynchronizedCache`</ph> instance.</source>
          <target state="translated">Первый записывает имена овощей, хранящихся в массиве для <ph id="ph1">`SynchronizedCache`</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</source>
          <target state="translated">Второй и третий задачи для отображения имен овощей первым в порядке возрастания (низкий индекс высокого уровня), второй в порядке убывания.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The final task searches for the string "cucumber" and, when it finds it, calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method  to substitute the string "green bean".</source>
          <target state="translated">Последняя задача осуществляет поиск строки «cucumber» и при обнаружении, вызывает <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> метод для замены строки «быть зеленый», с ягодами.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This type is thread safe.</source>
          <target state="translated">Данный тип потокобезопасен.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class with default property values.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> значениями свойств по умолчанию.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that is initialized with this constructor does not allow recursion.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> , инициализируемый это конструктор, не допускающих рекурсии.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>That is, the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> property returns <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">То есть свойство <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> возвращает значение <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>For more information about recursion policy and its effects, see the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Дополнительные сведения о политике рекурсии и его влияние см. в разделе <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> перечисления и <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The following example shows a simple synchronized cache that holds strings with integer keys.</source>
          <target state="translated">В следующем примере показано простого синхронизированного кэша, содержащего строки с целочисленных ключей.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>An instance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is used to synchronize access to the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> that serves as the inner cache.</source>
          <target state="translated">Экземпляр <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> используется для синхронизации доступа к <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> , служит в качестве внутреннего кэша.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The parameterless constructor is used to create the lock.</source>
          <target state="translated">Для создания блокировки используется конструктор без параметров.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</source>
          <target state="translated">Пример содержит простые методы для добавления в кэш, удаления из кэша и считано из кэша.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</source>
          <target state="translated">Чтобы продемонстрировать истечение времени ожидания, в примере содержит метод, который добавляет в кэш только в том случае, если это можно сделать в течение заданного времени ожидания.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Чтобы продемонстрировать обновляемый режим, в примере включает метод, который возвращает значение, связанное с ключом и сравнивает его с новым значением.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Если значение остается неизменным, метод возвращает состояние, указывающее без изменений.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Оно не найдено значение для ключа, вставляется пара ключ значение.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Если значение изменилось, она обновляется.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</source>
          <target state="translated">Обновляемый режим позволяет потоку для обновления от чтения доступа на запись без риска возникновения взаимоблокировок.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</source>
          <target state="translated">Пример включает вложенное перечисление, определяющее возвращаемые значения для метода, который демонстрирует обновляемом режиме.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">В примере используется конструктор по умолчанию для создания блокировки, поэтому рекурсия не допускается.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Программирование <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> стало проще и менее подвержены возникновению ошибок, когда блокировка не допускает рекурсии.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The following code then uses the <ph id="ph1">`SynchronizedCache`</ph> object to store a dictionary of vegetable names.</source>
          <target state="translated">В следующем коде используется затем <ph id="ph1">`SynchronizedCache`</ph> объект для сохранения словаря овощной имен.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>It creates three tasks.</source>
          <target state="translated">Он создает три задачи.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The first writes the names of vegetables stored in an array to a <ph id="ph1">`SynchronizedCache`</ph> instance.</source>
          <target state="translated">Первый записывает имена овощей, хранящихся в массиве для <ph id="ph1">`SynchronizedCache`</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</source>
          <target state="translated">Второй и третий задачи для отображения имен овощей первым в порядке возрастания (низкий индекс высокого уровня), второй в порядке убывания.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The final task searches for the string "cucumber" and, when it finds it, calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method  to substitute the string "green bean".</source>
          <target state="translated">Последняя задача осуществляет поиск строки «cucumber» и при обнаружении, вызывает <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> метод для замены строки «быть зеленый», с ягодами.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>One of the enumeration values that specifies the lock recursion policy.</source>
          <target state="translated">Одно из значений перечисления, определяющее политику рекурсии блокировки.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class, specifying the lock recursion policy.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> с указанием политики рекурсии блокировок.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Recursion policy determines the restrictions on threads that enter the lock more than once.</source>
          <target state="translated">Политика рекурсии определяет ограничения для потоков, войти в блокировку более одного раза.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>For example, if a lock was created with <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> and a thread has entered the lock in read mode, <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in read mode.</source>
          <target state="translated">Например, если блокировка была создана с <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> и поток вошел в блокировку в режиме чтения <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> создается, если поток пытается повторно вводить в блокировку в режиме чтения.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Similarly, if a thread has entered the lock in write mode, <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in any mode.</source>
          <target state="translated">Аналогично, если поток вошел в блокировку в режиме записи <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> создается, если поток пытается повторно вводить в блокировку в любом режиме.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</source>
          <target state="translated">Поток в обновляемом режиме можно обновить до режима записи или понизить до режима независимо от настроек политики рекурсии блокировки чтения.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</source>
          <target state="translated">Независимо от политики рекурсии поток, первоначально введенное чтения режим не разрешен для обновления до обновляемого режима или режима записи, так как этот шаблон создает большую вероятность возникновения взаимоблокировок.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>For more information about recursion policy and its effects, see the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Дополнительные сведения о политике рекурсии и его влияние см. в разделе <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> перечисления и <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The following example shows two exception scenarios, one that depends on the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> setting and one that does not.</source>
          <target state="translated">В следующем примере показано два сценария исключения, который зависит от <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> параметр, а другой — нет.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</source>
          <target state="translated">В первом сценарии поток входит в режим чтения, а затем пытается войти в режим чтения рекурсивно.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is created by using the default constructor, which sets recursion policy to <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>, an exception is thrown.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> создается с помощью конструктора по умолчанию, который задает политику рекурсии <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>, создается исключение.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> is used to create the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> используется для создания <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, исключение не возникает.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>In the second scenario, the thread enters read mode and then tries to enter write mode.</source>
          <target state="translated">Во втором сценарии поток входит в режим чтения и затем режим записи попыток ввода.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown regardless of the lock recursion policy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> создается независимо от политики рекурсии блокировок.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The following code then uses the <ph id="ph1">`SynchronizedCache`</ph> object to store a dictionary of vegetable names.</source>
          <target state="translated">В следующем коде используется затем <ph id="ph1">`SynchronizedCache`</ph> объект для сохранения словаря овощной имен.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>It creates three tasks.</source>
          <target state="translated">Он создает три задачи.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The first writes the names of vegetables stored in an array to a <ph id="ph1">`SynchronizedCache`</ph> instance.</source>
          <target state="translated">Первый записывает имена овощей, хранящихся в массиве для <ph id="ph1">`SynchronizedCache`</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</source>
          <target state="translated">Второй и третий задачи для отображения имен овощей первым в порядке возрастания (низкий индекс высокого уровня), второй в порядке убывания.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The final task searches for the string "cucumber" and, when it finds it, calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method  to substitute the string "green bean".</source>
          <target state="translated">Последняя задача осуществляет поиск строки «cucumber» и при обнаружении, вызывает <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> метод для замены строки «быть зеленый», с ягодами.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>Gets the total number of unique threads that have entered the lock in read mode.</source>
          <target state="translated">Получает общее количество уникальных потоков, вошедших в блокировку в режиме чтения.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>The number of unique threads that have entered the lock in read mode.</source>
          <target state="translated">Количество уникальных потоков, вошедших в блокировку в режиме чтения.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</source>
          <target state="translated">Поток учитывается только один раз, даже если блокировка допускает рекурсию и поток входил в режим чтения несколько раз.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Результаты можно изменить, как можно скорее после их вычисления.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Таким образом не является безопасным для принятия решений на основе этого свойства.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A&gt;</ph> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A&gt;</ph> свойства для создания записи в журнале событий, если количество потоков в режиме чтения превышает пороговое значение.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class.</source>
          <target state="translated">Освобождает все ресурсы, используемые текущим экземпляром класса <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>Call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.</source>
          <target state="translated">Вызовите метод <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> по окончании использования класса <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in an unusable state.</source>
          <target state="translated">Метод <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> оставляет класс <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> в непригодном для использования состоянии.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>After calling <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> was occupying.</source>
          <target state="translated">После вызова метода <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph>, необходимо освободить все ссылки на <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> , сборщик мусора мог освободить память, <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> занимаемую.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>очистки неуправляемых ресурсов<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> и <bpt id="p2">[</bpt>метода<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>Always call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> object.</source>
          <target state="translated">Всегда вызывайте метод <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> перед освобождением последней ссылки на <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /&gt;</ph> is greater than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /&gt;</ph> больше нуля.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /&gt;</ph> is greater than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /&gt;</ph> больше нуля.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /&gt;</ph> is greater than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /&gt;</ph> больше нуля.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>Tries to enter the lock in read mode.</source>
          <target state="translated">Пытается выполнить вход в блокировку в режиме чтения.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>This method blocks until the calling thread enters the lock, and therefore might never return.</source>
          <target state="translated">Этот метод блокируется до вызывающий поток вошел в блокировку, а следовательно, может никогда не возвращают.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> метод на указанный промежуток времени, и возвращается, если вызывающий поток не вошел в режим чтения во время этого интервала.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>Multiple threads can enter read mode at the same time.</source>
          <target state="translated">Несколько потоков могут войти в режим чтения в то же время.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Если один или несколько потоков, ожидающих входа в режим записи, поток, вызывающий <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> метод блокируется до этих потоков истекло время ожидания или вошел в режим записи и выйдут из него.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме чтения можно войти в режим чтения рекурсивно, даже если другие потоки ожидают входа в режим записи.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>At most one thread can be in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Максимум один поток может находиться в обновляемом режиме, когда другие потоки находятся в режиме чтения.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.</source>
          <target state="translated">Если нет потоков, ожидающих входа в режим записи дополнительных потоков, ожидающих входа в обновляемый режим, потоки, вызывающих метод <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> метод сразу же войти в режим чтения и не блокируются.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method to enter the lock in read mode.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> метод, чтобы войти в блокировку в режиме чтения.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The method shown in the example retrieves the value associated with a key.</source>
          <target state="translated">Метод, показанный в примере возвращает значение, связанное с ключом.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If the key is not found, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Если ключ не найден, исключение, вызванное внутреннего <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> допускается завершение метода.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> method, ensuring that the caller exits read mode.</source>
          <target state="translated">Объект <ph id="ph1">`finally`</ph> блок используется для выполнения <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> метод, гарантируя, что вызывающий объект выходит из режима чтения.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The current thread cannot acquire the write lock when it holds the read lock.</source>
          <target state="translated">Текущему потоку не удается получить блокировку записи, когда он удерживает блокировку чтения.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, and the current thread has attempted to acquire the read lock when it already holds the read lock.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> имеет значение <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, и текущий поток попытался получить блокировку чтения, когда уже удерживает эту блокировку чтения.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, and the current thread has attempted to acquire the read lock when it already holds the write lock.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> имеет значение <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, и текущий поток попытался получить блокировку записи, когда уже удерживает эту блокировку записи.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Глубина рекурсии превышает емкость счетчика.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>This limit is so large that applications should never encounter this exception.</source>
          <target state="translated">Данное ограничение настолько велико, что приложения никогда не должны столкнуться с этим исключением.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> был удален.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Tries to enter the lock in upgradeable mode.</source>
          <target state="translated">Пытается выполнить вход в блокировку в обновляемом режиме.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>This method blocks until the calling thread enters the lock, and therefore might never return.</source>
          <target state="translated">Этот метод блокируется до вызывающий поток вошел в блокировку, а следовательно, может никогда не возвращают.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> метод на указанный промежуток времени, и возвращается, если вызывающий поток имеет не вошел в обновляемый режим во время этого интервала.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Use upgradeable mode when a thread usually accesses the resource that is protected by the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.</source>
          <target state="translated">Обновляемый режим следует применять при поток обычно получает доступ к ресурсу, который защищен службой <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> в режиме чтения, но может потребоваться войти в режим записи при соблюдении определенных условий.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</source>
          <target state="translated">Поток в обновляемом режиме можно перейти в режим чтения или перейти в режим записи.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Only one thread can enter upgradeable mode at any given time.</source>
          <target state="translated">В любой момент времени только один поток может войти в обновляемый режим.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</source>
          <target state="translated">Если поток находится в обновляемом режиме и нет потоков, ожидающих входа в режим записи, любое количество других потоков может войти в режим чтения, даже если нет потоков, ожидающих входа в обновляемый режим.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Если один или несколько потоков, ожидающих входа в режим записи, поток, вызывающий <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> метод блокируется до этих потоков истекло время ожидания или вошел в режим записи и выйдут из него.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Если блокировка допускает рекурсию, поток, который вошел в блокировку в обновляемом режиме можно ввести обновляемый режим рекурсивно, даже если другие потоки ожидают входа в режим записи.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method to enter the lock in upgradeable mode.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> метод, чтобы войти в блокировку в обновляемом режиме.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method, ensuring that the caller exits upgradeable mode.</source>
          <target state="translated">Объект <ph id="ph1">`finally`</ph> блок используется для выполнения <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> метод, гарантируя, что вызывающий объект выходит из обновляемого режима.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The method shown in the example retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Метод, показанный в примере возвращает значение, связанное с ключом и сравнивает его с новым значением.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Если значение остается неизменным, метод возвращает состояние, указывающее без изменений.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Оно не найдено значение для ключа, вставляется пара ключ значение.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Если значение изменилось, она обновляется.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</source>
          <target state="translated">Обновляемый режим позволяет потоку блокировки чтения без риска возникновения взаимоблокировок.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">В примере используется конструктор по умолчанию для создания блокировки, поэтому рекурсия не допускается.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Программирование <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> стало проще и менее подвержены возникновению ошибок, когда блокировка не допускает рекурсии.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock in any mode.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> имеет значение <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, а текущий поток уже вошел в блокировку в любом из режимов.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</source>
          <target state="translated">Текущий поток вошел в режим чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Глубина рекурсии превышает емкость счетчика.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> был удален.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>Tries to enter the lock in write mode.</source>
          <target state="translated">Пытается выполнить вход в блокировку в режиме записи.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>This method blocks until the calling thread enters the lock, and therefore might never return.</source>
          <target state="translated">Этот метод блокируется до вызывающий поток вошел в блокировку, а следовательно, может никогда не возвращают.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> метод на указанный промежуток времени, и возвращается, если вызывающий поток не вошел режим записи во время этого интервала.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>If other threads have entered the lock in read mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode.</source>
          <target state="translated">Если других потоков, вошедших в блокировку в режиме чтения, на поток, который вызывает <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> метод блокируется до эти потоки вышли из режима чтения.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">При наличии потоков, ожидающих входа в режим записи, дополнительные потоки, пытающиеся войти режим чтения или обновляемый режим, блокируются, пока у всех потоков, ожидающих входа в режим записи, либо истекло время ожидания или вошел в режим записи и выйдут из него.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме записи можно ввести режим записи рекурсивно, даже если другие потоки ожидают входа в режим записи.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method to enter the lock in write mode.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> метод, чтобы войти в блокировку в режиме записи.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The method shown in the example adds a new key/value pair to the synchronized cache.</source>
          <target state="translated">Метод, показанный в примере синхронизированного кэша добавляет новую пару ключ значение.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>If the key is already in the cache, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Если ключ уже имеется в кэше, исключение, вызванное внутреннего <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> допускается завершение метода.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> method, ensuring that the caller exits write mode.</source>
          <target state="translated">Объект <ph id="ph1">`finally`</ph> блок используется для выполнения <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> метод, гарантируя, что вызывающий объект выходит из режима записи.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock in any mode.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> имеет значение <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, а текущий поток уже вошел в блокировку в любом из режимов.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock.</source>
          <target state="translated">Текущий поток вошел в режим чтения, поэтому попытка войти в блокировку в обновляемом режиме создаст риск взаимоблокировки.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Глубина рекурсии превышает емкость счетчика.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> был удален.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</source>
          <target state="translated">Уменьшает счетчик глубины рекурсии для режима чтения и выходит из режима чтения, если счетчик принял значение 0 (нуль).</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>This method is not sensitive to recursion order.</source>
          <target state="translated">Этот метод не чувствителен к порядку рекурсии.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</source>
          <target state="translated">Например если поток вошел в блокировку в обновляемом режиме, а затем вошел в блокировку в режиме чтения, порядок, в котором поток выходит из двух режимов не имеет значения.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</source>
          <target state="translated">Если блокировка допускает рекурсию, поток может войти в блокировку в режиме записи и затем войти в нее рекурсивно в режиме чтения. порядок, в котором поток выходит из режима чтения и записи режим не имеет значения.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>Exiting the lock might signal other waiting threads.</source>
          <target state="translated">Выход из блокировки может сигнализировать другим ожидающим потокам.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The following example shows how to use a <ph id="ph1">`finally`</ph> block to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> method, ensuring that the caller exits read mode.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">`finally`</ph> к выполнению блока <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> метод, гарантируя, что вызывающий объект выходит из режима чтения.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The method shown in the example retrieves the value associated with a key.</source>
          <target state="translated">Метод, показанный в примере возвращает значение, связанное с ключом.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>If the key is not found, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Если ключ не найден, исключение, вызванное внутреннего <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> допускается завершение метода.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method is used to enter read mode.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> Метод позволяет войти в режим чтения.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The current thread has not entered the lock in read mode.</source>
          <target state="translated">Текущий поток не вошел в блокировку в режиме чтения.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</source>
          <target state="translated">Уменьшает счетчик глубины рекурсии для обновляемого режима и выходит из обновляемого режима, если счетчик принял значение 0 (нуль).</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>This method is not sensitive to recursion order.</source>
          <target state="translated">Этот метод не чувствителен к порядку рекурсии.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</source>
          <target state="translated">Например если поток вошел в блокировку в обновляемом режиме, а затем вошел в блокировку в режиме записи, порядок, в котором поток выходит из двух режимов не имеет значения.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</source>
          <target state="translated">Если блокировка допускает рекурсию, поток может войти в блокировку в режиме записи и затем войти в нее рекурсивно в обновляемом режиме. порядок, в котором поток выходит из обновляемого режима и режима записи не имеет значения.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Exiting the lock might signal other waiting threads.</source>
          <target state="translated">Выход из блокировки может сигнализировать другим ожидающим потокам.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The following example shows how to use a <ph id="ph1">`finally`</ph> block to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method, ensuring that the caller exits upgradeable mode.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">`finally`</ph> к выполнению блока <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> метод, гарантируя, что вызывающий объект выходит из обновляемого режима.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The method shown in the example retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Метод, показанный в примере возвращает значение, связанное с ключом и сравнивает его с новым значением.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Если значение остается неизменным, метод возвращает состояние, указывающее без изменений.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Оно не найдено значение для ключа, вставляется пара ключ значение.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Если значение изменилось, она обновляется.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</source>
          <target state="translated">Обновляемый режим позволяет потоку блокировки чтения без риска возникновения взаимоблокировок.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">В примере используется конструктор по умолчанию для создания блокировки, поэтому рекурсия не допускается.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Программирование <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> стало проще и менее подвержены возникновению ошибок, когда блокировка не допускает рекурсии.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The current thread has not entered the lock in upgradeable mode.</source>
          <target state="translated">Текущий поток не вошел в блокировку в обновляемом режиме.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</source>
          <target state="translated">Уменьшает счетчик глубины рекурсии для режима записи и выходит из режима записи, если счетчик принял значение 0 (нуль).</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>This method is not sensitive to recursion order.</source>
          <target state="translated">Этот метод не чувствителен к порядку рекурсии.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</source>
          <target state="translated">Например если поток вошел в блокировку в обновляемом режиме, а затем вошел в блокировку в режиме записи, порядок, в котором поток выходит из двух режимов не имеет значения.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</source>
          <target state="translated">Если блокировка допускает рекурсию, поток может войти в блокировку в режиме записи и затем войти в нее рекурсивно в режиме чтения. порядок, в котором поток выходит из режима чтения и записи режим не имеет значения.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>Exiting the lock might signal other waiting threads.</source>
          <target state="translated">Выход из блокировки может сигнализировать другим ожидающим потокам.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The following example shows how to use a <ph id="ph1">`finally`</ph> block to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> method, ensuring that the caller exits write mode.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">`finally`</ph> к выполнению блока <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> метод, гарантируя, что вызывающий объект выходит из режима записи.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The method shown in the example adds a new key/value pair to the synchronized cache.</source>
          <target state="translated">Метод, показанный в примере синхронизированного кэша добавляет новую пару ключ значение.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>If the key is already in the cache, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Если ключ уже имеется в кэше, исключение, вызванное внутреннего <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> допускается завершение метода.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method is used to enter the lock in write mode.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> Метод используется для входа в блокировку в режиме записи.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The current thread has not entered the lock in write mode.</source>
          <target state="translated">Текущий поток не вошел в блокировку в режиме записи.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>Gets a value that indicates whether the current thread has entered the lock in read mode.</source>
          <target state="translated">Получает значение, указывающее, вошел ли текущий поток в блокировку в режиме чтения.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread has entered read mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий поток вошел в режим чтения; в противном случае <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>This property is intended for use in asserts or for other debugging purposes.</source>
          <target state="translated">Это свойство предназначено для использования в подтверждениях или для других целей отладки.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>Do not use it to control the flow of program execution.</source>
          <target state="translated">Не используйте его для управления потоком выполнения программы.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A&gt;</ph> property to generate an assert if the current thread has entered read mode unexpectedly.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A&gt;</ph> свойства для создания утверждения, если текущий поток вошел в режим чтения неожиданно.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</source>
          <target state="translated">Возвращает значение, указывающее, вошел ли текущий поток в блокировку в обновляемом режиме.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread has entered upgradeable mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий поток вошел в обновляемый режим, противном случае – <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>This property is intended for use in asserts or for other debugging purposes.</source>
          <target state="translated">Это свойство предназначено для использования в подтверждениях или для других целей отладки.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>Do not use it to control the flow of program execution.</source>
          <target state="translated">Не используйте его для управления потоком выполнения программы.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A&gt;</ph> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A&gt;</ph> свойства для создания утверждения, если текущий поток вошел в обновляемый режим неожиданно.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>Gets a value that indicates whether the current thread has entered the lock in write mode.</source>
          <target state="translated">Получает значение, указывающее, вошел ли текущий поток в блокировку в режиме записи.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread has entered write mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий поток вошел в режим записи; в противном случае <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>This property is intended for use in asserts or for other debugging purposes.</source>
          <target state="translated">Это свойство предназначено для использования в подтверждениях или для других целей отладки.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>Do not use it to control the flow of program execution.</source>
          <target state="translated">Не используйте его для управления потоком выполнения программы.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A&gt;</ph> property to generate an assert if the current thread has entered write mode unexpectedly.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A&gt;</ph> свойства для создания утверждения, если текущий поток вошел в режим записи неожиданно.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>Gets a value that indicates the recursion policy for the current <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object.</source>
          <target state="translated">Возвращает значение, указывающее политику рекурсии для текущего объекта <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>One of the enumeration values that specifies the lock recursion policy.</source>
          <target state="translated">Одно из значений перечисления, определяющее политику рекурсии блокировки.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>Recursion policy determines the restrictions on threads that enter the lock more than once.</source>
          <target state="translated">Политика рекурсии определяет ограничения для потоков, войти в блокировку более одного раза.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>For example, if a lock was created with <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> and a thread has entered the lock in read mode, <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in read mode.</source>
          <target state="translated">Например, если блокировка была создана с <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> и поток вошел в блокировку в режиме чтения <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> создается, если поток пытается повторно вводить в блокировку в режиме чтения.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</source>
          <target state="translated">Поток в обновляемом режиме можно обновить до режима записи или понизить до режима независимо от настроек политики рекурсии блокировки чтения.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</source>
          <target state="translated">Независимо от политики рекурсии поток, первоначально введенное чтения режим не разрешен для обновления до обновляемого режима или режима записи, так как этот шаблон создает большую вероятность возникновения взаимоблокировок.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>For more information about recursion policy and its effects, see the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Дополнительные сведения о политике рекурсии и его влияние см. в разделе <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> перечисления и <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</source>
          <target state="translated">Получает количество раз, которые текущий поток входил в блокировку в режиме чтения, как показатель рекурсии.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or <bpt id="p1">*</bpt>n<ept id="p1">*</ept> if the thread has entered the lock recursively <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 times.</source>
          <target state="translated">0 (нуль), если текущий поток не вошел в режим чтения, 1, если поток вошел в режим чтения, но не рекурсивно, или <bpt id="p1">*</bpt>n<ept id="p1">*</ept> Если поток вошел в блокировку рекурсивно <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 раз.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Результаты можно изменить, как можно скорее после их вычисления.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Таким образом не является безопасным для принятия решений на основе этого свойства.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</source>
          <target state="translated">Получает количество раз, которые текущий поток входил в блокировку в обновляемом режиме, как показатель рекурсии.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or <bpt id="p1">*</bpt>n<ept id="p1">*</ept> if the thread has entered upgradeable mode recursively <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 times.</source>
          <target state="translated">0, если текущий поток не вошел в обновляемый режим, 1, если поток вошел в обновляемый режим, но не вошел в него рекурсивно, или <bpt id="p1">*</bpt>n<ept id="p1">*</ept> Если поток вошел в обновляемый режим рекурсивно <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 раз.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Результаты можно изменить, как можно скорее после их вычисления.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Таким образом не является безопасным для принятия решений на основе этого свойства.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</source>
          <target state="translated">Получает количество раз, которые текущий поток входил в блокировку в режиме записи, как показатель рекурсии.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or <bpt id="p1">*</bpt>n<ept id="p1">*</ept> if the thread has entered write mode recursively <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 times.</source>
          <target state="translated">0, если текущий поток не вошел в режим записи, 1, если поток вошел в режим записи, но не рекурсивно, или <bpt id="p1">*</bpt>n<ept id="p1">*</ept> Если поток вошел в режим записи рекурсивно <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 раз.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Результаты можно изменить, как можно скорее после их вычисления.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Таким образом не является безопасным для принятия решений на основе этого свойства.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Tries to enter the lock in read mode, with an optional time-out.</source>
          <target state="translated">Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The number of milliseconds to wait, or -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) to wait indefinitely.</source>
          <target state="translated">Время ожидания в миллисекундах или -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) в случае неограниченного времени ожидания.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>Tries to enter the lock in read mode, with an optional integer time-out.</source>
          <target state="translated">Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания целым числом.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered read mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если вызывающий поток вошел в режим чтения; в противном случае <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Если <ph id="ph1">`millisecondsTimeout`</ph> равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает <ph id="ph2">`false`</ph> немедленно в том случае, если нужное состояние недоступно.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>Multiple threads can enter read mode at the same time.</source>
          <target state="translated">Несколько потоков могут войти в режим чтения в то же время.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Если один или несколько потоков, ожидающих входа в режим записи, поток, вызывающий <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> метод блокируется, пока эти потоки либо истекло время ожидания или вошел в режим записи и не выйдут из него, или пока не истечет время ожидания вызывающего потока собственные.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме чтения можно войти в режим чтения рекурсивно, даже если другие потоки ожидают входа в режим записи.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>One thread can be in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Один поток может находиться в обновляемом режиме, когда другие потоки находятся в режиме чтения.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.</source>
          <target state="translated">Если нет потоков, ожидающих входа в режим записи дополнительных потоков, ожидающих входа в обновляемый режим, потоки, вызывающих метод <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> метод сразу же войти в режим чтения и не блокируются.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> имеет значение <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, а текущий поток уже вошел в блокировку.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Глубина рекурсии превышает емкость счетчика.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, but it is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), which is the only negative value allowed.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> меньше нуля, но не равно <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), которое является единственным допустимым отрицательным значением.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> был удален.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The interval to wait, or -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Период ожидания или значение -1 миллисекунда для ожидания в течение неограниченного времени.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>Tries to enter the lock in read mode, with an optional time-out.</source>
          <target state="translated">Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered read mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если вызывающий поток вошел в режим чтения; в противном случае <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Если <ph id="ph1">`timeout`</ph> равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает <ph id="ph2">`false`</ph> немедленно в том случае, если нужное состояние недоступно.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>Multiple threads can enter the lock in read mode at the same time.</source>
          <target state="translated">Несколько потоков может войти в блокировку в режиме чтения, в то же время.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If one or more threads are queued to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Если один или несколько потоков помещаются в очередь в режим записи, поток, вызывающий <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> метод блокируется, пока эти потоки либо истекло время ожидания или вошел в режим записи и не выйдут из него, или пока не истечет время ожидания вызывающего потока собственные.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме чтения можно войти в режим чтения рекурсивно, даже если другие потоки ожидают входа в режим записи.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>One thread can be in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Один поток может находиться в обновляемом режиме, когда другие потоки находятся в режиме чтения.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.</source>
          <target state="translated">Если нет потоков, ожидающих входа в режим записи дополнительных потоков, ожидающих входа в обновляемый режим, потоки, вызывающих метод <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> метод сразу же войти в режим чтения и не блокируются.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> имеет значение <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, а текущий поток уже вошел в блокировку.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Глубина рекурсии превышает емкость счетчика.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> отрицательное, но оно не равно -1 миллисекунде, которое является единственным допустимым отрицательным значением.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> больше <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> миллисекунд.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> был удален.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Tries to enter the lock in upgradeable mode, with an optional time-out.</source>
          <target state="translated">Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The number of milliseconds to wait, or -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) to wait indefinitely.</source>
          <target state="translated">Время ожидания в миллисекундах или -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) в случае неограниченного времени ожидания.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>Tries to enter the lock in upgradeable mode, with an optional time-out.</source>
          <target state="translated">Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered upgradeable mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если вызывающий поток вошел в обновляемый режим; в противном случае <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Если <ph id="ph1">`millisecondsTimeout`</ph> равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает <ph id="ph2">`false`</ph> немедленно в том случае, если нужное состояние недоступно.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>Use upgradeable mode when a thread usually accesses the resource that is protected by the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.</source>
          <target state="translated">Обновляемый режим следует применять при поток обычно получает доступ к ресурсу, который защищен службой <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> в режиме чтения, но может потребоваться войти в режим записи при соблюдении определенных условий.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</source>
          <target state="translated">Поток в обновляемом режиме можно обновить до режима записи или понизить до режима чтения.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>Only one thread can enter a lock in upgradeable mode at any given time.</source>
          <target state="translated">Только один поток может войти в блокировку в обновляемом режиме в любой момент времени.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</source>
          <target state="translated">Если поток находится в обновляемом режиме и нет потоков, ожидающих входа в режим записи, любое количество других потоков может войти в режим чтения, даже если нет потоков, ожидающих входа в обновляемый режим.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Если один или несколько потоков, ожидающих входа в режим записи, поток, вызывающий <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> метод блокируется, пока эти потоки либо истекло время ожидания или вошел в режим записи и не выйдут из него, или пока не истечет время ожидания вызывающего потока собственные.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Если блокировка допускает рекурсию, поток, который вошел в блокировку в обновляемом режиме можно ввести обновляемый режим рекурсивно, даже если другие потоки ожидают входа в режим записи.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> имеет значение <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, а текущий поток уже вошел в блокировку.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</source>
          <target state="translated">Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Глубина рекурсии превышает емкость счетчика.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, but it is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), which is the only negative value allowed.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> меньше нуля, но не равно <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), которое является единственным допустимым отрицательным значением.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> был удален.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The interval to wait, or -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Период ожидания или значение -1 миллисекунда для ожидания в течение неограниченного времени.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>Tries to enter the lock in upgradeable mode, with an optional time-out.</source>
          <target state="translated">Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered upgradeable mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если вызывающий поток вошел в обновляемый режим; в противном случае <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Если <ph id="ph1">`timeout`</ph> равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает <ph id="ph2">`false`</ph> немедленно в том случае, если нужное состояние недоступно.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>Use upgradeable mode when a thread usually accesses the resource protected by the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.</source>
          <target state="translated">Используйте обновляемый режим, когда поток обычно обращается к ресурсу, защищенному <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> в режиме чтения, но может потребоваться войти в режим записи при соблюдении определенных условий.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</source>
          <target state="translated">Поток в обновляемом режиме можно обновить до режима записи или понизить до режима чтения.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>Only one thread can enter a lock in upgradeable mode at any given time.</source>
          <target state="translated">Только один поток может войти в блокировку в обновляемом режиме в любой момент времени.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</source>
          <target state="translated">Если поток находится в обновляемом режиме и нет потоков, ожидающих входа в режим записи, любое количество других потоков может войти в режим чтения, даже если нет потоков, ожидающих входа в обновляемый режим.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Если один или несколько потоков, ожидающих входа в режим записи, поток, вызывающий <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> метод блокируется, пока эти потоки либо истекло время ожидания или вошел в режим записи и не выйдут из него, или пока не истечет время ожидания вызывающего потока собственные.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Если блокировка допускает рекурсию, поток, который вошел в блокировку в обновляемом режиме можно ввести обновляемый режим рекурсивно, даже если другие потоки ожидают входа в режим записи.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> имеет значение <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, а текущий поток уже вошел в блокировку.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</source>
          <target state="translated">Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Глубина рекурсии превышает емкость счетчика.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> отрицательное, но оно не равно -1 миллисекунде, которое является единственным допустимым отрицательным значением.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> больше <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> миллисекунд.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> был удален.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Tries to enter the lock in write mode, with an optional time-out.</source>
          <target state="translated">Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The number of milliseconds to wait, or -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) to wait indefinitely.</source>
          <target state="translated">Время ожидания в миллисекундах или -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) в случае неограниченного времени ожидания.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>Tries to enter the lock in write mode, with an optional time-out.</source>
          <target state="translated">Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered write mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если вызывающий поток вошел в режим записи, иначе — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Если <ph id="ph1">`millisecondsTimeout`</ph> равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает <ph id="ph2">`false`</ph> немедленно в том случае, если нужное состояние недоступно.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If other threads have entered the lock in read mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</source>
          <target state="translated">Если других потоков, вошедших в блокировку в режиме чтения, на поток, который вызывает <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> метод блокируется, пока эти потоки вышли из режима чтения, или пока не истечет время ожидания.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Хотя потоки заблокированы, ожидающих входа в режим записи, дополнительные потоки, пытающиеся войти в режим чтения или в обновляемый режим блокироваться, пока не всех потоков, ожидающих входа в режим записи, он либо истекло время ожидания или вошел в режим записи и выйдут из него.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме записи можно ввести режим записи рекурсивно, даже если другие потоки ожидают входа в режим записи.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> метод, чтобы войти в блокировку в режиме записи с тайм-аута. Метод, показанный в примере синхронизированного кэша добавляет новую пару ключ значение.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If the specified time-out interval elapses before the thread enters the lock, the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Если указанные временные интервалы истекают, прежде чем поток вошел в блокировку, метод возвращает <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The method returns <ph id="ph1">`true`</ph> if the key/value pair is added.</source>
          <target state="translated">Метод возвращает <ph id="ph1">`true`</ph> Если добавлена пара ключ значение.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If the key is already in the cache, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Если ключ уже имеется в кэше, исключение, вызванное внутреннего <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> допускается завершение метода.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> method, ensuring that the caller exits the lock.</source>
          <target state="translated">Объект <ph id="ph1">`finally`</ph> блок используется для выполнения <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> метод, гарантируя, что вызывающий объект выходит из блокировки.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> имеет значение <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, а текущий поток уже вошел в блокировку.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</source>
          <target state="translated">Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в режим записи создаст возможность взаимоблокировки.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Глубина рекурсии превышает емкость счетчика.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, but it is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), which is the only negative value allowed.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> меньше нуля, но не равно <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), которое является единственным допустимым отрицательным значением.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> был удален.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The interval to wait, or -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Период ожидания или значение -1 миллисекунда для ожидания в течение неограниченного времени.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>Tries to enter the lock in write mode, with an optional time-out.</source>
          <target state="translated">Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered write mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если вызывающий поток вошел в режим записи, иначе — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Если <ph id="ph1">`timeout`</ph> равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает <ph id="ph2">`false`</ph> немедленно в том случае, если нужное состояние недоступно.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>If other threads have entered the lock in read mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</source>
          <target state="translated">Если других потоков, вошедших в блокировку в режиме чтения, на поток, который вызывает <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> метод блокируется, пока эти потоки вышли из режима чтения, или пока не истечет время ожидания.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Хотя потоки заблокированы, ожидающих входа в режим записи, дополнительные потоки, пытающиеся войти в режим чтения или в обновляемый режим блокироваться, пока не всех потоков, ожидающих входа в режим записи, он либо истекло время ожидания или вошел в режим записи и выйдут из него.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме записи можно ввести режим записи рекурсивно, даже если другие потоки ожидают входа в режим записи.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> имеет значение <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, а текущий поток уже вошел в блокировку.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</source>
          <target state="translated">Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в режим записи создаст возможность взаимоблокировки.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Глубина рекурсии превышает емкость счетчика.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> отрицательное, но оно не равно -1 миллисекунде, которое является единственным допустимым отрицательным значением.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> больше <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> миллисекунд.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> был удален.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>Gets the total number of threads that are waiting to enter the lock in read mode.</source>
          <target state="translated">Получает общее количество потоков, ожидающих вхождения в блокировку в режиме чтения.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>The total number of threads that are waiting to enter read mode.</source>
          <target state="translated">Общее количество потоков, ожидающих вхождения в режим чтения.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Результаты можно изменить, как можно скорее после их вычисления.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Таким образом не является безопасным для принятия решений на основе этого свойства.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A&gt;</ph> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A&gt;</ph> свойства для создания записи в журнале событий, если число потоков, которые заблокированы, ожидающих вхождения в режим чтения превышает пороговое значение.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</source>
          <target state="translated">Получает общее количество потоков, ожидающих входа в блокировку в обновляемом режиме.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>The total number of threads that are waiting to enter upgradeable mode.</source>
          <target state="translated">Общее количество потоков, ожидающих входа в обновляемый режим.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Результаты можно изменить, как можно скорее после их вычисления.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Таким образом не является безопасным для принятия решений на основе этого свойства.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A&gt;</ph> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A&gt;</ph> свойства для создания записи в журнале событий, если число потоков, которые заблокированы, ожидающих входа в обновляемый режим, превышает пороговое значение.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>Gets the total number of threads that are waiting to enter the lock in write mode.</source>
          <target state="translated">Получает общее количество потоков, ожидающих входа в блокировку в режиме записи.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>The total number of threads that are waiting to enter write mode.</source>
          <target state="translated">Общее количество потоков, ожидающих входа в режим записи.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Результаты можно изменить, как можно скорее после их вычисления.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Таким образом не является безопасным для принятия решений на основе этого свойства.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A&gt;</ph> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A&gt;</ph> свойства для создания записи в журнале событий, если число потоков, которые заблокированы, ожидающих входа в режим записи превышает пороговое значение.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>