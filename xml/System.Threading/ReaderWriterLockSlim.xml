<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2ff770bb9446d6ebe71649784ebe115f60734cc0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531358" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет блокировку, используемую для управления доступом к ресурсу, которая позволяет нескольким потокам производить считывание или получать монопольный доступ на запись.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Threading.ReaderWriterLockSlim> для защиты ресурса, считываемых из нескольких потоков и записи по одному потоку за раз. <xref:System.Threading.ReaderWriterLockSlim> позволяет нескольким потокам находиться в режиме чтения, одному потоку в режиме записи с монопольного доступа блокировки и позволяет одному потоку, который имеет доступ на чтение в обновляемом режиме чтения, откуда поток может перейти в режим записи без необходимости отказываться от его s разрешение на чтение к ресурсу.  
  
> [!NOTE]
>  <xref:System.Threading.ReaderWriterLockSlim> действует так же, как и <xref:System.Threading.ReaderWriterLock>, но с более простыми правилами рекурсии и изменения состояния блокировки. <xref:System.Threading.ReaderWriterLockSlim> позволяет избежать многих ситуаций взаимоблокировки. Кроме того, производительность <xref:System.Threading.ReaderWriterLockSlim> значительно выше, чем у <xref:System.Threading.ReaderWriterLock>. Мы рекомендуем применять <xref:System.Threading.ReaderWriterLockSlim> при любых новых разработках.  
  
 По умолчанию новые экземпляры <xref:System.Threading.ReaderWriterLockSlim> создаются с <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> флаг и не допускает рекурсии. Эта политика по умолчанию рекомендуется для всех новых разработках, поскольку рекурсия приводит ненужные сложности и повышает вероятность возникновения взаимоблокировок в вашем коде. Чтобы упростить миграцию с существующие проекты, использующие <xref:System.Threading.Monitor> или <xref:System.Threading.ReaderWriterLock>, можно использовать <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> флаг для создания экземпляров <xref:System.Threading.ReaderWriterLockSlim> , которые позволяют рекурсии.  
  
 Поток может войти в блокировку в трех режимах: режим, режим записи и обновляемый режим чтения. (В остальной части этого раздела, «обновляемый режим чтения» называется «обновляемый режим» и фразу «введите `x` режим» используется вместо более длинной фразы «войти в блокировку в `x` режим».)  
  
 Независимо от политики рекурсии только один поток может находиться в режиме записи в любое время. Когда поток находится в режиме записи, ни один поток может войти в блокировку в любом режиме. Только один поток может находиться в обновляемом режиме, в любое время. Может быть любое количество потоков в режиме чтения, и может быть один поток в обновляемом режиме, пока другие потоки находятся в режиме чтения.  
  
> [!IMPORTANT]
>  Этот тип реализует <xref:System.IDisposable> интерфейса. После завершения с помощью типа следует освободить его прямо или косвенно. Для удаления типа непосредственно вызвать его <xref:System.IDisposable.Dispose%2A> метод в `try` / `catch` блока. Чтобы удалить ее косвенно, использовать языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <xref:System.IDisposable> разделе интерфейса.  
  
 <xref:System.Threading.ReaderWriterLockSlim> управляемого сходство потоков; то есть каждый <xref:System.Threading.Thread> объекта должны вызывать свой собственный метод войти и выйти из режима блокировки. Ни один поток может изменить режим другого потока.  
  
 Если <xref:System.Threading.ReaderWriterLockSlim> не допускает рекурсию, поток можно заблокировать, пытается войти в блокировку по следующим причинам:  
  
-   Поток, который пытается войти в режим чтения блокируется, если количество потоков, ожидающих входа в режим записи или, если один поток в режиме записи в.  
  
    > [!NOTE]
    >  Блокировка новых модулей чтения при записи помещаются в очередь — политика распределение ресурсов блокировок, дает преимущества потокам записи. Распределяет доступ для чтения и записи, для обеспечения оптимальной производительности в наиболее распространенных сценариев между текущей политики распределение ресурсов. Будущие версии [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] может вызвать новые политики распределение ресурсов.  
  
-   Поток, который пытается войти в обновляемый режим блокируется, если уже существует поток в обновляемом режиме, если количество потоков, ожидающих входа в режим записи, или если существует один поток в режиме записи.  
  
-   Поток, который пытается войти в режим записи блокируется, существует ли поток в любом из трех режимов.  
  
## <a name="upgrading-and-downgrading-locks"></a>Повышение и понижение уровня блокировки  
 Обновляемый режим предназначен для ситуаций, где обычно считывает поток из защищенного ресурса, но может потребоваться записать в него, если какое-либо условие. Поток, который <xref:System.Threading.ReaderWriterLockSlim> в обновляемом режиме имеет доступ на чтение к защищенному ресурсу и можно перейти в режим записи путем вызова <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> или <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> методы. Поскольку может существовать только один поток в обновляемом режиме одновременно, обновление до режима записи не может создать ситуацию взаимоблокировки при рекурсии не разрешено, при которой — политика по умолчанию.  
  
> [!IMPORTANT]
>  Независимо от политики рекурсии поток, первоначально введенное чтения режим не разрешен для обновления до обновляемого режима или режима записи, так как этот шаблон создает большую вероятность возникновения взаимоблокировок. Например если два потока в режиме чтения, которые попытаются войти в режим записи, они будут взаимоблокировка. Обновляемый режим предназначена для предотвращения такой взаимоблокировки.  
  
 Если имеются другие потоки в режиме чтения, поток, который повышает уровень блокировки. Пока поток заблокирован, блокируются другие потоки, которые пытаются войти в режим чтения. Если все потоки вышли из режима чтения, заблокированный обновляемый поток входит в режим записи. Если нет других потоков, ожидающих входа в режим записи, они остаются заблокированными, так как один поток, который находится в обновляемом режиме не дает им получить монопольный доступ к ресурсу.  
  
 Когда поток в обновляемом режиме выходит из режима записи, других потоков, ожидающих вхождения в режим чтения можно сделать, только при наличии потоков, ожидающих входа в режим записи. Поток в обновляемом режиме можно обновить и понизить неопределенно долгое время, поскольку он является единственным потоком, который записывает к защищенному ресурсу.  
  
> [!IMPORTANT]
>  Если разрешить несколько потоков ввести запись режиме или в обновляемом режиме, не должно допускать один поток монополизировать обновляемый режим. В противном случае потоки, которые пытаются войти записи режим напрямую, будут заблокированы бесконечно, а пока они блокируются, другие потоки не сможет войти в режим чтения.  
  
 Поток в обновляемом режиме можно понизить до режима чтения путем вызова метода <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> и затем вызвать метод <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> метод. Этот шаблон переход к более раннему допустим для всех политик рекурсии блокировки, даже <xref:System.Threading.LockRecursionPolicy.NoRecursion>.  
  
 После понижения до режима чтения потока невозможно повторно войти в обновляемом режиме, пока он выйдет из режима чтения.  
  
## <a name="entering-the-lock-recursively"></a>Рекурсивный вход в блокировку  
 Можно создать <xref:System.Threading.ReaderWriterLockSlim> с поддержкой рекурсивная запись блокировки с помощью <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> конструктор, который задает политику блокировки, а также указать <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Использование рекурсии для новых разработок не рекомендуется, поскольку он вводит ненужные сложности и повышает вероятность возникновения взаимоблокировок в вашем коде.  
  
 Для <xref:System.Threading.ReaderWriterLockSlim> , позволяющий рекурсии, о режимах, поток может войти можно назвать следующие:  
  
-   Поток в режиме чтения, может войти в режим чтения рекурсивно, но не может войти в режим записи или обновляемый режим. При попытке сделать это, <xref:System.Threading.LockRecursionException> возникает исключение. Ввод считывать режим и введя в режим записи или обновляемый режим — это шаблон, с большой вероятностью взаимоблокировок, поэтому он не разрешен. Как было сказано ранее, обновляемый режим предназначен для случаев, где это необходимо повысить уровень блокировки.  
  
-   Поток в обновляемом режиме можно указать режим записи или чтения и можно ввести любой из трех режимов рекурсивно. Однако попытка входа режим записи блокируется, если существуют другие потоки в режиме чтения.  
  
-   Поток в режиме записи можно ввести в режиме чтения и/или в обновляемый режим и можно ввести любой из трех режимов рекурсивно.  
  
-   Поток, который не входил в блокировку можно ввести любой режим. Эта попытка может заблокировать по тем же причинам, попытка войти в блокировку нерекурсивного.  
  
 Поток может выйти из режимов, которые он вошел в любом порядке, при условии, что он выходит из каждого режима ровно столько раз, сколько он вошел в этот режим. Если поток пытается выйти из режима слишком много раз или выйти из режима, не вошел, <xref:System.Threading.SynchronizationLockException> возникает исключение.  
  
## <a name="lock-states"></a>Состояния блокировки  
 Могут оказаться полезными представлять блокировки в терминах его состояний. Объект <xref:System.Threading.ReaderWriterLockSlim> может находиться в одном из четырех состояний: не указан, чтение, обновление и записи.  
  
-   Не введены: В этом состоянии нет потоков, вошедших в блокировку (или все потоки вышли из блокировки).  
  
-   Ознакомьтесь с разделом В этом состоянии один или несколько потоков вошедших в блокировку для доступа на чтение к защищенному ресурсу.  
  
    > [!NOTE]
    >  Поток может войти в блокировку в режиме чтения с помощью <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> или <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> методов, или при переходе из обновляемого режима.  
  
-   Обновление: В этом состоянии один поток вошел в блокировку для доступа на чтение с возможностью повышения уровня доступа на запись (то есть в обновляемом режиме), и нуль или более потоков, вошедших в блокировку для доступа на чтение. Не более одного потока в каждый момент может войти в блокировку с возможностью обновления; Дополнительные потоки, пытающиеся войти в обновляемый режим, блокируются.  
  
-   Записи: В этом состоянии один поток вошел в блокировку для доступа на запись к защищенному ресурсу. Этот поток, обладает монопольная блокировка. Другой поток, который пытается войти в блокировку по любой причине блокируется.  
  
 В следующей таблице описаны переходы между состояниями для блокировок, не допускающих рекурсии, когда поток `t` выполняет действие, приведенное в левом столбце. Во время он выполняет действие, `t` имеет без режима. (Особый случай где `t` в обновляемый режим описан в таблице сноски.) В верхней строке указано начальное состояние блокировки. Ячейки выполняются в поток и отображать изменения в состоянии блокировки в круглых скобках.  
  
||Нет входов (N)|Read (R)|Обновления (U)|Записи (W)|  
|-|-----------------------|----------------|-------------------|-----------------|  
|`t` входит в режим чтения|`t` вводит (R).|`t` блокируется, если потоки ожидают режим записи; в противном случае `t` вводит.|`t` блокируется, если потоки ожидают режим записи; в противном случае `t` вводит.<sup> 1</sup>|`t` блокирует вызывающий поток.|  
|`t` входит в обновляемый режим|`t` вводит (U).|`t` блокируется, если потоки ожидают режим записи или обновляемый режим; в противном случае `t` вводит (U).|`t` блокирует вызывающий поток.|`t` блокирует вызывающий поток.|  
|`t` входит в режим записи|`t` вводит (W).|`t` блокирует вызывающий поток.|`t` блокирует вызывающий поток. <sup>2</sup>|`t` блокирует вызывающий поток.|  
  
 <sup>1</sup> Если `t` запускает помещает в обновляемом режиме, он входит в режим чтения. Это действие никогда не блокируется. Состояние блокировки не изменяется. (Поток может завершить понижение уровня блокировки для режима чтения, выполнив выход из обновляемого режима.)  
  
 <sup>2</sup> Если `t` запускается в обновляемом режиме, он блокируется, если существуют потоки в режиме чтения. В противном случае он обновляет режим записи. Изменения состояния блокировки записи (W). Если `t` блокируется из-за потоков в режиме чтения, он входит в режим записи, как только последний поток выходит из режима чтения, даже при наличии потоков, ожидающих входа в режим записи.  
  
 Когда происходит изменение состояния, так как поток завершает работу блокировку, следующий поток активируемый выбран следующим образом:  
  
-   Во-первых поток, который ожидает режим записи и уже находится в обновляемом режиме (может существовать не более одного потока).  
  
-   Сбой, поток, который ожидает режим записи.  
  
-   Сбой, поток, который ожидает в обновляемом режиме.  
  
-   Произошел сбой, всех потоков, ожидающих в режиме чтения.  
  
 Состояние блокировки всегда находится запись (W) в первых двух случаях и обновления (U) в третьем, независимо от состояния блокировки, при выходе из нее потока, вызвавшего изменение состояния. В последнем случае состояние блокировки — обновления (U) при наличии поток в обновляемом режиме после изменения состояния и Read (R) в противном случае, независимо от предыдущего состояния.  
  
   
  
## Examples  
 В следующем примере показано простого синхронизированного кэша, содержащего строки с целочисленных ключей. Экземпляр <xref:System.Threading.ReaderWriterLockSlim> используется для синхронизации доступа к <xref:System.Collections.Generic.Dictionary%602> , служит в качестве внутреннего кэша.  
  
 Пример содержит простые методы для добавления в кэш, удаления из кэша и считано из кэша. Чтобы продемонстрировать истечение времени ожидания, в примере содержит метод, который добавляет в кэш только в том случае, если это можно сделать в течение заданного времени ожидания.  
  
 Чтобы продемонстрировать обновляемый режим, в примере включает метод, который возвращает значение, связанное с ключом и сравнивает его с новым значением. Если значение остается неизменным, метод возвращает состояние, указывающее без изменений. Оно не найдено значение для ключа, вставляется пара ключ значение. Если значение изменилось, она обновляется. Обновляемый режим позволяет потоку для обновления от чтения доступа на запись без риска возникновения взаимоблокировок.  
  
 Пример включает вложенное перечисление, определяющее возвращаемые значения для метода, который демонстрирует обновляемом режиме.  
  
 В примере используется конструктор по умолчанию для создания блокировки, поэтому рекурсия не допускается. Программирование <xref:System.Threading.ReaderWriterLockSlim> стало проще и менее подвержены возникновению ошибок, когда блокировка не допускает рекурсии.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 В следующем коде используется затем `SynchronizedCache` объект для сохранения словаря овощной имен. Он создает три задачи. Первый записывает имена овощей, хранящихся в массиве для `SynchronizedCache` экземпляра. Второй и третий задачи для отображения имен овощей первым в порядке возрастания (низкий индекс высокого уровня), второй в порядке убывания. Последняя задача осуществляет поиск строки «cucumber» и при обнаружении, вызывает <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> метод для замены строки «быть зеленый», с ягодами.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLockSlim" /> значениями свойств по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Threading.ReaderWriterLockSlim> , инициализируемый это конструктор, не допускающих рекурсии. То есть свойство <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> возвращает значение <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.  
  
 Дополнительные сведения о политике рекурсии и его влияние см. в разделе <xref:System.Threading.LockRecursionPolicy> перечисления и <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
   
  
## Examples  
 В следующем примере показано простого синхронизированного кэша, содержащего строки с целочисленных ключей. Экземпляр <xref:System.Threading.ReaderWriterLockSlim> используется для синхронизации доступа к <xref:System.Collections.Generic.Dictionary%602> , служит в качестве внутреннего кэша. Для создания блокировки используется конструктор без параметров.  
  
 Пример содержит простые методы для добавления в кэш, удаления из кэша и считано из кэша. Чтобы продемонстрировать истечение времени ожидания, в примере содержит метод, который добавляет в кэш только в том случае, если это можно сделать в течение заданного времени ожидания.  
  
 Чтобы продемонстрировать обновляемый режим, в примере включает метод, который возвращает значение, связанное с ключом и сравнивает его с новым значением. Если значение остается неизменным, метод возвращает состояние, указывающее без изменений. Оно не найдено значение для ключа, вставляется пара ключ значение. Если значение изменилось, она обновляется. Обновляемый режим позволяет потоку для обновления от чтения доступа на запись без риска возникновения взаимоблокировок.  
  
 Пример включает вложенное перечисление, определяющее возвращаемые значения для метода, который демонстрирует обновляемом режиме.  
  
 В примере используется конструктор по умолчанию для создания блокировки, поэтому рекурсия не допускается. Программирование <xref:System.Threading.ReaderWriterLockSlim> стало проще и менее подвержены возникновению ошибок, когда блокировка не допускает рекурсии.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 В следующем коде используется затем `SynchronizedCache` объект для сохранения словаря овощной имен. Он создает три задачи. Первый записывает имена овощей, хранящихся в массиве для `SynchronizedCache` экземпляра. Второй и третий задачи для отображения имен овощей первым в порядке возрастания (низкий индекс высокого уровня), второй в порядке убывания. Последняя задача осуществляет поиск строки «cucumber» и при обнаружении, вызывает <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> метод для замены строки «быть зеленый», с ягодами.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">Одно из значений перечисления, определяющее политику рекурсии блокировки.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLockSlim" /> с указанием политики рекурсии блокировок.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Политика рекурсии определяет ограничения для потоков, войти в блокировку более одного раза. Например, если блокировка была создана с <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> и поток вошел в блокировку в режиме чтения <xref:System.Threading.LockRecursionException> создается, если поток пытается повторно вводить в блокировку в режиме чтения. Аналогично, если поток вошел в блокировку в режиме записи <xref:System.Threading.LockRecursionException> создается, если поток пытается повторно вводить в блокировку в любом режиме.  
  
> [!NOTE]
>  Поток в обновляемом режиме можно обновить до режима записи или понизить до режима независимо от настроек политики рекурсии блокировки чтения.  
  
 Независимо от политики рекурсии поток, первоначально введенное чтения режим не разрешен для обновления до обновляемого режима или режима записи, так как этот шаблон создает большую вероятность возникновения взаимоблокировок.  
  
 Дополнительные сведения о политике рекурсии и его влияние см. в разделе <xref:System.Threading.LockRecursionPolicy> перечисления и <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
   
  
## Examples  
 В следующем примере показано два сценария исключения, который зависит от <xref:System.Threading.LockRecursionPolicy> параметр, а другой — нет.  
  
 В первом сценарии поток входит в режим чтения, а затем пытается войти в режим чтения рекурсивно. Если <xref:System.Threading.ReaderWriterLockSlim> создается с помощью конструктора по умолчанию, который задает политику рекурсии <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, создается исключение. Если <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> используется для создания <xref:System.Threading.ReaderWriterLockSlim>, исключение не возникает.  
  
 Во втором сценарии поток входит в режим чтения и затем режим записи попыток ввода. <xref:System.Threading.LockRecursionException> создается независимо от политики рекурсии блокировок.  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 В следующем коде используется затем `SynchronizedCache` объект для сохранения словаря овощной имен. Он создает три задачи. Первый записывает имена овощей, хранящихся в массиве для `SynchronizedCache` экземпляра. Второй и третий задачи для отображения имен овощей первым в порядке возрастания (низкий индекс высокого уровня), второй в порядке убывания. Последняя задача осуществляет поиск строки «cucumber» и при обнаружении, вызывает <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> метод для замены строки «быть зеленый», с ягодами.  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает общее количество уникальных потоков, вошедших в блокировку в режиме чтения.</summary>
        <value>Количество уникальных потоков, вошедших в блокировку в режиме чтения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток учитывается только один раз, даже если блокировка допускает рекурсию и поток входил в режим чтения несколько раз.  
  
 Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма. Результаты можно изменить, как можно скорее после их вычисления. Таким образом не является безопасным для принятия решений на основе этого свойства.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> свойства для создания записи в журнале событий, если количество потоков в режиме чтения превышает пороговое значение.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> по окончании использования класса <xref:System.Threading.ReaderWriterLockSlim>. Метод <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> оставляет класс <xref:System.Threading.ReaderWriterLockSlim> в непригодном для использования состоянии. После вызова метода <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, необходимо освободить все ссылки на <xref:System.Threading.ReaderWriterLockSlim> , сборщик мусора мог освободить память, <xref:System.Threading.ReaderWriterLockSlim> занимаемую. Дополнительные сведения см. в разделе [очистки неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [метода](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Всегда вызывайте метод <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> перед освобождением последней ссылки на <xref:System.Threading.ReaderWriterLockSlim> объекта.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          Значение параметра <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> больше нуля.  
  
 - или -  
  
 Значение параметра <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> больше нуля.  
  
 - или -  
  
 Значение параметра <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> больше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пытается выполнить вход в блокировку в режиме чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до вызывающий поток вошел в блокировку, а следовательно, может никогда не возвращают. Используйте <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> метод на указанный промежуток времени, и возвращается, если вызывающий поток не вошел в режим чтения во время этого интервала.  
  
 Несколько потоков могут войти в режим чтения в то же время.  
  
 Если один или несколько потоков, ожидающих входа в режим записи, поток, вызывающий <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> метод блокируется до этих потоков истекло время ожидания или вошел в режим записи и выйдут из него.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме чтения можно войти в режим чтения рекурсивно, даже если другие потоки ожидают входа в режим записи.  
  
 Максимум один поток может находиться в обновляемом режиме, когда другие потоки находятся в режиме чтения. Если нет потоков, ожидающих входа в режим записи дополнительных потоков, ожидающих входа в обновляемый режим, потоки, вызывающих метод <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> метод сразу же войти в режим чтения и не блокируются.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> метод, чтобы войти в блокировку в режиме чтения. Метод, показанный в примере возвращает значение, связанное с ключом. Если ключ не найден, исключение, вызванное внутреннего <xref:System.Collections.Generic.Dictionary%602> допускается завершение метода. Объект `finally` блок используется для выполнения <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> метод, гарантируя, что вызывающий объект выходит из режима чтения.  
  
 Данный пример кода является частью большего примера, приведенного для <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Текущему потоку не удается получить блокировку записи, когда он удерживает блокировку чтения.  
  
 - или -  
  
 Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, и текущий поток попытался получить блокировку чтения, когда уже удерживает эту блокировку чтения.  
  
 - или -  
  
 Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, и текущий поток попытался получить блокировку записи, когда уже удерживает эту блокировку записи.  
  
 - или -  
  
 Глубина рекурсии превышает емкость счетчика. Данное ограничение настолько велико, что приложения никогда не должны столкнуться с этим исключением.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пытается выполнить вход в блокировку в обновляемом режиме.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до вызывающий поток вошел в блокировку, а следовательно, может никогда не возвращают. Используйте <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> метод на указанный промежуток времени, и возвращается, если вызывающий поток имеет не вошел в обновляемый режим во время этого интервала.  
  
 Обновляемый режим следует применять при поток обычно получает доступ к ресурсу, который защищен службой <xref:System.Threading.ReaderWriterLockSlim> в режиме чтения, но может потребоваться войти в режим записи при соблюдении определенных условий. Поток в обновляемом режиме можно перейти в режим чтения или перейти в режим записи.  
  
 В любой момент времени только один поток может войти в обновляемый режим. Если поток находится в обновляемом режиме и нет потоков, ожидающих входа в режим записи, любое количество других потоков может войти в режим чтения, даже если нет потоков, ожидающих входа в обновляемый режим.  
  
 Если один или несколько потоков, ожидающих входа в режим записи, поток, вызывающий <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> метод блокируется до этих потоков истекло время ожидания или вошел в режим записи и выйдут из него.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в обновляемом режиме можно ввести обновляемый режим рекурсивно, даже если другие потоки ожидают входа в режим записи.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> метод, чтобы войти в блокировку в обновляемом режиме. Объект `finally` блок используется для выполнения <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> метод, гарантируя, что вызывающий объект выходит из обновляемого режима.  
  
 Метод, показанный в примере возвращает значение, связанное с ключом и сравнивает его с новым значением. Если значение остается неизменным, метод возвращает состояние, указывающее без изменений. Оно не найдено значение для ключа, вставляется пара ключ значение. Если значение изменилось, она обновляется. Обновляемый режим позволяет потоку блокировки чтения без риска возникновения взаимоблокировок.  
  
 В примере используется конструктор по умолчанию для создания блокировки, поэтому рекурсия не допускается. Программирование <xref:System.Threading.ReaderWriterLockSlim> стало проще и менее подвержены возникновению ошибок, когда блокировка не допускает рекурсии.  
  
 Данный пример кода является частью большего примера, приведенного для <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку в любом из режимов.  
  
 - или -  
  
 Текущий поток вошел в режим чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.  
  
 - или -  
  
 Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пытается выполнить вход в блокировку в режиме записи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до вызывающий поток вошел в блокировку, а следовательно, может никогда не возвращают. Используйте <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> метод на указанный промежуток времени, и возвращается, если вызывающий поток не вошел режим записи во время этого интервала.  
  
 Если других потоков, вошедших в блокировку в режиме чтения, на поток, который вызывает <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> метод блокируется до эти потоки вышли из режима чтения. При наличии потоков, ожидающих входа в режим записи, дополнительные потоки, пытающиеся войти режим чтения или обновляемый режим, блокируются, пока у всех потоков, ожидающих входа в режим записи, либо истекло время ожидания или вошел в режим записи и выйдут из него.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме записи можно ввести режим записи рекурсивно, даже если другие потоки ожидают входа в режим записи.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> метод, чтобы войти в блокировку в режиме записи. Метод, показанный в примере синхронизированного кэша добавляет новую пару ключ значение. Если ключ уже имеется в кэше, исключение, вызванное внутреннего <xref:System.Collections.Generic.Dictionary%602> допускается завершение метода. Объект `finally` блок используется для выполнения <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> метод, гарантируя, что вызывающий объект выходит из режима записи.  
  
 Данный пример кода является частью большего примера, приведенного для <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку в любом из режимов.  
  
 - или -  
  
 Текущий поток вошел в режим чтения, поэтому попытка войти в блокировку в обновляемом режиме создаст риск взаимоблокировки.  
  
 - или -  
  
 Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Уменьшает счетчик глубины рекурсии для режима чтения и выходит из режима чтения, если счетчик принял значение 0 (нуль).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не чувствителен к порядку рекурсии. Например если поток вошел в блокировку в обновляемом режиме, а затем вошел в блокировку в режиме чтения, порядок, в котором поток выходит из двух режимов не имеет значения. Если блокировка допускает рекурсию, поток может войти в блокировку в режиме записи и затем войти в нее рекурсивно в режиме чтения. порядок, в котором поток выходит из режима чтения и записи режим не имеет значения.  
  
 Выход из блокировки может сигнализировать другим ожидающим потокам.  
  
   
  
## Examples  
 В следующем примере показано, как использовать `finally` к выполнению блока <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> метод, гарантируя, что вызывающий объект выходит из режима чтения. Метод, показанный в примере возвращает значение, связанное с ключом. Если ключ не найден, исключение, вызванное внутреннего <xref:System.Collections.Generic.Dictionary%602> допускается завершение метода. <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> Метод позволяет войти в режим чтения.  
  
 Данный пример кода является частью большего примера, приведенного для <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Текущий поток не вошел в блокировку в режиме чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Уменьшает счетчик глубины рекурсии для обновляемого режима и выходит из обновляемого режима, если счетчик принял значение 0 (нуль).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не чувствителен к порядку рекурсии. Например если поток вошел в блокировку в обновляемом режиме, а затем вошел в блокировку в режиме записи, порядок, в котором поток выходит из двух режимов не имеет значения. Если блокировка допускает рекурсию, поток может войти в блокировку в режиме записи и затем войти в нее рекурсивно в обновляемом режиме. порядок, в котором поток выходит из обновляемого режима и режима записи не имеет значения.  
  
 Выход из блокировки может сигнализировать другим ожидающим потокам.  
  
   
  
## Examples  
 В следующем примере показано, как использовать `finally` к выполнению блока <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> метод, гарантируя, что вызывающий объект выходит из обновляемого режима.  
  
 Метод, показанный в примере возвращает значение, связанное с ключом и сравнивает его с новым значением. Если значение остается неизменным, метод возвращает состояние, указывающее без изменений. Оно не найдено значение для ключа, вставляется пара ключ значение. Если значение изменилось, она обновляется. Обновляемый режим позволяет потоку блокировки чтения без риска возникновения взаимоблокировок.  
  
 В примере используется конструктор по умолчанию для создания блокировки, поэтому рекурсия не допускается. Программирование <xref:System.Threading.ReaderWriterLockSlim> стало проще и менее подвержены возникновению ошибок, когда блокировка не допускает рекурсии.  
  
 Данный пример кода является частью большего примера, приведенного для <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Текущий поток не вошел в блокировку в обновляемом режиме.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Уменьшает счетчик глубины рекурсии для режима записи и выходит из режима записи, если счетчик принял значение 0 (нуль).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не чувствителен к порядку рекурсии. Например если поток вошел в блокировку в обновляемом режиме, а затем вошел в блокировку в режиме записи, порядок, в котором поток выходит из двух режимов не имеет значения. Если блокировка допускает рекурсию, поток может войти в блокировку в режиме записи и затем войти в нее рекурсивно в режиме чтения. порядок, в котором поток выходит из режима чтения и записи режим не имеет значения.  
  
 Выход из блокировки может сигнализировать другим ожидающим потокам.  
  
   
  
## Examples  
 В следующем примере показано, как использовать `finally` к выполнению блока <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> метод, гарантируя, что вызывающий объект выходит из режима записи. Метод, показанный в примере синхронизированного кэша добавляет новую пару ключ значение. Если ключ уже имеется в кэше, исключение, вызванное внутреннего <xref:System.Collections.Generic.Dictionary%602> допускается завершение метода. <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> Метод используется для входа в блокировку в режиме записи.  
  
 Данный пример кода является частью большего примера, приведенного для <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Текущий поток не вошел в блокировку в режиме записи.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, вошел ли текущий поток в блокировку в режиме чтения.</summary>
        <value>
          Значение <see langword="true" />, если текущий поток вошел в режим чтения; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предназначено для использования в подтверждениях или для других целей отладки. Не используйте его для управления потоком выполнения программы.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> свойства для создания утверждения, если текущий поток вошел в режим чтения неожиданно.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, вошел ли текущий поток в блокировку в обновляемом режиме.</summary>
        <value>
          Значение <see langword="true" />, если текущий поток вошел в обновляемый режим, противном случае – <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предназначено для использования в подтверждениях или для других целей отладки. Не используйте его для управления потоком выполнения программы.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> свойства для создания утверждения, если текущий поток вошел в обновляемый режим неожиданно.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, вошел ли текущий поток в блокировку в режиме записи.</summary>
        <value>
          Значение <see langword="true" />, если текущий поток вошел в режим записи; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предназначено для использования в подтверждениях или для других целей отладки. Не используйте его для управления потоком выполнения программы.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> свойства для создания утверждения, если текущий поток вошел в режим записи неожиданно.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее политику рекурсии для текущего объекта <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
        <value>Одно из значений перечисления, определяющее политику рекурсии блокировки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Политика рекурсии определяет ограничения для потоков, войти в блокировку более одного раза. Например, если блокировка была создана с <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> и поток вошел в блокировку в режиме чтения <xref:System.Threading.LockRecursionException> создается, если поток пытается повторно вводить в блокировку в режиме чтения.  
  
> [!NOTE]
>  Поток в обновляемом режиме можно обновить до режима записи или понизить до режима независимо от настроек политики рекурсии блокировки чтения.  
  
 Независимо от политики рекурсии поток, первоначально введенное чтения режим не разрешен для обновления до обновляемого режима или режима записи, так как этот шаблон создает большую вероятность возникновения взаимоблокировок.  
  
 Дополнительные сведения о политике рекурсии и его влияние см. в разделе <xref:System.Threading.LockRecursionPolicy> перечисления и <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает количество раз, которые текущий поток входил в блокировку в режиме чтения, как показатель рекурсии.</summary>
        <value>0 (нуль), если текущий поток не вошел в режим чтения, 1, если поток вошел в режим чтения, но не рекурсивно, или *n* Если поток вошел в блокировку рекурсивно *n* - 1 раз.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма. Результаты можно изменить, как можно скорее после их вычисления. Таким образом не является безопасным для принятия решений на основе этого свойства.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает количество раз, которые текущий поток входил в блокировку в обновляемом режиме, как показатель рекурсии.</summary>
        <value>0, если текущий поток не вошел в обновляемый режим, 1, если поток вошел в обновляемый режим, но не вошел в него рекурсивно, или *n* Если поток вошел в обновляемый режим рекурсивно *n* - 1 раз.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма. Результаты можно изменить, как можно скорее после их вычисления. Таким образом не является безопасным для принятия решений на основе этого свойства.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает количество раз, которые текущий поток входил в блокировку в режиме записи, как показатель рекурсии.</summary>
        <value>0, если текущий поток не вошел в режим записи, 1, если поток вошел в режим записи, но не рекурсивно, или *n* Если поток вошел в режим записи рекурсивно *n* - 1 раз.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма. Результаты можно изменить, как можно скорее после их вычисления. Таким образом не является безопасным для принятия решений на основе этого свойства.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или -1 (<see cref="F:System.Threading.Timeout.Infinite" />) в случае неограниченного времени ожидания.</param>
        <summary>Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания целым числом.</summary>
        <returns>
          Значение <see langword="true" />, если вызывающий поток вошел в режим чтения; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает `false` немедленно в том случае, если нужное состояние недоступно.  
  
 Несколько потоков могут войти в режим чтения в то же время.  
  
 Если один или несколько потоков, ожидающих входа в режим записи, поток, вызывающий <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> метод блокируется, пока эти потоки либо истекло время ожидания или вошел в режим записи и не выйдут из него, или пока не истечет время ожидания вызывающего потока собственные.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме чтения можно войти в режим чтения рекурсивно, даже если другие потоки ожидают входа в режим записи.  
  
 Один поток может находиться в обновляемом режиме, когда другие потоки находятся в режиме чтения. Если нет потоков, ожидающих входа в режим записи дополнительных потоков, ожидающих входа в обновляемый режим, потоки, вызывающих метод <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> метод сразу же войти в режим чтения и не блокируются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  
  
 - или -  
  
 Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> меньше нуля, но не равно <see cref="F:System.Threading.Timeout.Infinite" /> (-1), которое является единственным допустимым отрицательным значением.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период ожидания или значение -1 миллисекунда для ожидания в течение неограниченного времени.</param>
        <summary>Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания.</summary>
        <returns>
          Значение <see langword="true" />, если вызывающий поток вошел в режим чтения; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает `false` немедленно в том случае, если нужное состояние недоступно.  
  
 Несколько потоков может войти в блокировку в режиме чтения, в то же время.  
  
 Если один или несколько потоков помещаются в очередь в режим записи, поток, вызывающий <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> метод блокируется, пока эти потоки либо истекло время ожидания или вошел в режим записи и не выйдут из него, или пока не истечет время ожидания вызывающего потока собственные.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме чтения можно войти в режим чтения рекурсивно, даже если другие потоки ожидают входа в режим записи.  
  
 Один поток может находиться в обновляемом режиме, когда другие потоки находятся в режиме чтения. Если нет потоков, ожидающих входа в режим записи дополнительных потоков, ожидающих входа в обновляемый режим, потоки, вызывающих метод <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> метод сразу же войти в режим чтения и не блокируются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  
  
 - или -  
  
 Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> отрицательное, но оно не равно -1 миллисекунде, которое является единственным допустимым отрицательным значением.  
  
 - или -  
  
 Значение <paramref name="timeout" /> больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или -1 (<see cref="F:System.Threading.Timeout.Infinite" />) в случае неограниченного времени ожидания.</param>
        <summary>Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</summary>
        <returns>
          Значение <see langword="true" />, если вызывающий поток вошел в обновляемый режим; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает `false` немедленно в том случае, если нужное состояние недоступно.  
  
 Обновляемый режим следует применять при поток обычно получает доступ к ресурсу, который защищен службой <xref:System.Threading.ReaderWriterLockSlim> в режиме чтения, но может потребоваться войти в режим записи при соблюдении определенных условий. Поток в обновляемом режиме можно обновить до режима записи или понизить до режима чтения.  
  
 Только один поток может войти в блокировку в обновляемом режиме в любой момент времени. Если поток находится в обновляемом режиме и нет потоков, ожидающих входа в режим записи, любое количество других потоков может войти в режим чтения, даже если нет потоков, ожидающих входа в обновляемый режим.  
  
 Если один или несколько потоков, ожидающих входа в режим записи, поток, вызывающий <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> метод блокируется, пока эти потоки либо истекло время ожидания или вошел в режим записи и не выйдут из него, или пока не истечет время ожидания вызывающего потока собственные.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в обновляемом режиме можно ввести обновляемый режим рекурсивно, даже если другие потоки ожидают входа в режим записи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  
  
 - или -  
  
 Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.  
  
 - или -  
  
 Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> меньше нуля, но не равно <see cref="F:System.Threading.Timeout.Infinite" /> (-1), которое является единственным допустимым отрицательным значением.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период ожидания или значение -1 миллисекунда для ожидания в течение неограниченного времени.</param>
        <summary>Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</summary>
        <returns>
          Значение <see langword="true" />, если вызывающий поток вошел в обновляемый режим; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает `false` немедленно в том случае, если нужное состояние недоступно.  
  
 Используйте обновляемый режим, когда поток обычно обращается к ресурсу, защищенному <xref:System.Threading.ReaderWriterLockSlim> в режиме чтения, но может потребоваться войти в режим записи при соблюдении определенных условий. Поток в обновляемом режиме можно обновить до режима записи или понизить до режима чтения.  
  
 Только один поток может войти в блокировку в обновляемом режиме в любой момент времени. Если поток находится в обновляемом режиме и нет потоков, ожидающих входа в режим записи, любое количество других потоков может войти в режим чтения, даже если нет потоков, ожидающих входа в обновляемый режим.  
  
 Если один или несколько потоков, ожидающих входа в режим записи, поток, вызывающий <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> метод блокируется, пока эти потоки либо истекло время ожидания или вошел в режим записи и не выйдут из него, или пока не истечет время ожидания вызывающего потока собственные.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в обновляемом режиме можно ввести обновляемый режим рекурсивно, даже если другие потоки ожидают входа в режим записи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  
  
 - или -  
  
 Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.  
  
 - или -  
  
 Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> отрицательное, но оно не равно -1 миллисекунде, которое является единственным допустимым отрицательным значением.  
  
 - или -  
  
 Значение <paramref name="timeout" /> больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или -1 (<see cref="F:System.Threading.Timeout.Infinite" />) в случае неограниченного времени ожидания.</param>
        <summary>Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</summary>
        <returns>
          Значение <see langword="true" />, если вызывающий поток вошел в режим записи, иначе — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает `false` немедленно в том случае, если нужное состояние недоступно.  
  
 Если других потоков, вошедших в блокировку в режиме чтения, на поток, который вызывает <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> метод блокируется, пока эти потоки вышли из режима чтения, или пока не истечет время ожидания. Хотя потоки заблокированы, ожидающих входа в режим записи, дополнительные потоки, пытающиеся войти в режим чтения или в обновляемый режим блокироваться, пока не всех потоков, ожидающих входа в режим записи, он либо истекло время ожидания или вошел в режим записи и выйдут из него.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме записи можно ввести режим записи рекурсивно, даже если другие потоки ожидают входа в режим записи.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> метод, чтобы войти в блокировку в режиме записи с тайм-аута. Метод, показанный в примере синхронизированного кэша добавляет новую пару ключ значение. Если указанные временные интервалы истекают, прежде чем поток вошел в блокировку, метод возвращает `false`. Метод возвращает `true` Если добавлена пара ключ значение.  
  
 Если ключ уже имеется в кэше, исключение, вызванное внутреннего <xref:System.Collections.Generic.Dictionary%602> допускается завершение метода. Объект `finally` блок используется для выполнения <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> метод, гарантируя, что вызывающий объект выходит из блокировки.  
  
 Данный пример кода является частью большего примера, приведенного для <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  
  
 - или -  
  
 Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в режим записи создаст возможность взаимоблокировки.  
  
 - или -  
  
 Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> меньше нуля, но не равно <see cref="F:System.Threading.Timeout.Infinite" /> (-1), которое является единственным допустимым отрицательным значением.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период ожидания или значение -1 миллисекунда для ожидания в течение неограниченного времени.</param>
        <summary>Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</summary>
        <returns>
          Значение <see langword="true" />, если вызывающий поток вошел в режим записи, иначе — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает `false` немедленно в том случае, если нужное состояние недоступно.  
  
 Если других потоков, вошедших в блокировку в режиме чтения, на поток, который вызывает <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> метод блокируется, пока эти потоки вышли из режима чтения, или пока не истечет время ожидания. Хотя потоки заблокированы, ожидающих входа в режим записи, дополнительные потоки, пытающиеся войти в режим чтения или в обновляемый режим блокироваться, пока не всех потоков, ожидающих входа в режим записи, он либо истекло время ожидания или вошел в режим записи и выйдут из него.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме записи можно ввести режим записи рекурсивно, даже если другие потоки ожидают входа в режим записи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  
  
 - или -  
  
 Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в режим записи создаст возможность взаимоблокировки.  
  
 - или -  
  
 Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> отрицательное, но оно не равно -1 миллисекунде, которое является единственным допустимым отрицательным значением.  
  
 - или -  
  
 Значение <paramref name="timeout" /> больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает общее количество потоков, ожидающих вхождения в блокировку в режиме чтения.</summary>
        <value>Общее количество потоков, ожидающих вхождения в режим чтения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма. Результаты можно изменить, как можно скорее после их вычисления. Таким образом не является безопасным для принятия решений на основе этого свойства.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> свойства для создания записи в журнале событий, если число потоков, которые заблокированы, ожидающих вхождения в режим чтения превышает пороговое значение.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает общее количество потоков, ожидающих входа в блокировку в обновляемом режиме.</summary>
        <value>Общее количество потоков, ожидающих входа в обновляемый режим.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма. Результаты можно изменить, как можно скорее после их вычисления. Таким образом не является безопасным для принятия решений на основе этого свойства.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> свойства для создания записи в журнале событий, если число потоков, которые заблокированы, ожидающих входа в обновляемый режим, превышает пороговое значение.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает общее количество потоков, ожидающих входа в блокировку в режиме записи.</summary>
        <value>Общее количество потоков, ожидающих входа в режим записи.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма. Результаты можно изменить, как можно скорее после их вычисления. Таким образом не является безопасным для принятия решений на основе этого свойства.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> свойства для создания записи в журнале событий, если число потоков, которые заблокированы, ожидающих входа в режим записи превышает пороговое значение.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>