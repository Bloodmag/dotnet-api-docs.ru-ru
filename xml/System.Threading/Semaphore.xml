<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="312a73b1d0f299dfb59a7dcba73d3cf9dbc2bb2c" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609200" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Limits the number of threads that can access a resource or pool of resources concurrently.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Threading.Semaphore> класс для управления доступом к пулу ресурсов. Потоков в семафор посредством вызова <xref:System.Threading.WaitHandle.WaitOne%2A> метод, который наследуется от <xref:System.Threading.WaitHandle> класса и освобождают семафор посредством вызова <xref:System.Threading.Semaphore.Release%2A> метод.  
  
 Счетчик на семафоре уменьшается на единицу каждый раз поток входит в семафор и значение счетчика увеличивается, когда поток выходит из семафора. Если счетчик равен нулю, последующие запросы блокируются, пока другие потоки освобождают семафор. При всех потоков выпустили семафора, счетчик максимальное значение указывается при создании семафора.  
  
 Нет гарантированного порядка, например FIFO, LIFO, в котором заблокированных потоков в семафор.  
  
 Поток может войти в семафор несколько раз, путем вызова <xref:System.Threading.WaitHandle.WaitOne%2A> метод несколько раз. Чтобы освободить некоторые или все эти записи, можно вызвать без параметров потока <xref:System.Threading.Semaphore.Release> несколько раз, или его можно вызвать перегрузку метода <xref:System.Threading.Semaphore.Release%28System.Int32%29> перегрузку метода, которая указывает количество освобождаемых записей.  
  
 <xref:System.Threading.Semaphore> Класс не обеспечивают идентификацию потоков при вызовах метода <xref:System.Threading.WaitHandle.WaitOne%2A> или <xref:System.Threading.Semaphore.Release%2A>. Это программист должен убедиться, что потоки не освобождают семафор слишком много раз. Например предположим, что семафор имеет максимальное значение счетчика равное двум, а два потока A и B входят в семафор. Если ошибка программирования в потоке B заставляет его вызывать метод <xref:System.Threading.Semaphore.Release%2A> дважды, оба вызова оканчиваются успешно. Счетчик на семафоре переполнен, и если поток A вызывает <xref:System.Threading.Semaphore.Release%2A>, <xref:System.Threading.SemaphoreFullException> создается исключение.  
  
 Семафоры бывают двух типов: локальные семафоры и именованных системных семафоров. Если вы создаете <xref:System.Threading.Semaphore> с помощью конструктора, который принимает имя, она будет связана с данное имя семафором операционной системы. Именованных системных семафоров доступны во всей операционной системы и может использоваться для синхронизации действий процессов. Вы можете создать несколько <xref:System.Threading.Semaphore> объекты, представляющие же именованный семафор, и можно использовать <xref:System.Threading.Semaphore.OpenExisting%2A> метод, чтобы открыть существующий именованный семафор.  
  
 Локальный семафор существует только внутри процесса. Его может использовать любой поток в вашем процессе, имеющий ссылку на локальный объект <xref:System.Threading.Semaphore>. Каждый <xref:System.Threading.Semaphore> объект — это отдельный локальный семафор.  
  
   
  
## Examples  
 В следующем примере кода создается семафор с максимум из трех и начальное число ноль. В примере запускается пять потоков, которые блокируют ожидание семафора. Основной поток использует <xref:System.Threading.Semaphore.Release%28System.Int32%29> перегруженный метод, чтобы увеличить счетчик семафора максимальное значение ограничения, позволяя трех потоков в семафор. Каждый поток использует <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод для ожидания в течение одной секунды для имитации работы, а затем вызывает <xref:System.Threading.Semaphore.Release> перегруженный метод, чтобы освободить семафор. Каждый раз, когда выпускается семафора, счетчик семафора предыдущих отображается. Консоль сообщения отслеживать использование семафора. Интервал имитирующей работу немного увеличивается для каждого потока, чтобы облегчить чтение выходных данных.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует неименованный семафор. Все потоки, использующие экземпляр такого семафора должен иметь ссылки на экземпляр.  
  
 Если `initialCount` — меньше, чем `maximumCount`, действует так же, как если бы метод текущего потока <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` минус `initialCount`) раз. Если вы не хотите зарезервировать все записи потока, который создает семафора, используйте один и тот же номер для `maximumCount` и `initialCount`.  
  
   
  
## Examples  
 В следующем примере создается семафор с максимальным значением счетчика из трех и начальное число ноль. В примере запускается пять потоков, которые блокируют ожидание семафора. Основной поток использует <xref:System.Threading.Semaphore.Release%28System.Int32%29> перегруженный метод, чтобы увеличить счетчик семафора максимальное значение ограничения, позволяя трех потоков в семафор. Каждый поток использует <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод для ожидания в течение одной секунды для имитации работы, а затем вызывает <xref:System.Threading.Semaphore.Release> перегруженный метод, чтобы освободить семафор. Каждый раз, когда выпускается семафора, счетчик семафора предыдущих отображается. Консоль сообщения отслеживать использование семафора. Интервал имитирующей работу немного увеличивается для каждого потока, чтобы облегчить чтение выходных данных.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
        <param name="name">The name of a named system semaphore object.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует <xref:System.Threading.Semaphore> , представляющий именованный системный семафор. Вы можете создать несколько <xref:System.Threading.Semaphore> объекты, представляющие же именованный семафор.  
  
 Если именованный системный семафор не существует, он создается с начальным и максимальное значение, определяемое `initialCount` и `maximumCount`. Если именованный системный семафор уже существует, `initialCount` и `maximumCount` не используются, несмотря на то, что недопустимые значения по-прежнему вызывать исключения. Если вам нужно определить ли именованный системный семафор был создан, используйте <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> вместо перегрузки конструктора.  
  
> [!IMPORTANT]
>  Если вы используете эту перегрузку конструктора, рекомендуется указывать один и тот же номер для `initialCount` и `maximumCount`. Если `initialCount` — меньше, чем `maximumCount`и создается именованный системный семафор, действует так же, как если бы метод текущего потока <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` минус `initialCount`) раз. Тем не менее с помощью этой перегрузки конструктора нет способа определить, был ли создан именованный системный семафор.  
  
 Если указать `null` или пустую строку для `name`, создан локальный семафор, как если бы Вы вызвали <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> перегрузку конструктора.  
  
 Так как именованные семафоры относятся видимой во всей операционной системы, они могут использоваться для координирования использования ресурсов через границы процессов.  
  
 Если вы хотите узнать, существует ли именованный системный семафор, используйте <xref:System.Threading.Semaphore.OpenExisting%2A> метод. <xref:System.Threading.Semaphore.OpenExisting%2A> Метод пытается открыть существующий именованный семафор и создает исключение, если системный семафор не существует.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного семафора. В примере создается именованный семафор с максимум 5 и исходным значением счетчика до пяти. Программа выполняет три вызова <xref:System.Threading.WaitHandle.WaitOne%2A> метод. Таким образом, если скомпилированный пример запускается из два командных окна, вторую копию заблокирует на третий вызов <xref:System.Threading.WaitHandle.WaitOne%2A>. Освободить один или несколько записей в первую копию сообщения программы, чтобы разблокировать второй.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода для создания именованного системного семафора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Если не удается найти <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />, он проходит по иерархии класса, пока не найдет типом-примитивом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="name">The name of a named system semaphore object.</param>
        <param name="createdNew">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed. This parameter is passed uninitialized.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует <xref:System.Threading.Semaphore> , представляющий именованный системный семафор. Вы можете создать несколько <xref:System.Threading.Semaphore> объекты, представляющие же именованный семафор.  
  
 Если именованный системный семафор не существует, он создается с начальным и максимальное значение, определяемое `initialCount` и `maximumCount`. Если именованный системный семафор уже существует, `initialCount` и `maximumCount` не используются, несмотря на то, что недопустимые значения по-прежнему вызывать исключения. Используйте `createdNew` для определения, был ли создан системный семафор.  
  
 Если `initialCount` — меньше, чем `maximumCount`, и `createdNew` — `true`, действует так же, как если бы метод текущего потока <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` минус `initialCount`) раз.  
  
 Если указать `null` или пустую строку для `name`, создан локальный семафор, как если бы Вы вызвали <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> перегрузку конструктора. В этом случае `createdNew` всегда `true`.  
  
 Так как именованные семафоры относятся видимой во всей операционной системы, они могут использоваться для координирования использования ресурсов через границы процессов.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного семафора. В примере создается именованный семафор с максимум 5 и начальное число 2. То есть она способна резервировать три записи для потока, который вызывает конструктор. Если `createNew` — `false`, программа выполняет три вызова <xref:System.Threading.WaitHandle.WaitOne%2A> метод. Таким образом, если скомпилированный пример запускается из два командных окна, вторую копию заблокирует на третий вызов <xref:System.Threading.WaitHandle.WaitOne%2A>. Освободить один или несколько записей в первую копию сообщения программы, чтобы разблокировать второй.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода для создания именованного системного семафора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Если не удается найти <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />, он проходит по иерархии класса, пока не найдет типом-примитивом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="name">The name of a named system semaphore object.</param>
        <param name="createdNew">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed. This parameter is passed uninitialized.</param>
        <param name="semaphoreSecurity">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется для применения управления доступом для именованного системного семафора, при его создании, чтобы предотвратить возможность управления семафора другого кода.  
  
 Этот конструктор инициализирует <xref:System.Threading.Semaphore> , представляющий именованный системный семафор. Вы можете создать несколько <xref:System.Threading.Semaphore> объекты, представляющие же именованный семафор.  
  
 Если именованный системный семафор не существует, он создается с указанного элемента управления доступом. Если именованный семафор существует, указанный управления доступом учитывается.  
  
> [!NOTE]
>  Вызывающий объект имеет полный контроль над только что созданный <xref:System.Threading.Semaphore> объект, даже если `semaphoreSecurity` запрещает или не удалось предоставить некоторые права доступа для текущего пользователя. Тем не менее если текущий пользователь пытается получить другой <xref:System.Threading.Semaphore> объекта для представления же именованный семафор, с помощью конструктора или <xref:System.Threading.Semaphore.OpenExisting%2A> метод применения управления доступом Windows.  
  
 Если именованный системный семафор не существует, он создается с начальным и максимальное значение, определяемое `initialCount` и `maximumCount`. Если именованный системный семафор уже существует, `initialCount` и `maximumCount` не используются, несмотря на то, что недопустимые значения по-прежнему вызывать исключения. Используйте `createdNew` параметр, чтобы определить, был ли создан системный семафор этим конструктором.  
  
 Если `initialCount` — меньше, чем `maximumCount`, и `createdNew` — `true`, действует так же, как если бы метод текущего потока <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` минус `initialCount`) раз.  
  
 Если указать `null` или пустую строку для `name`, создан локальный семафор, как если бы Вы вызвали <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> перегрузку конструктора. В этом случае `createdNew` всегда `true`.  
  
 Так как именованные семафоры относятся видимой во всей операционной системы, они могут использоваться для координирования использования ресурсов через границы процессов.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного семафора с безопасность управления доступом. В примере используется <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного семафора. Если семафор не существует, он создается с максимальное число 2 и управления доступом, которые запрещают текущему пользователю использовать семафор, но не дает право на чтение и изменение разрешений семафора. Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> метод. Порождено исключение, и в примере используется <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> перегрузку метода открыть семафор с прав, необходимых для чтения и изменения разрешений.  
  
 После изменения разрешений, семафор открывается с права, необходимые для ввода и выпуска. При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода для создания именованного системного семафора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Если не удается найти <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />, он проходит по иерархии класса, пока не найдет типом-примитивом.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the access control security for a named system semaphore.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security for the named system semaphore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Semaphore.GetAccessControl%2A> Методе используется комбинация флагов (в сочетании с помощью побитовой операции OR) для поиска для разрешения: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, и <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Пользователь должен иметь <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> права для вызова этого метода и семафора должен быть открыт с <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> права.  
  
 На локальный семафор управления доступом не имеет значения. Если <xref:System.Threading.Semaphore> объект не представляет именованный системный семафор, этот метод возвращает <xref:System.Security.AccessControl.SemaphoreSecurity> объект, который предоставляет все права всем пользователям.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного семафора с безопасность управления доступом. В примере используется <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного семафора.  
  
 Если семафор не существует, он создается с максимальное число 2 и управления доступом, который запрещает текущий пользователь право использовать семафор, но не дает право на чтение и изменение разрешений семафора.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> метод. Порождено исключение, и в примере используется <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> перегрузку метода открыть семафор с прав, необходимых для чтения и изменения разрешений. Безопасность управления доступом для системного семафора получается с помощью <xref:System.Threading.Semaphore.GetAccessControl%2A> метод.  
  
 После изменения разрешений, семафор открывается с права, необходимые для ввода и выпуска. При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.  -or-  The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore and was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</exception>
        <exception cref="T:System.NotSupportedException">Not supported for Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named semaphore, if it already exists.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <summary>Opens the specified named semaphore, if it already exists.</summary>
        <returns>An object that represents the named system semaphore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Semaphore.OpenExisting%2A> Метод пытается открыть указанный именованный семафор. Если системный семафор не существует, этот метод выдает исключение вместо создания системного семафора. Чтобы создать системный семафор, если он еще не существует, используйте один из <xref:System.Threading.Semaphore.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.Semaphore> объекта, несмотря на то, что объекты, возвращаемые представляют же именованный семафор.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Threading.Semaphore.OpenExisting%2A> перегрузку метода с указанием <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> права, объединяются с помощью побитовой операции или.  
  
 Указание <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> флаг позволяет потоку в семафор и указав <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> флаг позволяет потоку на вызов метода <xref:System.Threading.Semaphore.Release%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного семафора с безопасность управления доступом. В примере используется <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного семафора.  
  
 Если семафор не существует, он создается с максимальное число 2 и безопасность управления доступом, которая запрещает текущий пользователь право на использование семафора, но предоставляют право на чтение и изменение разрешений семафора.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> перегрузки метода. Порождено исключение, и в примере используется <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> перегрузку метода открыть семафор с прав, необходимых для чтения и изменения разрешений.  
  
 После изменения разрешений, семафор открывается с права, необходимые для ввода и освободите его. При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода, чтобы открыть именованный системный семафор. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Если не удается найти <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />, он проходит по иерархии класса, пока не найдет типом-примитивом.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <summary>Opens the specified named semaphore, if it already exists, with the desired security access.</summary>
        <returns>An object that represents the named system semaphore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` Параметр должен содержать <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> флаг, чтобы разрешить потоков в семафор и <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> флаг, чтобы разрешить потокам вызывать <xref:System.Threading.Semaphore.Release%2A> метод.  
  
 <xref:System.Threading.Semaphore.OpenExisting%2A> Метод пытается открыть существующий именованный семафор. Если системный семафор не существует, этот метод выдает исключение вместо создания системного семафора. Чтобы создать системный семафор, если он еще не существует, используйте один из <xref:System.Threading.Semaphore.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.Semaphore> объекта, несмотря на то, что объекты, возвращаемые представляют же именованный семафор.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного семафора с безопасность управления доступом. В примере используется <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного семафора.  
  
 Если семафор не существует, он создается с максимальное число 2 и управления доступом, который запрещает текущий пользователь право использовать семафор, но не дает право на чтение и изменение разрешений семафора.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> метод. Порождено исключение, и в примере используется <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> перегрузку метода открыть семафор с прав, необходимых для чтения и изменения разрешений.  
  
 После изменения разрешений, семафор открывается с права, необходимые для ввода и освободите его. При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the desired security access rights.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода для создания именованного системного семафора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Если не удается найти <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />, он проходит по иерархии класса, пока не найдет типом-примитивом.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exits the semaphore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exits the semaphore and returns the previous count.</summary>
        <returns>The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Потоки обычно используют <xref:System.Threading.WaitHandle.WaitOne%2A> метод ввести семафор и они обычно данная перегрузка метода для выхода.  
  
 Если <xref:System.Threading.SemaphoreFullException> вызывается <xref:System.Threading.Semaphore.Release%2A> метод, он не обязательно на проблему с вызывающего потока. Программная ошибка в другом потоке вызвавшую этот поток из семафора больше раз, чем вход в него.  
  
 Если текущий <xref:System.Threading.Semaphore> представляет именованный системный семафор, пользователь должен иметь <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> права и семафора должен быть открыт с <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> права.  
  
   
  
## Examples  
 В следующем примере кода создается семафор с максимум из трех и начальное число ноль. В примере запускается пять потоков, которые блокируют ожидание семафора. Основной поток использует <xref:System.Threading.Semaphore.Release%28System.Int32%29> перегруженный метод, чтобы увеличить счетчик семафора максимальное значение ограничения, позволяя трех потоков в семафор. Каждый поток использует <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод для ожидания в течение одной секунды для имитации работы, а затем вызывает <xref:System.Threading.Semaphore.Release> перегруженный метод, чтобы освободить семафор.  
  
 Каждый раз, когда выпускается семафора, счетчик семафора предыдущих отображается. Консоль сообщения отслеживать использование семафора. Интервал имитирующей работу немного увеличивается для каждого потока, чтобы облегчить чтение выходных данных.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">The semaphore count is already at the maximum value.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred with a named semaphore.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  -or-  The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">The number of times to exit the semaphore.</param>
        <summary>Exits the semaphore a specified number of times and returns the previous count.</summary>
        <returns>The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если поток вошел в семафор несколько раз, перегрузка метода позволяет счетчик семафора для восстановления с помощью одного вызова.  
  
 Если <xref:System.Threading.SemaphoreFullException> вызывается <xref:System.Threading.Semaphore.Release%2A> метод, он не обязательно на проблему с вызывающего потока. Программная ошибка в другом потоке вызвавшую этот поток из семафора больше раз, чем вход в него.  
  
 Если текущий <xref:System.Threading.Semaphore> представляет именованный системный семафор, пользователь должен иметь <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> права и семафора должен быть открыт с <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> права.  
  
   
  
## Examples  
 В следующем примере кода создается семафор с максимум из трех и начальное число ноль. В примере запускается пять потоков, которые блокируют ожидание семафора. Основной поток использует <xref:System.Threading.Semaphore.Release%28System.Int32%29> перегруженный метод, чтобы увеличить счетчик семафора максимальное значение ограничения, позволяя трех потоков в семафор. Каждый поток использует <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод для ожидания в течение одной секунды для имитации работы, а затем вызывает <xref:System.Threading.Semaphore.Release> перегруженный метод, чтобы освободить семафор.  
  
 Каждый раз, когда выпускается семафора, счетчик семафора предыдущих отображается. Консоль сообщения отслеживать использование семафора. Интервал имитирующей работу немного увеличивается для каждого потока, чтобы облегчить чтение выходных данных.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> is less than 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">The semaphore count is already at the maximum value.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred with a named semaphore.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.  -or-  The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</param>
        <summary>Sets the access control security for a named system semaphore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Безопасность управления доступом можно установить только на <xref:System.Threading.Semaphore> объекты, представляющие именованных системных семафоров.  
  
 Пользователь должен иметь <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> права для вызова этого метода и семафора должен быть открыт с <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> права.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного семафора с безопасность управления доступом. В примере используется <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного семафора.  
  
 Если семафор не существует, он создается с максимальное число 2 и управления доступом, которые запрещают текущему пользователю использовать семафор, но не дает право на чтение и изменение разрешений семафора.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> метод. Порождено исключение, и в примере используется <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> перегрузку метода открыть семафор с прав, необходимых для чтения и изменения разрешений.  
  
 После изменения разрешений, с помощью <xref:System.Threading.Semaphore.SetAccessControl%2A> метод семафора открыт с помощью права, необходимые для ввода и выпуска. При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="semaphoreSecurity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.  -or-  The semaphore was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</exception>
        <exception cref="T:System.NotSupportedException">The current <see cref="T:System.Threading.Semaphore" /> object does not represent a named system semaphore.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованный семафор существует, этот метод не создает его. Чтобы создать системный семафор, если он еще не существует, используйте один из <xref:System.Threading.Semaphore.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Если вы не уверены, является ли именованный семафор существует, используйте эту перегрузку метода вместо <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> перегрузку метода, который создает исключение, если семафор не существует.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Threading.Semaphore.TryOpenExisting%2A> перегрузку метода с указанием <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> права, объединяются с помощью побитовой операции или. Указание <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> флаг позволяет потоку в семафор и указав <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> флаг позволяет потоку на вызов метода <xref:System.Threading.Semaphore.Release%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the security access required to use it.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованный семафор существует, этот метод не создает его. Чтобы создать системный семафор, если он еще не существует, используйте один из <xref:System.Threading.Semaphore.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Если вы не уверены, является ли именованный семафор существует, используйте эту перегрузку метода вместо <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> перегрузку метода, который создает исключение, если семафор не существует.  
  
 `rights` Параметр должен содержать <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> флаг, чтобы разрешить потоков в семафор и <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> флаг, чтобы разрешить потокам вызывать <xref:System.Threading.Semaphore.Release%2A> метод.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.Semaphore> объекта, несмотря на то, что объекты, возвращаемые представляют же именованный семафор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the security access required to use it.</exception>
      </Docs>
    </Member>
  </Members>
</Type>