<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="589fcf34edfc4ff1eb1c243acad8b5ad0d3cd911" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530948" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ограничивает число потоков, которые могут одновременно обращаться к ресурсу или пулу ресурсов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Threading.Semaphore> класса для управления доступом к пулу ресурсов. Потоки входили в семафор посредством вызова <xref:System.Threading.WaitHandle.WaitOne%2A> метод, который наследуется от <xref:System.Threading.WaitHandle> класса и освобождают семафор посредством вызова <xref:System.Threading.Semaphore.Release%2A> метод.  
  
 Счетчик на семафоре уменьшается на единицу каждый раз поток входит в семафор и увеличивается на единицу, когда поток выходит из семафора. Если счетчик равен нулю, последующие запросы блокируются, пока другие потоки освобождают семафор. Если семафор освобожден всеми потоками, счетчик равен максимальному значению указывается при создании семафора.  
  
 Нет гарантированного порядка, например FIFO, LIFO, в котором заблокированных потоков в семафор.  
  
 Поток может войти в семафор несколько раз, вызвав <xref:System.Threading.WaitHandle.WaitOne%2A> метода несколько раз. Чтобы освободить все или некоторые из этих записей, можно вызвать без параметров потока <xref:System.Threading.Semaphore.Release> несколько раз, или его можно вызвать перегрузку метода <xref:System.Threading.Semaphore.Release%28System.Int32%29> перегрузки метода, который указывает количество освобождаемых записей.  
  
 <xref:System.Threading.Semaphore> Класс обеспечивает идентификацию вызовов <xref:System.Threading.WaitHandle.WaitOne%2A> или <xref:System.Threading.Semaphore.Release%2A>. Это программист должен убедиться, что потоки не освободить семафор слишком много раз. Например предположим, что семафор имеет максимальное значение счетчика равное двум, а два потока A и B входят в семафор. Если ошибка программирования в потоке B заставляет его вызывать метод <xref:System.Threading.Semaphore.Release%2A> дважды, оба вызова оканчиваются успешно. Счетчик на семафоре переполнен, и если поток A вызывает <xref:System.Threading.Semaphore.Release%2A>, <xref:System.Threading.SemaphoreFullException> создается исключение.  
  
 Семафоры бывают двух типов: локальные семафоры и именованного системного семафора. Если вы создаете <xref:System.Threading.Semaphore> объекта, используя конструктор, который принимает имя, она связана с семафора операционной системы с тем же именем. Именованные системные семафоры доступны в пределах всей операционной системы и может использоваться для синхронизации действий процессов. Можно создать несколько <xref:System.Threading.Semaphore> объекты, представляющие же именованный семафор, и можно использовать <xref:System.Threading.Semaphore.OpenExisting%2A> метод, чтобы открыть существующий именованный семафор.  
  
 Локальный семафор существует только внутри одного процесса. Его может использовать любой поток в вашем процессе, имеющий ссылку на локальный объект <xref:System.Threading.Semaphore>. Каждый <xref:System.Threading.Semaphore> объект — это отдельный локальный семафор.  
  
   
  
## Examples  
 В следующем примере кода создается семафор с максимальное число из трех и исходным значением счетчика равно нулю. В примере запускается пять потоков, которые блокируют ожидание семафора. Основной поток, используя <xref:System.Threading.Semaphore.Release%28System.Int32%29> перегрузка метода, чтобы увеличить значение счетчика семафора максимальное разрешение трех потоков в семафор. Каждый поток использует <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод для ожидания одной секунды для имитации работы, а затем вызывает <xref:System.Threading.Semaphore.Release> перегрузка метода, чтобы освободить семафор. Каждый раз, когда освобождения семафора отображается предыдущее значение счетчика семафора. Консоль сообщения позволяют отслеживать использование семафора. Интервал имитирующей работу немного увеличивается для каждого потока, чтобы облегчить чтение выходных данных.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Начальное количество запросов для семафора, которое может быть обеспечено одновременно.</param>
        <param name="maximumCount">Максимальное количество запросов семафора, которое может быть обеспеченно одновременно.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" />, задающий начальное количество входов и максимальное количество одновременных входов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует неименованный семафор. Все потоки, использующие экземпляр такого семафора должно иметь ссылки на экземпляр.  
  
 Если `initialCount` — меньше, чем `maximumCount`, действует так же как если бы метод текущий поток <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` минус `initialCount`) раз. Если вы не хотите резервировать входы для потока, создающего семафор, используйте один и тот же номер для `maximumCount` и `initialCount`.  
  
   
  
## Examples  
 В следующем примере создается семафор с максимальное число из трех и исходным значением счетчика равно нулю. В примере запускается пять потоков, которые блокируют ожидание семафора. Основной поток, используя <xref:System.Threading.Semaphore.Release%28System.Int32%29> перегрузка метода, чтобы увеличить значение счетчика семафора максимальное разрешение трех потоков в семафор. Каждый поток использует <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод для ожидания одной секунды для имитации работы, а затем вызывает <xref:System.Threading.Semaphore.Release> перегрузка метода, чтобы освободить семафор. Каждый раз, когда освобождения семафора отображается предыдущее значение счетчика семафора. Консоль сообщения позволяют отслеживать использование семафора. Интервал имитирующей работу немного увеличивается для каждого потока, чтобы облегчить чтение выходных данных.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Значение <paramref name="initialCount" /> больше значения <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="maximumCount" /> меньше 1.  
  
 - или -  
  
 Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">Начальное количество запросов для семафора, которое может быть обеспечено одновременно.</param>
        <param name="maximumCount">Максимальное количество запросов семафора, которое может быть обеспеченно одновременно.</param>
        <param name="name">Имя объекта именованного системного семафора.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" />, задающий начальное количество входов и максимальное количество одновременных входов, а также при необходимости имя объекта системного семафора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует <xref:System.Threading.Semaphore> , представляющий именованный системный семафор. Можно создать несколько <xref:System.Threading.Semaphore> объекты, представляющие же именованный семафор.  
  
 Если именованный системный семафор не существует, он создается с начальным и максимальное число, указанное в `initialCount` и `maximumCount`. Если именованный системный семафор уже существует, `initialCount` и `maximumCount` не используются, несмотря на то, что недопустимые значения по-прежнему вызывать исключения. Если необходимо определить ли именованный системный семафор был создан, используйте <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> перегрузку конструктора.  
  
> [!IMPORTANT]
>  При использовании этого перегруженного конструктора, рекомендуется указать тот же номер для `initialCount` и `maximumCount`. Если `initialCount` — меньше, чем `maximumCount`и создается именованный системный семафор, действует так же как если бы метод текущий поток <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` минус `initialCount`) раз. Однако эта перегрузка конструктора является не может определить, был ли создан именованный системный семафор.  
  
 При указании `null` или пустую строку для `name`, создан локальный семафор, как если бы метод <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> перегрузку конструктора.  
  
 Так как именованные семафоры доступны в пределах всей операционной системы, их можно использовать для координирования использования ресурсов разными процессами.  
  
 Если вы хотите узнать, существует ли именованный системный семафор, используйте <xref:System.Threading.Semaphore.OpenExisting%2A> метод. <xref:System.Threading.Semaphore.OpenExisting%2A> Метод пытается открыть существующий именованный семафор и вызывает исключение, если не существует системного семафора.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованный семафор. В примере создается именованный семафор с максимум 5 и начальное число 5. Программа выполняет три вызова <xref:System.Threading.WaitHandle.WaitOne%2A> метод. Таким образом, при запуске скомпилированный пример из двух окнах команда второй копии заблокирует третий вызов <xref:System.Threading.WaitHandle.WaitOne%2A>. Освободить один или несколько записей в первой копии программы, чтобы разблокировать за секунду.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Значение <paramref name="initialCount" /> больше значения <paramref name="maximumCount" />.  
  
 - или -  
  
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="maximumCount" /> меньше 1.  
  
 - или -  
  
 Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, доступ к нему безопасно регулируется, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор нельзя создать. Вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода для создания именованного системного семафора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">Начальное количество запросов семафора, которое может быть удовлетворено одновременно.</param>
        <param name="maximumCount">Максимальное количество запросов семафора, которое может быть удовлетворено одновременно.</param>
        <param name="name">Имя объекта именованного системного семафора.</param>
        <param name="createdNew">При возврате этот метод содержит значение <see langword="true" />, если был создан локальный семафор (то есть если параметр <c>name</c> имеет значение <see langword="null" /> или содержит пустую строку) или был создан заданный именованный системный семафор; значение <see langword="false" />, если указанный именованный семафор уже существовал. Этот параметр передается неинициализированным.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" />, задающий начальное количество входов и максимальное количество одновременных входов, а также при необходимости задающий имя объекта системного семафора и переменную, получающую значение, которое указывает, был ли создан новый системный семафор.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует <xref:System.Threading.Semaphore> , представляющий именованный системный семафор. Можно создать несколько <xref:System.Threading.Semaphore> объекты, представляющие же именованный семафор.  
  
 Если именованный системный семафор не существует, он создается с начальным и максимальное число, указанное в `initialCount` и `maximumCount`. Если именованный системный семафор уже существует, `initialCount` и `maximumCount` не используются, несмотря на то, что недопустимые значения по-прежнему вызывать исключения. Используйте `createdNew` для определения, был ли создан системный семафор.  
  
 Если `initialCount` — меньше, чем `maximumCount`, и `createdNew` — `true`, действует так же как если бы метод текущий поток <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` минус `initialCount`) раз.  
  
 При указании `null` или пустую строку для `name`, создан локальный семафор, как если бы метод <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> перегрузку конструктора. В этом случае `createdNew` всегда `true`.  
  
 Так как именованные семафоры доступны в пределах всей операционной системы, их можно использовать для координирования использования ресурсов разными процессами.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованный семафор. В примере создается именованный семафор с максимум 5 и исходным значением счетчика двух. То есть резервируется три входа для потока, который вызывает конструктор. Если `createNew` — `false`, программа выполняет три вызова <xref:System.Threading.WaitHandle.WaitOne%2A> метод. Таким образом, при запуске скомпилированный пример из двух окнах команда второй копии заблокирует третий вызов <xref:System.Threading.WaitHandle.WaitOne%2A>. Освободить один или несколько записей в первой копии программы, чтобы разблокировать за секунду.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Значение <paramref name="initialCount" /> больше значения <paramref name="maximumCount" />.  
  
 - или -  
  
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="maximumCount" /> меньше 1.  
  
 - или -  
  
 Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, доступ к нему безопасно регулируется, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор нельзя создать. Вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода для создания именованного системного семафора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">Начальное количество запросов семафора, которое может быть удовлетворено одновременно.</param>
        <param name="maximumCount">Максимальное количество запросов семафора, которое может быть удовлетворено одновременно.</param>
        <param name="name">Имя объекта именованного системного семафора.</param>
        <param name="createdNew">При возврате этот метод содержит значение <see langword="true" />, если был создан локальный семафор (то есть если параметр <c>name</c> имеет значение <see langword="null" /> или содержит пустую строку) или был создан заданный именованный системный семафор; значение <see langword="false" />, если указанный именованный семафор уже существовал. Этот параметр передается неинициализированным.</param>
        <param name="semaphoreSecurity">Объект <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />, представляющий безопасность управления доступом для применения к именованному системному семафору.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" />, задающий начальное количество входов и максимальное количество одновременных входов, а также при необходимости задает имя объекта системного семафора, переменную, которая получает значение, указывающее, был ли создан новый системный семафор, и управление безопасным доступом для системного семафора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется, чтобы применить безопасность управления доступом для именованного системного семафора, при его создании, чтобы предотвратить возможность управления семафора другим кодом.  
  
 Этот конструктор инициализирует <xref:System.Threading.Semaphore> , представляющий именованный системный семафор. Можно создать несколько <xref:System.Threading.Semaphore> объекты, представляющие же именованный семафор.  
  
 Если именованный системный семафор не существует, он создается с указанными управления доступом. Если именованный семафор существует, указанные настройки управления доступом учитывается.  
  
> [!NOTE]
>  Вызывающий оператор имеет полный контроль над только что созданный <xref:System.Threading.Semaphore> объект, даже если `semaphoreSecurity` запрещает или не может предоставить некоторые права доступа для текущего пользователя. Тем не менее если текущий пользователь пытается получить другой <xref:System.Threading.Semaphore> объекта для представления же именованный семафор, с помощью конструктора или <xref:System.Threading.Semaphore.OpenExisting%2A> метод применяется безопасность управления доступом Windows.  
  
 Если именованный системный семафор не существует, он создается с начальным и максимальное число, указанное в `initialCount` и `maximumCount`. Если именованный системный семафор уже существует, `initialCount` и `maximumCount` не используются, несмотря на то, что недопустимые значения по-прежнему вызывать исключения. Используйте `createdNew` параметра, чтобы определить, был ли создан системный семафор этим конструктором.  
  
 Если `initialCount` — меньше, чем `maximumCount`, и `createdNew` — `true`, действует так же как если бы метод текущий поток <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` минус `initialCount`) раз.  
  
 При указании `null` или пустую строку для `name`, создан локальный семафор, как если бы метод <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> перегрузку конструктора. В этом случае `createdNew` всегда `true`.  
  
 Так как именованные семафоры доступны в пределах всей операционной системы, их можно использовать для координирования использования ресурсов разными процессами.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованный семафор с безопасность управления доступом. В этом примере <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> перегрузка метода для проверки существования именованный семафор. Если семафор не существует, он создается с двух максимальное значение счетчика и управления доступом, которые запрещают текущему пользователю использовать семафор, но предоставляет право на чтение и изменение разрешений семафора. При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> метода. Исключение перехватывается, а в примере используется <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> перегрузку метода, чтобы открыть семафор с права, необходимые для чтения и изменения разрешений.  
  
 После изменения разрешений семафор открывается с права, необходимые для ввода и вывода. Если запустить скомпилированный пример в третьем командном окне, запускается с помощью новых разрешений.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Значение <paramref name="initialCount" /> больше значения <paramref name="maximumCount" />.  
  
 - или -  
  
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="maximumCount" /> меньше 1.  
  
 - или -  
  
 Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, доступ к нему безопасно регулируется, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор нельзя создать. Вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода для создания именованного системного семафора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает настройки управления доступом для именованного системного семафора.</summary>
        <returns>Объект <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />, представляющий параметры безопасности управления доступом для именованного системного семафора.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Semaphore.GetAccessControl%2A> Метод используется комбинация следующих (объединены с помощью битовой операции OR) флагов для поиска для разрешения: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, и <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Пользователь должен иметь <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> правами для вызова этого метода и семафора должен быть открыт с <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> права.  
  
 На локальный семафор безопасность управления доступом не имеет значения. Если <xref:System.Threading.Semaphore> объект не представляет именованный системный семафор, этот метод возвращает <xref:System.Security.AccessControl.SemaphoreSecurity> объект, который предоставляет все права для любого пользователя.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованный семафор с безопасность управления доступом. В этом примере <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> перегрузка метода для проверки существования именованный семафор.  
  
 Если семафор не существует, он создается с двух максимальное значение счетчика и управления доступом, которые запрещают текущему пользователю использовать семафор, но предоставляет право на чтение и изменение разрешений семафора.  
  
 При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> метода. Исключение перехватывается, а в примере используется <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> перегрузку метода, чтобы открыть семафор с права, необходимые для чтения и изменения разрешений. Безопасность управления доступом для системного семафора, можно получить <xref:System.Threading.Semaphore.GetAccessControl%2A> метод.  
  
 После изменения разрешений семафор открывается с права, необходимые для ввода и вывода. Если запустить скомпилированный пример в третьем командном окне, запускается с помощью новых разрешений.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Текущий объект <see cref="T:System.Threading.Semaphore" /> представляет именованный системный семафор, а пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.  
  
 - или -  
  
 Текущий объект <see cref="T:System.Threading.Semaphore" /> представляет именованный системный семафор и не был открыт с использованием прав <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Не поддерживается для Windows 98 или Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает указанный именованный семафор, если он уже существует.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного семафора для открытия.</param>
        <summary>Открывает указанный именованный семафор, если он уже существует.</summary>
        <returns>Объект, представляющий именованный системный семафор.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Semaphore.OpenExisting%2A> Метод пытается открыть указанный именованный семафор. Если системный семафор не существует, этот метод выдает исключение вместо создания системного семафора. Чтобы создать системный семафор, если он еще не существует, используйте один из <xref:System.Threading.Semaphore.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` необязательно возвратят же <xref:System.Threading.Semaphore> объекта, несмотря на то, что объекты, возвращаемые представляют же именованный семафор.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Threading.Semaphore.OpenExisting%2A> перегруженный метод и указывая <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> прав, объединяются с помощью битовой операции или.  
  
 Указание <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> флаг позволяет потоков в семафор и указав <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> флаг позволяет потоку для вызова <xref:System.Threading.Semaphore.Release%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованный семафор с безопасность управления доступом. В этом примере <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> перегрузка метода для проверки существования именованный семафор.  
  
 Если семафор не существует, он создается с двух максимальное значение счетчика и управления доступом, запрещают текущему пользователю использовать семафор, но предоставляют право на чтение и изменение разрешений семафора.  
  
 При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> перегрузки метода. Исключение перехватывается, а в примере используется <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> перегрузку метода, чтобы открыть семафор с права, необходимые для чтения и изменения разрешений.  
  
 После изменения разрешений семафор открывается с права, необходимые для ввода и освободите его. Если запустить скомпилированный пример в третьем командном окне, запускается с помощью новых разрешений.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="name" /> равен пустой строке.  
  
 - или -  
  
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор не существует.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода для открытия именованного системного семафора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного семафора для открытия.</param>
        <param name="rights">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</param>
        <summary>Открывает указанный именованный семафор, если он уже существует, с требуемым безопасным доступом.</summary>
        <returns>Объект, представляющий именованный системный семафор.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` Необходимо включить параметр <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> флаг, чтобы разрешить потоков в семафор и <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> флаг, чтобы разрешить потоков для вызова <xref:System.Threading.Semaphore.Release%2A> метод.  
  
 <xref:System.Threading.Semaphore.OpenExisting%2A> Метод пытается открыть существующий именованный семафор. Если системный семафор не существует, этот метод выдает исключение вместо создания системного семафора. Чтобы создать системный семафор, если он еще не существует, используйте один из <xref:System.Threading.Semaphore.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` необязательно возвратят же <xref:System.Threading.Semaphore> объекта, несмотря на то, что объекты, возвращаемые представляют же именованный семафор.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованный семафор с безопасность управления доступом. В этом примере <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> перегрузка метода для проверки существования именованный семафор.  
  
 Если семафор не существует, он создается с двух максимальное значение счетчика и управления доступом, которые запрещают текущему пользователю использовать семафор, но предоставляет право на чтение и изменение разрешений семафора.  
  
 При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> метода. Исключение перехватывается, а в примере используется <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> перегрузку метода, чтобы открыть семафор с права, необходимые для чтения и изменения разрешений.  
  
 После изменения разрешений семафор открывается с права, необходимые для ввода и освободите его. Если запустить скомпилированный пример в третьем командном окне, запускается с помощью новых разрешений.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="name" /> равен пустой строке.  
  
 - или -  
  
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор не существует.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, но у пользователя нет требуемых прав доступа.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода для создания именованного системного семафора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет выход из семафора.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выходит из семафора и возвращает последнее значение счетчика.</summary>
        <returns>Счетчик семафора перед вызовом метода <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Потоки обычно используют <xref:System.Threading.WaitHandle.WaitOne%2A> метод для ввода семафора и они обычно используйте перегрузку этого метода, чтобы выйти из.  
  
 Если <xref:System.Threading.SemaphoreFullException> вызванное <xref:System.Threading.Semaphore.Release%2A> метод, он не обязательно указывает на проблему с вызывающего потока. Возможно, этот поток из семафора больше раз, чем вход в него вызвана ошибка программирования в другом потоке.  
  
 Если текущий <xref:System.Threading.Semaphore> представляет именованный системный семафор, пользователь должен иметь <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> права и семафора должен быть открыт с <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> права.  
  
   
  
## Examples  
 В следующем примере кода создается семафор с максимальное число из трех и исходным значением счетчика равно нулю. В примере запускается пять потоков, которые блокируют ожидание семафора. Основной поток, используя <xref:System.Threading.Semaphore.Release%28System.Int32%29> перегрузка метода, чтобы увеличить значение счетчика семафора максимальное разрешение трех потоков в семафор. Каждый поток использует <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод для ожидания одной секунды для имитации работы, а затем вызывает <xref:System.Threading.Semaphore.Release> перегрузка метода, чтобы освободить семафор.  
  
 Каждый раз, когда освобождения семафора отображается предыдущее значение счетчика семафора. Консоль сообщения позволяют отслеживать использование семафора. Интервал имитирующей работу немного увеличивается для каждого потока, чтобы облегчить чтение выходных данных.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">Счетчик семафора уже имеет максимальное значение.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32, связанная с именованным семафором.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Текущий семафор представляет именованный системный семафор, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
 - или -  
  
 Текущий семафор представляет именованный системный семафор, но он не был открыт с правами доступа <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">Количество требуемых выходов из семафора.</param>
        <summary>Выходит из семафора указанное число раз и возвращает последнее значение счетчика.</summary>
        <returns>Счетчик семафора перед вызовом метода <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если поток вошел в семафор несколько раз, эта перегрузка метода позволяет восстановить с помощью одного вызова счетчик семафора.  
  
 Если <xref:System.Threading.SemaphoreFullException> вызванное <xref:System.Threading.Semaphore.Release%2A> метод, он не обязательно указывает на проблему с вызывающего потока. Возможно, этот поток из семафора больше раз, чем вход в него вызвана ошибка программирования в другом потоке.  
  
 Если текущий <xref:System.Threading.Semaphore> представляет именованный системный семафор, пользователь должен иметь <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> права и семафора должен быть открыт с <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> права.  
  
   
  
## Examples  
 В следующем примере кода создается семафор с максимальное число из трех и исходным значением счетчика равно нулю. В примере запускается пять потоков, которые блокируют ожидание семафора. Основной поток, используя <xref:System.Threading.Semaphore.Release%28System.Int32%29> перегрузка метода, чтобы увеличить значение счетчика семафора максимальное разрешение трех потоков в семафор. Каждый поток использует <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод для ожидания одной секунды для имитации работы, а затем вызывает <xref:System.Threading.Semaphore.Release> перегрузка метода, чтобы освободить семафор.  
  
 Каждый раз, когда освобождения семафора отображается предыдущее значение счетчика семафора. Консоль сообщения позволяют отслеживать использование семафора. Интервал имитирующей работу немного увеличивается для каждого потока, чтобы облегчить чтение выходных данных.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="releaseCount" /> меньше 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">Счетчик семафора уже имеет максимальное значение.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32, связанная с именованным семафором.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Текущий семафор представляет именованный системный семафор, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
 - или -  
  
 Текущий семафор представляет именованный системный семафор, но он не был открыт с правами <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">Объект <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />, представляющий безопасность управления доступом для применения к именованному системному семафору.</param>
        <summary>Задает безопасность управления доступом для именованного системного семафора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Безопасность управления доступом можно задать только на <xref:System.Threading.Semaphore> объекты, представляющие именованного системного семафора.  
  
 Пользователь должен иметь <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> правами для вызова этого метода и семафора должен быть открыт с <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> права.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованный семафор с безопасность управления доступом. В этом примере <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> перегрузка метода для проверки существования именованный семафор.  
  
 Если семафор не существует, он создается с двух максимальное значение счетчика и управления доступом, которые запрещают текущему пользователю использовать семафор, но предоставляет право на чтение и изменение разрешений семафора.  
  
 При запуске скомпилированный пример из двух окнах команда второй копии вызовет нарушение прав доступа при вызове <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> метода. Исключение перехватывается, а в примере используется <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> перегрузку метода, чтобы открыть семафор с права, необходимые для чтения и изменения разрешений.  
  
 После изменения разрешений, с помощью <xref:System.Threading.Semaphore.SetAccessControl%2A> метод семафор открывается с права, необходимые для ввода и вывода. Если запустить скомпилированный пример в третьем командном окне, запускается с помощью новых разрешений.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="semaphoreSecurity" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.  
  
 - или -  
  
 Семафор не был открыт с правами <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Текущий объект <see cref="T:System.Threading.Semaphore" /> не представляет именованный системный семафор.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает заданный именованный семафор, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного семафора для открытия.</param>
        <param name="result">При возврате этот метод содержит объект <see cref="T:System.Threading.Semaphore" />, представляющий именованный семафор, если вызов завершился успешно, или значение <see langword="null" />, если вызов завершился неудачно. Этот параметр обрабатывается как неинициализированный.</param>
        <summary>Открывает указанный именованный семафор, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
        <returns>
          Значение <see langword="true" />, если именованный семафор был успешно открыт; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованный семафор не существует, этот метод не создает его. Чтобы создать системный семафор, если он еще не существует, используйте один из <xref:System.Threading.Semaphore.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Если неизвестно, существует ли именованный семафор, используйте перегрузку этого метода, а не <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> перегрузка метода, который создает исключение, если семафора не существует.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Threading.Semaphore.TryOpenExisting%2A> перегруженный метод и указывая <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> прав, объединяются с помощью битовой операции или. Указание <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> флаг позволяет потоков в семафор и указав <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> флаг позволяет потоку для вызова <xref:System.Threading.Semaphore.Release%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="name" /> равен пустой строке.  
  
 - или -  
  
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного семафора для открытия.</param>
        <param name="rights">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</param>
        <param name="result">При возврате этот метод содержит объект <see cref="T:System.Threading.Semaphore" />, представляющий именованный семафор, если вызов завершился успешно, или значение <see langword="null" />, если вызов завершился неудачно. Этот параметр обрабатывается как неинициализированный.</param>
        <summary>Открывает заданный именованный семафор, если он уже существует, с требуемыми правами доступа, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
        <returns>
          Значение <see langword="true" />, если именованный семафор был успешно открыт; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованный семафор не существует, этот метод не создает его. Чтобы создать системный семафор, если он еще не существует, используйте один из <xref:System.Threading.Semaphore.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Если неизвестно, существует ли именованный семафор, используйте перегрузку этого метода, а не <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> перегрузка метода, который создает исключение, если семафора не существует.  
  
 `rights` Необходимо включить параметр <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> флаг, чтобы разрешить потоков в семафор и <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> флаг, чтобы разрешить потоков для вызова <xref:System.Threading.Semaphore.Release%2A> метод.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` необязательно возвратят же <xref:System.Threading.Semaphore> объекта, несмотря на то, что объекты, возвращаемые представляют же именованный семафор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="name" /> равен пустой строке.  
  
 - или -  
  
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
      </Docs>
    </Member>
  </Members>
</Type>