<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3affe4872ffccc66fbf65bb8eeb4555921416133" />
    <Meta Name="ms.sourcegitcommit" Value="4303c81814c0b4fd5963444073ed25c176c5ddad" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="07/31/2018" />
    <Meta Name="ms.locfileid" Value="39361197" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="3895c-101">Предоставляет пул потоков, который можно использовать для выполнения задач, отправки рабочих элементов, обработки асинхронного ввода-вывода, ожидания от имени других потоков и обработки таймеров.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3895c-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-102">Многие приложения создают потоки, которые тратить много времени в состоянии, ожидая возникновения события.</span><span class="sxs-lookup"><span data-stu-id="3895c-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="3895c-103">Другие потоки могут входить в бездействующее состояние только для периодически опрашивать для изменения или обновлять сведения о состоянии.</span><span class="sxs-lookup"><span data-stu-id="3895c-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="3895c-104">Пул потоков позволяет более эффективно использовать потоки, предоставляя приложения с пулом рабочих потоков, управляемых системой.</span><span class="sxs-lookup"><span data-stu-id="3895c-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="3895c-105">Следующие примеры операций, использующих потоки пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="3895c-106">При создании <xref:System.Threading.Tasks.Task> или <xref:System.Threading.Tasks.Task%601> объект асинхронно, выполнить ряд задач по умолчанию, задача запланирована для выполнения в потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="3895c-107">Асинхронные таймеры используют пул потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="3895c-108">Потоки из пула потоков исполнения ответных вызовов из <xref:System.Threading.Timer?displayProperty=nameWithType> класса и вызов событий из <xref:System.Timers.Timer?displayProperty=nameWithType> класса.</span><span class="sxs-lookup"><span data-stu-id="3895c-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="3895c-109">При использовании дескрипторов ожидания, зарегистрированных в потоке операционной системы следит за состоянием дескрипторов ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="3895c-110">При завершении операции ожидания, рабочий поток из пула потоков выполняет соответствующую функцию обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="3895c-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="3895c-111">При вызове <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> метод в очередь метод для выполнения в потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="3895c-112">Это можно сделать, передавая ему <xref:System.Threading.WaitCallback> делегировать.</span><span class="sxs-lookup"><span data-stu-id="3895c-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="3895c-113">Делегат имеет сигнатуру</span><span class="sxs-lookup"><span data-stu-id="3895c-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="3895c-114">где `state` — это объект, содержащий данные, используемые делегатом.</span><span class="sxs-lookup"><span data-stu-id="3895c-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="3895c-115">Фактические данные могут передаваться делегата путем вызова <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> метод.</span><span class="sxs-lookup"><span data-stu-id="3895c-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3895c-116">Потоки в пул управляемых потоков — это фоновые потоки.</span><span class="sxs-lookup"><span data-stu-id="3895c-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="3895c-117">То есть их <xref:System.Threading.Thread.IsBackground%2A> свойства являются `true`.</span><span class="sxs-lookup"><span data-stu-id="3895c-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="3895c-118">Это означает, что <xref:System.Threading.ThreadPool> поток не будет поддерживать работу после все основные потоки освободят приложения.</span><span class="sxs-lookup"><span data-stu-id="3895c-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3895c-119">Когда пул потоков повторно использует поток, он не очищает данные в локальном хранилище потока или в поля, помеченные атрибутом <xref:System.ThreadStaticAttribute> атрибута.</span><span class="sxs-lookup"><span data-stu-id="3895c-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="3895c-120">Таким образом, когда метод проверяет локальное хранилище потока или полей, будут отмечены <xref:System.ThreadStaticAttribute> атрибут, значения, он находит может остаться после более ранних версий используйте потока из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="3895c-121">Также можно поместить в очередь рабочие элементы, не относящиеся к операции ожидания в пул потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="3895c-122">Чтобы запросить, что рабочий элемент должен обрабатываться потоком в пуле потоков, вызовите <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="3895c-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="3895c-123">Этот метод принимает в качестве параметра ссылку на метод или делегат, который будет вызываться в потоке из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="3895c-124">Нет способа отмены рабочего элемента, после его находится в очереди.</span><span class="sxs-lookup"><span data-stu-id="3895c-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="3895c-125">Таймеры очереди и зарегистрированные операции ожидания также используют пул потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="3895c-126">Их функции обратного вызова помещаются в очередь в пул потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="3895c-127">Имеется один пул потоков каждого процесса.</span><span class="sxs-lookup"><span data-stu-id="3895c-127">There is one thread pool per process.</span></span> <span data-ttu-id="3895c-128">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] размер по умолчанию пула потоков для процесса зависит от нескольких факторов, таких как размер виртуального адресного пространства.</span><span class="sxs-lookup"><span data-stu-id="3895c-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="3895c-129">Процесс может вызвать метод <xref:System.Threading.ThreadPool.GetMaxThreads%2A> для определения количества потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="3895c-130">Число потоков в пуле потоков может быть изменен с помощью <xref:System.Threading.ThreadPool.SetMaxThreads%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="3895c-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="3895c-131">Каждый поток использует размер стека по умолчанию и выполняется с приоритетом по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="3895c-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3895c-132">Неуправляемый код, на котором размещается платформа .NET Framework можно изменить размер пула потоков с помощью `CorSetMaxThreads` функции, определенной в файле mscoree.h.</span><span class="sxs-lookup"><span data-stu-id="3895c-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="3895c-133">Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу, пока не будет достигнуто минимальное значение для каждой категории.</span><span class="sxs-lookup"><span data-stu-id="3895c-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="3895c-134">При достижении минимума пул потоков можно создавать дополнительные потоки в этой категории или дождитесь завершения выполнения некоторых задач.</span><span class="sxs-lookup"><span data-stu-id="3895c-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="3895c-135">Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] пул потоков создает и уничтожает рабочие потоки в целях оптимизации пропускной способности, которая определяется как количество задач, завершаемых за единицу времени.</span><span class="sxs-lookup"><span data-stu-id="3895c-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="3895c-136">Слишком малое количество потоков может препятствовать оптимальному использованию доступных ресурсов, тогда как слишком большое их количество может усиливать конкуренцию за ресурсы.</span><span class="sxs-lookup"><span data-stu-id="3895c-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3895c-137">Если потребность низкая, фактическое количество потоков из пула потоков может быть ниже минимальных значений.</span><span class="sxs-lookup"><span data-stu-id="3895c-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="3895c-138">Для получения этих минимальных значений можно использовать метод <xref:System.Threading.ThreadPool.GetMinThreads%2A>.</span><span class="sxs-lookup"><span data-stu-id="3895c-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3895c-139">Можно использовать <xref:System.Threading.ThreadPool.SetMinThreads%2A> метод, чтобы увеличить минимальное количество потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="3895c-140">Однако необоснованное увеличение этих значений может привести к снижению производительности.</span><span class="sxs-lookup"><span data-stu-id="3895c-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="3895c-141">Если одновременно запускается слишком много задач, все они могут выполняться слишком медленно.</span><span class="sxs-lookup"><span data-stu-id="3895c-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="3895c-142">В большинстве случаев пул потоков работает наилучшим образом, если он использует собственный алгоритм выделения потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3895c-143">В следующем примере основного потока приложения помещает метод с именем `ThreadProc` для выполнения в потоке пула потоков, бездействует одной секунде, а затем завершает работу.</span><span class="sxs-lookup"><span data-stu-id="3895c-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="3895c-144">`ThreadProc` Метод просто отображает сообщение.</span><span class="sxs-lookup"><span data-stu-id="3895c-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="3895c-145">Если закомментировать вызов <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод, основной поток завершает работу до выполнения метода в потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="3895c-146">Пул потоков использует фоновые потоки, которые не смогут обеспечить работоспособность приложения при всех основных потоков завершены.</span><span class="sxs-lookup"><span data-stu-id="3895c-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="3895c-147">(Это простой пример гонки).</span><span class="sxs-lookup"><span data-stu-id="3895c-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="3895c-148">Данный тип потокобезопасен.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3895c-148">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3895c-149">Связывает дескриптор операционной системы с объектом <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-149">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="3895c-150">Структура <see cref="T:System.IntPtr" />, хранящая дескриптор.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-150">An <see cref="T:System.IntPtr" /> that holds the handle.</span>
          </span>
          <span data-ttu-id="3895c-151">Дескриптор должен быть открыт для перекрывающегося ввода-вывода в неуправляемой области.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-151">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-152">Связывает дескриптор операционной системы с объектом <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-152">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-153">Значение <see langword="true" />, если дескриптор является связанным; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-153">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="3895c-154">У вызывающего объекта отсутствует необходимое разрешение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-154">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="3895c-155">для возможности вызова неуправляемого кода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-155">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="3895c-156">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-156">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="3895c-157">Объект <see cref="T:System.Runtime.InteropServices.SafeHandle" />, содержащий дескриптор операционной системы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-157">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span>
          </span>
          <span data-ttu-id="3895c-158">Дескриптор должен быть открыт для перекрывающегося ввода-вывода в неуправляемой области.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-158">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-159">Связывает дескриптор операционной системы с объектом <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-159">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-160">Значение <see langword="true" />, если дескриптор является связанным; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-160">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-161">`osHandle` Параметр должен быть <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, который является производным от абстрактного <xref:System.Runtime.InteropServices.SafeHandle> класса.</span><span class="sxs-lookup"><span data-stu-id="3895c-161">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3895c-162">Свойство <paramref name="osHandle" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-162">
              <paramref name="osHandle" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="3895c-163">для возможности вызова неуправляемого кода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-163">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="3895c-164">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-164">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="3895c-165">Количество доступных рабочих потоков.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-165">The number of available worker threads.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="3895c-166">Количество доступных потоков асинхронного ввода-вывода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-166">The number of available asynchronous I/O threads.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-167">Возвращает разницу между максимальным числом потоков пула, возвращаемых методом <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />, и числом активных в данный момент потоков.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-167">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-168">Когда <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> возвращает, переменная, указанная параметром `workerThreads` содержит число дополнительных рабочих потоков, которые могут быть запущены и переменная, указанная параметром `completionPortThreads` содержит число дополнительных потоков асинхронного ввода-вывода, которые могут быть к работе.</span><span class="sxs-lookup"><span data-stu-id="3895c-168">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="3895c-169">Если нет доступных потоков, запросы к пулу дополнительный поток остаются в очереди, пока не станут доступными из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-169">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3895c-170">Следующий пример отображает количество рабочих потоков и потоков ввода-вывода, доступных, когда запускается простое приложение.</span><span class="sxs-lookup"><span data-stu-id="3895c-170">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="3895c-171">Максимальное количество рабочих потоков в пуле потоков.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-171">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="3895c-172">Максимальное количество потоков асинхронного ввода-вывода в пуле потоков.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-172">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-173">Возвращает количество запросов к пулу потоков, которые могут быть активными одновременно.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-173">Retrieves the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="3895c-174">Все запросы, превышающие это количество, остаются в очереди до тех пор, пока потоки пула не станут доступны.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-174">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-175">Когда <xref:System.Threading.ThreadPool.GetMaxThreads%2A> возвращает, переменная, указанная параметром `workerThreads` содержит максимальное число рабочих потоков, допустимых в пуле потоков, а переменная, указанная параметром `completionPortThreads` содержит максимальное количество потоков асинхронного ввода-вывода, разрешенных в пул потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-175">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="3895c-176">Можно использовать <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> метод, чтобы определить фактическое число потоков в пуле потоков в любой момент времени.</span><span class="sxs-lookup"><span data-stu-id="3895c-176">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="3895c-177">Можно использовать <xref:System.Threading.ThreadPool.SetMaxThreads%2A> задать максимальное число рабочих потоков и потоков асинхронного ввода-вывода в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-177">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="3895c-178">Можно поместить в очередь многие запросы к пулу потоков, сколько позволяет системной памяти.</span><span class="sxs-lookup"><span data-stu-id="3895c-178">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="3895c-179">Если запросов больше, чем пула потоков, дополнительные запросы остаются в очереди, пока не станут доступными из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-179">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3895c-180">В следующем примере кода показано, как получить число доступных и максимальное число потоков в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-180">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="3895c-181">Рабочий элемент помещается в очередь, использует `FileStream` для асинхронной записи в два файла.</span><span class="sxs-lookup"><span data-stu-id="3895c-181">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="3895c-182">Перекрывать методы обратного вызова истекло время ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-182">The callback methods are timed to overlap.</span></span> <span data-ttu-id="3895c-183">Рабочий поток обрабатывает рабочий элемент, и в зависимости от скорости и количества процессоров на компьютере, одного или двух потоков портов завершения обработки операций записи.</span><span class="sxs-lookup"><span data-stu-id="3895c-183">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="3895c-184">При возвращении метода содержит минимальное количество рабочих потоков, которые создаются пулом потоков по требованию.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-184">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="3895c-185">При возвращении метода содержит минимальное количество потоков асинхронного ввода-вывода, которые создаются пулом потоков по требованию.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-185">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-186">Возвращает минимальное число потоков, создаваемых пулом потоков по требованию по мере поступления новых запросов перед переходом на алгоритм управления созданием и уничтожением потоков.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-186">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-187">Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу, пока не будет достигнуто минимальное значение для каждой категории.</span><span class="sxs-lookup"><span data-stu-id="3895c-187">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="3895c-188">Минимальное количество потоков по умолчанию присваивается количество процессоров в системе.</span><span class="sxs-lookup"><span data-stu-id="3895c-188">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="3895c-189">При достижении минимума пул потоков может создавать дополнительные потоки в этой категории или дождитесь завершения выполнения некоторых задач.</span><span class="sxs-lookup"><span data-stu-id="3895c-189">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="3895c-190">Начиная с версии [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], пул потоков, создание и удаление потоков для оптимизации пропускной способности, которая определяется как количество задач, завершаемых за единицу времени.</span><span class="sxs-lookup"><span data-stu-id="3895c-190">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="3895c-191">Слишком малое количество потоков может препятствовать оптимальному использованию доступных ресурсов, тогда как слишком большое их количество может усиливать конкуренцию за ресурсы.</span><span class="sxs-lookup"><span data-stu-id="3895c-191">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3895c-192">Если потребность низкая, фактическое количество потоков из пула потоков может быть ниже минимальных значений.</span><span class="sxs-lookup"><span data-stu-id="3895c-192">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3895c-193">Следующий пример задает минимальное количество рабочих потоков до четырех и сохраняет исходное значение минимальное количество потоков асинхронного завершения ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="3895c-193">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3895c-194">Помещает метод в очередь на выполнение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-194">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="3895c-195">Метод выполняется, когда становится доступен поток из пула потоков.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-195">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="3895c-196">Делегат <see cref="T:System.Threading.WaitCallback" />, представляющий метод, который требуется выполнить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-196">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-197">Помещает метод в очередь на выполнение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-197">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="3895c-198">Метод выполняется, когда становится доступен поток из пула потоков.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-198">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-199">Значение <see langword="true" />, если метод успешно помещен в очередь. Если рабочий элемент не может быть помещен очередь, выдается исключение <see cref="T:System.NotSupportedException" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-199">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-200">Можно поместить данные, необходимые в очереди в поля экземпляра класса, в котором определен метод, или можно использовать метод <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> перегрузку, которая принимает объект, содержащий необходимые данные.</span><span class="sxs-lookup"><span data-stu-id="3895c-200">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3895c-201">Пользователи Visual Basic могут опускать <xref:System.Threading.WaitCallback> конструктора и просто использовать `AddressOf` оператор при передаче в метод обратного вызова, <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="3895c-201">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="3895c-202">Visual Basic автоматически вызывает соответствующий конструктор делегата.</span><span class="sxs-lookup"><span data-stu-id="3895c-202">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="3895c-203">Сведения о версии</span><span class="sxs-lookup"><span data-stu-id="3895c-203">Version Information</span></span>  
 <span data-ttu-id="3895c-204">В .NET Framework версии 2.0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="3895c-204">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="3895c-205">В более ранних версий информация об участнике не распространяются.</span><span class="sxs-lookup"><span data-stu-id="3895c-205">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3895c-206">В следующем примере используется <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> перегрузку метода в очередь задачу, представленный `ThreadProc` метод для выполнения, когда поток станет доступным.</span><span class="sxs-lookup"><span data-stu-id="3895c-206">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="3895c-207">Сведения о задачах предоставляется с помощью этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="3895c-207">No task information is supplied with this overload.</span></span> <span data-ttu-id="3895c-208">Поэтому сведения, позволяющие `ThreadProc` метод ограничен объект принадлежит метод.</span><span class="sxs-lookup"><span data-stu-id="3895c-208">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3895c-209">Свойство <paramref name="callBack" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-209">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3895c-210">Среда CLR является размещенной, а основное приложение не поддерживает это действие.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-210">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="3895c-211">Делегат <see cref="T:System.Threading.WaitCallback" />, представляющий выполняемый метод.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-211">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="3895c-212">Объект, содержащий данные, используемые методом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-212">An object containing data to be used by the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-213">Помещает метод в очередь на выполнение и указывает объект, содержащий данные для использования методом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-213">Queues a method for execution, and specifies an object containing data to be used by the method.</span>
          </span>
          <span data-ttu-id="3895c-214">Метод выполняется, когда становится доступен поток из пула потоков.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-214">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-215">Значение <see langword="true" />, если метод успешно помещен в очередь. Если рабочий элемент не может быть помещен очередь, выдается исключение <see cref="T:System.NotSupportedException" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-215">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-216">Если метод обратного вызова требуются сложные данные, можно определить класс, содержащий данные.</span><span class="sxs-lookup"><span data-stu-id="3895c-216">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3895c-217">Пользователи Visual Basic могут опускать <xref:System.Threading.WaitCallback> конструктора и просто использовать `AddressOf` оператор при передаче в метод обратного вызова, <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="3895c-217">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="3895c-218">Visual Basic автоматически вызывает соответствующий конструктор делегата.</span><span class="sxs-lookup"><span data-stu-id="3895c-218">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="3895c-219">Сведения о версии</span><span class="sxs-lookup"><span data-stu-id="3895c-219">Version Information</span></span>  
 <span data-ttu-id="3895c-220">В .NET Framework версии 2.0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="3895c-220">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="3895c-221">В более ранних версий информация об участнике не распространяются.</span><span class="sxs-lookup"><span data-stu-id="3895c-221">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3895c-222">В следующем примере пул потоков .NET для вычисления `Fibonacci` результат для пяти числа в диапазоне от 20 до 40.</span><span class="sxs-lookup"><span data-stu-id="3895c-222">The following example uses the .NET thread pool to calculate the `Fibonacci` result for five numbers between 20 and 40.</span></span> <span data-ttu-id="3895c-223">Каждый результат `Fibonacci` представлен классом `Fibonacci`, который предоставляет метод с именем `ThreadPoolCallback`, выполняющий вычисление.</span><span class="sxs-lookup"><span data-stu-id="3895c-223">Each `Fibonacci` result is represented by the `Fibonacci` class, which provides a method named `ThreadPoolCallback` that performs the calculation.</span></span> <span data-ttu-id="3895c-224">Создается объект, представляющий каждое значение `Fibonacci`, а затем метод `ThreadPoolCallback` передается в объект <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, который назначает для выполнения метода доступный в пуле поток.</span><span class="sxs-lookup"><span data-stu-id="3895c-224">An object that represents each `Fibonacci` value is created, and the `ThreadPoolCallback` method is passed to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, which assigns an available thread in the pool to execute the method.</span></span>  
  
 <span data-ttu-id="3895c-225">Так как каждый `Fibonacci` объекту присваивается полупроизвольное значение для вычисления, и так как каждый поток будут конкурировать за ресурсы процессора, не знает заранее, сколько времени потребуется для всех пяти результатов необходимо вычислить.</span><span class="sxs-lookup"><span data-stu-id="3895c-225">Because each `Fibonacci` object is given a semi-random value to compute, and because each thread will be competing for processor time, you cannot know in advance how long it will take for all five results to be calculated.</span></span> <span data-ttu-id="3895c-226">Именно поэтому во время конструирования каждому объекту `Fibonacci` передается экземпляр класса <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="3895c-226">That is why each `Fibonacci` object is passed an instance of the <xref:System.Threading.ManualResetEvent> class during construction.</span></span> <span data-ttu-id="3895c-227">Каждый объект сигнализирует предоставленному объекту события когда его вычисление будет завершена, который позволяет основному потоку блокировать выполнение <xref:System.Threading.WaitHandle.WaitAll%2A> до всех пяти `Fibonacci` объектов вычисления результата.</span><span class="sxs-lookup"><span data-stu-id="3895c-227">Each object signals the provided event object when its calculation is complete, which allows the primary thread to block execution with <xref:System.Threading.WaitHandle.WaitAll%2A> until all five `Fibonacci` objects have calculated a result.</span></span> <span data-ttu-id="3895c-228">После этого метод `Main` отображает каждый результат `Fibonacci`.</span><span class="sxs-lookup"><span data-stu-id="3895c-228">The `Main` method then displays each `Fibonacci` result.</span></span>
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3895c-229">Среда CLR является размещенной, а основное приложение не поддерживает это действие.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-229">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3895c-230">Свойство <paramref name="callBack" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-230">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3895c-231">Регистрирует делегат, ожидающий объект <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-231">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="3895c-232">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-232">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="3895c-233">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-233">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="3895c-234">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-234">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="3895c-235">Передаваемый делегату объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-235">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="3895c-236">Время ожидания в миллисекундах.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-236">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="3895c-237">Если параметр <c>millisecondsTimeOutInterval</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-237">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="3895c-238">Если параметр <c>millisecondsTimeOutInterval</c> равен –1, время ожидания функции никогда не истекает.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-238">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="3895c-239">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-239">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-240">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-240">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-241">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, инкапсулирующий собственный дескриптор.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-241">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-242">При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-242">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="3895c-243">Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="3895c-243">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="3895c-244">Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.</span><span class="sxs-lookup"><span data-stu-id="3895c-244">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="3895c-245"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод ставит в очередь указанный делегат в пул потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-245">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="3895c-246">Рабочий поток выполняет делегат, когда происходит одно из следующих:</span><span class="sxs-lookup"><span data-stu-id="3895c-246">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="3895c-247">Указанный объект находится в сигнальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="3895c-247">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="3895c-248">По истечении интервала времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-248">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="3895c-249"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод проверяет текущее состояние заданного объекта <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="3895c-249">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="3895c-250">Если состояние объекта является сигналом, метод регистрирует операцию ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-250">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="3895c-251">Поток из пула потоков выполняет операцию ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-251">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="3895c-252">Делегат выполняется в рабочем потоке, когда переходит в сигнальное состояние объекта или по истечении интервала времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-252">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="3895c-253">Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или по истечении интервала времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-253">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3895c-254">С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-254">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="3895c-255">Вместо <xref:System.Threading.Mutex>, использовать <xref:System.Threading.Semaphore> с максимальное число, равное 1.</span><span class="sxs-lookup"><span data-stu-id="3895c-255">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="3895c-256">Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="3895c-256">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="3895c-257">Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для наблюдения за зарегистрированные операции ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-257">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="3895c-258">Таким образом, если необходимо использовать же собственный дескриптор операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, следует повторно используя Win32 `DuplicateHandle` функции.</span><span class="sxs-lookup"><span data-stu-id="3895c-258">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="3895c-259">Обратите внимание, что не следует посылать объект события, передаваемый <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.</span><span class="sxs-lookup"><span data-stu-id="3895c-259">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="3895c-260">Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации.</span><span class="sxs-lookup"><span data-stu-id="3895c-260">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="3895c-261">Изменение происходит только для объекта условия ожидания вызвало которого сигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="3895c-261">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="3895c-262">Например счетчик семафора уменьшается на единицу.</span><span class="sxs-lookup"><span data-stu-id="3895c-262">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="3895c-263">Сведения о версии</span><span class="sxs-lookup"><span data-stu-id="3895c-263">Version Information</span></span>  
 <span data-ttu-id="3895c-264">Начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="3895c-264">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="3895c-265">В более ранних версий информация об участнике не распространяются.</span><span class="sxs-lookup"><span data-stu-id="3895c-265">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3895c-266">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-266">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="3895c-267">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-267">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="3895c-268">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-268">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="3895c-269">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-269">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="3895c-270">Передаваемый делегату объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-270">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="3895c-271">Время ожидания в миллисекундах.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-271">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="3895c-272">Если параметр <c>millisecondsTimeOutInterval</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-272">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="3895c-273">Если параметр <c>millisecondsTimeOutInterval</c> равен –1, время ожидания функции никогда не истекает.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-273">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="3895c-274">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-274">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-275">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 64-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-275">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-276">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, инкапсулирующий собственный дескриптор.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-276">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-277">При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-277">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="3895c-278">Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="3895c-278">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="3895c-279">Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.</span><span class="sxs-lookup"><span data-stu-id="3895c-279">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="3895c-280"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод ставит в очередь указанный делегат в пул потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-280">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="3895c-281">Рабочий поток выполняет делегат, когда происходит одно из следующих:</span><span class="sxs-lookup"><span data-stu-id="3895c-281">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="3895c-282">Указанный объект находится в сигнальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="3895c-282">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="3895c-283">По истечении интервала времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-283">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="3895c-284"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод проверяет текущее состояние заданного объекта <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="3895c-284">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="3895c-285">Если состояние объекта является сигналом, метод регистрирует операцию ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-285">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="3895c-286">Поток из пула потоков выполняет операцию ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-286">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="3895c-287">Делегат выполняется в рабочем потоке, когда переходит в сигнальное состояние объекта или по истечении интервала времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-287">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="3895c-288">Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или по истечении интервала времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-288">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3895c-289">С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-289">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="3895c-290">Вместо <xref:System.Threading.Mutex>, использовать <xref:System.Threading.Semaphore> с максимальное число, равное 1.</span><span class="sxs-lookup"><span data-stu-id="3895c-290">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="3895c-291">Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="3895c-291">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="3895c-292">Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для наблюдения за зарегистрированные операции ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-292">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="3895c-293">Таким образом, если необходимо использовать же собственный дескриптор операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, следует повторно используя Win32 `DuplicateHandle` функции.</span><span class="sxs-lookup"><span data-stu-id="3895c-293">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="3895c-294">Обратите внимание, что не следует посылать объект события, передаваемый <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.</span><span class="sxs-lookup"><span data-stu-id="3895c-294">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="3895c-295">Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации.</span><span class="sxs-lookup"><span data-stu-id="3895c-295">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="3895c-296">Изменение происходит только для объекта условия ожидания вызвало которого сигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="3895c-296">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="3895c-297">Например счетчик семафора уменьшается на единицу.</span><span class="sxs-lookup"><span data-stu-id="3895c-297">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="3895c-298">Сведения о версии</span><span class="sxs-lookup"><span data-stu-id="3895c-298">Version Information</span></span>  
 <span data-ttu-id="3895c-299">Начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="3895c-299">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="3895c-300">В более ранних версий информация об участнике не распространяются.</span><span class="sxs-lookup"><span data-stu-id="3895c-300">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3895c-301">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-301">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="3895c-302">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-302">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="3895c-303">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-303">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="3895c-304">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-304">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="3895c-305">Передаваемый делегату объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-305">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="3895c-306">Время ожидания, представленное объектом <see cref="T:System.TimeSpan" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-306">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="3895c-307">Если параметр <c>timeout</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-307">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="3895c-308">Если параметр <c>timeout</c> равен –1, время ожидания функции никогда не истекает.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-308">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="3895c-309">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-309">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-310">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая значение <see cref="T:System.TimeSpan" /> для времени ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-310">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-311">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, инкапсулирующий собственный дескриптор.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-311">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-312">При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-312">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="3895c-313">Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="3895c-313">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="3895c-314">Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.</span><span class="sxs-lookup"><span data-stu-id="3895c-314">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="3895c-315"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод ставит в очередь указанный делегат в пул потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-315">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="3895c-316">Рабочий поток выполняет делегат, когда происходит одно из следующих:</span><span class="sxs-lookup"><span data-stu-id="3895c-316">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="3895c-317">Указанный объект находится в сигнальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="3895c-317">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="3895c-318">По истечении интервала времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-318">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="3895c-319"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод проверяет текущее состояние заданного объекта <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="3895c-319">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="3895c-320">Если состояние объекта является сигналом, метод регистрирует операцию ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-320">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="3895c-321">Поток из пула потоков выполняет операцию ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-321">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="3895c-322">Делегат выполняется в рабочем потоке, когда переходит в сигнальное состояние объекта или по истечении интервала времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-322">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="3895c-323">Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или по истечении интервала времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-323">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3895c-324">С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-324">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="3895c-325">Вместо <xref:System.Threading.Mutex>, использовать <xref:System.Threading.Semaphore> с максимальное число, равное 1.</span><span class="sxs-lookup"><span data-stu-id="3895c-325">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="3895c-326">Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="3895c-326">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="3895c-327">Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для наблюдения за зарегистрированные операции ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-327">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="3895c-328">Таким образом, если необходимо использовать же собственный дескриптор операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, следует повторно используя Win32 `DuplicateHandle` функции.</span><span class="sxs-lookup"><span data-stu-id="3895c-328">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="3895c-329">Обратите внимание, что не следует посылать объект события, передаваемый <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.</span><span class="sxs-lookup"><span data-stu-id="3895c-329">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="3895c-330">Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации.</span><span class="sxs-lookup"><span data-stu-id="3895c-330">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="3895c-331">Изменение происходит только для объекта условия ожидания вызвало которого сигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="3895c-331">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="3895c-332">Например счетчик семафора уменьшается на единицу.</span><span class="sxs-lookup"><span data-stu-id="3895c-332">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="3895c-333">Сведения о версии</span><span class="sxs-lookup"><span data-stu-id="3895c-333">Version Information</span></span>  
 <span data-ttu-id="3895c-334">Начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="3895c-334">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="3895c-335">В более ранних версий информация об участнике не распространяются.</span><span class="sxs-lookup"><span data-stu-id="3895c-335">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3895c-336">Значение параметра <paramref name="timeout" /> меньше –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-336">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3895c-337">Значение параметра <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-337">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="3895c-338">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-338">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="3895c-339">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-339">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="3895c-340">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-340">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="3895c-341">Передаваемый делегату объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-341">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="3895c-342">Время ожидания в миллисекундах.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-342">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="3895c-343">Если параметр <c>millisecondsTimeOutInterval</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-343">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="3895c-344">Если параметр <c>millisecondsTimeOutInterval</c> равен –1, время ожидания функции никогда не истекает.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-344">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="3895c-345">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-345">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-346">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа без знака.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-346">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-347">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-347">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-348">При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-348">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="3895c-349">Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="3895c-349">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="3895c-350">Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.</span><span class="sxs-lookup"><span data-stu-id="3895c-350">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="3895c-351"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод ставит в очередь указанный делегат в пул потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-351">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="3895c-352">Рабочий поток выполняет делегат, когда происходит одно из следующих:</span><span class="sxs-lookup"><span data-stu-id="3895c-352">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="3895c-353">Указанный объект находится в сигнальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="3895c-353">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="3895c-354">По истечении интервала времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-354">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="3895c-355"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод проверяет текущее состояние заданного объекта <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="3895c-355">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="3895c-356">Если состояние объекта является сигналом, метод регистрирует операцию ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-356">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="3895c-357">Поток из пула потоков выполняет операцию ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-357">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="3895c-358">Делегат выполняется в рабочем потоке, когда переходит в сигнальное состояние объекта или по истечении интервала времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-358">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="3895c-359">Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или по истечении интервала времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-359">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3895c-360">С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-360">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="3895c-361">Вместо <xref:System.Threading.Mutex>, использовать <xref:System.Threading.Semaphore> с максимальное число, равное 1.</span><span class="sxs-lookup"><span data-stu-id="3895c-361">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="3895c-362">Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="3895c-362">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="3895c-363">Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для наблюдения за зарегистрированные операции ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-363">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="3895c-364">Таким образом, если необходимо использовать же собственный дескриптор операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, следует повторно используя Win32 `DuplicateHandle` функции.</span><span class="sxs-lookup"><span data-stu-id="3895c-364">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="3895c-365">Обратите внимание, что не следует посылать объект события, передаваемый <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.</span><span class="sxs-lookup"><span data-stu-id="3895c-365">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="3895c-366">Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации.</span><span class="sxs-lookup"><span data-stu-id="3895c-366">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="3895c-367">Изменение происходит только для объекта условия ожидания вызвало которого сигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="3895c-367">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="3895c-368">Например счетчик семафора уменьшается на единицу.</span><span class="sxs-lookup"><span data-stu-id="3895c-368">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="3895c-369">Сведения о версии</span><span class="sxs-lookup"><span data-stu-id="3895c-369">Version Information</span></span>  
 <span data-ttu-id="3895c-370">Начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="3895c-370">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="3895c-371">В более ранних версий информация об участнике не распространяются.</span><span class="sxs-lookup"><span data-stu-id="3895c-371">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3895c-372">В следующем примере показано, как использовать <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> методом, выполняемым указанный метод обратного вызова, когда сигнал дескриптор ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-372">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="3895c-373">В этом примере метод обратного вызова — `WaitProc`, и дескриптора ожидания <xref:System.Threading.AutoResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="3895c-373">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="3895c-374">В примере определяется `TaskInfo` класса для хранения сведений, который передается методу обратного вызова при его выполнении.</span><span class="sxs-lookup"><span data-stu-id="3895c-374">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="3895c-375">В примере создается `TaskInfo` , которому присваивается некоторых строковых данных.</span><span class="sxs-lookup"><span data-stu-id="3895c-375">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="3895c-376"><xref:System.Threading.RegisteredWaitHandle> , Возвращаемый <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод назначается `Handle` поле `TaskInfo` таким образом, метод обратного вызова имеет доступ к <xref:System.Threading.RegisteredWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="3895c-376">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="3895c-377">Помимо указания `TaskInfo` как объект, передаваемый в метод обратного вызова, вызов <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> указывает метод <xref:System.Threading.AutoResetEvent> которого задачи будут ожидать, <xref:System.Threading.WaitOrTimerCallback> делегат, представляющий `WaitProc` метод обратного вызова интервал времени ожидания в одну секунду и несколько обратных вызовов.</span><span class="sxs-lookup"><span data-stu-id="3895c-377">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="3895c-378">Когда основной поток не сигнализирует о <xref:System.Threading.AutoResetEvent> путем вызова его <xref:System.Threading.EventWaitHandle.Set%2A> метода <xref:System.Threading.WaitOrTimerCallback> вызове делегата.</span><span class="sxs-lookup"><span data-stu-id="3895c-378">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="3895c-379">`WaitProc` Тесты метод <xref:System.Threading.RegisteredWaitHandle> для определения, истекло ли время ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-379">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="3895c-380">Если был вызван обратный вызов, так как получил сигнал дескриптор ожидания, `WaitProc` отменяет регистрацию метод <xref:System.Threading.RegisteredWaitHandle>, остановка дополнительные обратные вызовы.</span><span class="sxs-lookup"><span data-stu-id="3895c-380">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="3895c-381">В случае времени ожидания она будет продолжать ожидать.</span><span class="sxs-lookup"><span data-stu-id="3895c-381">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="3895c-382">`WaitProc` Метод завершает сообщение в окно консоли.</span><span class="sxs-lookup"><span data-stu-id="3895c-382">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3895c-383">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-383">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="3895c-384">Максимальное количество рабочих потоков в пуле потоков.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-384">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="3895c-385">Максимальное количество потоков асинхронного ввода-вывода в пуле потоков.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-385">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-386">Задает количество запросов к пулу потоков, которые могут быть активными одновременно.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-386">Sets the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="3895c-387">Все запросы, превышающие это количество, остаются в очереди до тех пор, пока потоки пула не станут доступны.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-387">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-388">Значение <see langword="true" />, если изменение выполнено успешно; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-388">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-389">Максимальное число рабочих потоков или потоков завершения ввода-вывода в число не может задать меньше, чем количество процессоров на компьютере.</span><span class="sxs-lookup"><span data-stu-id="3895c-389">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="3895c-390">Чтобы определить, сколько процессоров присутствуют, получения значения <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> свойство.</span><span class="sxs-lookup"><span data-stu-id="3895c-390">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="3895c-391">Кроме того невозможно задать максимальное число рабочих потоков или потоков завершения ввода-вывода в число меньше, чем соответствующий минимальное количество рабочих потоков или потоков завершения ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="3895c-391">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="3895c-392">Чтобы определить размер пула потоков, минимальное, вызовите <xref:System.Threading.ThreadPool.GetMinThreads%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="3895c-392">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="3895c-393">Если среда CLR размещается, например с помощью Internet Information Services (IIS) или SQL Server, узел может ограничить или запретить изменение размера пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-393">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="3895c-394">Соблюдайте осторожность при изменении максимальное количество потоков в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-394">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="3895c-395">Во время вашего кода изменения могут возникнуть неблагоприятное воздействие на используемые библиотеки кода.</span><span class="sxs-lookup"><span data-stu-id="3895c-395">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="3895c-396">Задание слишком большой размер пула потоков может вызвать проблемы с производительностью.</span><span class="sxs-lookup"><span data-stu-id="3895c-396">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="3895c-397">Если слишком много потоков выполняются одновременно, переключение задач издержки становится существенной.</span><span class="sxs-lookup"><span data-stu-id="3895c-397">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="3895c-398">для возможности управления потоками.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-398">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="3895c-399">Значение разрешения: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-399">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="3895c-400">Минимальное количество рабочих потоков, которые создаются пулом потоков по требованию.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-400">The minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="3895c-401">Минимальное количество потоков асинхронного ввода-вывода, которые создаются пулом потоков по требованию.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-401">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-402">Задает минимальное число потоков, создаваемых пулом потоков по требованию по мере поступления новых запросов перед переходом на алгоритм управления созданием и уничтожением потоков.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-402">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-403">Значение <see langword="true" />, если изменение выполнено успешно; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-403">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-404">Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу, пока не будет достигнуто минимальное значение для каждой категории.</span><span class="sxs-lookup"><span data-stu-id="3895c-404">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="3895c-405">При достижении минимума пул потоков может создавать дополнительные потоки в этой категории или дождитесь завершения выполнения некоторых задач.</span><span class="sxs-lookup"><span data-stu-id="3895c-405">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="3895c-406">Начиная с версии [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], пул потоков, создание и удаление потоков для оптимизации пропускной способности, которая определяется как количество задач, завершаемых за единицу времени.</span><span class="sxs-lookup"><span data-stu-id="3895c-406">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="3895c-407">Слишком малое количество потоков может препятствовать оптимальному использованию доступных ресурсов, тогда как слишком большое их количество может усиливать конкуренцию за ресурсы.</span><span class="sxs-lookup"><span data-stu-id="3895c-407">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="3895c-408">Если потребность низкая, фактическое количество потоков из пула потоков может быть ниже минимальных значений.</span><span class="sxs-lookup"><span data-stu-id="3895c-408">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="3895c-409">Если указать отрицательное число или число, большее, чем максимальное число активных потоков пула потоков (полученное с помощью <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> возвращает `false` и не меняется наименьших значений.</span><span class="sxs-lookup"><span data-stu-id="3895c-409">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3895c-410">Минимальное количество потоков по умолчанию присваивается количество процессоров в системе.</span><span class="sxs-lookup"><span data-stu-id="3895c-410">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="3895c-411">Можно использовать <xref:System.Threading.ThreadPool.SetMinThreads%2A> метод для увеличения минимального числа ofthreads.</span><span class="sxs-lookup"><span data-stu-id="3895c-411">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number ofthreads.</span></span> <span data-ttu-id="3895c-412">Однако необоснованное увеличение этих значений может привести к снижению производительности.</span><span class="sxs-lookup"><span data-stu-id="3895c-412">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="3895c-413">Если одновременно запускается слишком много задач, все они могут выполняться слишком медленно.</span><span class="sxs-lookup"><span data-stu-id="3895c-413">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="3895c-414">В большинстве случаев пул потоков работает наилучшим собственный алгоритм выделения потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-414">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="3895c-415">Уменьшить минимальное меньшего, чем количество процессоров также может вызвать снижение производительности.</span><span class="sxs-lookup"><span data-stu-id="3895c-415">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3895c-416">Следующий пример задает минимальное количество рабочих потоков до четырех и сохраняет исходное значение минимальное количество потоков асинхронного завершения ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="3895c-416">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="3895c-417">для возможности управления потоками.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-417">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="3895c-418">Значение разрешения: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-418">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">
          <span data-ttu-id="3895c-419">Помещаемая в очередь структура <see cref="T:System.Threading.NativeOverlapped" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-419">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-420">Помещает в очередь на выполнение операцию перекрывающегося ввода-вывода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-420">Queues an overlapped I/O operation for execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-421">Значение <see langword="true" />, если операция была успешна помещена в очередь порта завершения ввода-вывода; в противном случае значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-421">
              <see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-422">Сведения об использовании собственный доступ Win32 перекрывающегося ввода-вывода, см. в разделе <xref:System.Threading.Overlapped> класс, <xref:System.Threading.NativeOverlapped> структуры и `OVERLAPPED` структуры в пакете SDK для платформы Win32.</span><span class="sxs-lookup"><span data-stu-id="3895c-422">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3895c-423">С помощью <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> метод может непреднамеренно открыть брешь в системе безопасности.</span><span class="sxs-lookup"><span data-stu-id="3895c-423">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="3895c-424">Управление доступом для кода выполняет его проверки разрешений всех вызывающих объектов разрешений на стеке.</span><span class="sxs-lookup"><span data-stu-id="3895c-424">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="3895c-425">Когда работу в очереди для потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, стек потока из пула потоков не имеет контекста вызывающих.</span><span class="sxs-lookup"><span data-stu-id="3895c-425">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="3895c-426">Вредоносный код, можно воспользоваться этим, чтобы избежать проверки разрешений.</span><span class="sxs-lookup"><span data-stu-id="3895c-426">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="3895c-427">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-427">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="3895c-428">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-428">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="3895c-429">Метод <see cref="T:System.Threading.WaitCallback" />, представляющий делегат, который вызывается, когда потоку в пуле потоков назначается рабочий элемент.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-429">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="3895c-430">Объект, передаваемый делегату при вызове его из пула потоков.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-430">The object that is passed to the delegate when serviced from the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-431">Помещает указанный делегат в очередь пула потоков, но не распространяет вызывающий стек на рабочий поток.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-431">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-432">Значение <see langword="true" />, если метод завершается успешно. Если рабочий элемент не удалось поместить в очередь, создается исключение <see cref="T:System.OutOfMemoryException" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-432">
              <see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-433">В отличие от <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> метода <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> не распространяет вызывающий стек на рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="3895c-433">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="3895c-434">Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.</span><span class="sxs-lookup"><span data-stu-id="3895c-434">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3895c-435">С помощью <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> может непреднамеренно открыть брешь в системе безопасности.</span><span class="sxs-lookup"><span data-stu-id="3895c-435">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="3895c-436">Управление доступом для кода выполняет его проверки разрешений всех вызывающих объектов разрешений на стеке.</span><span class="sxs-lookup"><span data-stu-id="3895c-436">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="3895c-437">Когда работу в очереди для потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, стек потока из пула потоков не будет иметь контекст вызывающих.</span><span class="sxs-lookup"><span data-stu-id="3895c-437">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="3895c-438">Вредоносный код, можно воспользоваться этим, чтобы избежать проверки разрешений.</span><span class="sxs-lookup"><span data-stu-id="3895c-438">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="3895c-439">У вызывающего объекта отсутствует необходимое разрешение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-439">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3895c-440">Возникла ситуация нехватки памяти.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-440">An out-of-memory condition was encountered.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="3895c-441">Не удается поместить в очередь рабочий элемент.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-441">The work item could not be queued.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3895c-442">Свойство <paramref name="callBack" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-442">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="3895c-443">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-443">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="3895c-444">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-444">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3895c-445">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, но не распространяет вызывающий стек на рабочий поток.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-445">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="3895c-446">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-446">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="3895c-447">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-447">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="3895c-448">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-448">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="3895c-449">Передаваемый делегату объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-449">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="3895c-450">Время ожидания в миллисекундах.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-450">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="3895c-451">Если параметр <c>millisecondsTimeOutInterval</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-451">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="3895c-452">Если параметр <c>millisecondsTimeOutInterval</c> равен –1, время ожидания функции никогда не истекает.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-452">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="3895c-453">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-453">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-454">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-454">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="3895c-455">Этот метод не распространяет вызывающий стек на рабочий поток.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-455">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-456">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-456">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-457">В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метода <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек на рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="3895c-457">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="3895c-458">Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.</span><span class="sxs-lookup"><span data-stu-id="3895c-458">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3895c-459">С помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может непреднамеренно открыть брешь в системе безопасности.</span><span class="sxs-lookup"><span data-stu-id="3895c-459">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="3895c-460">Управление доступом для кода выполняет его проверки разрешений всех вызывающих объектов разрешений на стеке.</span><span class="sxs-lookup"><span data-stu-id="3895c-460">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="3895c-461">Когда работу в очереди для потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек потока из пула потоков не будет иметь контекст вызывающих.</span><span class="sxs-lookup"><span data-stu-id="3895c-461">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="3895c-462">Вредоносный код, можно воспользоваться этим, чтобы избежать проверки разрешений.</span><span class="sxs-lookup"><span data-stu-id="3895c-462">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="3895c-463">С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-463">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="3895c-464">При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-464">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="3895c-465">Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="3895c-465">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="3895c-466">Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.</span><span class="sxs-lookup"><span data-stu-id="3895c-466">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3895c-467">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-467">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="3895c-468">У вызывающего объекта отсутствует необходимое разрешение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-468">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="3895c-469">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-469">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="3895c-470">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-470">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="3895c-471">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-471">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="3895c-472">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-472">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="3895c-473">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-473">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="3895c-474">Передаваемый делегату объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-474">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="3895c-475">Время ожидания в миллисекундах.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-475">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="3895c-476">Если параметр <c>millisecondsTimeOutInterval</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-476">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="3895c-477">Если параметр <c>millisecondsTimeOutInterval</c> равен –1, время ожидания функции никогда не истекает.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-477">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="3895c-478">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-478">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-479">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 64-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-479">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="3895c-480">Этот метод не распространяет вызывающий стек на рабочий поток.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-480">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-481">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-481">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-482">В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метода <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек на рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="3895c-482">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="3895c-483">Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.</span><span class="sxs-lookup"><span data-stu-id="3895c-483">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3895c-484">С помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может непреднамеренно открыть брешь в системе безопасности.</span><span class="sxs-lookup"><span data-stu-id="3895c-484">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="3895c-485">Управление доступом для кода выполняет его проверки разрешений всех вызывающих объектов разрешений на стеке.</span><span class="sxs-lookup"><span data-stu-id="3895c-485">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="3895c-486">Когда работу в очереди для потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек потока из пула потоков не будет иметь контекст вызывающих.</span><span class="sxs-lookup"><span data-stu-id="3895c-486">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="3895c-487">Вредоносный код, можно воспользоваться этим, чтобы избежать проверки разрешений.</span><span class="sxs-lookup"><span data-stu-id="3895c-487">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="3895c-488">С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-488">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="3895c-489">При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-489">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="3895c-490">Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="3895c-490">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="3895c-491">Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.</span><span class="sxs-lookup"><span data-stu-id="3895c-491">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3895c-492">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-492">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="3895c-493">У вызывающего объекта отсутствует необходимое разрешение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-493">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="3895c-494">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-494">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="3895c-495">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-495">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="3895c-496">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-496">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="3895c-497">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-497">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="3895c-498">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-498">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="3895c-499">Передаваемый делегату объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-499">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="3895c-500">Время ожидания, представленное объектом <see cref="T:System.TimeSpan" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-500">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="3895c-501">Если параметр <c>timeout</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-501">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="3895c-502">Если параметр <c>timeout</c> равен –1, время ожидания функции никогда не истекает.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-502">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="3895c-503">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-503">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-504">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая значение <see cref="T:System.TimeSpan" /> для времени ожидания. Этот метод не распространяет вызывающий стек на рабочий поток.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-504">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-505">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-505">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-506">В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метода <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек на рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="3895c-506">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="3895c-507">Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.</span><span class="sxs-lookup"><span data-stu-id="3895c-507">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3895c-508">С помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может непреднамеренно открыть брешь в системе безопасности.</span><span class="sxs-lookup"><span data-stu-id="3895c-508">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="3895c-509">Управление доступом для кода выполняет его проверки разрешений всех вызывающих объектов разрешений на стеке.</span><span class="sxs-lookup"><span data-stu-id="3895c-509">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="3895c-510">Когда работу в очереди для потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек потока из пула потоков не будет иметь контекст вызывающих.</span><span class="sxs-lookup"><span data-stu-id="3895c-510">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="3895c-511">Вредоносный код, можно воспользоваться этим, чтобы избежать проверки разрешений.</span><span class="sxs-lookup"><span data-stu-id="3895c-511">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="3895c-512">С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-512">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="3895c-513">При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-513">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="3895c-514">Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="3895c-514">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="3895c-515">Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.</span><span class="sxs-lookup"><span data-stu-id="3895c-515">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3895c-516">Значение параметра <paramref name="timeout" /> меньше –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-516">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3895c-517">Значение параметра <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-517">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="3895c-518">У вызывающего объекта отсутствует необходимое разрешение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-518">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="3895c-519">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-519">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="3895c-520">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-520">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="3895c-521">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-521">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="3895c-522">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-522">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="3895c-523">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-523">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="3895c-524">Передаваемый делегату объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-524">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="3895c-525">Время ожидания в миллисекундах.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-525">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="3895c-526">Если параметр <c>millisecondsTimeOutInterval</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-526">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="3895c-527">Если параметр <c>millisecondsTimeOutInterval</c> равен –1, время ожидания функции никогда не истекает.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-527">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="3895c-528">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-528">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3895c-529">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа без знака.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-529">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="3895c-530">Этот метод не распространяет вызывающий стек на рабочий поток.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-530">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3895c-531">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-531">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3895c-532">В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метода <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек на рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="3895c-532">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="3895c-533">Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.</span><span class="sxs-lookup"><span data-stu-id="3895c-533">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3895c-534">С помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может непреднамеренно открыть брешь в системе безопасности.</span><span class="sxs-lookup"><span data-stu-id="3895c-534">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="3895c-535">Управление доступом для кода выполняет его проверки разрешений всех вызывающих объектов разрешений на стеке.</span><span class="sxs-lookup"><span data-stu-id="3895c-535">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="3895c-536">Когда работу в очереди для потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек потока из пула потоков не будет иметь контекст вызывающих.</span><span class="sxs-lookup"><span data-stu-id="3895c-536">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="3895c-537">Вредоносный код, можно воспользоваться этим, чтобы избежать проверки разрешений.</span><span class="sxs-lookup"><span data-stu-id="3895c-537">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="3895c-538">С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3895c-538">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="3895c-539">При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания.</span><span class="sxs-lookup"><span data-stu-id="3895c-539">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="3895c-540">Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="3895c-540">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="3895c-541">Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.</span><span class="sxs-lookup"><span data-stu-id="3895c-541">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="3895c-542">У вызывающего объекта отсутствует необходимое разрешение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-542">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="3895c-543">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-543">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="3895c-544">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3895c-544">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>