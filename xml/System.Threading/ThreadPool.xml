<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2a9494e53c8c3c4a4db1cc0f00c52b716f7945b8" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407000" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет пул потоков, который можно использовать для выполнения задач, отправки рабочих элементов, обработки асинхронного ввода-вывода, ожидания от имени других потоков и обработки таймеров.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Многие приложения создают потоки, которые проводят много времени в бездействующее состояние ожидания возникновения события. Другие потоки могут входить в бездействующее состояние только для периодически опрашивать для изменения или обновления сведений о состоянии. Пул потоков позволяет более эффективно использовать потоки, предоставляя приложения с пулом рабочих потоков, управляемых системой. Следующие примеры операций, которые используют пул потоков.  
  
-   При создании <xref:System.Threading.Tasks.Task> или <xref:System.Threading.Tasks.Task%601> объекта для выполнения некоторых задач асинхронно, по умолчанию, задача запланирована для выполнения в потоке пула потоков.  
  
-   Асинхронные таймеры используют пул потоков. Потоки из пула потоков выполнения обратных вызовов с <xref:System.Threading.Timer?displayProperty=nameWithType> класса и инициировать события из <xref:System.Timers.Timer?displayProperty=nameWithType> класса.  
  
-   При использовании дескрипторы ожидания зарегистрированного потока системы отслеживает состояние дескрипторов ожидания. По завершении операции ожидания рабочий поток из пула потоков выполняет соответствующую функцию обратного вызова.  
  
-   При вызове <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> метод в очередь метод для выполнения в потоке пула потоков. Это можно сделать, передав в метод <xref:System.Threading.WaitCallback> делегата.   Делегат имеет подпись  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     где `state` — это объект, содержащий данные для использования в делегат. Фактические данные могут передаваться делегата путем вызова <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> метод.  
  
> [!NOTE]
>  Потоки в пул управляемых потоков — это фоновые потоки. То есть их <xref:System.Threading.Thread.IsBackground%2A> свойства `true`. Это означает, что <xref:System.Threading.ThreadPool> поток не будет поддерживать выполнение приложения после все основные потоки вышли.  
  
> [!IMPORTANT]
>  Когда пул потоков повторно использует поток, не очищает данные в локальном хранилище потока или в поля, отмеченные <xref:System.ThreadStaticAttribute> атрибута. Таким образом, когда метод проверяет локальное хранилище потока или полей, отмеченные <xref:System.ThreadStaticAttribute> атрибут, находит значения может быть оставлено на более ранних использование пула потоков.  
  
 Можно также поместить в очередь рабочих элементов, которые не относятся к операции ожидания в пуле потоков. Для запроса, что рабочий элемент должен обрабатываться потоком в пуле потоков, вызовите <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> метод. Этот метод принимает в качестве параметра ссылку на метод или делегат, который будет вызываться из потока из пула потоков. Нет возможности для отмены рабочего элемента после ее поставлен в очередь.  
  
 Таймеры очереди и зарегистрированные операции ожидания также используют пул потоков. Их функции обратного вызова помещаются в очередь пула потоков.  
  
 Имеется один пул потоков для каждого процесса. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] размер по умолчанию пула потоков для процесса зависит от нескольких факторов, таких как размер виртуального адресного пространства. Процесс может вызвать метод <xref:System.Threading.ThreadPool.GetMaxThreads%2A> для определения количества потоков. Число потоков в пуле потоков может быть изменен с помощью <xref:System.Threading.ThreadPool.SetMaxThreads%2A> метод. Каждый поток использует размер стека по умолчанию и запускается с приоритетом по умолчанию.  
  
> [!NOTE]
>  Неуправляемый код, на котором размещена .NET Framework можно изменить размер пула потоков с помощью `CorSetMaxThreads` функции, определенные в файле mscoree.h.  
  
 Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу, пока не достигнет минимум для каждой категории. При достижении минимума пул потоков может создавать дополнительные потоки в этой категории или ожидать завершения некоторых задач. Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] пул потоков создает и уничтожает рабочие потоки в целях оптимизации пропускной способности, которая определяется как количество задач, завершаемых за единицу времени. Слишком малое количество потоков может препятствовать оптимальному использованию доступных ресурсов, тогда как слишком большое их количество может усиливать конкуренцию за ресурсы.  
  
> [!NOTE]
>  Если потребность низкая, фактическое количество потоков из пула потоков может быть ниже минимальных значений.  
  
 Для получения этих минимальных значений можно использовать метод <xref:System.Threading.ThreadPool.GetMinThreads%2A>.  
  
> [!CAUTION]
>  Можно использовать <xref:System.Threading.ThreadPool.SetMinThreads%2A> метод для увеличения минимального количества потоков. Однако необоснованное увеличение этих значений может привести к снижению производительности. Если одновременно запускается слишком много задач, все они могут выполняться слишком медленно. В большинстве случаев пул потоков работает наилучшим образом, если он использует собственный алгоритм выделения потоков.  
  
   
  
## Examples  
 В следующем примере основного потока приложения помещает в очередь метод с именем `ThreadProc` для выполнения в потоке пула потоков, бездействует в течение одной секунды, а затем завершает работу. `ThreadProc` Метод просто отображает сообщение.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 Если закомментировать вызов <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод, основной поток завершается прежде, чем метод выполняется в потоке пула потоков.  Пул потоков использует фоновые потоки, которые не могут поддерживать приложения, если все основные потоки завершились.  (Это простой пример состояние гонки).  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Связывает дескриптор операционной системы с объектом <see cref="T:System.Threading.ThreadPool" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">Структура <see cref="T:System.IntPtr" />, хранящая дескриптор. Дескриптор должен быть открыт для перекрывающегося ввода-вывода в неуправляемой области.</param>
        <summary>Связывает дескриптор операционной системы с объектом <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns>Значение <see langword="true" />, если дескриптор является связанным; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">Объект <see cref="T:System.Runtime.InteropServices.SafeHandle" />, содержащий дескриптор операционной системы. Дескриптор должен быть открыт для перекрывающегося ввода-вывода в неуправляемой области.</param>
        <summary>Связывает дескриптор операционной системы с объектом <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns>Значение <see langword="true" />, если дескриптор является связанным; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `osHandle` Параметр должен быть <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, который является производным от абстрактного <xref:System.Runtime.InteropServices.SafeHandle> класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="osHandle" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Количество доступных рабочих потоков.</param>
        <param name="completionPortThreads">Количество доступных потоков асинхронного ввода-вывода.</param>
        <summary>Возвращает разницу между максимальным числом потоков пула, возвращаемых методом <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />, и числом активных в данный момент потоков.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> возвращает переменную, указанную в `workerThreads` содержит число дополнительных рабочих потоков, которые могут быть запущены и переменную, указанную в `completionPortThreads` содержит число дополнительных потоков асинхронного ввода-вывода, может быть запущен.  
  
 Если нет доступных потоков, запросы к пулу потоков дополнительных остаются в очереди, пока не станут доступными пула потоков.  
  
   
  
## Examples  
 Следующий пример отображает число рабочих потоков и ввода-вывода потоков, доступных при запуске простого приложения.  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Максимальное количество рабочих потоков в пуле потоков.</param>
        <param name="completionPortThreads">Максимальное количество потоков асинхронного ввода-вывода в пуле потоков.</param>
        <summary>Возвращает количество запросов к пулу потоков, которые могут быть активными одновременно. Все запросы, превышающие это количество, остаются в очереди до тех пор, пока потоки пула не станут доступны.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Threading.ThreadPool.GetMaxThreads%2A> возвращает переменную, указанную в `workerThreads` содержит максимальное число рабочих потоков, допустимых в пуле потоков, а переменная, указанная параметром `completionPortThreads` содержит максимальное количество потоков асинхронного ввода-вывода в пул потоков.  
  
 Можно использовать <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> метод, чтобы определить фактическое количество потоков в пуле потоков в любой момент времени.  
  
 Можно использовать <xref:System.Threading.ThreadPool.SetMaxThreads%2A> Чтобы задать максимальное число рабочих потоков и потоков асинхронного ввода-вывода в пуле потоков.  
  
 Можно поместить в очередь многие запросы к пулу потоков, сколько позволяет системная память. Если запросов больше, чем потоки из пула потоков, дополнительные запросы остаются в очереди, пока не станут доступными пула потоков.  
  
   
  
## Examples  
 В следующем примере кода показано, как получить число доступных и максимального числа потоков в пуле потоков. Рабочий элемент в очередь, использует `FileStream` для асинхронной записи в два файла. Методы обратного вызова истекло время ожидания перекрываются друг с другом. Рабочий поток обрабатывает рабочий элемент, и в зависимости от скорости и количества процессоров на компьютере одного или двух потоков портов завершения обработки операций записи.  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">При возвращении метода содержит минимальное количество рабочих потоков, которые создаются пулом потоков по требованию.</param>
        <param name="completionPortThreads">При возвращении метода содержит минимальное количество потоков асинхронного ввода-вывода, которые создаются пулом потоков по требованию.</param>
        <summary>Возвращает минимальное число потоков, создаваемых пулом потоков по требованию по мере поступления новых запросов перед переходом на алгоритм управления созданием и уничтожением потоков.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу, пока не достигнет минимум для каждой категории. По умолчанию минимальное количество потоков равно числу процессоров в системе. По достижении минимального пула потоков может создавать дополнительные потоки в этой категории или ожидать завершения некоторых задач. Начиная с версии [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], пул потоков создает и уничтожает потоки в целях оптимизации пропускной способности, которая определяется как количество задач, завершаемых за единицу времени. Слишком малое количество потоков может препятствовать оптимальному использованию доступных ресурсов, тогда как слишком большое их количество может усиливать конкуренцию за ресурсы.  
  
> [!NOTE]
>  Если потребность низкая, фактическое количество потоков из пула потоков может быть ниже минимальных значений.  
  
   
  
## Examples  
 Следующий пример задает минимальное количество рабочих потоков до 4, а также сохраняет исходное значение минимальное количество потоков асинхронного завершения ввода-вывода.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Помещает метод в очередь на выполнение. Метод выполняется, когда становится доступен поток из пула потоков.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">Делегат <see cref="T:System.Threading.WaitCallback" />, представляющий метод, который требуется выполнить.</param>
        <summary>Помещает метод в очередь на выполнение. Метод выполняется, когда становится доступен поток из пула потоков.</summary>
        <returns>Значение <see langword="true" />, если метод успешно помещен в очередь. Если рабочий элемент не может быть помещен очередь, выдается исключение <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно разместить данные, необходимые для метода в очереди в поля экземпляра класса, в котором определен метод, или можно использовать <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> перегрузку, которая принимает объект, содержащий необходимые данные.  
  
> [!NOTE]
>  Пользователи Visual Basic могут опускать <xref:System.Threading.WaitCallback> конструктор и просто использовать `AddressOf` оператор при передаче в метод обратного вызова, <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic автоматически вызывает соответствующий конструктор делегата.  
  
## <a name="version-information"></a>Сведения о версии  
 В .NET Framework версии 2.0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> метод. В более ранних версиях информация об участнике не распространяются.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> перегрузка метода в очередь помещается задача, представленная `ThreadProc` метод для выполнения, когда поток становится доступной. Сведения о задачах предоставляется с помощью этой перегрузки. Таким образом, сведения, позволяющие `ThreadProc` метод ограничена объект принадлежит метод.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="callBack" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Среда CLR является размещенной, а основное приложение не поддерживает это действие.</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">Делегат <see cref="T:System.Threading.WaitCallback" />, представляющий выполняемый метод.</param>
        <param name="state">Объект, содержащий данные, используемые методом.</param>
        <summary>Помещает метод в очередь на выполнение и указывает объект, содержащий данные для использования методом. Метод выполняется, когда становится доступен поток из пула потоков.</summary>
        <returns>Значение <see langword="true" />, если метод успешно помещен в очередь. Если рабочий элемент не может быть помещен очередь, выдается исключение <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если метод обратного вызова требуются сложные данные, можно определить класс, содержащий данные.  
  
> [!NOTE]
>  Пользователи Visual Basic могут опускать <xref:System.Threading.WaitCallback> конструктор и просто использовать `AddressOf` оператор при передаче в метод обратного вызова, <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic автоматически вызывает соответствующий конструктор делегата.  
  
## <a name="version-information"></a>Сведения о версии  
 В .NET Framework версии 2.0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> метод. В более ранних версиях информация об участнике не распространяются.  
  
   
  
## Examples  
 В следующем примере показано, как создать объект, содержащий сведения о задаче. Также демонстрируется передача этого объекта задачу, которая стоит в очереди на выполнение в пуле потоков.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Среда CLR является размещенной, а основное приложение не поддерживает это действие.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="callBack" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует делегат, ожидающий объект <see cref="T:System.Threading.WaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="millisecondsTimeOutInterval">Время ожидания в миллисекундах. Если параметр <c>millisecondsTimeOutInterval</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <c>millisecondsTimeOutInterval</c> равен –1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа со знаком.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, инкапсулирующий собственный дескриптор.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По окончании с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже если указать `true` для `executeOnlyOnce`. Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод ставит в очередь указанный делегат в пул потоков. Рабочий поток выполняет делегат, когда происходит одно из следующих:  
  
-   Указанный объект находится в состоянии получения сигнала.  
  
-   Время ожидания истекло.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод проверяет текущее состояние указанного объекта <xref:System.Threading.WaitHandle>. Если состояние объекта несигнальное, метод регистрирует операцию ожидания. Поток из пула потоков выполняет операцию ожидания. Делегат выполняется рабочим потоком, когда состояние объекта становится сигнальным или истекает время ожидания. Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или истекает время ожидания.  
  
> [!IMPORTANT]
>  С помощью <xref:System.Threading.Mutex> для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков. Вместо <xref:System.Threading.Mutex>, используйте <xref:System.Threading.Semaphore> и максимальное число 1.  
  
 Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод.  
  
 Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для мониторинга зарегистрированные операции ожидания. Таким образом, если необходимо использовать один и тот же дескриптор операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, необходимо дублировать дескриптор с помощью Win32 `DuplicateHandle` функции. Обратите внимание, что не следует посылать событие объекта, передаваемого <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.  
  
 Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации. Изменение происходит только для объекта, чьи сигнальные состояния вызвали условия ожидания. Например счетчик семафора уменьшается на единицу.  
  
## <a name="version-information"></a>Сведения о версии  
 Начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод. В более ранних версиях информация об участнике не распространяются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="millisecondsTimeOutInterval">Время ожидания в миллисекундах. Если параметр <c>millisecondsTimeOutInterval</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <c>millisecondsTimeOutInterval</c> равен –1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 64-разрядного целого числа со знаком.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, инкапсулирующий собственный дескриптор.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По окончании с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже если указать `true` для `executeOnlyOnce`. Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод ставит в очередь указанный делегат в пул потоков. Рабочий поток выполняет делегат, когда происходит одно из следующих:  
  
-   Указанный объект находится в состоянии получения сигнала.  
  
-   Время ожидания истекло.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод проверяет текущее состояние указанного объекта <xref:System.Threading.WaitHandle>. Если состояние объекта несигнальное, метод регистрирует операцию ожидания. Поток из пула потоков выполняет операцию ожидания. Делегат выполняется рабочим потоком, когда состояние объекта становится сигнальным или истекает время ожидания. Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или истекает время ожидания.  
  
> [!IMPORTANT]
>  С помощью <xref:System.Threading.Mutex> для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков. Вместо <xref:System.Threading.Mutex>, используйте <xref:System.Threading.Semaphore> и максимальное число 1.  
  
 Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод.  
  
 Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для мониторинга зарегистрированные операции ожидания. Таким образом, если необходимо использовать один и тот же дескриптор операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, необходимо дублировать дескриптор с помощью Win32 `DuplicateHandle` функции. Обратите внимание, что не следует посылать событие объекта, передаваемого <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.  
  
 Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации. Изменение происходит только для объекта, чьи сигнальные состояния вызвали условия ожидания. Например счетчик семафора уменьшается на единицу.  
  
## <a name="version-information"></a>Сведения о версии  
 Начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод. В более ранних версиях информация об участнике не распространяются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="timeout">Время ожидания, представленное объектом <see cref="T:System.TimeSpan" />. Если параметр <c>timeout</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <c>timeout</c> равен –1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая значение <see cref="T:System.TimeSpan" /> для времени ожидания.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, инкапсулирующий собственный дескриптор.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По окончании с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже если указать `true` для `executeOnlyOnce`. Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод ставит в очередь указанный делегат в пул потоков. Рабочий поток выполняет делегат, когда происходит одно из следующих:  
  
-   Указанный объект находится в состоянии получения сигнала.  
  
-   Время ожидания истекло.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод проверяет текущее состояние указанного объекта <xref:System.Threading.WaitHandle>. Если состояние объекта несигнальное, метод регистрирует операцию ожидания. Поток из пула потоков выполняет операцию ожидания. Делегат выполняется рабочим потоком, когда состояние объекта становится сигнальным или истекает время ожидания. Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или истекает время ожидания.  
  
> [!IMPORTANT]
>  С помощью <xref:System.Threading.Mutex> для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков. Вместо <xref:System.Threading.Mutex>, используйте <xref:System.Threading.Semaphore> и максимальное число 1.  
  
 Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод.  
  
 Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для мониторинга зарегистрированные операции ожидания. Таким образом, если необходимо использовать один и тот же дескриптор операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, необходимо дублировать дескриптор с помощью Win32 `DuplicateHandle` функции. Обратите внимание, что не следует посылать событие объекта, передаваемого <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.  
  
 Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации. Изменение происходит только для объекта, чьи сигнальные состояния вызвали условия ожидания. Например счетчик семафора уменьшается на единицу.  
  
## <a name="version-information"></a>Сведения о версии  
 Начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод. В более ранних версиях информация об участнике не распространяются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> меньше –1.</exception>
        <exception cref="T:System.NotSupportedException">Значение параметра <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="millisecondsTimeOutInterval">Время ожидания в миллисекундах. Если параметр <c>millisecondsTimeOutInterval</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <c>millisecondsTimeOutInterval</c> равен –1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа без знака.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По окончании с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже если указать `true` для `executeOnlyOnce`. Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод ставит в очередь указанный делегат в пул потоков. Рабочий поток выполняет делегат, когда происходит одно из следующих:  
  
-   Указанный объект находится в состоянии получения сигнала.  
  
-   Время ожидания истекло.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод проверяет текущее состояние указанного объекта <xref:System.Threading.WaitHandle>. Если состояние объекта несигнальное, метод регистрирует операцию ожидания. Поток из пула потоков выполняет операцию ожидания. Делегат выполняется рабочим потоком, когда состояние объекта становится сигнальным или истекает время ожидания. Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или истекает время ожидания.  
  
> [!IMPORTANT]
>  С помощью <xref:System.Threading.Mutex> для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков. Вместо <xref:System.Threading.Mutex>, используйте <xref:System.Threading.Semaphore> и максимальное число 1.  
  
 Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод.  
  
 Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для мониторинга зарегистрированные операции ожидания. Таким образом, если необходимо использовать один и тот же дескриптор операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, необходимо дублировать дескриптор с помощью Win32 `DuplicateHandle` функции. Обратите внимание, что не следует посылать событие объекта, передаваемого <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.  
  
 Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации. Изменение происходит только для объекта, чьи сигнальные состояния вызвали условия ожидания. Например счетчик семафора уменьшается на единицу.  
  
## <a name="version-information"></a>Сведения о версии  
 Начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод. В более ранних версиях информация об участнике не распространяются.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> для выполнения указанный метод обратного вызова, когда сигнал дескриптор ожидания, указанного метода. В этом примере метод обратного вызова является `WaitProc`, и дескриптора ожидания <xref:System.Threading.AutoResetEvent>.  
  
 В примере определяется `TaskInfo` класс для хранения информации, который передается функции обратного вызова при его выполнении. В примере создается `TaskInfo` объекта и присваивает его некоторых строковых данных. <xref:System.Threading.RegisteredWaitHandle> , Возвращаемый <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> назначен метод `Handle` поле `TaskInfo` таким образом, метод обратного вызова имеет доступ к <xref:System.Threading.RegisteredWaitHandle>.  
  
 Помимо указания `TaskInfo` как объект, передаваемый в метод обратного вызова, вызов <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> указывает метод <xref:System.Threading.AutoResetEvent> , задача будет ожидать, <xref:System.Threading.WaitOrTimerCallback> делегат, который представляет `WaitProc` метод обратного вызова интервал времени ожидания в одну секунду и нескольких обратных вызовов.  
  
 Когда главный поток сигнализирует <xref:System.Threading.AutoResetEvent> путем вызова его <xref:System.Threading.EventWaitHandle.Set%2A> метод, <xref:System.Threading.WaitOrTimerCallback> вызове делегата. `WaitProc` Тесты метод <xref:System.Threading.RegisteredWaitHandle> для определения, является ли время ожидания истекло. Если был вызван обратный вызов был сигнал дескриптору ожидания, `WaitProc` отменяет регистрацию метод <xref:System.Threading.RegisteredWaitHandle>, остановка дополнительные обратные вызовы. В случае тайм-аут задача будет продолжать ожидать. `WaitProc` Метод завершает сообщение в окно консоли.  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Максимальное количество рабочих потоков в пуле потоков.</param>
        <param name="completionPortThreads">Максимальное количество потоков асинхронного ввода-вывода в пуле потоков.</param>
        <summary>Задает количество запросов к пулу потоков, которые могут быть активными одновременно. Все запросы, превышающие это количество, остаются в очереди до тех пор, пока потоки пула не станут доступны.</summary>
        <returns>Значение <see langword="true" />, если изменение выполнено успешно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Максимальное число рабочих потоков или потоков завершения ввода-вывода в число невозможно задать меньше, чем количество процессоров на компьютере. Чтобы определить, сколько процессоров присутствуют, извлечь значение <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> свойства. Кроме того нельзя задать максимальное число рабочих потоков или потоков завершения ввода-вывода в число меньше, чем соответствующий минимальное количество рабочих потоков или потоков завершения ввода-вывода. Чтобы определить размер пула потоков с минимальным, вызовите <xref:System.Threading.ThreadPool.GetMinThreads%2A> метод.  
  
 Если среда находится, например Internet Information Services (IIS) или SQL Server, узел позволяет ограничить или запретить изменения размера пула потоков.  
  
 Соблюдайте осторожность при изменении максимальное число потоков в пуле потоков. Во время может повыситься при использовании кода, изменения могут возникнуть неблагоприятное воздействие на библиотек кода, которые вы используете.  
  
 Задание слишком большой размер пула потоков может привести к снижению производительности. Если слишком много потоков выполняются одновременно, расходы на переключение между задачами становится важным фактором.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Для получения возможности управления потоками. Значение разрешения: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Минимальное количество рабочих потоков, которые создаются пулом потоков по требованию.</param>
        <param name="completionPortThreads">Минимальное количество потоков асинхронного ввода-вывода, которые создаются пулом потоков по требованию.</param>
        <summary>Задает минимальное число потоков, создаваемых пулом потоков по требованию по мере поступления новых запросов перед переходом на алгоритм управления созданием и уничтожением потоков.</summary>
        <returns>Значение <see langword="true" />, если изменение выполнено успешно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу, пока не достигнет минимум для каждой категории. По достижении минимального пула потоков может создавать дополнительные потоки в этой категории или ожидать завершения некоторых задач. Начиная с версии [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], пул потоков создает и уничтожает потоки в целях оптимизации пропускной способности, которая определяется как количество задач, завершаемых за единицу времени. Слишком малое количество потоков может препятствовать оптимальному использованию доступных ресурсов, тогда как слишком большое их количество может усиливать конкуренцию за ресурсы.  
  
 Если потребность низкая, фактическое количество потоков из пула потоков может быть ниже минимальных значений.  
  
 Если указано отрицательное число или число, большее, чем максимальное число активных потоков из пула потоков (полученный с использованием <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> возвращает `false` и не изменяет либо минимальных значений.  
  
> [!CAUTION]
>  По умолчанию минимальное количество потоков равно числу процессоров в системе. Можно использовать <xref:System.Threading.ThreadPool.SetMinThreads%2A> метод для увеличения минимального числа ofthreads. Однако необоснованное увеличение этих значений может привести к снижению производительности. Если одновременно запускается слишком много задач, все они могут выполняться слишком медленно. В большинстве случаев пул потоков работает лучше использует собственный алгоритм выделения потоков. Снижение минимальным меньшего, чем число процессоров, также может вызвать снижение производительности.  
  
   
  
## Examples  
 Следующий пример задает минимальное количество рабочих потоков до 4, а также сохраняет исходное значение минимальное количество потоков асинхронного завершения ввода-вывода.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Для получения возможности управления потоками. Значение разрешения: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">Помещаемая в очередь структура <see cref="T:System.Threading.NativeOverlapped" />.</param>
        <summary>Помещает в очередь на выполнение операцию перекрывающегося ввода-вывода.</summary>
        <returns>Значение <see langword="true" />, если операция была успешна помещена в очередь порта завершения ввода-вывода; в противном случае значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сведения об использовании собственного Win32 перекрывающегося ввода-вывода, см. в разделе <xref:System.Threading.Overlapped> класса <xref:System.Threading.NativeOverlapped> структуры и `OVERLAPPED` структуры в пакете SDK для платформы Win32.  
  
> [!CAUTION]
>  С помощью <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> метод может случайно открываются брешь в системе безопасности. Управление доступом для кода сформирует его проверки разрешений всех вызывающих объектов разрешений в стеке. Когда работу в очереди пула потоков поток при помощи <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, стек пула потоков не обладает контекстом вызывающих. Вредоносный код, можно использовать этот параметр, чтобы избежать проверки разрешений.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">Метод <see cref="T:System.Threading.WaitCallback" />, представляющий делегат, который вызывается, когда потоку в пуле потоков назначается рабочий элемент.</param>
        <param name="state">Объект, передаваемый делегату при вызове его из пула потоков.</param>
        <summary>Помещает указанный делегат в очередь пула потоков, но не распространяет вызывающий стек на рабочий поток.</summary>
        <returns>Значение <see langword="true" />, если метод завершается успешно. Если рабочий элемент не удалось поместить в очередь, создается исключение <see cref="T:System.OutOfMemoryException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> метод <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> не распространяет вызывающий стек на рабочий поток. Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.  
  
> [!CAUTION]
>  С помощью <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> может случайно открываются брешь в системе безопасности. Управление доступом для кода сформирует его проверки разрешений всех вызывающих объектов разрешений в стеке. Когда работу в очереди пула потоков поток при помощи <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, стек пула потоков не будет иметь контекста вызывающих. Вредоносный код, можно использовать этот параметр, чтобы избежать проверки разрешений.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ApplicationException">Возникла ситуация нехватки памяти.</exception>
        <exception cref="T:System.OutOfMemoryException">Не удается поместить в очередь рабочий элемент.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="callBack" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, но не распространяет вызывающий стек на рабочий поток.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="millisecondsTimeOutInterval">Время ожидания в миллисекундах. Если параметр <c>millisecondsTimeOutInterval</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <c>millisecondsTimeOutInterval</c> равен –1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа со знаком. Этот метод не распространяет вызывающий стек на рабочий поток.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек на рабочий поток. Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.  
  
> [!CAUTION]
>  С помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может случайно открываются брешь в системе безопасности. Управление доступом для кода сформирует его проверки разрешений всех вызывающих объектов разрешений в стеке. Когда работу в очереди пула потоков поток при помощи <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек пула потоков не будет иметь контекста вызывающих. Вредоносный код, можно использовать этот параметр, чтобы избежать проверки разрешений.  
  
 С помощью <xref:System.Threading.Mutex> для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков.  
  
 По окончании с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже если указать `true` для `executeOnlyOnce`. Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="millisecondsTimeOutInterval">Время ожидания в миллисекундах. Если параметр <c>millisecondsTimeOutInterval</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <c>millisecondsTimeOutInterval</c> равен –1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 64-разрядного целого числа со знаком. Этот метод не распространяет вызывающий стек на рабочий поток.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек на рабочий поток. Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.  
  
> [!CAUTION]
>  С помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может случайно открываются брешь в системе безопасности. Управление доступом для кода сформирует его проверки разрешений всех вызывающих объектов разрешений в стеке. Когда работу в очереди пула потоков поток при помощи <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек пула потоков не будет иметь контекста вызывающих. Вредоносный код, можно использовать этот параметр, чтобы избежать проверки разрешений.  
  
 С помощью <xref:System.Threading.Mutex> для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков.  
  
 По окончании с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже если указать `true` для `executeOnlyOnce`. Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="timeout">Время ожидания, представленное объектом <see cref="T:System.TimeSpan" />. Если параметр <c>timeout</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <c>timeout</c> равен –1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая значение <see cref="T:System.TimeSpan" /> для времени ожидания. Этот метод не распространяет вызывающий стек на рабочий поток.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек на рабочий поток. Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.  
  
> [!CAUTION]
>  С помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может случайно открываются брешь в системе безопасности. Управление доступом для кода сформирует его проверки разрешений всех вызывающих объектов разрешений в стеке. Когда работу в очереди пула потоков поток при помощи <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек пула потоков не будет иметь контекста вызывающих. Вредоносный код, можно использовать этот параметр, чтобы избежать проверки разрешений.  
  
 С помощью <xref:System.Threading.Mutex> для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков.  
  
 По окончании с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже если указать `true` для `executeOnlyOnce`. Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> меньше –1.</exception>
        <exception cref="T:System.NotSupportedException">Значение параметра <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <c>waitObject</c>.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="millisecondsTimeOutInterval">Время ожидания в миллисекундах. Если параметр <c>millisecondsTimeOutInterval</c> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <c>millisecondsTimeOutInterval</c> равен –1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <c>waitObject</c>; значение<see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа без знака. Этот метод не распространяет вызывающий стек на рабочий поток.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек на рабочий поток. Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.  
  
> [!CAUTION]
>  С помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может случайно открываются брешь в системе безопасности. Управление доступом для кода сформирует его проверки разрешений всех вызывающих объектов разрешений в стеке. Когда работу в очереди пула потоков поток при помощи <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек пула потоков не будет иметь контекста вызывающих. Вредоносный код, можно использовать этот параметр, чтобы избежать проверки разрешений.  
  
 С помощью <xref:System.Threading.Mutex> для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков.  
  
 По окончании с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже если указать `true` для `executeOnlyOnce`. Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
  </Members>
</Type>