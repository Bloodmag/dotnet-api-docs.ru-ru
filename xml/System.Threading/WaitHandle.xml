<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a13a27594fa1d97d7387994076cdc3b3a30d735d" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609278" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.WaitHandle> Класс инкапсулирует дескрипторы синхронизации Win32 и используется для представления всех объектов синхронизации в среде выполнения, выполнять несколько операций ожидания. Сравнение дескрипторов ожидания с другими объектами синхронизации, см. в разделе [Обзор примитивов синхронизации](~/docs/standard/threading/overview-of-synchronization-primitives.md).  
  
 <xref:System.Threading.WaitHandle> Сам класс является абстрактным. Классы, производные от <xref:System.Threading.WaitHandle> определяют механизм сигнализации о предоставлении или освобождение доступ к общему ресурсу, но они используют наследуемого <xref:System.Threading.WaitHandle> методы на время ожидания для доступа к общим ресурсам. Классы, унаследованные от <xref:System.Threading.WaitHandle> включают:  
  
-   класс <xref:System.Threading.Mutex>; См. в разделе [мьютексы](~/docs/standard/threading/mutexes.md).  
  
-   <xref:System.Threading.EventWaitHandle> Класс и его производные классы <xref:System.Threading.AutoResetEvent> и <xref:System.Threading.ManualResetEvent>. См. дополнительные сведения об [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
-   класс <xref:System.Threading.Semaphore>; См. в разделе [Semaphore и SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  
  
 Потоки могут блокироваться по отдельному дескриптору ожидания путем вызова метода экземпляра <xref:System.Threading.WaitHandle.WaitOne%2A>, которая наследуется производными классами <xref:System.Threading.WaitHandle>.  
  
 Классов, производных от <xref:System.Threading.WaitHandle> их сходство потоков по-разному. Дескрипторы ожидания событий (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, и <xref:System.Threading.ManualResetEvent>) и семафоры не поддерживают сходство потоков; любой поток может подать сигнал дескриптор ожидания событий или семафора. Мьютексы, с другой стороны, поддерживают сходство потоков; поток, который является владельцем мьютекса необходимо освободить его, и исключение возникает в том случае, если поток вызывает <xref:System.Threading.Mutex.ReleaseMutex%2A> метод, который не является владельцем мьютекса.  
  
 Так как <xref:System.Threading.WaitHandle> класс является производным от <xref:System.MarshalByRefObject>, эти классы можно использовать для синхронизации действий потоков за границами домена приложения.  
  
 В дополнение к его производные классы <xref:System.Threading.WaitHandle> класс содержит несколько статических методов, которые блокируют поток, пока один или несколько объектов синхронизации получения сигнала... Сюда входит следующее.  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, что позволяет потоку сигнал одному дескриптору ожидания и немедленно ожидать на другом.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>, что позволяет потоку ожидать все дескрипторы ожидания в массиве получения сигнала.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>, который позволяет потоку ожидать, пока не будет выдан сигнал любого из указанного набора дескрипторов ожидания.  
  
 Перегрузки этих методов предоставляют интервалы времени ожидания для прерывания ожидания, а также возможность выхода из контекста синхронизации до начала ожидания, что позволяет другим потокам использовать контекст синхронизации.  
  
> [!IMPORTANT]
>  Этот тип реализует <xref:System.IDisposable> интерфейс. Когда вы закончите, используя тип или тип, производный от него, следует освободить его прямо или косвенно. Чтобы удалить тип напрямую, вызовите его <xref:System.Threading.WaitHandle.Close%2A> метод в `try` / `catch` блока. Чтобы избавиться от его косвенно, используйте языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует IDisposable» <xref:System.IDisposable> разделу интерфейса.  
  
 <xref:System.Threading.WaitHandle> реализует <xref:System.IDisposable.Dispose%2A> шаблон. См. в разделе [шаблон удаления](~/docs/standard/design-guidelines/dispose-pattern.md). При наследовании от <xref:System.Threading.WaitHandle>, используйте <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство, чтобы сохранять маркер собственный дескриптор операционной системы. Необходимо переопределить защищенный <xref:System.Threading.WaitHandle.Dispose%2A> метод только при использовании дополнительных неуправляемые ресурсы.  
  
   
  
## Examples  
 В следующем примере кода показано как два потока могут сделать фоновых задач при основной поток ожидает завершения с помощью статического задач <xref:System.Threading.WaitHandle.WaitAny%2A> и <xref:System.Threading.WaitHandle.WaitAll%2A> методы <xref:System.Threading.WaitHandle> класса.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является открытую реализацию <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> метод <xref:System.Threading.WaitHandle> класса и его производных классов. Он предоставляет стандартную реализацию, которая вызывает `Dispose(Boolean)` перегрузка с `true` аргумент, а затем вызывает <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> метод. Вызовите этот метод, чтобы освободить все ресурсы, удерживаемые экземпляром `WaitHandle` или производного класса.  
  
 Когда этот метод вызывается, ссылки на текущий экземпляр привести к неопределенному поведению.  
  
> [!NOTE]
>  Всегда вызывайте метод <xref:System.Threading.WaitHandle.Close%2A> или <xref:System.Threading.WaitHandle.Dispose> перед освобождением последней ссылки на <xref:System.Threading.WaitHandle>. В противном случае им ресурсы не будут освобождены.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Необходимо переопределить <see langword="Dispose(Boolean)" /> метод для освобождения ресурсов, выделенных в производных классах.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод эквивалентен <xref:System.Threading.WaitHandle.Close%2A> метод.  
  
> [!NOTE]
>  Всегда вызывайте метод <xref:System.Threading.WaitHandle.Close%2A> или <xref:System.Threading.WaitHandle.Dispose> перед освобождением последней ссылки на <xref:System.Threading.WaitHandle>. В противном случае им ресурсы не будут освобождены.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается <xref:System.Threading.WaitHandle.Close%2A> и <xref:System.Threading.WaitHandle.Dispose> методы с `explicitDisposing` параметру присвоить `true`.  Когда `explicitDisposing` параметр `true`, этот метод освобождает все ресурсы, занятые любыми управляемыми объектами, <xref:System.Threading.WaitHandle> ссылки на объекты.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Необходимо переопределить <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> метод для освобождения ресурсов, выделенных в производных классах.  <see cref="M:System.Threading.WaitHandle.Close" /> Или <see cref="M:System.Threading.WaitHandle.Dispose" /> метод может вызываться несколько раз другими объектами. При переопределении этого метода нужно избегать ссылок на объекты, которые были уничтожены предыдущими вызовами <see langword="Dispose" /> или <see langword="Close" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the native operating system handle.</summary>
        <value>Объект <see langword="IntPtr" />, представляющий собственный дескриптор операционной системы. Значением по умолчанию является значение поля <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Назначение нового значения для <xref:System.Threading.WaitHandle.Handle%2A> свойства не закрывает дескриптор предыдущего. Это может привести утечка дескриптора.  
  
 Не используйте это свойство в .NET Framework версии 2.0 или более поздней версии; Используйте <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство вместо этого. Этому свойству присвоить допустимый дескриптор также наборы <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство, но задание значения <xref:System.Threading.WaitHandle.InvalidHandle> может привести к утечка дескриптора.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта задать значение свойства. Этот член не может задать частично доверенном или прозрачном коде.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Производные типы должны иметь <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> для задания значения свойства.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents an invalid native operating system handle. This field is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используется внутренним образом для инициализации <xref:System.Threading.WaitHandle.Handle%2A> свойство.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Это значение можно использовать, чтобы определить, является ли <see cref="P:System.Threading.WaitHandle.Handle" /> свойство содержит допустимый собственный дескриптор операционной системы.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the native operating system handle.</summary>
        <value>Объект <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />, представляющий собственный дескриптор операционной системы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При назначении нового значения для <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство, предыдущих дескриптор закрывается при предыдущем <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> объект собран. Не следует вручную закрывать дескриптор, так как это приводит к <xref:System.ObjectDisposedException> при <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> предпринимается попытка закрыть дескриптор.  
  
 <xref:System.Threading.WaitHandle> реализует <xref:System.IDisposable.Dispose%2A> шаблон. См. в разделе [шаблон удаления](~/docs/standard/design-guidelines/dispose-pattern.md). При наследовании от <xref:System.Threading.WaitHandle>, используйте <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство, чтобы сохранять маркер собственный дескриптор операционной системы. Необходимо переопределить защищенный <xref:System.Threading.WaitHandle.Dispose%2A> метод только при использовании дополнительных неуправляемые ресурсы.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Производные типы должны иметь <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> для вызова этого члена.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">The <see cref="T:System.Threading.WaitHandle" /> to signal.</param>
        <param name="toWaitOn">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</param>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</summary>
        <returns>
          <see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта операция не обязательно быть атомарными. После текущего потока сигналы `toSignal` , но до его ожидает `toWaitOn`, поток, на котором выполняется на другом процессоре может сигнализировать `toWaitOn` или ждать ее завершения.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> перегруженный метод, чтобы разрешить основному потоку сигнала заблокированный поток и затем подождите, пока поток завершает задачу.  
  
 Пример начинается пять потоков, позволяет им блокировать на <xref:System.Threading.EventWaitHandle> созданные с помощью <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> флага, а затем времени одним потоком выпусков, пользователь нажимает клавишу ВВОД. Затем ставит в очередь другой пять потоков и освобождает их все с помощью <xref:System.Threading.EventWaitHandle> созданные с помощью <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> флаг.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> is <see langword="null" />.  -or-  <paramref name="toWaitOn" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">This method is not supported on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> is a semaphore, and it already has a full count.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">The <see cref="T:System.Threading.WaitHandle" /> to signal.</param>
        <param name="toWaitOn">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</param>
        <param name="millisecondsTimeout">An integer that represents the interval to wait. If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</summary>
        <returns>
          <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта операция не обязательно быть атомарными. После текущего потока сигналы `toSignal` , но до его ожидает `toWaitOn`, поток, на котором выполняется на другом процессоре может сигнализировать `toWaitOn` или ждать ее завершения.  
  
 Если `millisecondsTimeout` равно нулю, метод не блокируется. Он проверяет состояние `toWaitOn` и сразу же.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод. Поток возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.SignalAndWait%2A> завершения метода.  
  
 Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса. Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.SignalAndWait%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> is <see langword="null" />.  -or-  <paramref name="toWaitOn" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">This method is not supported on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">The <see cref="T:System.Threading.WaitHandle" /> to signal.</param>
        <param name="toWaitOn">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the interval to wait. If the value is -1, the wait is infinite.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</summary>
        <returns>
          <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта операция не обязательно быть атомарными. После текущего потока сигналы `toSignal` , но до его ожидает `toWaitOn`, поток, на котором выполняется на другом процессоре может сигнализировать `toWaitOn` или ждать ее завершения.  
  
 Максимальное значение для `timeout` является <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Если `timeout` равно нулю, метод не блокируется. Он проверяет состояние `toWaitOn` и сразу же.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод. Поток возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.SignalAndWait%2A> завершения метода.  
  
 Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса. Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.SignalAndWait%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> is <see langword="null" />.  -or-  <paramref name="toWaitOn" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">This method is not supported on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> is a semaphore, and it already has a full count.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Waits for all the elements in the specified array to receive a signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</param>
        <summary>Waits for all the elements in the specified array to receive a signal.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает метод `true` когда прерывается мьютекс. Брошенный мьютекс часто признаком серьезной ошибки в коде. В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows). Исключение содержит сведения, полезные для отладки.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Метод возвращает при получении сигнала всех дескрипторов. В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение. Если массив содержит дубликаты, вызов завершится сбоем с <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.  
  
 Вызов перегрузки этого метода эквивалентен вызову <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузку метода и указав значение -1 (или <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) для `millisecondsTimeout` и `true` для `exitContext`.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать пул потоков для асинхронного создания и записи для группы файлов. Каждой операции записи помещается в очередь рабочий элемент и сигналов, при его завершении. Основной поток ожидает сигнала все элементы, а затем завершается.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />. -or-  One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
          </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно нулю, метод не блокируется. Он проверяет состояние дескрипторов ожидания и немедленно возвращает.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, если ожидание завершается, что означает либо при получении сигнала всех дескрипторов ожидания. В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение. Если есть повторяющиеся значения в массиве, вызов завершится сбоем с <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.  
  
 Вызов перегрузки этого метода равносилен вызову метода является <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
          </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно нулю, метод не блокируется. Он проверяет состояние дескрипторов ожидания и немедленно возвращает.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, если ожидание завершается, что означает, что или все дескрипторы получили сигнал или истечения. В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение. Если массив содержит дубликаты, вызов завершится ошибкой.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.  
  
 Максимальное значение для `timeout` является <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Вызов перегрузки этого метода равносилен вызову метода является <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
          </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно нулю, метод не блокируется. Он проверяет состояние дескрипторов ожидания и немедленно возвращает.  
  
 <xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает метод `true` когда прерывается мьютекс. Брошенный мьютекс часто признаком серьезной ошибки в коде. В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows). Исключение содержит сведения, полезные для отладки.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, если ожидание завершается, что означает либо при получении сигнала всех дескрипторов ожидания. В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение. Если есть повторяющиеся значения в массиве, вызов завершится сбоем с <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAll%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который не является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAll%2A> метод. Поток возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAll%2A> завершения метода.  
  
 Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> атрибута. В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса. Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.WaitAll%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.WaitAll%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать пул потоков для асинхронного создания и записи для группы файлов. Каждой операции записи помещается в очередь рабочий элемент и сигналов, при его завершении. Основной поток ожидает сигнала все элементы, а затем завершается.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно нулю, метод не блокируется. Он проверяет состояние дескрипторов ожидания и немедленно возвращает.  
  
 <xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает метод `true` когда прерывается мьютекс. Брошенный мьютекс часто признаком серьезной ошибки в коде. В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows). Исключение содержит сведения, полезные для отладки.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, если ожидание завершается, что означает, что или все дескрипторы получили сигнал или истечения. В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение. Если массив содержит дубликаты, вызов завершится ошибкой.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.  
  
 Максимальное значение для `timeout` является <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAll%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который не является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAll%2A> метод. Возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAll%2A> завершения метода.  
  
 Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса. Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.WaitAll%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.WaitAll%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать пул потоков для асинхронного создания и записи для группы файлов. Каждой операции записи помещается в очередь рабочий элемент и сигналов, при его завершении. Основной поток ожидает сигнала все элементы, а затем завершается.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Waits for any of the elements in the specified array to receive a signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal.</summary>
        <returns>The array index of the object that satisfied the wait.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает метод `true` Если ожидание завершается, так как мьютекс завершается. Брошенный мьютекс часто признаком серьезной ошибки в коде. В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows). Исключение содержит сведения, полезные для отладки.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает метод <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за брошенного мьютекса. Если `waitHandles` содержит выпущенные мьютекс с меньшим количеством индекса, чем Брошенный мьютекс, <xref:System.Threading.WaitHandle.WaitAny%2A> метод завершается нормально, и исключение не создается.  
  
> [!NOTE]
>  В версиях .NET Framework до версии 2.0, если поток завершает работу или прерывает без явно освобождая <xref:System.Threading.Mutex>и что `Mutex` имеет индекс 0 (ноль) в `WaitAny` массива в другом потоке, индекс, возвращенный `WaitAny` — 128 вместо 0.  
  
 Этот метод возвращает при любой дескриптор получает сигнал. Если во время вызова оповещенным более одного объекта, возвращается индекс массива объект получил сигнал с наименьшим значением индекса сигнальное объектов. В некоторых реализациях, если сведения, которые передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.  
  
 Вызов перегрузки этого метода эквивалентен вызову <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузку метода и указав значение -1 (или <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) для `millisecondsTimeout` и `true` для `exitContext`.  
  
   
  
## Examples  
 В следующем примере кода показан вызов <xref:System.Threading.WaitHandle.WaitAny%2A> метод.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно нулю, метод не блокируется. Он проверяет состояние дескрипторов ожидания и немедленно возвращает.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает метод <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за брошенного мьютекса. Если `waitHandles` содержит выпущенные мьютекс с меньшим количеством индекса, чем Брошенный мьютекс, <xref:System.Threading.WaitHandle.WaitAny%2A> метод завершается нормально, и исключение не создается.  
  
 Этот метод возвращает, если ожидание завершается, когда все дескрипторы получили сигнал или истечении времени ожидания. Если во время вызова оповещенным более одного объекта, возвращается индекс массива объект получил сигнал с наименьшим значением индекса сигнальное объектов. В некоторых реализациях, если сведения, которые передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.  
  
 Вызов перегрузки этого метода равносилен вызову метода является <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно нулю, метод не блокируется. Он проверяет состояние дескрипторов ожидания и немедленно возвращает.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает метод <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за брошенного мьютекса. Если `waitHandles` содержит выпущенные мьютекс с меньшим количеством индекса, чем Брошенный мьютекс, <xref:System.Threading.WaitHandle.WaitAny%2A> метод завершается нормально, и исключение не создается.  
  
 Этот метод возвращает, если ожидание завершается, когда все дескрипторы получили сигнал или при возникновении тайм-аута. Если во время вызова оповещенным более одного объекта, возвращается индекс массива объект получил сигнал с наименьшим значением индекса сигнальное объектов. В некоторых реализациях, если сведения, которые передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.  
  
 Максимальное значение для `timeout` является <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Вызов перегрузки этого метода равносилен вызову метода является <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно нулю, метод не блокируется. Он проверяет состояние дескрипторов ожидания и немедленно возвращает.  
  
 <xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает метод `true` Если ожидание завершается, так как мьютекс завершается. Брошенный мьютекс часто признаком серьезной ошибки в коде. В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows). Исключение содержит сведения, полезные для отладки.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает метод <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за брошенного мьютекса. Если `waitHandles` содержит выпущенные мьютекс с меньшим количеством индекса, чем Брошенный мьютекс, <xref:System.Threading.WaitHandle.WaitAny%2A> метод завершается нормально, и исключение не создается.  
  
> [!NOTE]
>  В версиях .NET Framework до версии 2.0, если поток завершает работу или прерывает без явно освобождая <xref:System.Threading.Mutex>и что `Mutex` имеет индекс 0 (ноль) в `WaitAny` массива в другом потоке, индекс, возвращенный `WaitAny` — 128 вместо 0.  
  
 Этот метод возвращает, если ожидание завершается, когда все дескрипторы получили сигнал или истечении времени ожидания. Если во время вызова оповещенным более одного объекта, возвращается индекс массива объект получил сигнал с наименьшим значением индекса сигнальное объектов. В некоторых реализациях, если сведения, которые передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAny%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAny%2A> метод. Поток возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAny%2A> завершения метода.  
  
 Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса. Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.WaitAny%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.WaitAny%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать пул потоков для поиска файла на несколько дисков одновременно. Для краткости выполнялся поиск только в корневом каталоге каждого диска.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно нулю, метод не блокируется. Он проверяет состояние дескрипторов ожидания и немедленно возвращает.  
  
 <xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает метод `true` Если ожидание завершается, так как мьютекс завершается. Брошенный мьютекс часто признаком серьезной ошибки в коде. В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows). Исключение содержит сведения, полезные для отладки.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает метод <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за брошенного мьютекса. Если `waitHandles` содержит выпущенные мьютекс с меньшим количеством индекса, чем Брошенный мьютекс, <xref:System.Threading.WaitHandle.WaitAny%2A> метод завершается нормально, и исключение не создается.  
  
> [!NOTE]
>  В версиях .NET Framework до версии 2.0, если поток завершает работу или прерывает без явно освобождая <xref:System.Threading.Mutex>и что `Mutex` имеет индекс 0 (ноль) в `WaitAny` массива в другом потоке, индекс, возвращенный `WaitAny` — 128 вместо 0.  
  
 Этот метод возвращает, если ожидание завершается, когда все дескрипторы получили сигнал или при возникновении тайм-аута. Если во время вызова оповещенным более одного объекта, возвращается индекс массива объект получил сигнал с наименьшим значением индекса сигнальное объектов. В некоторых реализациях, если сведения, которые передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.  
  
 Максимальное значение для `timeout` является <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAny%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAny%2A> метод. Поток возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAny%2A> завершения метода.  
  
 Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса. Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.WaitAny%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.WaitAny%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать пул потоков для поиска файла на несколько дисков одновременно. Для краткости выполнялся поиск только в корневом каталоге каждого диска.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal. If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `true` когда прерывается мьютекс. Брошенный мьютекс часто признаком серьезной ошибки в коде. В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows). Исключение содержит сведения, полезные для отладки.  
  
 Объект, вызывающий этот метод блокируется неограниченное время до получения сигнала текущим экземпляром. Этот метод используется для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, такие как формируется при завершении асинхронной операции. Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейс.  
  
 Вызов перегрузки этого метода эквивалентен вызову <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> перегрузку метода и указав значение -1 или <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> для первого параметра и `false` для второго параметра.  
  
 Переопределите этот метод для настройки поведения из производных классов.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать дескриптор ожидания, чтобы сохранить процесса завершения работы при ожидании фоновый поток для завершения выполнения.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно нулю, метод не блокируется. Он проверяет состояние дескриптора ожидания и немедленно возвращает.  
  
 Объект, вызывающий этот метод блокируется до получения текущим экземпляром сигнала или время ожидания имеет место. Этот метод используется для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, такие как формируется при завершении асинхронной операции. Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейс.  
  
 Переопределите этот метод для настройки поведения из производных классов.  
  
 Вызов перегрузки этого метода равносилен вызову метода является <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать дескриптор ожидания, чтобы сохранить процесса завершения работы при ожидании фоновый поток для завершения выполнения.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <summary>Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно нулю, метод не блокируется. Он проверяет состояние дескриптора ожидания и немедленно возвращает.  
  
 Объект, вызывающий этот метод блокируется до получения текущим экземпляром сигнала или время ожидания имеет место. Этот метод используется для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, такие как формируется при завершении асинхронной операции. Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейс.  
  
 Переопределите этот метод для настройки поведения из производных классов.  
  
 Максимальное значение для `timeout` является <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Вызов перегрузки этого метода равносилен вызову метода является <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно нулю, метод не блокируется. Он проверяет состояние дескриптора ожидания и немедленно возвращает.  
  
 <xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `true` когда прерывается мьютекс. Брошенный мьютекс часто признаком серьезной ошибки в коде. В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows). Исключение содержит сведения, полезные для отладки.  
  
 Объект, вызывающий этот метод блокируется до получения текущим экземпляром сигнала или время ожидания имеет место. Этот метод используется для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, такие как формируется при завершении асинхронной операции. Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейс.  
  
 Переопределите этот метод для настройки поведения из производных классов.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitOne%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitOne%2A> метод. Поток возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitOne%2A> завершения метода.  
  
 Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса. Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.WaitOne%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.WaitOne%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.  
  
   
  
## Examples  
 В следующем примере показан способ <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> перегруженный метод ведет себя при вызове в домен синхронизации. Во-первых, поток ожидает открытия с `exitContext` присвоено `false` и блокируется, пока не истечет время ожидания ожидания. Второй поток выполняет после первый поток завершается и ожидает с `exitContext` присвоено `true`. Вызов сигнал дескриптор ожидания для этой второй поток не заблокирован, и до истечения времени ожидания ожидания завершения потока.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно нулю, метод не блокируется. Он проверяет состояние дескриптора ожидания и немедленно возвращает.  
  
 <xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `true` когда прерывается мьютекс. Брошенный мьютекс часто признаком серьезной ошибки в коде. В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows). Исключение содержит сведения, полезные для отладки.  
  
 Объект, вызывающий этот метод блокируется до получения текущим экземпляром сигнала или время ожидания имеет место. Этот метод используется для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, такие как формируется при завершении асинхронной операции. Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейс.  
  
 Переопределите этот метод для настройки поведения из производных классов.  
  
 Максимальное значение для `timeout` является <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitOne%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitOne%2A> метод. Поток возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitOne%2A> завершения метода.  
  
 Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса. Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.WaitOne%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.WaitOne%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать дескриптор ожидания, чтобы сохранить процесса завершения работы при ожидании фоновый поток для завершения выполнения.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled. This field is constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это поле является одним из возможных возвращаемых значений `WaitAny`.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать пул потоков для поиска файла на несколько дисков одновременно. Для краткости выполнялся поиск только в корневом каталоге каждого диска.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>