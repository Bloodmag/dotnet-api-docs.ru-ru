<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="1d21b-101">Инкапсулирует связанные с операционной системой объекты, ожидающие монопольного доступа к общим ресурсам.</span><span class="sxs-lookup"><span data-stu-id="1d21b-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-102"><xref:System.Threading.WaitHandle> Класс, инкапсулирующий дескрипторы синхронизации Win32 и используется для представления всех объектов синхронизации в среде выполнения, выполнять несколько операций ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-102">The <xref:System.Threading.WaitHandle> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="1d21b-103">Сравнение дескрипторов ожидания с другими объектами синхронизации см. в разделе [Обзор примитивов синхронизации](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="1d21b-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="1d21b-104"><xref:System.Threading.WaitHandle> Сам класс является абстрактным.</span><span class="sxs-lookup"><span data-stu-id="1d21b-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="1d21b-105">Классы, производные от <xref:System.Threading.WaitHandle> определяют механизм сигнализации о предоставлении или освобождении монопольного доступа к общему ресурсу, но используют наследуемого <xref:System.Threading.WaitHandle> методов на время ожидания для доступа к общим ресурсам.</span><span class="sxs-lookup"><span data-stu-id="1d21b-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="1d21b-106">Классы, производные от <xref:System.Threading.WaitHandle> включают:</span><span class="sxs-lookup"><span data-stu-id="1d21b-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="1d21b-107">класс <xref:System.Threading.Mutex>;</span><span class="sxs-lookup"><span data-stu-id="1d21b-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="1d21b-108">В разделе [мьютексы](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="1d21b-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="1d21b-109"><xref:System.Threading.EventWaitHandle> Класс и его производные классы <xref:System.Threading.AutoResetEvent> и <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="1d21b-110">См. дополнительные сведения об [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="1d21b-110">See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
-   <span data-ttu-id="1d21b-111">класс <xref:System.Threading.Semaphore>;</span><span class="sxs-lookup"><span data-stu-id="1d21b-111">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="1d21b-112">В разделе [Semaphore и SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="1d21b-112">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="1d21b-113">Потоки могут блокироваться по отдельному дескриптору ожидания посредством вызова метода экземпляра <xref:System.Threading.WaitHandle.WaitOne%2A>, который наследуется производными классами <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-113">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="1d21b-114">Классов, производных от <xref:System.Threading.WaitHandle> отличающихся своей поддержкой сходства потоков.</span><span class="sxs-lookup"><span data-stu-id="1d21b-114">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="1d21b-115">Дескрипторы ожидания событий (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, и <xref:System.Threading.ManualResetEvent>) и семафоры не поддерживают сходство потоков; любой поток может подать сигнал, дескриптор ожидания событий или семафора.</span><span class="sxs-lookup"><span data-stu-id="1d21b-115">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="1d21b-116">Мьютексы, с другой стороны, поддерживают сходство потоков; должен освободить поток, который является владельцем мьютекса, и создается исключение, если поток выполняет вызов <xref:System.Threading.Mutex.ReleaseMutex%2A> метод, который не является владельцем мьютекса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-116">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="1d21b-117">Поскольку <xref:System.Threading.WaitHandle> класс является производным от <xref:System.MarshalByRefObject>, эти классы можно использовать для синхронизации действий потоков за границами доменов приложений.</span><span class="sxs-lookup"><span data-stu-id="1d21b-117">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="1d21b-118">В дополнение к его производные классы <xref:System.Threading.WaitHandle> класс содержит несколько статических методов, которые блокирования потока, пока один или несколько объектов синхронизации получения сигнала...</span><span class="sxs-lookup"><span data-stu-id="1d21b-118">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal..</span></span> <span data-ttu-id="1d21b-119">Сюда входит следующее.</span><span class="sxs-lookup"><span data-stu-id="1d21b-119">These include:</span></span>  
  
-   <span data-ttu-id="1d21b-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, что позволяет потоку сигнал одному дескриптору ожидания и немедленно ожидать другого.</span><span class="sxs-lookup"><span data-stu-id="1d21b-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="1d21b-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, что позволяет потоку подождать, пока все дескрипторы в массиве ожидания получения сигнала.</span><span class="sxs-lookup"><span data-stu-id="1d21b-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="1d21b-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, который позволяет потоку ожидать, пока один из указанного набора дескрипторов ожидания было сообщено.</span><span class="sxs-lookup"><span data-stu-id="1d21b-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</span></span>  
  
 <span data-ttu-id="1d21b-123">Перегрузки этих методов предоставляют интервалы времени ожидания для прерывания ожидания, а также возможность выхода из контекста синхронизации до начала ожидания, что позволяет другим потокам использовать контекст синхронизации.</span><span class="sxs-lookup"><span data-stu-id="1d21b-123">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1d21b-124">Этот тип реализует <xref:System.IDisposable> интерфейса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-124">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="1d21b-125">После завершения с помощью типа или типа, производного от него следует освободить его прямо или косвенно.</span><span class="sxs-lookup"><span data-stu-id="1d21b-125">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="1d21b-126">Для удаления типа непосредственно вызвать его <xref:System.Threading.WaitHandle.Close%2A> метод в `try` / `catch` блока.</span><span class="sxs-lookup"><span data-stu-id="1d21b-126">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="1d21b-127">Чтобы удалить ее косвенно, использовать языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="1d21b-127">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="1d21b-128">Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <xref:System.IDisposable> разделе интерфейса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-128">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="1d21b-129"><xref:System.Threading.WaitHandle> реализует <xref:System.IDisposable.Dispose%2A> шаблон.</span><span class="sxs-lookup"><span data-stu-id="1d21b-129"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="1d21b-130">В разделе [шаблон удаления](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="1d21b-130">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="1d21b-131">При наследовании от <xref:System.Threading.WaitHandle>, используйте <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство для хранения маркер собственный дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-131">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="1d21b-132">Необходимо переопределить защищенный <xref:System.Threading.WaitHandle.Dispose%2A> метод без использования дополнительных неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-132">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d21b-133">В следующем примере кода показан как два потока могут сделать фоновые задачи при основной поток ожидает завершения задач для выполнения с помощью статического <xref:System.Threading.WaitHandle.WaitAny%2A> и <xref:System.Threading.WaitHandle.WaitAll%2A> методы <xref:System.Threading.WaitHandle> класса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-133">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="1d21b-134">Данный тип потокобезопасен.</span><span class="sxs-lookup"><span data-stu-id="1d21b-134">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1d21b-135">Инициализирует новый экземпляр класса <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-135">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1d21b-136">Освобождает все ресурсы, удерживаемые текущим объектом <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-136">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-137">Этот метод является открытую реализацию <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> метод <xref:System.Threading.WaitHandle> класса и его производные классы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-137">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="1d21b-138">Он предоставляет стандартную реализацию, которая вызывает `Dispose(Boolean)` перегрузка с `true` аргумент, а затем вызывает метод <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="1d21b-138">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1d21b-139">Вызовите этот метод, чтобы освободить все ресурсы, удерживаемые экземпляром `WaitHandle` или производного класса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-139">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="1d21b-140">Когда этот метод вызван, ссылки на текущий экземпляр вызвать неопределенное поведение.</span><span class="sxs-lookup"><span data-stu-id="1d21b-140">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d21b-141">Всегда вызывайте метод <xref:System.Threading.WaitHandle.Close%2A> или <xref:System.Threading.WaitHandle.Dispose> перед освобождением последней ссылки на <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-141">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="1d21b-142">В противном случае им ресурсы не будут освобождены.</span><span class="sxs-lookup"><span data-stu-id="1d21b-142">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1d21b-143">Необходимо переопределить <see langword="Dispose(Boolean)" /> метод для освобождения ресурсов, выделенных в производных классах.</span><span class="sxs-lookup"><span data-stu-id="1d21b-143">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span></span></para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1d21b-144">Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-144">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1d21b-145">Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-145">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-146">Этот метод эквивалентен методу <xref:System.Threading.WaitHandle.Close%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="1d21b-146">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d21b-147">Всегда вызывайте метод <xref:System.Threading.WaitHandle.Close%2A> или <xref:System.Threading.WaitHandle.Dispose> перед освобождением последней ссылки на <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-147">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="1d21b-148">В противном случае им ресурсы не будут освобождены.</span><span class="sxs-lookup"><span data-stu-id="1d21b-148">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <span data-ttu-id="1d21b-149">Значение <see langword="true" /> позволяет освободить как управляемые, так и неуправляемые ресурсы; значение <see langword="false" /> освобождает только неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-149"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="1d21b-150">При переопределении в производном классе освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.Threading.WaitHandle" />, и при необходимости освобождает управляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-150">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-151">Этот метод вызывается методом <xref:System.Threading.WaitHandle.Close%2A> и <xref:System.Threading.WaitHandle.Dispose> методы с `explicitDisposing` равным `true`.</span><span class="sxs-lookup"><span data-stu-id="1d21b-151">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="1d21b-152">При `explicitDisposing` параметр `true`, данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, которые <xref:System.Threading.WaitHandle> ссылки на объекты.</span><span class="sxs-lookup"><span data-stu-id="1d21b-152">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1d21b-153">Необходимо переопределить <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> метод для освобождения ресурсов, выделенных в производных классах.</span><span class="sxs-lookup"><span data-stu-id="1d21b-153">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span></span>  
  
 <span data-ttu-id="1d21b-154"><see cref="M:System.Threading.WaitHandle.Close" /> Или <see cref="M:System.Threading.WaitHandle.Dispose" /> метод может вызываться несколько раз другими объектами.</span><span class="sxs-lookup"><span data-stu-id="1d21b-154">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span></span> <span data-ttu-id="1d21b-155">При переопределении этого метода следует избегать ссылок на объекты, которые были уничтожены предыдущими вызовами метода <see langword="Dispose" /> или <see langword="Close" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-155">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1d21b-156">Возвращает или задает собственный дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-156">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="1d21b-157">Объект <see langword="IntPtr" />, представляющий собственный дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-157">An <see langword="IntPtr" /> representing the native operating system handle.</span></span> <span data-ttu-id="1d21b-158">Значением по умолчанию является значение поля <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-158">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-159">Назначение нового значения для <xref:System.Threading.WaitHandle.Handle%2A> свойства не закрывает дескриптор предыдущего.</span><span class="sxs-lookup"><span data-stu-id="1d21b-159">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="1d21b-160">Это может привести к потерянных дескриптор.</span><span class="sxs-lookup"><span data-stu-id="1d21b-160">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="1d21b-161">Не используйте это свойство в платформе .NET Framework версии 2.0 или более поздней версии; Используйте <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство вместо него.</span><span class="sxs-lookup"><span data-stu-id="1d21b-161">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="1d21b-162">Установка этого свойства в допустимый дескриптор также наборы <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство, но значения этого свойства <xref:System.Threading.WaitHandle.InvalidHandle> может привести к потерянных дескриптор.</span><span class="sxs-lookup"><span data-stu-id="1d21b-162">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="1d21b-163">Требуется полное доверие для непосредственно вызывающего метода задать значение свойства.</span><span class="sxs-lookup"><span data-stu-id="1d21b-163">Requires full trust for the immediate caller to set the property value.</span></span> <span data-ttu-id="1d21b-164">Этот член не может задаваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="1d21b-164">This member cannot be set by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="1d21b-165">Производные типы должны иметь <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> требуется задать значение свойства.</span><span class="sxs-lookup"><span data-stu-id="1d21b-165">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1d21b-166">Представляет недопустимый собственный дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-166">Represents an invalid native operating system handle.</span></span> <span data-ttu-id="1d21b-167">Это поле доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-167">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-168">Используется внутренним образом для инициализации <xref:System.Threading.WaitHandle.Handle%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="1d21b-168">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1d21b-169">Это значение можно использовать, чтобы определить, является ли <see cref="P:System.Threading.WaitHandle.Handle" /> свойство содержит допустимый собственный дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-169">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1d21b-170">Возвращает или задает собственный дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-170">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="1d21b-171">Объект <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />, представляющий собственный дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-171">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-172">При назначении нового значения для <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойства предыдущей дескриптор будет закрыт при предыдущей <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> собираются объекта.</span><span class="sxs-lookup"><span data-stu-id="1d21b-172">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="1d21b-173">Не закрывайте вручную дескриптора, так как это приведет к <xref:System.ObjectDisposedException> при <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> пытается закрыть дескриптор.</span><span class="sxs-lookup"><span data-stu-id="1d21b-173">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="1d21b-174"><xref:System.Threading.WaitHandle> реализует <xref:System.IDisposable.Dispose%2A> шаблон.</span><span class="sxs-lookup"><span data-stu-id="1d21b-174"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="1d21b-175">В разделе [шаблон удаления](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="1d21b-175">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="1d21b-176">При наследовании от <xref:System.Threading.WaitHandle>, используйте <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство для хранения маркер собственный дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-176">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="1d21b-177">Необходимо переопределить защищенный <xref:System.Threading.WaitHandle.Dispose%2A> метод без использования дополнительных неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-177">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="1d21b-178">требуется полное доверие для непосредственно вызывающего метода.</span><span class="sxs-lookup"><span data-stu-id="1d21b-178">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="1d21b-179">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="1d21b-179">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="1d21b-180">Производные типы должны иметь <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> для вызова этого элемента.</span><span class="sxs-lookup"><span data-stu-id="1d21b-180">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1d21b-181">Подает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает другого.</span><span class="sxs-lookup"><span data-stu-id="1d21b-181">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="1d21b-182">Объект <see cref="T:System.Threading.WaitHandle" />, который получает сигнал.</span><span class="sxs-lookup"><span data-stu-id="1d21b-182">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="1d21b-183">Объект <see cref="T:System.Threading.WaitHandle" />, сигнализация которого ожидается.</span><span class="sxs-lookup"><span data-stu-id="1d21b-183">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <summary><span data-ttu-id="1d21b-184">Подает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает другого.</span><span class="sxs-lookup"><span data-stu-id="1d21b-184">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
        <returns>
          <span data-ttu-id="1d21b-185">Значение <see langword="true" />, если и сигнал, и ожидание завершаются удачно; если операция ожидания не завершается, то возврат из метода не происходит.</span><span class="sxs-lookup"><span data-stu-id="1d21b-185"><see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-186">Эта операция не обязательно atomic.</span><span class="sxs-lookup"><span data-stu-id="1d21b-186">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="1d21b-187">После текущего потока сигналы `toSignal` , но до его ожидает `toWaitOn`, поток, который выполняется на другой процессор может сигнализировать `toWaitOn` или ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-187">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d21b-188">Следующий пример кода использует <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> перегрузка метода, чтобы разрешить основной поток отправлять сигнал заблокированный поток и подождите, пока поток завершает задачу.</span><span class="sxs-lookup"><span data-stu-id="1d21b-188">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="1d21b-189">Пример запускаются пять потоков, их можно заблокировать на <xref:System.Threading.EventWaitHandle> с <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> флага, а затем время выпуски один поток, пользователь нажимает клавишу ВВОД.</span><span class="sxs-lookup"><span data-stu-id="1d21b-189">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="1d21b-190">Затем помещает в очередь другой пять потоков и освобождает их с помощью <xref:System.Threading.EventWaitHandle> с <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> флаг.</span><span class="sxs-lookup"><span data-stu-id="1d21b-190">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1d21b-191">Свойство <paramref name="toSignal" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-191"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-192">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-192">-or-</span></span>  
  
 <span data-ttu-id="1d21b-193">Свойство <paramref name="toWaitOn" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-193"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1d21b-194">Метод был вызван в потоке с атрибутом <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-194">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="1d21b-195">Этот метод не поддерживается в Windows 98 и Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-195">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="1d21b-196">Параметр <paramref name="toSignal" /> является семафором и его счетчик уже достиг максимального значения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-196"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-197">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-197">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-198">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-198">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="1d21b-199">Объект <see cref="T:System.Threading.WaitHandle" />, который получает сигнал.</span><span class="sxs-lookup"><span data-stu-id="1d21b-199">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="1d21b-200">Объект <see cref="T:System.Threading.WaitHandle" />, сигнализация которого ожидается.</span><span class="sxs-lookup"><span data-stu-id="1d21b-200">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="1d21b-201">Целое число, представляющее интервал ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-201">An integer that represents the interval to wait.</span></span> <span data-ttu-id="1d21b-202">Если значение равно <see cref="F:System.Threading.Timeout.Infinite" />, то есть -1, то ожидание длится неограниченное время.</span><span class="sxs-lookup"><span data-stu-id="1d21b-202">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="1d21b-203">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-203"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1d21b-204">Передает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает сигнализации другого, задавая время ожидания в виде 32-разрядного целого числа со знаком и указывая, следует ли выйти из домена синхронизации контекста до начала ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-204">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="1d21b-205">Значение <see langword="true" />, если и передача сигнала, и ожидание завершились успешно; значение <see langword="false" />, если передача сигнала была выполнена, но время ожидания истекло.</span><span class="sxs-lookup"><span data-stu-id="1d21b-205"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-206">Эта операция не обязательно atomic.</span><span class="sxs-lookup"><span data-stu-id="1d21b-206">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="1d21b-207">После текущего потока сигналы `toSignal` , но до его ожидает `toWaitOn`, поток, который выполняется на другой процессор может сигнализировать `toWaitOn` или ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-207">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="1d21b-208">Если `millisecondsTimeout` равно нулю, метод не выполняет блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d21b-208">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1d21b-209">Он проверяет состояние `toWaitOn` и немедленно возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="1d21b-209">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1d21b-210">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="1d21b-210">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1d21b-211">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="1d21b-211">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1d21b-212">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-212">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1d21b-213">Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-213">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1d21b-214">Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="1d21b-214">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="1d21b-215">Поток осуществляет возврат к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод завершения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-215">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="1d21b-216">Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-216">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1d21b-217">В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-217">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1d21b-218">Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-218">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1d21b-219">Когда <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="1d21b-219">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1d21b-220">Свойство <paramref name="toSignal" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-220"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-221">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-221">-or-</span></span>  
  
 <span data-ttu-id="1d21b-222">Свойство <paramref name="toWaitOn" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-222"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1d21b-223">Метод вызывается в потоке с атрибутом <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-223">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="1d21b-224">Этот метод не поддерживается в Windows 98 и Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-224">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-225">Невозможно передать сигнал объекту <see cref="T:System.Threading.WaitHandle" />, поскольку его счетчик превысит максимальное значение.</span><span class="sxs-lookup"><span data-stu-id="1d21b-225">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d21b-226">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-226"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-227">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-227">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-228">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-228">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="1d21b-229">Объект <see cref="T:System.Threading.WaitHandle" />, который получает сигнал.</span><span class="sxs-lookup"><span data-stu-id="1d21b-229">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="1d21b-230">Объект <see cref="T:System.Threading.WaitHandle" />, сигнализация которого ожидается.</span><span class="sxs-lookup"><span data-stu-id="1d21b-230">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="timeout"><span data-ttu-id="1d21b-231">Объект <see cref="T:System.TimeSpan" />, представляющий период ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-231">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span></span> <span data-ttu-id="1d21b-232">Если значение равно -1, то ожидание выполняется неограниченное время.</span><span class="sxs-lookup"><span data-stu-id="1d21b-232">If the value is -1, the wait is infinite.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="1d21b-233">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-233"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1d21b-234">Передает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает сигнализации другого, задавая время ожидания в виде <see cref="T:System.TimeSpan" /> и указывая, следует ли выйти из домена синхронизации контекста до начала ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-234">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="1d21b-235">Значение <see langword="true" />, если и передача сигнала, и ожидание завершились успешно; значение <see langword="false" />, если передача сигнала была выполнена, но время ожидания истекло.</span><span class="sxs-lookup"><span data-stu-id="1d21b-235"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-236">Эта операция не обязательно atomic.</span><span class="sxs-lookup"><span data-stu-id="1d21b-236">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="1d21b-237">После текущего потока сигналы `toSignal` , но до его ожидает `toWaitOn`, поток, который выполняется на другой процессор может сигнализировать `toWaitOn` или ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-237">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="1d21b-238">Максимальное значение для `timeout` — <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-238">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1d21b-239">Если `timeout` равно нулю, метод не выполняет блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d21b-239">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1d21b-240">Он проверяет состояние `toWaitOn` и немедленно возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="1d21b-240">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1d21b-241">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="1d21b-241">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1d21b-242">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="1d21b-242">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1d21b-243">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-243">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1d21b-244">Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-244">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1d21b-245">Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="1d21b-245">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="1d21b-246">Поток осуществляет возврат к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод завершения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-246">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="1d21b-247">Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-247">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1d21b-248">В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-248">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1d21b-249">Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-249">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1d21b-250">Когда <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="1d21b-250">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1d21b-251">Свойство <paramref name="toSignal" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-251"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-252">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-252">-or-</span></span>  
  
 <span data-ttu-id="1d21b-253">Свойство <paramref name="toWaitOn" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-253"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1d21b-254">Метод был вызван в потоке с атрибутом <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-254">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="1d21b-255">Этот метод не поддерживается в Windows 98 и Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-255">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="1d21b-256">Параметр <paramref name="toSignal" /> является семафором и его счетчик уже достиг максимального значения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-256"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d21b-257">Значение параметра <paramref name="timeout" /> соответствует отрицательному числу, отличному от -1 миллисекунды.</span><span class="sxs-lookup"><span data-stu-id="1d21b-257"><paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span></span>  
  
 <span data-ttu-id="1d21b-258">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-258">-or-</span></span>  
  
 <span data-ttu-id="1d21b-259">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-259"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-260">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-260">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-261">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-261">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1d21b-262">Ожидает получения сигнала всеми элементами заданного массива.</span><span class="sxs-lookup"><span data-stu-id="1d21b-262">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1d21b-263">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="1d21b-263">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="1d21b-264">Этот массив не может содержать несколько ссылок на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="1d21b-264">This array cannot contain multiple references to the same object.</span></span></param>
        <summary><span data-ttu-id="1d21b-265">Ожидает получения сигнала всеми элементами заданного массива.</span><span class="sxs-lookup"><span data-stu-id="1d21b-265">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
        <returns>
          <span data-ttu-id="1d21b-266"><see langword="true" />, когда каждый элемент <paramref name="waitHandles" /> получил сигнал. В противном случае возврат из метода не происходит.</span><span class="sxs-lookup"><span data-stu-id="1d21b-266"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-267"><xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="1d21b-267"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1d21b-268">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает метод `true` при будет сброшен семафор.</span><span class="sxs-lookup"><span data-stu-id="1d21b-268">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1d21b-269">Брошенный mutex обычно признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="1d21b-269">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1d21b-270">В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач).</span><span class="sxs-lookup"><span data-stu-id="1d21b-270">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1d21b-271">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="1d21b-271">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1d21b-272"><xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, когда все дескрипторы получили сигнал.</span><span class="sxs-lookup"><span data-stu-id="1d21b-272">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="1d21b-273">В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="1d21b-273">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="1d21b-274">Если массив содержит дубликаты, вызов завершится ошибкой с <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-274">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d21b-275"><xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-275">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="1d21b-276">Вызов перегрузки этого метода эквивалентен вызову <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузка метода и указав значение -1 (или <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) для `millisecondsTimeout` и `true` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1d21b-276">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d21b-277">В следующем примере кода показано, как использовать пул потоков для асинхронного создания и записи в группы файлов.</span><span class="sxs-lookup"><span data-stu-id="1d21b-277">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="1d21b-278">Каждой операции записи в очередь как рабочий элемент и сигналов, при его завершении.</span><span class="sxs-lookup"><span data-stu-id="1d21b-278">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="1d21b-279">Основной поток ожидает сигнала всех элементов, а затем завершается.</span><span class="sxs-lookup"><span data-stu-id="1d21b-279">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1d21b-280">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-280">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span> <span data-ttu-id="1d21b-281">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-281">-or-</span></span>  
  
 <span data-ttu-id="1d21b-282">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-282">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-283">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-283">-or-</span></span>  
  
 <span data-ttu-id="1d21b-284">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 2.0 или более поздней.</span><span class="sxs-lookup"><span data-stu-id="1d21b-284"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="1d21b-285">Вместо этого в [.NET для приложений Магазина Windows](http://go.microsoft.com/fwlink/?LinkID=247912) или в [переносимой библиотеке классов](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) перехватите исключение базового класса <see cref="T:System.ArgumentException" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-285">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="1d21b-286">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-286">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1d21b-287">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="1d21b-287">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="1d21b-288">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-288">-or-</span></span>  
  
 <span data-ttu-id="1d21b-289">Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</span><span class="sxs-lookup"><span data-stu-id="1d21b-289">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="1d21b-290">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 1.0 или 1.1.</span><span class="sxs-lookup"><span data-stu-id="1d21b-290"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-291">Ожидание прервано, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-291">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-292">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-292">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-293">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-293">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1d21b-294">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="1d21b-294">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="1d21b-295">Данный массив не может содержать несколько ссылок на один и тот же объект (дубликатов).</span><span class="sxs-lookup"><span data-stu-id="1d21b-295">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="1d21b-296">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-296">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1d21b-297">Ожидает получения сигнала всеми элементами заданного массива, используя значение <see cref="T:System.Int32" /> для указания интервала времени.</span><span class="sxs-lookup"><span data-stu-id="1d21b-297">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="1d21b-298">Значение <see langword="true" />, если каждый элемент массива <paramref name="waitHandles" /> получил сигнал; в противном случае значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-298"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-299">Если `millisecondsTimeout` равно нулю, метод не выполняет блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d21b-299">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1d21b-300">Он проверяет состояние дескрипторов ожидания и возвращается немедленно.</span><span class="sxs-lookup"><span data-stu-id="1d21b-300">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1d21b-301"><xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, когда ожидание завершается, означающее, что если все дескрипторы получили сигнал или истечения времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-301">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="1d21b-302">В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="1d21b-302">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="1d21b-303">Если имеются повторяющиеся значения в массиве, вызов завершится ошибкой с <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-303">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d21b-304"><xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-304">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="1d21b-305">Вызов этой перегрузки метода является таким же, как вызов <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1d21b-305">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1d21b-306">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-306">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-307">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-307">-or-</span></span>  
  
 <span data-ttu-id="1d21b-308">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-308">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-309">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-309">-or-</span></span>  
  
 <span data-ttu-id="1d21b-310">В массиве <paramref name="waitHandles" /> отсутствуют элементы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-310"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="1d21b-311">Вместо этого в [.NET для приложений Магазина Windows](http://go.microsoft.com/fwlink/?LinkID=247912) или в [переносимой библиотеке классов](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) перехватите исключение базового класса <see cref="T:System.ArgumentException" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-311">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="1d21b-312">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-312">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1d21b-313">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="1d21b-313">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="1d21b-314">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-314">-or-</span></span>  
  
 <span data-ttu-id="1d21b-315">Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</span><span class="sxs-lookup"><span data-stu-id="1d21b-315">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d21b-316">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-316"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-317">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-317">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-318">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-318">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-319">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-319">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1d21b-320">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="1d21b-320">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="1d21b-321">Этот массив не может содержать несколько ссылок на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="1d21b-321">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="1d21b-322">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-322">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1d21b-323">Ожидает получения сигнала всеми элементами заданного массива, используя значение <see cref="T:System.TimeSpan" /> для указания интервала времени.</span><span class="sxs-lookup"><span data-stu-id="1d21b-323">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="1d21b-324">Значение <see langword="true" />, если каждый элемент массива <paramref name="waitHandles" /> получил сигнал; в противном случае значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-324"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-325">Если `timeout` равно нулю, метод не выполняет блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d21b-325">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1d21b-326">Он проверяет состояние дескрипторов ожидания и возвращается немедленно.</span><span class="sxs-lookup"><span data-stu-id="1d21b-326">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1d21b-327"><xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, когда ожидание завершается, что означает, что или все дескрипторы получили сигнал или истечения времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-327">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="1d21b-328">В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="1d21b-328">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="1d21b-329">Если массив содержит дубликаты, вызов завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="1d21b-329">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d21b-330"><xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-330">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="1d21b-331">Максимальное значение для `timeout` — <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-331">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1d21b-332">Вызов этой перегрузки метода является таким же, как вызов <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1d21b-332">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1d21b-333">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-333">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-334">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-334">-or-</span></span>  
  
 <span data-ttu-id="1d21b-335">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-335">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-336">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-336">-or-</span></span>  
  
 <span data-ttu-id="1d21b-337">В массиве <paramref name="waitHandles" /> отсутствуют элементы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-337"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="1d21b-338">Вместо этого в [.NET для приложений Магазина Windows](http://go.microsoft.com/fwlink/?LinkID=247912) или в [переносимой библиотеке классов](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) перехватите исключение базового класса <see cref="T:System.ArgumentException" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-338">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="1d21b-339">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-339">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1d21b-340">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="1d21b-340">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="1d21b-341">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-341">-or-</span></span>  
  
 <span data-ttu-id="1d21b-342">Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</span><span class="sxs-lookup"><span data-stu-id="1d21b-342">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d21b-343"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-343"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="1d21b-344">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-344">-or-</span></span>  
  
 <span data-ttu-id="1d21b-345">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-345"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-346">Ожидание прервано, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-346">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-347">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-347">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-348">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-348">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1d21b-349">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="1d21b-349">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="1d21b-350">Данный массив не может содержать несколько ссылок на один и тот же объект (дубликатов).</span><span class="sxs-lookup"><span data-stu-id="1d21b-350">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="1d21b-351">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-351">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="1d21b-352">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-352"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1d21b-353">Ожидает получения сигнала всеми элементами заданного массива, используя значение типа <see cref="T:System.Int32" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-353">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="1d21b-354">Значение <see langword="true" />, если каждый элемент массива <paramref name="waitHandles" /> получил сигнал; в противном случае значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-354"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-355">Если `millisecondsTimeout` равно нулю, метод не выполняет блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d21b-355">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1d21b-356">Он проверяет состояние дескрипторов ожидания и возвращается немедленно.</span><span class="sxs-lookup"><span data-stu-id="1d21b-356">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1d21b-357"><xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="1d21b-357"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1d21b-358">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает метод `true` при будет сброшен семафор.</span><span class="sxs-lookup"><span data-stu-id="1d21b-358">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1d21b-359">Брошенный mutex обычно признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="1d21b-359">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1d21b-360">В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач).</span><span class="sxs-lookup"><span data-stu-id="1d21b-360">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1d21b-361">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="1d21b-361">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1d21b-362"><xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, когда ожидание завершается, означающее, что если все дескрипторы получили сигнал или истечения времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-362">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="1d21b-363">В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="1d21b-363">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="1d21b-364">Если имеются повторяющиеся значения в массиве, вызов завершится ошибкой с <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-364">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d21b-365"><xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-365">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1d21b-366">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="1d21b-366">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1d21b-367">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAll%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="1d21b-367">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1d21b-368">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-368">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1d21b-369">Даже если в настоящее время выполняется метод в классе, который не является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-369">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1d21b-370">Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAll%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="1d21b-370">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="1d21b-371">Поток осуществляет возврат к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAll%2A> метод завершения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-371">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="1d21b-372">Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> атрибута.</span><span class="sxs-lookup"><span data-stu-id="1d21b-372">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="1d21b-373">В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-373">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1d21b-374">Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.WaitAll%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-374">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1d21b-375">Когда <xref:System.Threading.WaitHandle.WaitAll%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="1d21b-375">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d21b-376">В следующем примере кода показано, как использовать пул потоков для асинхронного создания и записи в группы файлов.</span><span class="sxs-lookup"><span data-stu-id="1d21b-376">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="1d21b-377">Каждой операции записи в очередь как рабочий элемент и сигналов, при его завершении.</span><span class="sxs-lookup"><span data-stu-id="1d21b-377">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="1d21b-378">Основной поток ожидает сигнала всех элементов, а затем завершается.</span><span class="sxs-lookup"><span data-stu-id="1d21b-378">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1d21b-379">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-379">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-380">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-380">-or-</span></span>  
  
 <span data-ttu-id="1d21b-381">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-381">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-382">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-382">-or-</span></span>  
  
 <span data-ttu-id="1d21b-383">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 2.0 или более поздней.</span><span class="sxs-lookup"><span data-stu-id="1d21b-383"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="1d21b-384">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-384">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1d21b-385">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="1d21b-385">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="1d21b-386">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-386">-or-</span></span>  
  
 <span data-ttu-id="1d21b-387">Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</span><span class="sxs-lookup"><span data-stu-id="1d21b-387">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="1d21b-388">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 1.0 или 1.1.</span><span class="sxs-lookup"><span data-stu-id="1d21b-388"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d21b-389">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-389"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-390">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-390">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-391">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-391">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-392">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-392">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1d21b-393">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="1d21b-393">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="1d21b-394">Этот массив не может содержать несколько ссылок на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="1d21b-394">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="1d21b-395">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-395">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="1d21b-396">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-396"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1d21b-397">Ожидает получения сигнала всеми элементами заданного массива, используя значение типа <see cref="T:System.TimeSpan" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-397">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="1d21b-398">Значение <see langword="true" />, когда каждый элемент массива <paramref name="waitHandles" /> получил сигнал; иначе — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-398"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-399">Если `timeout` равно нулю, метод не выполняет блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d21b-399">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1d21b-400">Он проверяет состояние дескрипторов ожидания и возвращается немедленно.</span><span class="sxs-lookup"><span data-stu-id="1d21b-400">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1d21b-401"><xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="1d21b-401"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1d21b-402">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает метод `true` при будет сброшен семафор.</span><span class="sxs-lookup"><span data-stu-id="1d21b-402">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1d21b-403">Брошенный mutex обычно признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="1d21b-403">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1d21b-404">В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач).</span><span class="sxs-lookup"><span data-stu-id="1d21b-404">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1d21b-405">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="1d21b-405">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1d21b-406"><xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, когда ожидание завершается, что означает, что или все дескрипторы получили сигнал или истечения времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-406">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="1d21b-407">В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="1d21b-407">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="1d21b-408">Если массив содержит дубликаты, вызов завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="1d21b-408">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d21b-409"><xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-409">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="1d21b-410">Максимальное значение для `timeout` — <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-410">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1d21b-411">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="1d21b-411">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1d21b-412">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAll%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="1d21b-412">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1d21b-413">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-413">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1d21b-414">Даже если в настоящее время выполняется метод в классе, который не является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-414">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1d21b-415">Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAll%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="1d21b-415">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="1d21b-416">Возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAll%2A> метод завершения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-416">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="1d21b-417">Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-417">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1d21b-418">В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-418">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1d21b-419">Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.WaitAll%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-419">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1d21b-420">Когда <xref:System.Threading.WaitHandle.WaitAll%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="1d21b-420">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d21b-421">В следующем примере кода показано, как использовать пул потоков для асинхронного создания и записи в группы файлов.</span><span class="sxs-lookup"><span data-stu-id="1d21b-421">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="1d21b-422">Каждой операции записи в очередь как рабочий элемент и сигналов, при его завершении.</span><span class="sxs-lookup"><span data-stu-id="1d21b-422">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="1d21b-423">Основной поток ожидает сигнала всех элементов, а затем завершается.</span><span class="sxs-lookup"><span data-stu-id="1d21b-423">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1d21b-424">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-424">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-425">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-425">-or-</span></span>  
  
 <span data-ttu-id="1d21b-426">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-426">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-427">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-427">-or-</span></span>  
  
 <span data-ttu-id="1d21b-428">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 2.0 или более поздней.</span><span class="sxs-lookup"><span data-stu-id="1d21b-428"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="1d21b-429">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-429">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1d21b-430">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="1d21b-430">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="1d21b-431">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-431">-or-</span></span>  
  
 <span data-ttu-id="1d21b-432">Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</span><span class="sxs-lookup"><span data-stu-id="1d21b-432">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="1d21b-433">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 1.0 или 1.1.</span><span class="sxs-lookup"><span data-stu-id="1d21b-433"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d21b-434"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-434"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="1d21b-435">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-435">-or-</span></span>  
  
 <span data-ttu-id="1d21b-436">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-436"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-437">Ожидание прервано, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-437">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-438">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-438">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-439">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-439">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1d21b-440">Ожидает получения сигнала какими-либо элементами заданного массива.</span><span class="sxs-lookup"><span data-stu-id="1d21b-440">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1d21b-441">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="1d21b-441">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <summary><span data-ttu-id="1d21b-442">Ожидает получения сигнала какими-либо элементами заданного массива.</span><span class="sxs-lookup"><span data-stu-id="1d21b-442">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="1d21b-443">Индекс объекта, удовлетворившего операцию ожидания, в массиве.</span><span class="sxs-lookup"><span data-stu-id="1d21b-443">The array index of the object that satisfied the wait.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-444"><xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="1d21b-444"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1d21b-445">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает `true` Если ожидание завершается, так как будет сброшен семафор.</span><span class="sxs-lookup"><span data-stu-id="1d21b-445">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="1d21b-446">Брошенный mutex обычно признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="1d21b-446">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1d21b-447">В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач).</span><span class="sxs-lookup"><span data-stu-id="1d21b-447">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1d21b-448">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="1d21b-448">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1d21b-449"><xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает исключение <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за Брошенный mutex.</span><span class="sxs-lookup"><span data-stu-id="1d21b-449">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="1d21b-450">Если `waitHandles` содержит выпущено мьютекс с меньшим значением индекса, чем Брошенный mutex <xref:System.Threading.WaitHandle.WaitAny%2A> метод обычно выполняется и исключение не вызывается.</span><span class="sxs-lookup"><span data-stu-id="1d21b-450">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d21b-451">В версиях .NET Framework, предшествующих версии 2.0, если поток завершает работу или прервана без явного освобождения <xref:System.Threading.Mutex>и что `Mutex` находится по индексу 0 (ноль) в `WaitAny` массива на другой поток, возвращенный индекс `WaitAny` — 128 вместо 0.</span><span class="sxs-lookup"><span data-stu-id="1d21b-451">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="1d21b-452">Этот метод возвращает, когда любой дескриптор получает сигнал.</span><span class="sxs-lookup"><span data-stu-id="1d21b-452">This method returns when any handle is signaled.</span></span> <span data-ttu-id="1d21b-453">Если во время вызова сигнала более одного объекта возвращает значение индекса массива сигнальное объекта с наименьшим значением индекса сигнальное объектов.</span><span class="sxs-lookup"><span data-stu-id="1d21b-453">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="1d21b-454">В некоторых реализациях, если несколько записей, передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="1d21b-454">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="1d21b-455">Вызов перегрузки этого метода эквивалентен вызову <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузка метода и указав значение -1 (или <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) для `millisecondsTimeout` и `true` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1d21b-455">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d21b-456">В следующем примере кода демонстрируется вызов <xref:System.Threading.WaitHandle.WaitAny%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="1d21b-456">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1d21b-457">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-457">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-458">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-458">-or-</span></span>  
  
 <span data-ttu-id="1d21b-459">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-459">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1d21b-460">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="1d21b-460">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="1d21b-461"><paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 1.0 или 1.1.</span><span class="sxs-lookup"><span data-stu-id="1d21b-461"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-462">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-462">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-463">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-463">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d21b-464"><paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 2.0 или выше.</span><span class="sxs-lookup"><span data-stu-id="1d21b-464"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-465">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-465">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1d21b-466">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="1d21b-466">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="1d21b-467">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-467">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1d21b-468">Ожидает получения сигнала любыми элементами указанного массива, используя 32-разрядное целое число со знаком для задания интервала времени.</span><span class="sxs-lookup"><span data-stu-id="1d21b-468">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="1d21b-469">Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="millisecondsTimeout" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-469">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-470">Если `millisecondsTimeout` равно нулю, метод не выполняет блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d21b-470">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1d21b-471">Он проверяет состояние дескрипторов ожидания и возвращается немедленно.</span><span class="sxs-lookup"><span data-stu-id="1d21b-471">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1d21b-472"><xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает исключение <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за Брошенный mutex.</span><span class="sxs-lookup"><span data-stu-id="1d21b-472">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="1d21b-473">Если `waitHandles` содержит выпущено мьютекс с меньшим значением индекса, чем Брошенный mutex <xref:System.Threading.WaitHandle.WaitAny%2A> метод обычно выполняется и исключение не вызывается.</span><span class="sxs-lookup"><span data-stu-id="1d21b-473">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="1d21b-474">Этот метод возвращает, когда ожидание завершается, когда все дескрипторы получили сигнал или истечении времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-474">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="1d21b-475">Если во время вызова сигнала более одного объекта возвращает значение индекса массива сигнальное объекта с наименьшим значением индекса сигнальное объектов.</span><span class="sxs-lookup"><span data-stu-id="1d21b-475">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="1d21b-476">В некоторых реализациях, если несколько записей, передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="1d21b-476">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="1d21b-477">Вызов этой перегрузки метода является таким же, как вызов <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1d21b-477">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1d21b-478">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-478">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-479">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-479">-or-</span></span>  
  
 <span data-ttu-id="1d21b-480">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-480">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1d21b-481">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="1d21b-481">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d21b-482">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-482"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-483">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-483">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-484">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-484">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d21b-485">В массиве <paramref name="waitHandles" /> отсутствуют элементы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-485"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-486">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-486">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1d21b-487">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="1d21b-487">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="1d21b-488">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-488">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1d21b-489">Ожидает получения сигнала любыми элементами заданного массива, используя значение типа <see cref="T:System.TimeSpan" /> для указания интервала времени.</span><span class="sxs-lookup"><span data-stu-id="1d21b-489">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="1d21b-490">Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="timeout" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-490">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-491">Если `timeout` равно нулю, метод не выполняет блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d21b-491">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1d21b-492">Он проверяет состояние дескрипторов ожидания и возвращается немедленно.</span><span class="sxs-lookup"><span data-stu-id="1d21b-492">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1d21b-493"><xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает исключение <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за Брошенный mutex.</span><span class="sxs-lookup"><span data-stu-id="1d21b-493">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="1d21b-494">Если `waitHandles` содержит выпущено мьютекс с меньшим значением индекса, чем Брошенный mutex <xref:System.Threading.WaitHandle.WaitAny%2A> метод обычно выполняется и исключение не вызывается.</span><span class="sxs-lookup"><span data-stu-id="1d21b-494">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="1d21b-495">Этот метод возвращает, когда ожидание завершается, когда все дескрипторы получили сигнал или при возникновении тайм-аута.</span><span class="sxs-lookup"><span data-stu-id="1d21b-495">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="1d21b-496">Если во время вызова сигнала более одного объекта возвращает значение индекса массива сигнальное объекта с наименьшим значением индекса сигнальное объектов.</span><span class="sxs-lookup"><span data-stu-id="1d21b-496">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="1d21b-497">В некоторых реализациях, если несколько записей, передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="1d21b-497">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="1d21b-498">Максимальное значение для `timeout` — <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-498">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1d21b-499">Вызов этой перегрузки метода является таким же, как вызов <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1d21b-499">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1d21b-500">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-500">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-501">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-501">-or-</span></span>  
  
 <span data-ttu-id="1d21b-502">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-502">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1d21b-503">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="1d21b-503">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d21b-504"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-504"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="1d21b-505">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-505">-or-</span></span>  
  
 <span data-ttu-id="1d21b-506">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-506"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-507">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-507">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-508">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-508">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d21b-509">В массиве <paramref name="waitHandles" /> отсутствуют элементы.</span><span class="sxs-lookup"><span data-stu-id="1d21b-509"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-510">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-510">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1d21b-511">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="1d21b-511">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="1d21b-512">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-512">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="1d21b-513">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-513"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1d21b-514">Ожидает, пока какой-либо из элементов заданного массива не получит сигнал, используя 32-разрядное целое число со знаком для задания интервала времени и определения, нужно ли осуществить выход из домена синхронизации до окончания ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-514">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="1d21b-515">Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="millisecondsTimeout" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-515">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-516">Если `millisecondsTimeout` равно нулю, метод не выполняет блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d21b-516">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1d21b-517">Он проверяет состояние дескрипторов ожидания и возвращается немедленно.</span><span class="sxs-lookup"><span data-stu-id="1d21b-517">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1d21b-518"><xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="1d21b-518"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1d21b-519">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает `true` Если ожидание завершается, так как будет сброшен семафор.</span><span class="sxs-lookup"><span data-stu-id="1d21b-519">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="1d21b-520">Брошенный mutex обычно признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="1d21b-520">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1d21b-521">В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач).</span><span class="sxs-lookup"><span data-stu-id="1d21b-521">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1d21b-522">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="1d21b-522">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1d21b-523"><xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает исключение <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за Брошенный mutex.</span><span class="sxs-lookup"><span data-stu-id="1d21b-523">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="1d21b-524">Если `waitHandles` содержит выпущено мьютекс с меньшим значением индекса, чем Брошенный mutex <xref:System.Threading.WaitHandle.WaitAny%2A> метод обычно выполняется и исключение не вызывается.</span><span class="sxs-lookup"><span data-stu-id="1d21b-524">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d21b-525">В версиях .NET Framework, предшествующих версии 2.0, если поток завершает работу или прервана без явного освобождения <xref:System.Threading.Mutex>и что `Mutex` находится по индексу 0 (ноль) в `WaitAny` массива на другой поток, возвращенный индекс `WaitAny` — 128 вместо 0.</span><span class="sxs-lookup"><span data-stu-id="1d21b-525">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="1d21b-526">Этот метод возвращает, когда ожидание завершается, когда все дескрипторы получили сигнал или истечении времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-526">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="1d21b-527">Если во время вызова сигнала более одного объекта возвращает значение индекса массива сигнальное объекта с наименьшим значением индекса сигнальное объектов.</span><span class="sxs-lookup"><span data-stu-id="1d21b-527">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="1d21b-528">В некоторых реализациях, если несколько записей, передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="1d21b-528">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1d21b-529">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="1d21b-529">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1d21b-530">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAny%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="1d21b-530">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1d21b-531">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-531">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1d21b-532">Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-532">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1d21b-533">Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAny%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="1d21b-533">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="1d21b-534">Поток осуществляет возврат к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAny%2A> метод завершения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-534">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="1d21b-535">Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-535">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1d21b-536">В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-536">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1d21b-537">Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.WaitAny%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-537">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1d21b-538">Когда <xref:System.Threading.WaitHandle.WaitAny%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="1d21b-538">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d21b-539">В следующем примере кода показано, как использовать пул потоков для одновременного поиска файла на нескольких дисках.</span><span class="sxs-lookup"><span data-stu-id="1d21b-539">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="1d21b-540">Для высвобождения места на диске выполняется поиск только корневом каталоге каждого диска.</span><span class="sxs-lookup"><span data-stu-id="1d21b-540">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1d21b-541">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-541">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-542">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-542">-or-</span></span>  
  
 <span data-ttu-id="1d21b-543">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-543">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1d21b-544">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="1d21b-544">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="1d21b-545"><paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 1.0 или 1.1.</span><span class="sxs-lookup"><span data-stu-id="1d21b-545"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d21b-546">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-546"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-547">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-547">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-548">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-548">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d21b-549"><paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 2.0 или выше.</span><span class="sxs-lookup"><span data-stu-id="1d21b-549"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-550">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-550">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1d21b-551">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="1d21b-551">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="1d21b-552">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-552">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="1d21b-553">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-553"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1d21b-554">Ожидает получения сигнала какими-либо элементами заданного массива, используя <see cref="T:System.TimeSpan" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-554">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="1d21b-555">Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="timeout" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-555">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-556">Если `timeout` равно нулю, метод не выполняет блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d21b-556">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1d21b-557">Он проверяет состояние дескрипторов ожидания и возвращается немедленно.</span><span class="sxs-lookup"><span data-stu-id="1d21b-557">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1d21b-558"><xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="1d21b-558"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1d21b-559">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает `true` Если ожидание завершается, так как будет сброшен семафор.</span><span class="sxs-lookup"><span data-stu-id="1d21b-559">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="1d21b-560">Брошенный mutex обычно признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="1d21b-560">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1d21b-561">В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач).</span><span class="sxs-lookup"><span data-stu-id="1d21b-561">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1d21b-562">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="1d21b-562">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1d21b-563"><xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает исключение <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за Брошенный mutex.</span><span class="sxs-lookup"><span data-stu-id="1d21b-563">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="1d21b-564">Если `waitHandles` содержит выпущено мьютекс с меньшим значением индекса, чем Брошенный mutex <xref:System.Threading.WaitHandle.WaitAny%2A> метод обычно выполняется и исключение не вызывается.</span><span class="sxs-lookup"><span data-stu-id="1d21b-564">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d21b-565">В версиях .NET Framework, предшествующих версии 2.0, если поток завершает работу или прервана без явного освобождения <xref:System.Threading.Mutex>и что `Mutex` находится по индексу 0 (ноль) в `WaitAny` массива на другой поток, возвращенный индекс `WaitAny` — 128 вместо 0.</span><span class="sxs-lookup"><span data-stu-id="1d21b-565">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="1d21b-566">Этот метод возвращает, когда ожидание завершается, когда все дескрипторы получили сигнал или при возникновении тайм-аута.</span><span class="sxs-lookup"><span data-stu-id="1d21b-566">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="1d21b-567">Если во время вызова сигнала более одного объекта возвращает значение индекса массива сигнальное объекта с наименьшим значением индекса сигнальное объектов.</span><span class="sxs-lookup"><span data-stu-id="1d21b-567">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="1d21b-568">В некоторых реализациях, если несколько записей, передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="1d21b-568">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="1d21b-569">Максимальное значение для `timeout` — <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-569">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1d21b-570">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="1d21b-570">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1d21b-571">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAny%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="1d21b-571">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1d21b-572">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-572">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1d21b-573">Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-573">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1d21b-574">Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAny%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="1d21b-574">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="1d21b-575">Поток осуществляет возврат к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAny%2A> метод завершения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-575">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="1d21b-576">Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-576">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1d21b-577">В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-577">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1d21b-578">Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.WaitAny%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-578">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1d21b-579">Когда <xref:System.Threading.WaitHandle.WaitAny%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="1d21b-579">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d21b-580">В следующем примере кода показано, как использовать пул потоков для одновременного поиска файла на нескольких дисках.</span><span class="sxs-lookup"><span data-stu-id="1d21b-580">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="1d21b-581">Для высвобождения места на диске выполняется поиск только корневом каталоге каждого диска.</span><span class="sxs-lookup"><span data-stu-id="1d21b-581">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1d21b-582">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-582">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="1d21b-583">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-583">-or-</span></span>  
  
 <span data-ttu-id="1d21b-584">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-584">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1d21b-585">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="1d21b-585">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="1d21b-586"><paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 1.0 или 1.1.</span><span class="sxs-lookup"><span data-stu-id="1d21b-586"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d21b-587"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-587"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="1d21b-588">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-588">-or-</span></span>  
  
 <span data-ttu-id="1d21b-589">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-589"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-590">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-590">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-591">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-591">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1d21b-592"><paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 2.0 или выше.</span><span class="sxs-lookup"><span data-stu-id="1d21b-592"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-593">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-593">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1d21b-594">Блокирует текущий поток до получения сигнала объектом <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-594">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1d21b-595">Блокирует текущий поток до получения сигнала объектом <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-595">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
        <returns>
          <span data-ttu-id="1d21b-596">Значение <see langword="true" />, если текущий экземпляр получает сигнал.</span><span class="sxs-lookup"><span data-stu-id="1d21b-596"><see langword="true" /> if the current instance receives a signal.</span></span> <span data-ttu-id="1d21b-597">Пока текущий экземпляр не сигнализирует, метод <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> не возвращает управление.</span><span class="sxs-lookup"><span data-stu-id="1d21b-597">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-598"><xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="1d21b-598"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1d21b-599">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `true` при будет сброшен семафор.</span><span class="sxs-lookup"><span data-stu-id="1d21b-599">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1d21b-600">Брошенный mutex обычно признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="1d21b-600">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1d21b-601">В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач).</span><span class="sxs-lookup"><span data-stu-id="1d21b-601">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1d21b-602">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="1d21b-602">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1d21b-603">Код, вызывающий этот метод блокируется неограниченное время до получения сигнала текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="1d21b-603">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="1d21b-604">Используйте этот метод для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, например, создается при завершении асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="1d21b-604">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="1d21b-605">Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-605">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="1d21b-606">Вызов перегрузки этого метода эквивалентен вызову <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> перегрузка метода и указав значение -1 или <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> для первого параметра и `false` для второго параметра.</span><span class="sxs-lookup"><span data-stu-id="1d21b-606">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="1d21b-607">Переопределите этот метод для настройки поведения производного класса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-607">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d21b-608">В следующем примере кода показано, как использовать дескриптор ожидания для поддержания процесса завершения работы при ожидании фоновый поток для завершения выполнения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-608">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1d21b-609">Текущий экземпляр уже удален.</span><span class="sxs-lookup"><span data-stu-id="1d21b-609">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-610">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-610">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-611">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-611">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-612">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-612">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="1d21b-613">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-613">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1d21b-614">Блокирует текущий поток до получения текущим дескриптором <see cref="T:System.Threading.WaitHandle" /> сигнала, используя 32-разрядное целое число со знаком для указания интервала времени в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="1d21b-614">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span></span></summary>
        <returns>
          <span data-ttu-id="1d21b-615">Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-615"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-616">Если `millisecondsTimeout` равно нулю, метод не выполняет блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d21b-616">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1d21b-617">Он проверяет состояние дескриптора ожидания и возвращается немедленно.</span><span class="sxs-lookup"><span data-stu-id="1d21b-617">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="1d21b-618">Происходит, код, вызывающий этот метод блокируется до текущий экземпляр получает сигнал или истечения времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-618">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="1d21b-619">Используйте этот метод для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, например, создается при завершении асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="1d21b-619">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="1d21b-620">Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-620">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="1d21b-621">Переопределите этот метод для настройки поведения производного класса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-621">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="1d21b-622">Вызов этой перегрузки метода является таким же, как вызов <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1d21b-622">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d21b-623">В следующем примере кода показано, как использовать дескриптор ожидания для поддержания процесса завершения работы при ожидании фоновый поток для завершения выполнения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-623">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1d21b-624">Текущий экземпляр уже удален.</span><span class="sxs-lookup"><span data-stu-id="1d21b-624">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d21b-625">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-625"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-626">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-626">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-627">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-627">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-628">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-628">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="1d21b-629">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-629">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1d21b-630">Блокирует текущий поток до получения сигнала текущим экземпляром, используя значение типа <see cref="T:System.TimeSpan" /> для указания интервала времени.</span><span class="sxs-lookup"><span data-stu-id="1d21b-630">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="1d21b-631">Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-631"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-632">Если `timeout` равно нулю, метод не выполняет блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d21b-632">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1d21b-633">Он проверяет состояние дескриптора ожидания и возвращается немедленно.</span><span class="sxs-lookup"><span data-stu-id="1d21b-633">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="1d21b-634">Происходит, код, вызывающий этот метод блокируется до текущий экземпляр получает сигнал или истечения времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-634">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="1d21b-635">Используйте этот метод для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, например, создается при завершении асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="1d21b-635">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="1d21b-636">Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-636">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="1d21b-637">Переопределите этот метод для настройки поведения производного класса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-637">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="1d21b-638">Максимальное значение для `timeout` — <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-638">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1d21b-639">Вызов этой перегрузки метода является таким же, как вызов <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="1d21b-639">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1d21b-640">Текущий экземпляр уже удален.</span><span class="sxs-lookup"><span data-stu-id="1d21b-640">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d21b-641"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-641"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="1d21b-642">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-642">-or-</span></span>  
  
 <span data-ttu-id="1d21b-643">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-643"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-644">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-644">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-645">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-645">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-646">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-646">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="1d21b-647">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-647">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="1d21b-648">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-648"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1d21b-649">Блокирует текущий поток до получения сигнала текущим объектом <see cref="T:System.Threading.WaitHandle" />, используя 32-разрядное целое число со знаком для задания периода времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-649">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="1d21b-650">Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-650"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-651">Если `millisecondsTimeout` равно нулю, метод не выполняет блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d21b-651">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1d21b-652">Он проверяет состояние дескриптора ожидания и возвращается немедленно.</span><span class="sxs-lookup"><span data-stu-id="1d21b-652">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="1d21b-653"><xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="1d21b-653"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1d21b-654">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `true` при будет сброшен семафор.</span><span class="sxs-lookup"><span data-stu-id="1d21b-654">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1d21b-655">Брошенный mutex обычно признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="1d21b-655">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1d21b-656">В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач).</span><span class="sxs-lookup"><span data-stu-id="1d21b-656">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1d21b-657">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="1d21b-657">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1d21b-658">Происходит, код, вызывающий этот метод блокируется до текущий экземпляр получает сигнал или истечения времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-658">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="1d21b-659">Используйте этот метод для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, например, создается при завершении асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="1d21b-659">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="1d21b-660">Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-660">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="1d21b-661">Переопределите этот метод для настройки поведения производного класса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-661">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1d21b-662">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="1d21b-662">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1d21b-663">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitOne%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="1d21b-663">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1d21b-664">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-664">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1d21b-665">Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-665">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1d21b-666">Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitOne%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="1d21b-666">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="1d21b-667">Поток осуществляет возврат к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitOne%2A> метод завершения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-667">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="1d21b-668">Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-668">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1d21b-669">В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-669">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1d21b-670">Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.WaitOne%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-670">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1d21b-671">Когда <xref:System.Threading.WaitHandle.WaitOne%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="1d21b-671">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d21b-672">В следующем примере показан способ <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> перегрузка метода должно происходить, когда он вызывается в пределах домена синхронизации.</span><span class="sxs-lookup"><span data-stu-id="1d21b-672">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="1d21b-673">Во-первых, поток ожидает с `exitContext` значение `false` и блокирует до истечения времени ожидания ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-673">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="1d21b-674">Второй поток выполняет после первый поток завершает и ожидает с `exitContext` значение `true`.</span><span class="sxs-lookup"><span data-stu-id="1d21b-674">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="1d21b-675">Вызов сигнала дескриптора ожидания для этого второй поток не заблокирован, и до истечения времени ожидания ожидания завершения потока.</span><span class="sxs-lookup"><span data-stu-id="1d21b-675">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1d21b-676">Текущий экземпляр уже удален.</span><span class="sxs-lookup"><span data-stu-id="1d21b-676">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d21b-677">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-677"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-678">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-678">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-679">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-679">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-680">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-680">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="1d21b-681">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-681">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="1d21b-682">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-682"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1d21b-683">Блокирует текущий поток до получения сигнала текущим экземпляром, используя значение типа <see cref="T:System.TimeSpan" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-683">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="1d21b-684">Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-684"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-685">Если `timeout` равно нулю, метод не выполняет блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d21b-685">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1d21b-686">Он проверяет состояние дескриптора ожидания и возвращается немедленно.</span><span class="sxs-lookup"><span data-stu-id="1d21b-686">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="1d21b-687"><xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="1d21b-687"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1d21b-688">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `true` при будет сброшен семафор.</span><span class="sxs-lookup"><span data-stu-id="1d21b-688">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1d21b-689">Брошенный mutex обычно признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="1d21b-689">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1d21b-690">В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач).</span><span class="sxs-lookup"><span data-stu-id="1d21b-690">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1d21b-691">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="1d21b-691">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1d21b-692">Происходит, код, вызывающий этот метод блокируется до текущий экземпляр получает сигнал или истечения времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-692">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="1d21b-693">Используйте этот метод для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, например, создается при завершении асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="1d21b-693">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="1d21b-694">Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-694">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="1d21b-695">Переопределите этот метод для настройки поведения производного класса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-695">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="1d21b-696">Максимальное значение для `timeout` — <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-696">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1d21b-697">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="1d21b-697">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1d21b-698">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitOne%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="1d21b-698">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1d21b-699">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-699">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1d21b-700">Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-700">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1d21b-701">Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitOne%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="1d21b-701">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="1d21b-702">Поток осуществляет возврат к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitOne%2A> метод завершения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-702">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="1d21b-703">Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="1d21b-703">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1d21b-704">В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса.</span><span class="sxs-lookup"><span data-stu-id="1d21b-704">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1d21b-705">Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.WaitOne%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-705">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1d21b-706">Когда <xref:System.Threading.WaitHandle.WaitOne%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="1d21b-706">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d21b-707">В следующем примере кода показано, как использовать дескриптор ожидания для поддержания процесса завершения работы при ожидании фоновый поток для завершения выполнения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-707">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1d21b-708">Текущий экземпляр уже удален.</span><span class="sxs-lookup"><span data-stu-id="1d21b-708">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1d21b-709"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-709"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="1d21b-710">- или -</span><span class="sxs-lookup"><span data-stu-id="1d21b-710">-or-</span></span>  
  
 <span data-ttu-id="1d21b-711">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1d21b-711"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1d21b-712">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="1d21b-712">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1d21b-713">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="1d21b-713">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1d21b-714">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="1d21b-714">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary><span data-ttu-id="1d21b-715">Указывает, что время ожидания операции <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> истекло до получения сигнала каким-либо из дескрипторов ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d21b-715">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span></span> <span data-ttu-id="1d21b-716">Это поле является константой.</span><span class="sxs-lookup"><span data-stu-id="1d21b-716">This field is constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1d21b-717">Это поле является одним из возможных возвращаемых значений `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="1d21b-717">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1d21b-718">В следующем примере кода показано, как использовать пул потоков для одновременного поиска файла на нескольких дисках.</span><span class="sxs-lookup"><span data-stu-id="1d21b-718">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="1d21b-719">Для высвобождения места на диске выполняется поиск только корневом каталоге каждого диска.</span><span class="sxs-lookup"><span data-stu-id="1d21b-719">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>