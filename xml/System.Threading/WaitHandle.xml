<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5bc57b6d09c8f3f7aebbf5cc7bfbbcb207a197ba" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51937865" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="a49a7-101">Инкапсулирует связанные с операционной системой объекты, ожидающие монопольного доступа к общим ресурсам.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a49a7-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-102"><xref:System.Threading.WaitHandle> Класс, инкапсулирующий собственный дескриптор операционной системы синхронизации и используется для представления всех объектов синхронизации в среде выполнения, выполнять несколько операций ожидания.</span><span class="sxs-lookup"><span data-stu-id="a49a7-102">The <xref:System.Threading.WaitHandle> class encapsulates a native operating system synchronization handle and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="a49a7-103">Сравнение дескрипторов ожидания с другими объектами синхронизации, см. в разделе [Обзор примитивов синхронизации](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="a49a7-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="a49a7-104"><xref:System.Threading.WaitHandle> Сам класс является абстрактным.</span><span class="sxs-lookup"><span data-stu-id="a49a7-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="a49a7-105">Классы, производные от <xref:System.Threading.WaitHandle> определяют механизм сигнализации о предоставлении или освобождение доступ к общему ресурсу, но они используют наследуемого <xref:System.Threading.WaitHandle> методы на время ожидания для доступа к общим ресурсам.</span><span class="sxs-lookup"><span data-stu-id="a49a7-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="a49a7-106">Классы, унаследованные от <xref:System.Threading.WaitHandle> включают:</span><span class="sxs-lookup"><span data-stu-id="a49a7-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="a49a7-107">класс <xref:System.Threading.Mutex>;</span><span class="sxs-lookup"><span data-stu-id="a49a7-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="a49a7-108">См. в разделе [мьютексы](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="a49a7-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="a49a7-109"><xref:System.Threading.EventWaitHandle> Класс и его производные классы <xref:System.Threading.AutoResetEvent> и <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="a49a7-110">См. дополнительные сведения об [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="a49a7-110">See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
-   <span data-ttu-id="a49a7-111">класс <xref:System.Threading.Semaphore>;</span><span class="sxs-lookup"><span data-stu-id="a49a7-111">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="a49a7-112">См. в разделе [Semaphore и SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="a49a7-112">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="a49a7-113">Потоки могут блокироваться по отдельному дескриптору ожидания путем вызова метода экземпляра <xref:System.Threading.WaitHandle.WaitOne%2A>, которая наследуется производными классами <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-113">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="a49a7-114">Классов, производных от <xref:System.Threading.WaitHandle> их сходство потоков по-разному.</span><span class="sxs-lookup"><span data-stu-id="a49a7-114">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="a49a7-115">Дескрипторы ожидания событий (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, и <xref:System.Threading.ManualResetEvent>) и семафоры не поддерживают сходство потоков; любой поток может подать сигнал дескриптор ожидания событий или семафора.</span><span class="sxs-lookup"><span data-stu-id="a49a7-115">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="a49a7-116">Мьютексы, с другой стороны, поддерживают сходство потоков; поток, который является владельцем мьютекса необходимо освободить его, и исключение возникает в том случае, если поток вызывает <xref:System.Threading.Mutex.ReleaseMutex%2A> метод, который не является владельцем мьютекса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-116">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="a49a7-117">Так как <xref:System.Threading.WaitHandle> класс является производным от <xref:System.MarshalByRefObject>, эти классы можно использовать для синхронизации действий потоков за границами домена приложения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-117">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="a49a7-118">В дополнение к его производные классы <xref:System.Threading.WaitHandle> класс содержит несколько статических методов, которые блокируют поток, пока один или несколько объектов синхронизации получения сигнала.</span><span class="sxs-lookup"><span data-stu-id="a49a7-118">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.</span></span> <span data-ttu-id="a49a7-119">Сюда входит следующее.</span><span class="sxs-lookup"><span data-stu-id="a49a7-119">These include:</span></span>  
  
-   <span data-ttu-id="a49a7-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, что позволяет потоку сигнал одному дескриптору ожидания и немедленно ожидать на другом.</span><span class="sxs-lookup"><span data-stu-id="a49a7-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="a49a7-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, что позволяет потоку ожидать все дескрипторы ожидания в массиве получения сигнала.</span><span class="sxs-lookup"><span data-stu-id="a49a7-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="a49a7-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, который позволяет потоку ожидать, пока не будет выдан сигнал любого из указанного набора дескрипторов ожидания.</span><span class="sxs-lookup"><span data-stu-id="a49a7-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</span></span>  
  
 <span data-ttu-id="a49a7-123">Перегрузки этих методов предоставляют интервалы времени ожидания для прерывания ожидания, а также возможность выхода из контекста синхронизации до начала ожидания, что позволяет другим потокам использовать контекст синхронизации.</span><span class="sxs-lookup"><span data-stu-id="a49a7-123">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a49a7-124">Этот тип реализует <xref:System.IDisposable> интерфейс.</span><span class="sxs-lookup"><span data-stu-id="a49a7-124">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="a49a7-125">Когда вы закончите, используя тип или тип, производный от него, следует освободить его прямо или косвенно.</span><span class="sxs-lookup"><span data-stu-id="a49a7-125">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="a49a7-126">Чтобы удалить тип напрямую, вызовите его <xref:System.Threading.WaitHandle.Close%2A> метод в `try` / `catch` блока.</span><span class="sxs-lookup"><span data-stu-id="a49a7-126">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="a49a7-127">Чтобы избавиться от его косвенно, используйте языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a49a7-127">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="a49a7-128">Дополнительные сведения см. в разделе «С помощью объекта, реализует IDisposable» <xref:System.IDisposable> разделу интерфейса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-128">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="a49a7-129"><xref:System.Threading.WaitHandle> реализует <xref:System.IDisposable.Dispose%2A> шаблон.</span><span class="sxs-lookup"><span data-stu-id="a49a7-129"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="a49a7-130">См. в разделе [шаблон удаления](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="a49a7-130">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="a49a7-131">При наследовании от <xref:System.Threading.WaitHandle>, используйте <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство, чтобы сохранять ваш собственный дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="a49a7-131">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native operating system handle.</span></span> <span data-ttu-id="a49a7-132">Необходимо переопределить защищенный <xref:System.Threading.WaitHandle.Dispose%2A> метод только при использовании дополнительных неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="a49a7-132">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a49a7-133">В следующем примере кода показано как два потока могут сделать фоновых задач при основной поток ожидает завершения с помощью статического задач <xref:System.Threading.WaitHandle.WaitAny%2A> и <xref:System.Threading.WaitHandle.WaitAll%2A> методы <xref:System.Threading.WaitHandle> класса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-133">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="a49a7-134">Данный тип потокобезопасен.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a49a7-134">This type is thread safe.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="a49a7-135">Потоки</span>
      <span class="sxs-lookup">
        <span data-stu-id="a49a7-135">Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">
      <span data-ttu-id="a49a7-136">Объекты и функциональные возможности работы с потоками</span>
      <span class="sxs-lookup">
        <span data-stu-id="a49a7-136">Threading Objects and Features</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">
      <span data-ttu-id="a49a7-137">Mutexes</span>
      <span class="sxs-lookup">
        <span data-stu-id="a49a7-137">Mutexes</span>
      </span>
    </related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
      <span data-ttu-id="a49a7-138">EventWaitHandle, AutoResetEvent и ManualResetEvent</span>
      <span class="sxs-lookup">
        <span data-stu-id="a49a7-138">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
      <span data-ttu-id="a49a7-139">Семафоры</span>
      <span class="sxs-lookup">
        <span data-stu-id="a49a7-139">Semaphores</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a49a7-140">Инициализирует новый экземпляр класса <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-140">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a49a7-141">Освобождает все ресурсы, удерживаемые текущим объектом <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-141">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-142">Этот метод является открытую реализацию <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> метод <xref:System.Threading.WaitHandle> класса и его производных классов.</span><span class="sxs-lookup"><span data-stu-id="a49a7-142">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="a49a7-143">Он предоставляет стандартную реализацию, которая вызывает `Dispose(Boolean)` перегрузка с `true` аргумент, а затем вызывает <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="a49a7-143">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a49a7-144">Вызовите этот метод, чтобы освободить все ресурсы, удерживаемые экземпляром `WaitHandle` или производного класса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-144">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="a49a7-145">Когда этот метод вызывается, ссылки на текущий экземпляр привести к неопределенному поведению.</span><span class="sxs-lookup"><span data-stu-id="a49a7-145">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a49a7-146">Всегда вызывайте метод <xref:System.Threading.WaitHandle.Close%2A> или <xref:System.Threading.WaitHandle.Dispose> перед освобождением последней ссылки на <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-146">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="a49a7-147">В противном случае им ресурсы не будут освобождены.</span><span class="sxs-lookup"><span data-stu-id="a49a7-147">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a49a7-148">Необходимо переопределить <see langword="Dispose(Boolean)" /> метод для освобождения ресурсов, выделенных в производных классах.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a49a7-148">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
          </para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">
          <span data-ttu-id="a49a7-149">Реализация метода Dispose</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-149">Implementing a Dispose Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a49a7-150">Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-150">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a49a7-151">Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-151">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-152">Этот метод эквивалентен <xref:System.Threading.WaitHandle.Close%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="a49a7-152">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a49a7-153">Всегда вызывайте метод <xref:System.Threading.WaitHandle.Close%2A> или <xref:System.Threading.WaitHandle.Dispose> перед освобождением последней ссылки на <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-153">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="a49a7-154">В противном случае им ресурсы не будут освобождены.</span><span class="sxs-lookup"><span data-stu-id="a49a7-154">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">
          <span data-ttu-id="a49a7-155">Очистка неуправляемых ресурсов</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-155">Cleaning Up Unmanaged Resources</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <span data-ttu-id="a49a7-156">Значение <see langword="true" /> позволяет освободить как управляемые, так и неуправляемые ресурсы; значение <see langword="false" /> освобождает только неуправляемые ресурсы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-156">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-157">При переопределении в производном классе освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.Threading.WaitHandle" />, и при необходимости освобождает управляемые ресурсы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-157">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-158">Этот метод вызывается <xref:System.Threading.WaitHandle.Close%2A> и <xref:System.Threading.WaitHandle.Dispose> методы с `explicitDisposing` параметру присвоить `true`.</span><span class="sxs-lookup"><span data-stu-id="a49a7-158">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="a49a7-159">Когда `explicitDisposing` параметр `true`, этот метод освобождает все ресурсы, занятые любыми управляемыми объектами, <xref:System.Threading.WaitHandle> ссылки на объекты.</span><span class="sxs-lookup"><span data-stu-id="a49a7-159">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a49a7-160">Необходимо переопределить <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> метод для освобождения ресурсов, выделенных в производных классах.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a49a7-160">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
            <span data-ttu-id="a49a7-161">
              <see cref="M:System.Threading.WaitHandle.Close" /> Или <see cref="M:System.Threading.WaitHandle.Dispose" /> метод может вызываться несколько раз другими объектами.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a49a7-161">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="a49a7-162">При переопределении этого метода нужно избегать ссылок на объекты, которые были уничтожены предыдущими вызовами <see langword="Dispose" /> или <see langword="Close" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a49a7-162">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span>
            </span>
          </para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">
          <span data-ttu-id="a49a7-163">Реализация метода Dispose</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-163">Implementing a Dispose Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a49a7-164">Возвращает или задает собственный дескриптор операционной системы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-164">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a49a7-165">Объект <see langword="IntPtr" />, представляющий собственный дескриптор операционной системы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-165">An <see langword="IntPtr" /> representing the native operating system handle.</span>
          </span>
          <span data-ttu-id="a49a7-166">Значением по умолчанию является значение поля <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-166">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-167">Назначение нового значения для <xref:System.Threading.WaitHandle.Handle%2A> свойства не закрывает дескриптор предыдущего.</span><span class="sxs-lookup"><span data-stu-id="a49a7-167">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="a49a7-168">Это может привести утечка дескриптора.</span><span class="sxs-lookup"><span data-stu-id="a49a7-168">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="a49a7-169">Не используйте это свойство в .NET Framework версии 2.0 или более поздней версии; Используйте <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство вместо этого.</span><span class="sxs-lookup"><span data-stu-id="a49a7-169">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="a49a7-170">Этому свойству присвоить допустимый дескриптор также наборы <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство, но задание значения <xref:System.Threading.WaitHandle.InvalidHandle> может привести к утечка дескриптора.</span><span class="sxs-lookup"><span data-stu-id="a49a7-170">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="a49a7-171">Требует полного доверия для непосредственного вызывающего объекта задать значение свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-171">Requires full trust for the immediate caller to set the property value.</span>
          </span>
          <span data-ttu-id="a49a7-172">Этот член не может задать частично доверенном или прозрачном коде.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-172">This member cannot be set by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="a49a7-173">Производные типы должны иметь <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> для задания значения свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-173">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a49a7-174">Представляет недопустимый собственный дескриптор операционной системы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-174">Represents an invalid native operating system handle.</span>
          </span>
          <span data-ttu-id="a49a7-175">Это поле доступно только для чтения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-175">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-176">Используется внутренним образом для инициализации <xref:System.Threading.WaitHandle.Handle%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="a49a7-176">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a49a7-177">Это значение можно использовать, чтобы определить, является ли <see cref="P:System.Threading.WaitHandle.Handle" /> свойство содержит допустимый собственный дескриптор операционной системы.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a49a7-177">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a49a7-178">Возвращает или задает собственный дескриптор операционной системы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-178">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a49a7-179">Объект <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />, представляющий собственный дескриптор операционной системы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-179">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-180">При назначении нового значения для <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство, предыдущих дескриптор закрывается при предыдущем <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> объект собран.</span><span class="sxs-lookup"><span data-stu-id="a49a7-180">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="a49a7-181">Не следует вручную закрывать дескриптор, так как это приводит к <xref:System.ObjectDisposedException> при <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> предпринимается попытка закрыть дескриптор.</span><span class="sxs-lookup"><span data-stu-id="a49a7-181">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="a49a7-182"><xref:System.Threading.WaitHandle> реализует <xref:System.IDisposable.Dispose%2A> шаблон.</span><span class="sxs-lookup"><span data-stu-id="a49a7-182"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="a49a7-183">См. в разделе [шаблон удаления](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="a49a7-183">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="a49a7-184">При наследовании от <xref:System.Threading.WaitHandle>, используйте <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство, чтобы сохранять маркер собственный дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="a49a7-184">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="a49a7-185">Необходимо переопределить защищенный <xref:System.Threading.WaitHandle.Dispose%2A> метод только при использовании дополнительных неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="a49a7-185">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="a49a7-186">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-186">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="a49a7-187">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-187">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="a49a7-188">Производные типы должны иметь <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> для вызова этого члена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-188">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a49a7-189">Подает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает другого.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-189">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="a49a7-190">Объект <see cref="T:System.Threading.WaitHandle" />, который получает сигнал.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-190">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="a49a7-191">Объект <see cref="T:System.Threading.WaitHandle" />, сигнализация которого ожидается.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-191">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-192">Подает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает другого.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-192">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-193">Значение <see langword="true" />, если и сигнал, и ожидание завершаются удачно; если операция ожидания не завершается, то возврат из метода не происходит.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-193">
              <see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-194">Эта операция не обязательно быть атомарными.</span><span class="sxs-lookup"><span data-stu-id="a49a7-194">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="a49a7-195">После текущего потока сигналы `toSignal` , но до его ожидает `toWaitOn`, поток, на котором выполняется на другом процессоре может сигнализировать `toWaitOn` или ждать ее завершения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-195">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a49a7-196">В следующем примере кода используется <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> перегруженный метод, чтобы разрешить основному потоку сигнала заблокированный поток и затем подождите, пока поток завершает задачу.</span><span class="sxs-lookup"><span data-stu-id="a49a7-196">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="a49a7-197">Пример начинается пять потоков, позволяет им блокировать на <xref:System.Threading.EventWaitHandle> созданные с помощью <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> флага, а затем времени одним потоком выпусков, пользователь нажимает клавишу ВВОД.</span><span class="sxs-lookup"><span data-stu-id="a49a7-197">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="a49a7-198">Затем ставит в очередь другой пять потоков и освобождает их все с помощью <xref:System.Threading.EventWaitHandle> созданные с помощью <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> флаг.</span><span class="sxs-lookup"><span data-stu-id="a49a7-198">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a49a7-199">Свойство <paramref name="toSignal" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-199">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-200">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-200">-or-</span>
          </span>
          <span data-ttu-id="a49a7-201">Свойство <paramref name="toWaitOn" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-201">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a49a7-202">Метод был вызван в потоке с атрибутом <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-202">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="a49a7-203">Этот метод не поддерживается в Windows 98 и Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-203">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-204">Параметр <paramref name="toSignal" /> является семафором и его счетчик уже достиг максимального значения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-204">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-205">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-205">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-206">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-206">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="a49a7-207">Объект <see cref="T:System.Threading.WaitHandle" />, который получает сигнал.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-207">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="a49a7-208">Объект <see cref="T:System.Threading.WaitHandle" />, сигнализация которого ожидается.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-208">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="a49a7-209">Целое число, представляющее интервал ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-209">An integer that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="a49a7-210">Если значение равно <see cref="F:System.Threading.Timeout.Infinite" />, то есть -1, то ожидание длится неограниченное время.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-210">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a49a7-211">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-211">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-212">Передает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает сигнализации другого, задавая время ожидания в виде 32-разрядного целого числа со знаком и указывая, следует ли выйти из домена синхронизации контекста до начала ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-212">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-213">Значение <see langword="true" />, если и передача сигнала, и ожидание завершились успешно; значение <see langword="false" />, если передача сигнала была выполнена, но время ожидания истекло.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-213">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-214">Эта операция не обязательно быть атомарными.</span><span class="sxs-lookup"><span data-stu-id="a49a7-214">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="a49a7-215">После текущего потока сигналы `toSignal` , но до его ожидает `toWaitOn`, поток, на котором выполняется на другом процессоре может сигнализировать `toWaitOn` или ждать ее завершения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-215">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="a49a7-216">Если `millisecondsTimeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="a49a7-216">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="a49a7-217">Он проверяет состояние `toWaitOn` и сразу же.</span><span class="sxs-lookup"><span data-stu-id="a49a7-217">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a49a7-218">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="a49a7-218">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a49a7-219">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="a49a7-219">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a49a7-220">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-220">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a49a7-221">Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-221">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a49a7-222">Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="a49a7-222">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="a49a7-223">Поток возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.SignalAndWait%2A> завершения метода.</span><span class="sxs-lookup"><span data-stu-id="a49a7-223">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="a49a7-224">Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-224">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="a49a7-225">В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-225">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a49a7-226">Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.SignalAndWait%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-226">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a49a7-227">Когда <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="a49a7-227">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a49a7-228">Свойство <paramref name="toSignal" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-228">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-229">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-229">-or-</span>
          </span>
          <span data-ttu-id="a49a7-230">Свойство <paramref name="toWaitOn" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-230">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a49a7-231">Метод вызывается в потоке с атрибутом <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-231">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="a49a7-232">Этот метод не поддерживается в Windows 98 и Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-232">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-233">Невозможно передать сигнал объекту <see cref="T:System.Threading.WaitHandle" />, поскольку его счетчик превысит максимальное значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-233">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a49a7-234">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-234">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-235">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-235">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-236">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-236">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="a49a7-237">Объект <see cref="T:System.Threading.WaitHandle" />, который получает сигнал.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-237">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="a49a7-238">Объект <see cref="T:System.Threading.WaitHandle" />, сигнализация которого ожидается.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-238">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="a49a7-239">Объект <see cref="T:System.TimeSpan" />, представляющий период ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-239">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="a49a7-240">Если значение равно -1, то ожидание выполняется неограниченное время.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-240">If the value is -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a49a7-241">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-241">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-242">Передает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает сигнализации другого, задавая время ожидания в виде <see cref="T:System.TimeSpan" /> и указывая, следует ли выйти из домена синхронизации контекста до начала ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-242">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-243">Значение <see langword="true" />, если и передача сигнала, и ожидание завершились успешно; значение <see langword="false" />, если передача сигнала была выполнена, но время ожидания истекло.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-243">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-244">Эта операция не обязательно быть атомарными.</span><span class="sxs-lookup"><span data-stu-id="a49a7-244">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="a49a7-245">После текущего потока сигналы `toSignal` , но до его ожидает `toWaitOn`, поток, на котором выполняется на другом процессоре может сигнализировать `toWaitOn` или ждать ее завершения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-245">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="a49a7-246">Максимальное значение для `timeout` является <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-246">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a49a7-247">Если `timeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="a49a7-247">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="a49a7-248">Он проверяет состояние `toWaitOn` и сразу же.</span><span class="sxs-lookup"><span data-stu-id="a49a7-248">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a49a7-249">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="a49a7-249">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a49a7-250">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="a49a7-250">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a49a7-251">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-251">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a49a7-252">Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-252">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a49a7-253">Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="a49a7-253">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="a49a7-254">Поток возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.SignalAndWait%2A> завершения метода.</span><span class="sxs-lookup"><span data-stu-id="a49a7-254">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="a49a7-255">Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-255">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="a49a7-256">В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-256">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a49a7-257">Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.SignalAndWait%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-257">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a49a7-258">Когда <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="a49a7-258">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a49a7-259">Свойство <paramref name="toSignal" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-259">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-260">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-260">-or-</span>
          </span>
          <span data-ttu-id="a49a7-261">Свойство <paramref name="toWaitOn" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-261">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a49a7-262">Метод был вызван в потоке с атрибутом <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-262">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="a49a7-263">Этот метод не поддерживается в Windows 98 и Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-263">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-264">Параметр <paramref name="toSignal" /> является семафором и его счетчик уже достиг максимального значения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-264">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a49a7-265">Значение параметра <paramref name="timeout" /> соответствует отрицательному числу, отличному от -1 миллисекунды.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-265">
              <paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span>
          </span>
          <span data-ttu-id="a49a7-266">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-266">-or-</span>
          </span>
          <span data-ttu-id="a49a7-267">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-267">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-268">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-268">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-269">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-269">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a49a7-270">Ожидает получения сигнала всеми элементами заданного массива.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-270">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a49a7-271">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-271">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="a49a7-272">Этот массив не может содержать несколько ссылок на один и тот же объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-272">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-273">Ожидает получения сигнала всеми элементами заданного массива.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-273">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-274">
            <see langword="true" />, когда каждый элемент <paramref name="waitHandles" /> получил сигнал. В противном случае возврат из метода не происходит.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-274">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-275"><xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="a49a7-275"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a49a7-276">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает метод `true` когда прерывается мьютекс.</span><span class="sxs-lookup"><span data-stu-id="a49a7-276">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="a49a7-277">Брошенный мьютекс часто признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="a49a7-277">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a49a7-278">В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="a49a7-278">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a49a7-279">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="a49a7-279">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a49a7-280"><xref:System.Threading.WaitHandle.WaitAll%2A> Метод возвращает при получении сигнала всех дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="a49a7-280">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="a49a7-281">В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="a49a7-281">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="a49a7-282">Если массив содержит дубликаты, вызов завершится сбоем с <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-282">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a49a7-283"><xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-283">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="a49a7-284">Вызов перегрузки этого метода эквивалентен вызову <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузку метода и указав значение -1 (или <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) для `millisecondsTimeout` и `true` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a49a7-284">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a49a7-285">В следующем примере кода показано, как использовать пул потоков для асинхронного создания и записи для группы файлов.</span><span class="sxs-lookup"><span data-stu-id="a49a7-285">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="a49a7-286">Каждой операции записи помещается в очередь рабочий элемент и сигналов, при его завершении.</span><span class="sxs-lookup"><span data-stu-id="a49a7-286">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="a49a7-287">Основной поток ожидает сигнала все элементы, а затем завершается.</span><span class="sxs-lookup"><span data-stu-id="a49a7-287">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a49a7-288">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-288">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-289">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-289">-or-</span>
          </span>
          <span data-ttu-id="a49a7-290">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-290">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-291">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-291">-or-</span>
          </span>
          <span data-ttu-id="a49a7-292">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 2.0 или более поздней.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-292">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="a49a7-293">Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.ArgumentException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="a49a7-293">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="a49a7-294">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-294">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a49a7-295">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-295">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="a49a7-296">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-296">-or-</span>
          </span>
          <span data-ttu-id="a49a7-297">Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-297">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="a49a7-298">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 1.0 или 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-298">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-299">Ожидание прервано, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-299">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-300">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-300">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-301">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-301">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a49a7-302">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-302">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="a49a7-303">Данный массив не может содержать несколько ссылок на один и тот же объект (дубликатов).</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-303">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="a49a7-304">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-304">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-305">Ожидает получения сигнала всеми элементами заданного массива, используя значение <see cref="T:System.Int32" /> для указания интервала времени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-305">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-306">Значение <see langword="true" />, если каждый элемент массива <paramref name="waitHandles" /> получил сигнал; в противном случае значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-306">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-307">Если `millisecondsTimeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="a49a7-307">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="a49a7-308">Он проверяет состояние дескрипторов ожидания и немедленно возвращает.</span><span class="sxs-lookup"><span data-stu-id="a49a7-308">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a49a7-309"><xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, если ожидание завершается, что означает либо при получении сигнала всех дескрипторов ожидания.</span><span class="sxs-lookup"><span data-stu-id="a49a7-309">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="a49a7-310">В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="a49a7-310">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="a49a7-311">Если есть повторяющиеся значения в массиве, вызов завершится сбоем с <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-311">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a49a7-312"><xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-312">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="a49a7-313">Вызов перегрузки этого метода равносилен вызову метода является <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a49a7-313">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a49a7-314">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-314">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-315">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-315">-or-</span>
          </span>
          <span data-ttu-id="a49a7-316">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-316">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-317">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-317">-or-</span>
          </span>
          <span data-ttu-id="a49a7-318">В массиве <paramref name="waitHandles" /> отсутствуют элементы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-318">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="a49a7-319">Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.ArgumentException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="a49a7-319">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="a49a7-320">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-320">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a49a7-321">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-321">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="a49a7-322">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-322">-or-</span>
          </span>
          <span data-ttu-id="a49a7-323">Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-323">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a49a7-324">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-324">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-325">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-325">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-326">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-326">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-327">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-327">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a49a7-328">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-328">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="a49a7-329">Этот массив не может содержать несколько ссылок на один и тот же объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-329">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="a49a7-330">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-330">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-331">Ожидает получения сигнала всеми элементами заданного массива, используя значение <see cref="T:System.TimeSpan" /> для указания интервала времени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-331">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-332">Значение <see langword="true" />, если каждый элемент массива <paramref name="waitHandles" /> получил сигнал; в противном случае значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-332">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-333">Если `timeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="a49a7-333">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="a49a7-334">Он проверяет состояние дескрипторов ожидания и немедленно возвращает.</span><span class="sxs-lookup"><span data-stu-id="a49a7-334">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a49a7-335"><xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, если ожидание завершается, что означает, что или все дескрипторы получили сигнал или истечения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-335">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="a49a7-336">В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="a49a7-336">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="a49a7-337">Если массив содержит дубликаты, вызов завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="a49a7-337">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a49a7-338"><xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-338">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="a49a7-339">Максимальное значение для `timeout` является <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-339">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a49a7-340">Вызов перегрузки этого метода равносилен вызову метода является <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a49a7-340">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a49a7-341">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-341">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-342">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-342">-or-</span>
          </span>
          <span data-ttu-id="a49a7-343">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-343">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-344">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-344">-or-</span>
          </span>
          <span data-ttu-id="a49a7-345">В массиве <paramref name="waitHandles" /> отсутствуют элементы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-345">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="a49a7-346">Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.ArgumentException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="a49a7-346">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="a49a7-347">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-347">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a49a7-348">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-348">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="a49a7-349">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-349">-or-</span>
          </span>
          <span data-ttu-id="a49a7-350">Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-350">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a49a7-351">
            <paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-351">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="a49a7-352">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-352">-or-</span>
          </span>
          <span data-ttu-id="a49a7-353">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-353">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-354">Ожидание прервано, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-354">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-355">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-355">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-356">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-356">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a49a7-357">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-357">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="a49a7-358">Данный массив не может содержать несколько ссылок на один и тот же объект (дубликатов).</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-358">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="a49a7-359">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-359">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a49a7-360">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-360">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-361">Ожидает получения сигнала всеми элементами заданного массива, используя значение типа <see cref="T:System.Int32" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-361">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-362">Значение <see langword="true" />, если каждый элемент массива <paramref name="waitHandles" /> получил сигнал; в противном случае значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-362">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-363">Если `millisecondsTimeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="a49a7-363">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="a49a7-364">Он проверяет состояние дескрипторов ожидания и немедленно возвращает.</span><span class="sxs-lookup"><span data-stu-id="a49a7-364">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a49a7-365"><xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="a49a7-365"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a49a7-366">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает метод `true` когда прерывается мьютекс.</span><span class="sxs-lookup"><span data-stu-id="a49a7-366">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="a49a7-367">Брошенный мьютекс часто признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="a49a7-367">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a49a7-368">В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="a49a7-368">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a49a7-369">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="a49a7-369">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a49a7-370"><xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, если ожидание завершается, что означает либо при получении сигнала всех дескрипторов ожидания.</span><span class="sxs-lookup"><span data-stu-id="a49a7-370">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="a49a7-371">В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="a49a7-371">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="a49a7-372">Если есть повторяющиеся значения в массиве, вызов завершится сбоем с <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-372">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a49a7-373"><xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-373">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a49a7-374">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="a49a7-374">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a49a7-375">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAll%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="a49a7-375">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a49a7-376">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-376">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a49a7-377">Даже если в настоящее время выполняется метод в классе, который не является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-377">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a49a7-378">Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAll%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="a49a7-378">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="a49a7-379">Поток возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAll%2A> завершения метода.</span><span class="sxs-lookup"><span data-stu-id="a49a7-379">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="a49a7-380">Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> атрибута.</span><span class="sxs-lookup"><span data-stu-id="a49a7-380">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="a49a7-381">В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-381">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a49a7-382">Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.WaitAll%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-382">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a49a7-383">Когда <xref:System.Threading.WaitHandle.WaitAll%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="a49a7-383">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a49a7-384">В следующем примере кода показано, как использовать пул потоков для асинхронного создания и записи для группы файлов.</span><span class="sxs-lookup"><span data-stu-id="a49a7-384">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="a49a7-385">Каждой операции записи помещается в очередь рабочий элемент и сигналов, при его завершении.</span><span class="sxs-lookup"><span data-stu-id="a49a7-385">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="a49a7-386">Основной поток ожидает сигнала все элементы, а затем завершается.</span><span class="sxs-lookup"><span data-stu-id="a49a7-386">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a49a7-387">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-387">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-388">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-388">-or-</span>
          </span>
          <span data-ttu-id="a49a7-389">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-389">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-390">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-390">-or-</span>
          </span>
          <span data-ttu-id="a49a7-391">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 2.0 или более поздней.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-391">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="a49a7-392">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-392">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a49a7-393">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-393">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="a49a7-394">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-394">-or-</span>
          </span>
          <span data-ttu-id="a49a7-395">Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-395">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="a49a7-396">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 1.0 или 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-396">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a49a7-397">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-397">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-398">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-398">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-399">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-399">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-400">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-400">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a49a7-401">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-401">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="a49a7-402">Этот массив не может содержать несколько ссылок на один и тот же объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-402">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="a49a7-403">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-403">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a49a7-404">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-404">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-405">Ожидает получения сигнала всеми элементами заданного массива, используя значение типа <see cref="T:System.TimeSpan" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-405">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-406">Значение <see langword="true" />, когда каждый элемент массива <paramref name="waitHandles" /> получил сигнал; иначе — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-406">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-407">Если `timeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="a49a7-407">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="a49a7-408">Он проверяет состояние дескрипторов ожидания и немедленно возвращает.</span><span class="sxs-lookup"><span data-stu-id="a49a7-408">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a49a7-409"><xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="a49a7-409"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a49a7-410">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает метод `true` когда прерывается мьютекс.</span><span class="sxs-lookup"><span data-stu-id="a49a7-410">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="a49a7-411">Брошенный мьютекс часто признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="a49a7-411">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a49a7-412">В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="a49a7-412">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a49a7-413">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="a49a7-413">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a49a7-414"><xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, если ожидание завершается, что означает, что или все дескрипторы получили сигнал или истечения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-414">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="a49a7-415">В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="a49a7-415">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="a49a7-416">Если массив содержит дубликаты, вызов завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="a49a7-416">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a49a7-417"><xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-417">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="a49a7-418">Максимальное значение для `timeout` является <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-418">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a49a7-419">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="a49a7-419">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a49a7-420">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAll%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="a49a7-420">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a49a7-421">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-421">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a49a7-422">Даже если в настоящее время выполняется метод в классе, который не является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-422">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a49a7-423">Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAll%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="a49a7-423">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="a49a7-424">Возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAll%2A> завершения метода.</span><span class="sxs-lookup"><span data-stu-id="a49a7-424">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="a49a7-425">Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-425">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="a49a7-426">В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-426">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a49a7-427">Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.WaitAll%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-427">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a49a7-428">Когда <xref:System.Threading.WaitHandle.WaitAll%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="a49a7-428">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a49a7-429">В следующем примере кода показано, как использовать пул потоков для асинхронного создания и записи для группы файлов.</span><span class="sxs-lookup"><span data-stu-id="a49a7-429">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="a49a7-430">Каждой операции записи помещается в очередь рабочий элемент и сигналов, при его завершении.</span><span class="sxs-lookup"><span data-stu-id="a49a7-430">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="a49a7-431">Основной поток ожидает сигнала все элементы, а затем завершается.</span><span class="sxs-lookup"><span data-stu-id="a49a7-431">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a49a7-432">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-432">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-433">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-433">-or-</span>
          </span>
          <span data-ttu-id="a49a7-434">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-434">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-435">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-435">-or-</span>
          </span>
          <span data-ttu-id="a49a7-436">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 2.0 или более поздней.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-436">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="a49a7-437">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-437">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a49a7-438">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-438">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="a49a7-439">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-439">-or-</span>
          </span>
          <span data-ttu-id="a49a7-440">Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-440">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="a49a7-441">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 1.0 или 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-441">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a49a7-442">
            <paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-442">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="a49a7-443">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-443">-or-</span>
          </span>
          <span data-ttu-id="a49a7-444">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-444">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-445">Ожидание прервано, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-445">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-446">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-446">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-447">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-447">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a49a7-448">Ожидает получения сигнала какими-либо элементами заданного массива.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-448">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a49a7-449">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-449">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-450">Ожидает получения сигнала какими-либо элементами заданного массива.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-450">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-451">Индекс объекта, удовлетворившего операцию ожидания, в массиве.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-451">The array index of the object that satisfied the wait.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-452"><xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="a49a7-452"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a49a7-453">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает метод `true` Если ожидание завершается, так как мьютекс завершается.</span><span class="sxs-lookup"><span data-stu-id="a49a7-453">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="a49a7-454">Брошенный мьютекс часто признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="a49a7-454">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a49a7-455">В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="a49a7-455">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a49a7-456">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="a49a7-456">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a49a7-457"><xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает метод <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за брошенного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-457">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="a49a7-458">Если `waitHandles` содержит выпущенные мьютекс с меньшим количеством индекса, чем Брошенный мьютекс, <xref:System.Threading.WaitHandle.WaitAny%2A> метод завершается нормально, и исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="a49a7-458">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a49a7-459">В версиях .NET Framework до версии 2.0, если поток завершает работу или прерывает без явно освобождая <xref:System.Threading.Mutex>и что `Mutex` имеет индекс 0 (ноль) в `WaitAny` массива в другом потоке, индекс, возвращенный `WaitAny` — 128 вместо 0.</span><span class="sxs-lookup"><span data-stu-id="a49a7-459">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="a49a7-460">Этот метод возвращает при любой дескриптор получает сигнал.</span><span class="sxs-lookup"><span data-stu-id="a49a7-460">This method returns when any handle is signaled.</span></span> <span data-ttu-id="a49a7-461">Если во время вызова оповещенным более одного объекта, возвращается индекс массива объект получил сигнал с наименьшим значением индекса сигнальное объектов.</span><span class="sxs-lookup"><span data-stu-id="a49a7-461">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="a49a7-462">В некоторых реализациях, если сведения, которые передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="a49a7-462">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="a49a7-463">Вызов перегрузки этого метода эквивалентен вызову <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузку метода и указав значение -1 (или <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) для `millisecondsTimeout` и `true` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a49a7-463">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a49a7-464">В следующем примере кода показан вызов <xref:System.Threading.WaitHandle.WaitAny%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="a49a7-464">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a49a7-465">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-465">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-466">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-466">-or-</span>
          </span>
          <span data-ttu-id="a49a7-467">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-467">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a49a7-468">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-468">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="a49a7-469">
            <paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 1.0 или 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-469">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-470">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-470">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-471">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-471">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a49a7-472">
            <paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 2.0 или выше.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-472">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-473">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-473">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a49a7-474">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-474">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="a49a7-475">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-475">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-476">Ожидает получения сигнала любыми элементами указанного массива, используя 32-разрядное целое число со знаком для задания интервала времени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-476">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-477">Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="millisecondsTimeout" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-477">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-478">Если `millisecondsTimeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="a49a7-478">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="a49a7-479">Он проверяет состояние дескрипторов ожидания и немедленно возвращает.</span><span class="sxs-lookup"><span data-stu-id="a49a7-479">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a49a7-480"><xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает метод <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за брошенного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-480">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="a49a7-481">Если `waitHandles` содержит выпущенные мьютекс с меньшим количеством индекса, чем Брошенный мьютекс, <xref:System.Threading.WaitHandle.WaitAny%2A> метод завершается нормально, и исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="a49a7-481">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="a49a7-482">Этот метод возвращает, если ожидание завершается, когда все дескрипторы получили сигнал или истечении времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="a49a7-482">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="a49a7-483">Если во время вызова оповещенным более одного объекта, возвращается индекс массива объект получил сигнал с наименьшим значением индекса сигнальное объектов.</span><span class="sxs-lookup"><span data-stu-id="a49a7-483">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="a49a7-484">В некоторых реализациях, если сведения, которые передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="a49a7-484">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="a49a7-485">Вызов перегрузки этого метода равносилен вызову метода является <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a49a7-485">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a49a7-486">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-486">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-487">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-487">-or-</span>
          </span>
          <span data-ttu-id="a49a7-488">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-488">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a49a7-489">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-489">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a49a7-490">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-490">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-491">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-491">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-492">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-492">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a49a7-493">В массиве <paramref name="waitHandles" /> отсутствуют элементы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-493">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-494">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-494">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a49a7-495">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-495">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="a49a7-496">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-496">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-497">Ожидает получения сигнала любыми элементами заданного массива, используя значение типа <see cref="T:System.TimeSpan" /> для указания интервала времени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-497">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-498">Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="timeout" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-498">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-499">Если `timeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="a49a7-499">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="a49a7-500">Он проверяет состояние дескрипторов ожидания и немедленно возвращает.</span><span class="sxs-lookup"><span data-stu-id="a49a7-500">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a49a7-501"><xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает метод <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за брошенного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-501">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="a49a7-502">Если `waitHandles` содержит выпущенные мьютекс с меньшим количеством индекса, чем Брошенный мьютекс, <xref:System.Threading.WaitHandle.WaitAny%2A> метод завершается нормально, и исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="a49a7-502">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="a49a7-503">Этот метод возвращает, если ожидание завершается, когда все дескрипторы получили сигнал или при возникновении тайм-аута.</span><span class="sxs-lookup"><span data-stu-id="a49a7-503">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="a49a7-504">Если во время вызова оповещенным более одного объекта, возвращается индекс массива объект получил сигнал с наименьшим значением индекса сигнальное объектов.</span><span class="sxs-lookup"><span data-stu-id="a49a7-504">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="a49a7-505">В некоторых реализациях, если сведения, которые передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="a49a7-505">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="a49a7-506">Максимальное значение для `timeout` является <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-506">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a49a7-507">Вызов перегрузки этого метода равносилен вызову метода является <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a49a7-507">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a49a7-508">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-508">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-509">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-509">-or-</span>
          </span>
          <span data-ttu-id="a49a7-510">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-510">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a49a7-511">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-511">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a49a7-512">
            <paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-512">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="a49a7-513">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-513">-or-</span>
          </span>
          <span data-ttu-id="a49a7-514">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-514">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-515">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-515">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-516">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-516">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a49a7-517">В массиве <paramref name="waitHandles" /> отсутствуют элементы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-517">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-518">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-518">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a49a7-519">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-519">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="a49a7-520">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-520">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a49a7-521">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-521">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-522">Ожидает, пока какой-либо из элементов заданного массива не получит сигнал, используя 32-разрядное целое число со знаком для задания интервала времени и определения, нужно ли осуществить выход из домена синхронизации до окончания ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-522">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-523">Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="millisecondsTimeout" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-523">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-524">Если `millisecondsTimeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="a49a7-524">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="a49a7-525">Он проверяет состояние дескрипторов ожидания и немедленно возвращает.</span><span class="sxs-lookup"><span data-stu-id="a49a7-525">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a49a7-526"><xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="a49a7-526"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a49a7-527">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает метод `true` Если ожидание завершается, так как мьютекс завершается.</span><span class="sxs-lookup"><span data-stu-id="a49a7-527">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="a49a7-528">Брошенный мьютекс часто признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="a49a7-528">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a49a7-529">В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="a49a7-529">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a49a7-530">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="a49a7-530">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a49a7-531"><xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает метод <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за брошенного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-531">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="a49a7-532">Если `waitHandles` содержит выпущенные мьютекс с меньшим количеством индекса, чем Брошенный мьютекс, <xref:System.Threading.WaitHandle.WaitAny%2A> метод завершается нормально, и исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="a49a7-532">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a49a7-533">В версиях .NET Framework до версии 2.0, если поток завершает работу или прерывает без явно освобождая <xref:System.Threading.Mutex>и что `Mutex` имеет индекс 0 (ноль) в `WaitAny` массива в другом потоке, индекс, возвращенный `WaitAny` — 128 вместо 0.</span><span class="sxs-lookup"><span data-stu-id="a49a7-533">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="a49a7-534">Этот метод возвращает, если ожидание завершается, когда все дескрипторы получили сигнал или истечении времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="a49a7-534">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="a49a7-535">Если во время вызова оповещенным более одного объекта, возвращается индекс массива объект получил сигнал с наименьшим значением индекса сигнальное объектов.</span><span class="sxs-lookup"><span data-stu-id="a49a7-535">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="a49a7-536">В некоторых реализациях, если сведения, которые передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="a49a7-536">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a49a7-537">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="a49a7-537">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a49a7-538">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAny%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="a49a7-538">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a49a7-539">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-539">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a49a7-540">Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-540">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a49a7-541">Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAny%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="a49a7-541">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="a49a7-542">Поток возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAny%2A> завершения метода.</span><span class="sxs-lookup"><span data-stu-id="a49a7-542">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="a49a7-543">Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-543">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="a49a7-544">В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-544">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a49a7-545">Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.WaitAny%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-545">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a49a7-546">Когда <xref:System.Threading.WaitHandle.WaitAny%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="a49a7-546">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a49a7-547">В следующем примере кода показано, как использовать пул потоков для поиска файла на несколько дисков одновременно.</span><span class="sxs-lookup"><span data-stu-id="a49a7-547">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="a49a7-548">Для краткости выполнялся поиск только в корневом каталоге каждого диска.</span><span class="sxs-lookup"><span data-stu-id="a49a7-548">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a49a7-549">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-549">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-550">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-550">-or-</span>
          </span>
          <span data-ttu-id="a49a7-551">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-551">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a49a7-552">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-552">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="a49a7-553">
            <paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 1.0 или 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-553">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a49a7-554">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-554">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-555">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-555">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-556">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-556">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a49a7-557">
            <paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 2.0 или выше.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-557">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-558">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-558">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a49a7-559">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-559">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="a49a7-560">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-560">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a49a7-561">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-561">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-562">Ожидает получения сигнала какими-либо элементами заданного массива, используя <see cref="T:System.TimeSpan" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-562">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-563">Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="timeout" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-563">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-564">Если `timeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="a49a7-564">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="a49a7-565">Он проверяет состояние дескрипторов ожидания и немедленно возвращает.</span><span class="sxs-lookup"><span data-stu-id="a49a7-565">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a49a7-566"><xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="a49a7-566"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a49a7-567">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает метод `true` Если ожидание завершается, так как мьютекс завершается.</span><span class="sxs-lookup"><span data-stu-id="a49a7-567">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="a49a7-568">Брошенный мьютекс часто признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="a49a7-568">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a49a7-569">В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="a49a7-569">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a49a7-570">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="a49a7-570">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a49a7-571"><xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает метод <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за брошенного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-571">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="a49a7-572">Если `waitHandles` содержит выпущенные мьютекс с меньшим количеством индекса, чем Брошенный мьютекс, <xref:System.Threading.WaitHandle.WaitAny%2A> метод завершается нормально, и исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="a49a7-572">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a49a7-573">В версиях .NET Framework до версии 2.0, если поток завершает работу или прерывает без явно освобождая <xref:System.Threading.Mutex>и что `Mutex` имеет индекс 0 (ноль) в `WaitAny` массива в другом потоке, индекс, возвращенный `WaitAny` — 128 вместо 0.</span><span class="sxs-lookup"><span data-stu-id="a49a7-573">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="a49a7-574">Этот метод возвращает, если ожидание завершается, когда все дескрипторы получили сигнал или при возникновении тайм-аута.</span><span class="sxs-lookup"><span data-stu-id="a49a7-574">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="a49a7-575">Если во время вызова оповещенным более одного объекта, возвращается индекс массива объект получил сигнал с наименьшим значением индекса сигнальное объектов.</span><span class="sxs-lookup"><span data-stu-id="a49a7-575">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="a49a7-576">В некоторых реализациях, если сведения, которые передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="a49a7-576">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="a49a7-577">Максимальное значение для `timeout` является <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-577">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a49a7-578">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="a49a7-578">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a49a7-579">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAny%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="a49a7-579">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a49a7-580">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-580">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a49a7-581">Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-581">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a49a7-582">Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAny%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="a49a7-582">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="a49a7-583">Поток возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAny%2A> завершения метода.</span><span class="sxs-lookup"><span data-stu-id="a49a7-583">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="a49a7-584">Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-584">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="a49a7-585">В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-585">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a49a7-586">Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.WaitAny%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-586">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a49a7-587">Когда <xref:System.Threading.WaitHandle.WaitAny%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="a49a7-587">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a49a7-588">В следующем примере кода показано, как использовать пул потоков для поиска файла на несколько дисков одновременно.</span><span class="sxs-lookup"><span data-stu-id="a49a7-588">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="a49a7-589">Для краткости выполнялся поиск только в корневом каталоге каждого диска.</span><span class="sxs-lookup"><span data-stu-id="a49a7-589">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a49a7-590">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-590">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a49a7-591">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-591">-or-</span>
          </span>
          <span data-ttu-id="a49a7-592">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-592">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a49a7-593">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-593">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="a49a7-594">
            <paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 1.0 или 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-594">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a49a7-595">
            <paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-595">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="a49a7-596">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-596">-or-</span>
          </span>
          <span data-ttu-id="a49a7-597">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-597">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-598">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-598">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-599">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-599">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a49a7-600">
            <paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 2.0 или выше.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-600">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-601">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-601">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a49a7-602">Блокирует текущий поток до получения сигнала объектом <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-602">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a49a7-603">Блокирует текущий поток до получения сигнала объектом <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-603">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-604">Значение <see langword="true" />, если текущий экземпляр получает сигнал.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-604">
              <see langword="true" /> if the current instance receives a signal.</span>
          </span>
          <span data-ttu-id="a49a7-605">Пока текущий экземпляр не сигнализирует, метод <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> не возвращает управление.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-605">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-606"><xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="a49a7-606"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a49a7-607">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `true` когда прерывается мьютекс.</span><span class="sxs-lookup"><span data-stu-id="a49a7-607">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="a49a7-608">Брошенный мьютекс часто признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="a49a7-608">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a49a7-609">В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="a49a7-609">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a49a7-610">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="a49a7-610">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a49a7-611">Объект, вызывающий этот метод блокируется неограниченное время до получения сигнала текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="a49a7-611">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="a49a7-612">Этот метод используется для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, такие как формируется при завершении асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="a49a7-612">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="a49a7-613">Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейс.</span><span class="sxs-lookup"><span data-stu-id="a49a7-613">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="a49a7-614">Вызов перегрузки этого метода эквивалентен вызову <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> перегрузку метода и указав значение -1 или <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> для первого параметра и `false` для второго параметра.</span><span class="sxs-lookup"><span data-stu-id="a49a7-614">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="a49a7-615">Переопределите этот метод для настройки поведения из производных классов.</span><span class="sxs-lookup"><span data-stu-id="a49a7-615">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a49a7-616">В следующем примере кода показано, как использовать дескриптор ожидания, чтобы сохранить процесса завершения работы при ожидании фоновый поток для завершения выполнения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-616">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a49a7-617">Текущий экземпляр уже удален.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-617">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-618">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-618">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-619">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-619">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-620">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-620">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="a49a7-621">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-621">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-622">Блокирует текущий поток до получения текущим дескриптором <see cref="T:System.Threading.WaitHandle" /> сигнала, используя 32-разрядное целое число со знаком для указания интервала времени в миллисекундах.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-622">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-623">Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-623">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-624">Если `millisecondsTimeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="a49a7-624">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="a49a7-625">Он проверяет состояние дескриптора ожидания и немедленно возвращает.</span><span class="sxs-lookup"><span data-stu-id="a49a7-625">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="a49a7-626">Объект, вызывающий этот метод блокируется до получения текущим экземпляром сигнала или время ожидания имеет место.</span><span class="sxs-lookup"><span data-stu-id="a49a7-626">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="a49a7-627">Этот метод используется для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, такие как формируется при завершении асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="a49a7-627">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="a49a7-628">Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейс.</span><span class="sxs-lookup"><span data-stu-id="a49a7-628">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="a49a7-629">Переопределите этот метод для настройки поведения из производных классов.</span><span class="sxs-lookup"><span data-stu-id="a49a7-629">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="a49a7-630">Вызов перегрузки этого метода равносилен вызову метода является <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a49a7-630">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a49a7-631">В следующем примере кода показано, как использовать дескриптор ожидания, чтобы сохранить процесса завершения работы при ожидании фоновый поток для завершения выполнения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-631">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a49a7-632">Текущий экземпляр уже удален.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-632">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a49a7-633">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-633">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-634">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-634">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-635">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-635">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-636">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-636">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="a49a7-637">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-637">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-638">Блокирует текущий поток до получения сигнала текущим экземпляром, используя значение типа <see cref="T:System.TimeSpan" /> для указания интервала времени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-638">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-639">Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-639">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-640">Если `timeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="a49a7-640">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="a49a7-641">Он проверяет состояние дескриптора ожидания и немедленно возвращает.</span><span class="sxs-lookup"><span data-stu-id="a49a7-641">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="a49a7-642">Объект, вызывающий этот метод блокируется до получения текущим экземпляром сигнала или время ожидания имеет место.</span><span class="sxs-lookup"><span data-stu-id="a49a7-642">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="a49a7-643">Этот метод используется для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, такие как формируется при завершении асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="a49a7-643">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="a49a7-644">Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейс.</span><span class="sxs-lookup"><span data-stu-id="a49a7-644">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="a49a7-645">Переопределите этот метод для настройки поведения из производных классов.</span><span class="sxs-lookup"><span data-stu-id="a49a7-645">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="a49a7-646">Максимальное значение для `timeout` является <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-646">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a49a7-647">Вызов перегрузки этого метода равносилен вызову метода является <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a49a7-647">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a49a7-648">Текущий экземпляр уже удален.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-648">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a49a7-649">
            <paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-649">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="a49a7-650">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-650">-or-</span>
          </span>
          <span data-ttu-id="a49a7-651">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-651">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-652">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-652">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-653">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-653">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-654">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-654">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="a49a7-655">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-655">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a49a7-656">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-656">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-657">Блокирует текущий поток до получения сигнала текущим объектом <see cref="T:System.Threading.WaitHandle" />, используя 32-разрядное целое число со знаком для задания периода времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-657">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-658">Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-658">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-659">Если `millisecondsTimeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="a49a7-659">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="a49a7-660">Он проверяет состояние дескриптора ожидания и немедленно возвращает.</span><span class="sxs-lookup"><span data-stu-id="a49a7-660">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="a49a7-661"><xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="a49a7-661"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a49a7-662">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `true` когда прерывается мьютекс.</span><span class="sxs-lookup"><span data-stu-id="a49a7-662">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="a49a7-663">Брошенный мьютекс часто признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="a49a7-663">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a49a7-664">В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="a49a7-664">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a49a7-665">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="a49a7-665">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a49a7-666">Объект, вызывающий этот метод блокируется до получения текущим экземпляром сигнала или время ожидания имеет место.</span><span class="sxs-lookup"><span data-stu-id="a49a7-666">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="a49a7-667">Этот метод используется для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, такие как формируется при завершении асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="a49a7-667">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="a49a7-668">Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейс.</span><span class="sxs-lookup"><span data-stu-id="a49a7-668">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="a49a7-669">Переопределите этот метод для настройки поведения из производных классов.</span><span class="sxs-lookup"><span data-stu-id="a49a7-669">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a49a7-670">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="a49a7-670">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a49a7-671">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitOne%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="a49a7-671">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a49a7-672">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-672">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a49a7-673">Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-673">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a49a7-674">Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitOne%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="a49a7-674">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="a49a7-675">Поток возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitOne%2A> завершения метода.</span><span class="sxs-lookup"><span data-stu-id="a49a7-675">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="a49a7-676">Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-676">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="a49a7-677">В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-677">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a49a7-678">Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.WaitOne%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-678">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a49a7-679">Когда <xref:System.Threading.WaitHandle.WaitOne%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="a49a7-679">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a49a7-680">В следующем примере показан способ <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> перегруженный метод ведет себя при вызове в домен синхронизации.</span><span class="sxs-lookup"><span data-stu-id="a49a7-680">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="a49a7-681">Во-первых, поток ожидает открытия с `exitContext` присвоено `false` и блокируется, пока не истечет время ожидания ожидания.</span><span class="sxs-lookup"><span data-stu-id="a49a7-681">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="a49a7-682">Второй поток выполняет после первый поток завершается и ожидает с `exitContext` присвоено `true`.</span><span class="sxs-lookup"><span data-stu-id="a49a7-682">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="a49a7-683">Вызов сигнал дескриптор ожидания для этой второй поток не заблокирован, и до истечения времени ожидания ожидания завершения потока.</span><span class="sxs-lookup"><span data-stu-id="a49a7-683">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a49a7-684">Текущий экземпляр уже удален.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-684">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a49a7-685">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-685">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-686">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-686">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-687">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-687">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-688">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-688">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="a49a7-689">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-689">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a49a7-690">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-690">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a49a7-691">Блокирует текущий поток до получения сигнала текущим экземпляром, используя значение типа <see cref="T:System.TimeSpan" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-691">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a49a7-692">Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-692">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-693">Если `timeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="a49a7-693">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="a49a7-694">Он проверяет состояние дескриптора ожидания и немедленно возвращает.</span><span class="sxs-lookup"><span data-stu-id="a49a7-694">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="a49a7-695"><xref:System.Threading.AbandonedMutexException> является новым в .NET Framework версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="a49a7-695"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a49a7-696">В предыдущих версиях <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `true` когда прерывается мьютекс.</span><span class="sxs-lookup"><span data-stu-id="a49a7-696">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="a49a7-697">Брошенный мьютекс часто признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="a49a7-697">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a49a7-698">В случае мьютекс всей системы это может означать, что приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="a49a7-698">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a49a7-699">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="a49a7-699">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a49a7-700">Объект, вызывающий этот метод блокируется до получения текущим экземпляром сигнала или время ожидания имеет место.</span><span class="sxs-lookup"><span data-stu-id="a49a7-700">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="a49a7-701">Этот метод используется для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, такие как формируется при завершении асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="a49a7-701">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="a49a7-702">Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейс.</span><span class="sxs-lookup"><span data-stu-id="a49a7-702">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="a49a7-703">Переопределите этот метод для настройки поведения из производных классов.</span><span class="sxs-lookup"><span data-stu-id="a49a7-703">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="a49a7-704">Максимальное значение для `timeout` является <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-704">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a49a7-705">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="a49a7-705">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a49a7-706">`exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitOne%2A> метод вызывается из внутри управляемого контекста не по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="a49a7-706">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a49a7-707">Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-707">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a49a7-708">Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-708">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a49a7-709">Когда ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть для перехода в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitOne%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="a49a7-709">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="a49a7-710">Поток возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitOne%2A> завершения метода.</span><span class="sxs-lookup"><span data-stu-id="a49a7-710">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="a49a7-711">Это может быть полезно, если класс контекстно привязанные имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a49a7-711">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="a49a7-712">В этом случае все вызовы к членам класса автоматически синхронизируются и области синхронизации находится в теле код для класса.</span><span class="sxs-lookup"><span data-stu-id="a49a7-712">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a49a7-713">Если в стеке вызовов элемента вызывается <xref:System.Threading.WaitHandle.WaitOne%2A> метода с указанием `true` для `exitContext`, поток выходит из области синхронизации, позволяя потоку, который блокируется во время вызова любого члена объекта для продолжения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-713">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a49a7-714">Когда <xref:System.Threading.WaitHandle.WaitOne%2A> метод возвращает поток, которой был сделан вызов должен ожидать повторный ввод области синхронизации.</span><span class="sxs-lookup"><span data-stu-id="a49a7-714">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a49a7-715">В следующем примере кода показано, как использовать дескриптор ожидания, чтобы сохранить процесса завершения работы при ожидании фоновый поток для завершения выполнения.</span><span class="sxs-lookup"><span data-stu-id="a49a7-715">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a49a7-716">Текущий экземпляр уже удален.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-716">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a49a7-717">
            <paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-717">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="a49a7-718">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-718">-or-</span>
          </span>
          <span data-ttu-id="a49a7-719">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-719">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a49a7-720">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-720">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a49a7-721">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-721">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a49a7-722">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-722">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="a49a7-723">Указывает, что время ожидания операции <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> истекло до получения сигнала каким-либо из дескрипторов ожидания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-723">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span>
          </span>
          <span data-ttu-id="a49a7-724">Это поле является константой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a49a7-724">This field is constant.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a49a7-725">Это поле является одним из возможных возвращаемых значений `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="a49a7-725">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a49a7-726">В следующем примере кода показано, как использовать пул потоков для поиска файла на несколько дисков одновременно.</span><span class="sxs-lookup"><span data-stu-id="a49a7-726">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="a49a7-727">Для краткости выполнялся поиск только в корневом каталоге каждого диска.</span><span class="sxs-lookup"><span data-stu-id="a49a7-727">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>