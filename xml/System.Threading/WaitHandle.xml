<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9c30c9bf2d271da2afe9d173213a99d04fceefda" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531508" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Инкапсулирует связанные с операционной системой объекты, ожидающие монопольного доступа к общим ресурсам.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.WaitHandle> Класс, инкапсулирующий дескрипторы синхронизации Win32 и используется для представления всех объектов синхронизации в среде выполнения, выполнять несколько операций ожидания. Сравнение дескрипторов ожидания с другими объектами синхронизации см. в разделе [Обзор примитивов синхронизации](~/docs/standard/threading/overview-of-synchronization-primitives.md).  
  
 <xref:System.Threading.WaitHandle> Сам класс является абстрактным. Классы, производные от <xref:System.Threading.WaitHandle> определяют механизм сигнализации о предоставлении или освобождении монопольного доступа к общему ресурсу, но используют наследуемого <xref:System.Threading.WaitHandle> методов на время ожидания для доступа к общим ресурсам. Классы, производные от <xref:System.Threading.WaitHandle> включают:  
  
-   класс <xref:System.Threading.Mutex>; В разделе [мьютексы](~/docs/standard/threading/mutexes.md).  
  
-   <xref:System.Threading.EventWaitHandle> Класс и его производные классы <xref:System.Threading.AutoResetEvent> и <xref:System.Threading.ManualResetEvent>. См. дополнительные сведения об [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
-   класс <xref:System.Threading.Semaphore>; В разделе [Semaphore и SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  
  
 Потоки могут блокироваться по отдельному дескриптору ожидания посредством вызова метода экземпляра <xref:System.Threading.WaitHandle.WaitOne%2A>, который наследуется производными классами <xref:System.Threading.WaitHandle>.  
  
 Классов, производных от <xref:System.Threading.WaitHandle> отличающихся своей поддержкой сходства потоков. Дескрипторы ожидания событий (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, и <xref:System.Threading.ManualResetEvent>) и семафоры не поддерживают сходство потоков; любой поток может подать сигнал, дескриптор ожидания событий или семафора. Мьютексы, с другой стороны, поддерживают сходство потоков; должен освободить поток, который является владельцем мьютекса, и создается исключение, если поток выполняет вызов <xref:System.Threading.Mutex.ReleaseMutex%2A> метод, который не является владельцем мьютекса.  
  
 Поскольку <xref:System.Threading.WaitHandle> класс является производным от <xref:System.MarshalByRefObject>, эти классы можно использовать для синхронизации действий потоков за границами доменов приложений.  
  
 В дополнение к его производные классы <xref:System.Threading.WaitHandle> класс содержит несколько статических методов, которые блокирования потока, пока один или несколько объектов синхронизации получения сигнала... Сюда входит следующее.  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, что позволяет потоку сигнал одному дескриптору ожидания и немедленно ожидать другого.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>, что позволяет потоку подождать, пока все дескрипторы в массиве ожидания получения сигнала.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>, который позволяет потоку ожидать, пока один из указанного набора дескрипторов ожидания было сообщено.  
  
 Перегрузки этих методов предоставляют интервалы времени ожидания для прерывания ожидания, а также возможность выхода из контекста синхронизации до начала ожидания, что позволяет другим потокам использовать контекст синхронизации.  
  
> [!IMPORTANT]
>  Этот тип реализует <xref:System.IDisposable> интерфейса. После завершения с помощью типа или типа, производного от него следует освободить его прямо или косвенно. Для удаления типа непосредственно вызвать его <xref:System.Threading.WaitHandle.Close%2A> метод в `try` / `catch` блока. Чтобы удалить ее косвенно, использовать языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <xref:System.IDisposable> разделе интерфейса.  
  
 <xref:System.Threading.WaitHandle> реализует <xref:System.IDisposable.Dispose%2A> шаблон. В разделе [шаблон удаления](~/docs/standard/design-guidelines/dispose-pattern.md). При наследовании от <xref:System.Threading.WaitHandle>, используйте <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство для хранения маркер собственный дескриптор операционной системы. Необходимо переопределить защищенный <xref:System.Threading.WaitHandle.Dispose%2A> метод без использования дополнительных неуправляемые ресурсы.  
  
   
  
## Examples  
 В следующем примере кода показан как два потока могут сделать фоновые задачи при основной поток ожидает завершения задач для выполнения с помощью статического <xref:System.Threading.WaitHandle.WaitAny%2A> и <xref:System.Threading.WaitHandle.WaitAll%2A> методы <xref:System.Threading.WaitHandle> класса.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, удерживаемые текущим объектом <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является открытую реализацию <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> метод <xref:System.Threading.WaitHandle> класса и его производные классы. Он предоставляет стандартную реализацию, которая вызывает `Dispose(Boolean)` перегрузка с `true` аргумент, а затем вызывает метод <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> метод. Вызовите этот метод, чтобы освободить все ресурсы, удерживаемые экземпляром `WaitHandle` или производного класса.  
  
 Когда этот метод вызван, ссылки на текущий экземпляр вызвать неопределенное поведение.  
  
> [!NOTE]
>  Всегда вызывайте метод <xref:System.Threading.WaitHandle.Close%2A> или <xref:System.Threading.WaitHandle.Dispose> перед освобождением последней ссылки на <xref:System.Threading.WaitHandle>. В противном случае им ресурсы не будут освобождены.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Необходимо переопределить <see langword="Dispose(Boolean)" /> метод для освобождения ресурсов, выделенных в производных классах.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.WaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод эквивалентен методу <xref:System.Threading.WaitHandle.Close%2A> метод.  
  
> [!NOTE]
>  Всегда вызывайте метод <xref:System.Threading.WaitHandle.Close%2A> или <xref:System.Threading.WaitHandle.Dispose> перед освобождением последней ссылки на <xref:System.Threading.WaitHandle>. В противном случае им ресурсы не будут освобождены.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          Значение <see langword="true" /> позволяет освободить как управляемые, так и неуправляемые ресурсы; значение <see langword="false" /> освобождает только неуправляемые ресурсы.</param>
        <summary>При переопределении в производном классе освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.Threading.WaitHandle" />, и при необходимости освобождает управляемые ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается методом <xref:System.Threading.WaitHandle.Close%2A> и <xref:System.Threading.WaitHandle.Dispose> методы с `explicitDisposing` равным `true`.  При `explicitDisposing` параметр `true`, данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, которые <xref:System.Threading.WaitHandle> ссылки на объекты.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Необходимо переопределить <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> метод для освобождения ресурсов, выделенных в производных классах.  
  
 <see cref="M:System.Threading.WaitHandle.Close" /> Или <see cref="M:System.Threading.WaitHandle.Dispose" /> метод может вызываться несколько раз другими объектами. При переопределении этого метода следует избегать ссылок на объекты, которые были уничтожены предыдущими вызовами метода <see langword="Dispose" /> или <see langword="Close" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает собственный дескриптор операционной системы.</summary>
        <value>Объект <see langword="IntPtr" />, представляющий собственный дескриптор операционной системы. Значением по умолчанию является значение поля <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Назначение нового значения для <xref:System.Threading.WaitHandle.Handle%2A> свойства не закрывает дескриптор предыдущего. Это может привести к потерянных дескриптор.  
  
 Не используйте это свойство в платформе .NET Framework версии 2.0 или более поздней версии; Используйте <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство вместо него. Установка этого свойства в допустимый дескриптор также наборы <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство, но значения этого свойства <xref:System.Threading.WaitHandle.InvalidHandle> может привести к потерянных дескриптор.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для непосредственно вызывающего метода задать значение свойства. Этот член не может задаваться частично доверенным или прозрачным кодом.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Производные типы должны иметь <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> требуется задать значение свойства.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет недопустимый собственный дескриптор операционной системы. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используется внутренним образом для инициализации <xref:System.Threading.WaitHandle.Handle%2A> свойство.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Это значение можно использовать, чтобы определить, является ли <see cref="P:System.Threading.WaitHandle.Handle" /> свойство содержит допустимый собственный дескриптор операционной системы.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает собственный дескриптор операционной системы.</summary>
        <value>Объект <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />, представляющий собственный дескриптор операционной системы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При назначении нового значения для <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойства предыдущей дескриптор будет закрыт при предыдущей <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> собираются объекта. Не закрывайте вручную дескриптора, так как это приведет к <xref:System.ObjectDisposedException> при <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> пытается закрыть дескриптор.  
  
 <xref:System.Threading.WaitHandle> реализует <xref:System.IDisposable.Dispose%2A> шаблон. В разделе [шаблон удаления](~/docs/standard/design-guidelines/dispose-pattern.md). При наследовании от <xref:System.Threading.WaitHandle>, используйте <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> свойство для хранения маркер собственный дескриптор операционной системы. Необходимо переопределить защищенный <xref:System.Threading.WaitHandle.Dispose%2A> метод без использования дополнительных неуправляемые ресурсы.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Производные типы должны иметь <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> для вызова этого элемента.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Подает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает другого.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">Объект <see cref="T:System.Threading.WaitHandle" />, который получает сигнал.</param>
        <param name="toWaitOn">Объект <see cref="T:System.Threading.WaitHandle" />, сигнализация которого ожидается.</param>
        <summary>Подает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает другого.</summary>
        <returns>
          Значение <see langword="true" />, если и сигнал, и ожидание завершаются удачно; если операция ожидания не завершается, то возврат из метода не происходит.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта операция не обязательно atomic. После текущего потока сигналы `toSignal` , но до его ожидает `toWaitOn`, поток, который выполняется на другой процессор может сигнализировать `toWaitOn` или ожидания.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> перегрузка метода, чтобы разрешить основной поток отправлять сигнал заблокированный поток и подождите, пока поток завершает задачу.  
  
 Пример запускаются пять потоков, их можно заблокировать на <xref:System.Threading.EventWaitHandle> с <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> флага, а затем время выпуски один поток, пользователь нажимает клавишу ВВОД. Затем помещает в очередь другой пять потоков и освобождает их с помощью <xref:System.Threading.EventWaitHandle> с <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> флаг.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="toSignal" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="toWaitOn" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Метод был вызван в потоке с атрибутом <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Этот метод не поддерживается в Windows 98 и Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          Параметр <paramref name="toSignal" /> является семафором и его счетчик уже достиг максимального значения.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">Объект <see cref="T:System.Threading.WaitHandle" />, который получает сигнал.</param>
        <param name="toWaitOn">Объект <see cref="T:System.Threading.WaitHandle" />, сигнализация которого ожидается.</param>
        <param name="millisecondsTimeout">Целое число, представляющее интервал ожидания. Если значение равно <see cref="F:System.Threading.Timeout.Infinite" />, то есть -1, то ожидание длится неограниченное время.</param>
        <param name="exitContext">
          Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</param>
        <summary>Передает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает сигнализации другого, задавая время ожидания в виде 32-разрядного целого числа со знаком и указывая, следует ли выйти из домена синхронизации контекста до начала ожидания.</summary>
        <returns>
          Значение <see langword="true" />, если и передача сигнала, и ожидание завершились успешно; значение <see langword="false" />, если передача сигнала была выполнена, но время ожидания истекло.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта операция не обязательно atomic. После текущего потока сигналы `toSignal` , но до его ожидает `toWaitOn`, поток, который выполняется на другой процессор может сигнализировать `toWaitOn` или ожидания.  
  
 Если `millisecondsTimeout` равно нулю, метод не выполняет блокировку. Он проверяет состояние `toWaitOn` и немедленно возвращает значение.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод. Поток осуществляет возврат к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод завершения.  
  
 Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса. Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="toSignal" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="toWaitOn" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Метод вызывается в потоке с атрибутом <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Этот метод не поддерживается в Windows 98 и Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Невозможно передать сигнал объекту <see cref="T:System.Threading.WaitHandle" />, поскольку его счетчик превысит максимальное значение.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">Объект <see cref="T:System.Threading.WaitHandle" />, который получает сигнал.</param>
        <param name="toWaitOn">Объект <see cref="T:System.Threading.WaitHandle" />, сигнализация которого ожидается.</param>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, представляющий период ожидания. Если значение равно -1, то ожидание выполняется неограниченное время.</param>
        <param name="exitContext">
          Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</param>
        <summary>Передает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает сигнализации другого, задавая время ожидания в виде <see cref="T:System.TimeSpan" /> и указывая, следует ли выйти из домена синхронизации контекста до начала ожидания.</summary>
        <returns>
          Значение <see langword="true" />, если и передача сигнала, и ожидание завершились успешно; значение <see langword="false" />, если передача сигнала была выполнена, но время ожидания истекло.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта операция не обязательно atomic. После текущего потока сигналы `toSignal` , но до его ожидает `toWaitOn`, поток, который выполняется на другой процессор может сигнализировать `toWaitOn` или ожидания.  
  
 Максимальное значение для `timeout` — <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Если `timeout` равно нулю, метод не выполняет блокировку. Он проверяет состояние `toWaitOn` и немедленно возвращает значение.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод. Поток осуществляет возврат к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод завершения.  
  
 Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса. Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.SignalAndWait%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="toSignal" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="toWaitOn" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Метод был вызван в потоке с атрибутом <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Этот метод не поддерживается в Windows 98 и Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          Параметр <paramref name="toSignal" /> является семафором и его счетчик уже достиг максимального значения.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="timeout" /> соответствует отрицательному числу, отличному от -1 миллисекунды.  
  
 - или -  
  
 Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ожидает получения сигнала всеми элементами заданного массива.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром. Этот массив не может содержать несколько ссылок на один и тот же объект.</param>
        <summary>Ожидает получения сигнала всеми элементами заданного массива.</summary>
        <returns>
          <see langword="true" />, когда каждый элемент <paramref name="waitHandles" /> получил сигнал. В противном случае возврат из метода не происходит.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает метод `true` при будет сброшен семафор. Брошенный mutex обычно признаком серьезной ошибки в коде. В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач). Исключение содержит сведения, полезные для отладки.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, когда все дескрипторы получили сигнал. В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение. Если массив содержит дубликаты, вызов завершится ошибкой с <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.  
  
 Вызов перегрузки этого метода эквивалентен вызову <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузка метода и указав значение -1 (или <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) для `millisecondsTimeout` и `true` для `exitContext`.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать пул потоков для асинхронного создания и записи в группы файлов. Каждой операции записи в очередь как рабочий элемент и сигналов, при его завершении. Основной поток ожидает сигнала всех элементов, а затем завершается.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />. - или -  
  
 Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.  
  
 - или -  
  
 Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 2.0 или более поздней.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 Вместо этого в [.NET для приложений Магазина Windows](http://go.microsoft.com/fwlink/?LinkID=247912) или в [переносимой библиотеке классов](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) перехватите исключение базового класса <see cref="T:System.ArgumentException" />.  
  
</para>
          </block>  
  
 Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</exception>
        <exception cref="T:System.NotSupportedException">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.  
  
 - или -  
  
 Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</exception>
        <exception cref="T:System.ApplicationException">
          Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 1.0 или 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание прервано, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром. Данный массив не может содержать несколько ссылок на один и тот же объект (дубликатов).</param>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
        <summary>Ожидает получения сигнала всеми элементами заданного массива, используя значение <see cref="T:System.Int32" /> для указания интервала времени.</summary>
        <returns>
          Значение <see langword="true" />, если каждый элемент массива <paramref name="waitHandles" /> получил сигнал; в противном случае значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно нулю, метод не выполняет блокировку. Он проверяет состояние дескрипторов ожидания и возвращается немедленно.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, когда ожидание завершается, означающее, что если все дескрипторы получили сигнал или истечения времени ожидания. В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение. Если имеются повторяющиеся значения в массиве, вызов завершится ошибкой с <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.  
  
 Вызов этой перегрузки метода является таким же, как вызов <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.  
  
 - или -  
  
 В массиве <paramref name="waitHandles" /> отсутствуют элементы.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 Вместо этого в [.NET для приложений Магазина Windows](http://go.microsoft.com/fwlink/?LinkID=247912) или в [переносимой библиотеке классов](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) перехватите исключение базового класса <see cref="T:System.ArgumentException" />.  
  
</para>
          </block>  
  
 Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</exception>
        <exception cref="T:System.NotSupportedException">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.  
  
 - или -  
  
 Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром. Этот массив не может содержать несколько ссылок на один и тот же объект.</param>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
        <summary>Ожидает получения сигнала всеми элементами заданного массива, используя значение <see cref="T:System.TimeSpan" /> для указания интервала времени.</summary>
        <returns>
          Значение <see langword="true" />, если каждый элемент массива <paramref name="waitHandles" /> получил сигнал; в противном случае значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно нулю, метод не выполняет блокировку. Он проверяет состояние дескрипторов ожидания и возвращается немедленно.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, когда ожидание завершается, что означает, что или все дескрипторы получили сигнал или истечения времени ожидания. В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение. Если массив содержит дубликаты, вызов завершится ошибкой.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.  
  
 Максимальное значение для `timeout` — <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Вызов этой перегрузки метода является таким же, как вызов <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.  
  
 - или -  
  
 В массиве <paramref name="waitHandles" /> отсутствуют элементы.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 Вместо этого в [.NET для приложений Магазина Windows](http://go.microsoft.com/fwlink/?LinkID=247912) или в [переносимой библиотеке классов](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) перехватите исключение базового класса <see cref="T:System.ArgumentException" />.  
  
</para>
          </block>  
  
 Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</exception>
        <exception cref="T:System.NotSupportedException">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.  
  
 - или -  
  
 Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.  
  
 - или -  
  
 Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание прервано, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром. Данный массив не может содержать несколько ссылок на один и тот же объект (дубликатов).</param>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
        <param name="exitContext">
          Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</param>
        <summary>Ожидает получения сигнала всеми элементами заданного массива, используя значение типа <see cref="T:System.Int32" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</summary>
        <returns>
          Значение <see langword="true" />, если каждый элемент массива <paramref name="waitHandles" /> получил сигнал; в противном случае значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно нулю, метод не выполняет блокировку. Он проверяет состояние дескрипторов ожидания и возвращается немедленно.  
  
 <xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает метод `true` при будет сброшен семафор. Брошенный mutex обычно признаком серьезной ошибки в коде. В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач). Исключение содержит сведения, полезные для отладки.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, когда ожидание завершается, означающее, что если все дескрипторы получили сигнал или истечения времени ожидания. В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение. Если имеются повторяющиеся значения в массиве, вызов завершится ошибкой с <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAll%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который не является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAll%2A> метод. Поток осуществляет возврат к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAll%2A> метод завершения.  
  
 Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> атрибута. В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса. Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.WaitAll%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.WaitAll%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать пул потоков для асинхронного создания и записи в группы файлов. Каждой операции записи в очередь как рабочий элемент и сигналов, при его завершении. Основной поток ожидает сигнала всех элементов, а затем завершается.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.  
  
 - или -  
  
 Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 2.0 или более поздней.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</exception>
        <exception cref="T:System.NotSupportedException">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.  
  
 - или -  
  
 Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</exception>
        <exception cref="T:System.ApplicationException">
          Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 1.0 или 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром. Этот массив не может содержать несколько ссылок на один и тот же объект.</param>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
        <param name="exitContext">
          Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</param>
        <summary>Ожидает получения сигнала всеми элементами заданного массива, используя значение типа <see cref="T:System.TimeSpan" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</summary>
        <returns>
          Значение <see langword="true" />, когда каждый элемент массива <paramref name="waitHandles" /> получил сигнал; иначе — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно нулю, метод не выполняет блокировку. Он проверяет состояние дескрипторов ожидания и возвращается немедленно.  
  
 <xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает метод `true` при будет сброшен семафор. Брошенный mutex обычно признаком серьезной ошибки в коде. В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач). Исключение содержит сведения, полезные для отладки.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Возвращает метод, когда ожидание завершается, что означает, что или все дескрипторы получили сигнал или истечения времени ожидания. В некоторых реализациях, если передано более 64 дескрипторов <xref:System.NotSupportedException> возникает исключение. Если массив содержит дубликаты, вызов завершится ошибкой.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Метод не поддерживается в потоках, которые имеют <xref:System.STAThreadAttribute>.  
  
 Максимальное значение для `timeout` — <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAll%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который не является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAll%2A> метод. Возвращается к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAll%2A> метод завершения.  
  
 Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса. Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.WaitAll%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.WaitAll%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать пул потоков для асинхронного создания и записи в группы файлов. Каждой операции записи в очередь как рабочий элемент и сигналов, при его завершении. Основной поток ожидает сигнала всех элементов, а затем завершается.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.  
  
 - или -  
  
 Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 2.0 или более поздней.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</exception>
        <exception cref="T:System.NotSupportedException">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.  
  
 - или -  
  
 Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</exception>
        <exception cref="T:System.ApplicationException">
          Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 1.0 или 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.  
  
 - или -  
  
 Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание прервано, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ожидает получения сигнала какими-либо элементами заданного массива.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</param>
        <summary>Ожидает получения сигнала какими-либо элементами заданного массива.</summary>
        <returns>Индекс объекта, удовлетворившего операцию ожидания, в массиве.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает `true` Если ожидание завершается, так как будет сброшен семафор. Брошенный mutex обычно признаком серьезной ошибки в коде. В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач). Исключение содержит сведения, полезные для отладки.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает исключение <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за Брошенный mutex. Если `waitHandles` содержит выпущено мьютекс с меньшим значением индекса, чем Брошенный mutex <xref:System.Threading.WaitHandle.WaitAny%2A> метод обычно выполняется и исключение не вызывается.  
  
> [!NOTE]
>  В версиях .NET Framework, предшествующих версии 2.0, если поток завершает работу или прервана без явного освобождения <xref:System.Threading.Mutex>и что `Mutex` находится по индексу 0 (ноль) в `WaitAny` массива на другой поток, возвращенный индекс `WaitAny` — 128 вместо 0.  
  
 Этот метод возвращает, когда любой дескриптор получает сигнал. Если во время вызова сигнала более одного объекта возвращает значение индекса массива сигнальное объекта с наименьшим значением индекса сигнальное объектов. В некоторых реализациях, если несколько записей, передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.  
  
 Вызов перегрузки этого метода эквивалентен вызову <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузка метода и указав значение -1 (или <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) для `millisecondsTimeout` и `true` для `exitContext`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется вызов <xref:System.Threading.WaitHandle.WaitAny%2A> метод.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 1.0 или 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 2.0 или выше.</exception>
        <exception cref="T:System.InvalidOperationException">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</param>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
        <summary>Ожидает получения сигнала любыми элементами указанного массива, используя 32-разрядное целое число со знаком для задания интервала времени.</summary>
        <returns>Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="millisecondsTimeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно нулю, метод не выполняет блокировку. Он проверяет состояние дескрипторов ожидания и возвращается немедленно.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает исключение <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за Брошенный mutex. Если `waitHandles` содержит выпущено мьютекс с меньшим значением индекса, чем Брошенный mutex <xref:System.Threading.WaitHandle.WaitAny%2A> метод обычно выполняется и исключение не вызывается.  
  
 Этот метод возвращает, когда ожидание завершается, когда все дескрипторы получили сигнал или истечении времени ожидания. Если во время вызова сигнала более одного объекта возвращает значение индекса массива сигнальное объекта с наименьшим значением индекса сигнальное объектов. В некоторых реализациях, если несколько записей, передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.  
  
 Вызов этой перегрузки метода является таким же, как вызов <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          В массиве <paramref name="waitHandles" /> отсутствуют элементы.</exception>
        <exception cref="T:System.InvalidOperationException">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</param>
        <param name="timeout">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
        <summary>Ожидает получения сигнала любыми элементами заданного массива, используя значение типа <see cref="T:System.TimeSpan" /> для указания интервала времени.</summary>
        <returns>Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="timeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно нулю, метод не выполняет блокировку. Он проверяет состояние дескрипторов ожидания и возвращается немедленно.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает исключение <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за Брошенный mutex. Если `waitHandles` содержит выпущено мьютекс с меньшим значением индекса, чем Брошенный mutex <xref:System.Threading.WaitHandle.WaitAny%2A> метод обычно выполняется и исключение не вызывается.  
  
 Этот метод возвращает, когда ожидание завершается, когда все дескрипторы получили сигнал или при возникновении тайм-аута. Если во время вызова сигнала более одного объекта возвращает значение индекса массива сигнальное объекта с наименьшим значением индекса сигнальное объектов. В некоторых реализациях, если несколько записей, передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.  
  
 Максимальное значение для `timeout` — <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Вызов этой перегрузки метода является таким же, как вызов <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.  
  
 - или -  
  
 Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          В массиве <paramref name="waitHandles" /> отсутствуют элементы.</exception>
        <exception cref="T:System.InvalidOperationException">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</param>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
        <param name="exitContext">
          Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</param>
        <summary>Ожидает, пока какой-либо из элементов заданного массива не получит сигнал, используя 32-разрядное целое число со знаком для задания интервала времени и определения, нужно ли осуществить выход из домена синхронизации до окончания ожидания.</summary>
        <returns>Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="millisecondsTimeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно нулю, метод не выполняет блокировку. Он проверяет состояние дескрипторов ожидания и возвращается немедленно.  
  
 <xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает `true` Если ожидание завершается, так как будет сброшен семафор. Брошенный mutex обычно признаком серьезной ошибки в коде. В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач). Исключение содержит сведения, полезные для отладки.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает исключение <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за Брошенный mutex. Если `waitHandles` содержит выпущено мьютекс с меньшим значением индекса, чем Брошенный mutex <xref:System.Threading.WaitHandle.WaitAny%2A> метод обычно выполняется и исключение не вызывается.  
  
> [!NOTE]
>  В версиях .NET Framework, предшествующих версии 2.0, если поток завершает работу или прервана без явного освобождения <xref:System.Threading.Mutex>и что `Mutex` находится по индексу 0 (ноль) в `WaitAny` массива на другой поток, возвращенный индекс `WaitAny` — 128 вместо 0.  
  
 Этот метод возвращает, когда ожидание завершается, когда все дескрипторы получили сигнал или истечении времени ожидания. Если во время вызова сигнала более одного объекта возвращает значение индекса массива сигнальное объекта с наименьшим значением индекса сигнальное объектов. В некоторых реализациях, если несколько записей, передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAny%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAny%2A> метод. Поток осуществляет возврат к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAny%2A> метод завершения.  
  
 Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса. Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.WaitAny%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.WaitAny%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать пул потоков для одновременного поиска файла на нескольких дисках. Для высвобождения места на диске выполняется поиск только корневом каталоге каждого диска.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 1.0 или 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 2.0 или выше.</exception>
        <exception cref="T:System.InvalidOperationException">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</param>
        <param name="timeout">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
        <param name="exitContext">
          Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</param>
        <summary>Ожидает получения сигнала какими-либо элементами заданного массива, используя <see cref="T:System.TimeSpan" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</summary>
        <returns>Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="timeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно нулю, метод не выполняет блокировку. Он проверяет состояние дескрипторов ожидания и возвращается немедленно.  
  
 <xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает `true` Если ожидание завершается, так как будет сброшен семафор. Брошенный mutex обычно признаком серьезной ошибки в коде. В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач). Исключение содержит сведения, полезные для отладки.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Вызывает исключение <xref:System.Threading.AbandonedMutexException> только тогда, когда ожидание завершается из-за Брошенный mutex. Если `waitHandles` содержит выпущено мьютекс с меньшим значением индекса, чем Брошенный mutex <xref:System.Threading.WaitHandle.WaitAny%2A> метод обычно выполняется и исключение не вызывается.  
  
> [!NOTE]
>  В версиях .NET Framework, предшествующих версии 2.0, если поток завершает работу или прервана без явного освобождения <xref:System.Threading.Mutex>и что `Mutex` находится по индексу 0 (ноль) в `WaitAny` массива на другой поток, возвращенный индекс `WaitAny` — 128 вместо 0.  
  
 Этот метод возвращает, когда ожидание завершается, когда все дескрипторы получили сигнал или при возникновении тайм-аута. Если во время вызова сигнала более одного объекта возвращает значение индекса массива сигнальное объекта с наименьшим значением индекса сигнальное объектов. В некоторых реализациях, если несколько записей, передаются 64 дескрипторов <xref:System.NotSupportedException> возникает исключение.  
  
 Максимальное значение для `timeout` — <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitAny%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitAny%2A> метод. Поток осуществляет возврат к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitAny%2A> метод завершения.  
  
 Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса. Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.WaitAny%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.WaitAny%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать пул потоков для одновременного поиска файла на нескольких дисках. Для высвобождения места на диске выполняется поиск только корневом каталоге каждого диска.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 1.0 или 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.  
  
 - или -  
  
 Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 2.0 или выше.</exception>
        <exception cref="T:System.InvalidOperationException">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Блокирует текущий поток до получения сигнала объектом <see cref="T:System.Threading.WaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Блокирует текущий поток до получения сигнала объектом <see cref="T:System.Threading.WaitHandle" />.</summary>
        <returns>
          Значение <see langword="true" />, если текущий экземпляр получает сигнал. Пока текущий экземпляр не сигнализирует, метод <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> не возвращает управление.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `true` при будет сброшен семафор. Брошенный mutex обычно признаком серьезной ошибки в коде. В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач). Исключение содержит сведения, полезные для отладки.  
  
 Код, вызывающий этот метод блокируется неограниченное время до получения сигнала текущим экземпляром. Используйте этот метод для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, например, создается при завершении асинхронной операции. Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейса.  
  
 Вызов перегрузки этого метода эквивалентен вызову <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> перегрузка метода и указав значение -1 или <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> для первого параметра и `false` для второго параметра.  
  
 Переопределите этот метод для настройки поведения производного класса.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать дескриптор ожидания для поддержания процесса завершения работы при ожидании фоновый поток для завершения выполнения.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
        <summary>Блокирует текущий поток до получения текущим дескриптором <see cref="T:System.Threading.WaitHandle" /> сигнала, используя 32-разрядное целое число со знаком для указания интервала времени в миллисекундах.</summary>
        <returns>
          Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно нулю, метод не выполняет блокировку. Он проверяет состояние дескриптора ожидания и возвращается немедленно.  
  
 Происходит, код, вызывающий этот метод блокируется до текущий экземпляр получает сигнал или истечения времени ожидания. Используйте этот метод для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, например, создается при завершении асинхронной операции. Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейса.  
  
 Переопределите этот метод для настройки поведения производного класса.  
  
 Вызов этой перегрузки метода является таким же, как вызов <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать дескриптор ожидания для поддержания процесса завершения работы при ожидании фоновый поток для завершения выполнения.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
        <summary>Блокирует текущий поток до получения сигнала текущим экземпляром, используя значение типа <see cref="T:System.TimeSpan" /> для указания интервала времени.</summary>
        <returns>
          Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно нулю, метод не выполняет блокировку. Он проверяет состояние дескриптора ожидания и возвращается немедленно.  
  
 Происходит, код, вызывающий этот метод блокируется до текущий экземпляр получает сигнал или истечения времени ожидания. Используйте этот метод для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, например, создается при завершении асинхронной операции. Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейса.  
  
 Переопределите этот метод для настройки поведения производного класса.  
  
 Максимальное значение для `timeout` — <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Вызов этой перегрузки метода является таким же, как вызов <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> перегрузки и указав `false` для `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.  
  
 - или -  
  
 Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
        <param name="exitContext">
          Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</param>
        <summary>Блокирует текущий поток до получения сигнала текущим объектом <see cref="T:System.Threading.WaitHandle" />, используя 32-разрядное целое число со знаком для задания периода времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</summary>
        <returns>
          Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно нулю, метод не выполняет блокировку. Он проверяет состояние дескриптора ожидания и возвращается немедленно.  
  
 <xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `true` при будет сброшен семафор. Брошенный mutex обычно признаком серьезной ошибки в коде. В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач). Исключение содержит сведения, полезные для отладки.  
  
 Происходит, код, вызывающий этот метод блокируется до текущий экземпляр получает сигнал или истечения времени ожидания. Используйте этот метод для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, например, создается при завершении асинхронной операции. Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейса.  
  
 Переопределите этот метод для настройки поведения производного класса.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitOne%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitOne%2A> метод. Поток осуществляет возврат к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitOne%2A> метод завершения.  
  
 Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса. Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.WaitOne%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.WaitOne%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.  
  
   
  
## Examples  
 В следующем примере показан способ <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> перегрузка метода должно происходить, когда он вызывается в пределах домена синхронизации. Во-первых, поток ожидает с `exitContext` значение `false` и блокирует до истечения времени ожидания ожидания. Второй поток выполняет после первый поток завершает и ожидает с `exitContext` значение `true`. Вызов сигнала дескриптора ожидания для этого второй поток не заблокирован, и до истечения времени ожидания ожидания завершения потока.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
        <param name="exitContext">
          Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</param>
        <summary>Блокирует текущий поток до получения сигнала текущим экземпляром, используя значение типа <see cref="T:System.TimeSpan" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</summary>
        <returns>
          Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно нулю, метод не выполняет блокировку. Он проверяет состояние дескриптора ожидания и возвращается немедленно.  
  
 <xref:System.Threading.AbandonedMutexException> впервые появился в платформе .NET Framework версии 2.0. В предыдущих версиях <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `true` при будет сброшен семафор. Брошенный mutex обычно признаком серьезной ошибки в коде. В случае системный мьютекс может означать, что внезапном прекращении выполнения приложения (например, с помощью диспетчера задач). Исключение содержит сведения, полезные для отладки.  
  
 Происходит, код, вызывающий этот метод блокируется до текущий экземпляр получает сигнал или истечения времени ожидания. Используйте этот метод для блокирования до <xref:System.Threading.WaitHandle> получения сигнала от другого потока, например, создается при завершении асинхронной операции. Дополнительные сведения см. в разделе <xref:System.IAsyncResult> интерфейса.  
  
 Переопределите этот метод для настройки поведения производного класса.  
  
 Максимальное значение для `timeout` — <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 `exitContext` Параметр действует только <xref:System.Threading.WaitHandle.WaitOne%2A> метод вызывается из внутри управляемого контекста не по умолчанию. Это может произойти, если ваш поток находится внутри вызова к экземпляру класса, производного от <xref:System.ContextBoundObject>. Даже если в настоящее время выполняется метод в классе, который является производным от <xref:System.ContextBoundObject>, таких как <xref:System.String>, может быть в контексте не по умолчанию если <xref:System.ContextBoundObject> стеке в текущем домене приложения.  
  
 Если ваш код выполняется в контексте не по умолчанию, указав `true` для `exitContext` вызывающий поток выйти из управляемого контекста не по умолчанию (то есть переход в контекст по умолчанию) перед выполнением <xref:System.Threading.WaitHandle.WaitOne%2A> метод. Поток осуществляет возврат к исходному контексту не по умолчанию после вызова <xref:System.Threading.WaitHandle.WaitOne%2A> метод завершения.  
  
 Это может быть полезно, если привязанные к контексту класс имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы к членам класса автоматически синхронизируются, и области синхронизации находится в теле кода для класса. Если код в стеке вызовов члена вызывает <xref:System.Threading.WaitHandle.WaitOne%2A> метод и указывает `true` для `exitContext`, поток выходит из области синхронизации, что поток, который блокируется во время вызова любого члена объекта для продолжения. Когда <xref:System.Threading.WaitHandle.WaitOne%2A> метод возвращает поток, в которой был сделан вызов необходимо подождать для повторного ввода области синхронизации.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать дескриптор ожидания для поддержания процесса завершения работы при ожидании фоновый поток для завершения выполнения.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.  
  
 - или -  
  
 Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс. Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>Указывает, что время ожидания операции <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> истекло до получения сигнала каким-либо из дескрипторов ожидания. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это поле является одним из возможных возвращаемых значений `WaitAny`.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать пул потоков для одновременного поиска файла на нескольких дисках. Для высвобождения места на диске выполняется поиск только корневом каталоге каждого диска.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>