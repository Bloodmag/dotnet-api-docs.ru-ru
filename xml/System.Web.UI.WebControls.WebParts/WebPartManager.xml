<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="39878b0a58d88077e3f60f42a8b9f566fd421748" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30601308" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Служит в качестве центрального класса набора элементов управления веб-частей, управляющего всеми элементами управления веб-частей, функциональностью и событиями, происходящими на веб-странице.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Управления выступает в качестве центра концентратора или элемента управления веб-частей приложения. Должен быть один — и только один--<xref:System.Web.UI.WebControls.WebParts.WebPartManager> экземпляр элемента управления на каждой странице, которое использует элементы управления веб-частей. Как и с большинством аспектов приложений веб-частей <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления работает только с проверкой подлинности пользователей. Кроме того, работает его функциональность практически полностью с серверными элементами управления, которые находятся в пределах зоны веб-частей, которые наследуют от <xref:System.Web.UI.WebControls.WebParts.WebZone> класса. Серверные элементы управления, которые находятся на странице за пределами этих зон может иметь очень малую часть функциональности веб-частей или взаимодействия с <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления.  
  
 В качестве концентратора для функциональных возможностей веб-частей на странице <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемент управления выполняет видов задач, описанных в следующей таблице.  
  
|Категория задачи|Действие элемента управления|  
|-------------------|---------------------------|  
|Отслеживание элементов управления веб-частей|Хранит список много различных типов элементов управления на странице, которые обеспечивают функциональные возможности веб-частей, включая <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, подключения, зоны и другим пользователям.|  
|Добавление и удаление элементов управления веб-частей|Предоставляет методы для добавления, удаления и закрытие <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления на странице.|  
|Администрирование подключений|Создает соединения между элементами управления и отслеживает соединения, а также процессы добавления и удаления их.|  
|Персонализация страниц и элементов управления|Пользователи могут перемещать элементы управления в разных местах на странице и запускает представления, в которых пользователи могут изменять внешний вид, свойства и поведение элементов управления. Поддерживает параметры персонализации для различных пользователей на каждой странице.|  
|Переключение между различными представлениями страниц|Переключает между различными специализированными представлениями страницы, чтобы пользователи могли выполнять определенные задачи, такие как изменение макета страницы и редактирование элементов управления.|  
|Создание событий жизненного цикла веб-частей|Определяет, создает событие и позволяет разработчикам обрабатывать события жизненного цикла управления веб-частей, например, когда элементы управления добавляемых, перемещены, подключенном или удалены.|  
|Разрешение импорта и экспорта элементов управления|Экспортирует XML-потоки, содержащие состояние свойств <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов, а также позволяет пользователям импортировать файлы для удобства при персонализации сложных элементов управления на других страницах или сайтах.|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Класс имеет большой набор свойств. Соответствует <xref:System.Web.UI.WebControls.WebParts.WebPartManager> роли отслеживания других элементов управления, он имеет несколько свойств, которые ссылаются на коллекции элементов управления веб-частей или других специальных объектов веб-частей. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>, И <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> свойства являются все коллекции, используемые <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления для его отслеживания и других задачи управления.  
  
 Другая группа свойств содержит настраиваемые предупреждения, которые применяются в определенных сценариях, происходящих в приложении веб-частей. К ним относятся <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>и <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> свойства.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Класс переопределяет некоторые из его базового наследуемых свойств, используемых многих серверных элементов управления. К ним относятся <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>, и <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> свойства.  
  
 Наконец есть группа свойств, полезна при доступе к текущее состояние приложения. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> Указывает текущий режим отображения, используется страница. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> Свойство указывает, может ли элемент управления для подготовки к просмотру клиентского скрипта, который используется в ситуациях, где пользователь может иметь браузеры по своим возможностям или сценарии отключены. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> Свойство можно использовать для ссылки на служебный класс, который содержит вызовы ряд важных методов веб-части, используемые для расширения вариантов. Можно скрыть вызовы этих методов в отдельный класс ( <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> класса), <xref:System.Web.UI.WebControls.WebParts.WebPartManager> упрощено класса собственных API. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> Свойство предоставляет доступ к объектам персонализации, которые хранят параметры персонализации пользователей и сохранения этих данных в постоянном хранилище. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> Свойство указывает, что <xref:System.Web.UI.WebControls.WebParts.WebPart> управления на странице выбранного пользователем или приложением. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> Свойство указывает ли данные пользовательской персонализации на <xref:System.Web.UI.WebControls.WebParts.WebPart> элемент управления был изменен.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Элемент управления содержит пять встроенные режимы отображения или представления веб-страницы. Разработчики могут расширить эту функцию создания пользовательские режимы отображения, расширяя типов, таких как <xref:System.Web.UI.WebControls.WebParts.WebZone> класса или <xref:System.Web.UI.WebControls.WebParts.ToolZone> класса. Пользователи могут переключаться в режимы отображения страницы, условии, что на странице есть правильный тип элементов управления, которые соответствуют в определенном режиме отображения.  
  
> [!NOTE]
>  Можно расширить эту функцию, чтобы пользователи могли переключиться в режим отображения пользовательских без необходимости соответствующей зоны на странице. Однако поведение по умолчанию является соответствие режимов отображения зонам.  
  
 Режимы отображения стандартных представлены открытых полей в <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класса. В следующей таблице перечислены поля и режимы отображения, которые они ссылаются. Текущий режим отображения страницы, как указано выше, всегда указывается в <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> содержится свойство, а также набор режимов отображения, доступный на конкретной странице, заданный тип зоны, которые присутствуют на странице в <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> свойство.  
  
|Поле|Сведения о режиме отображения|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|Обычное пользовательское представление веб-страницы; по умолчанию и наиболее распространенных режима отображения.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|Представление, в котором пользователи можно изменять и удалять элементы управления для изменения макета страницы.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|Представление, в котором редактирования пользовательский интерфейс (UI) становится видимым. Пользователи могут изменять внешний вид, свойства и поведение элементов управления, которые отображаются в обычном режиме.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|Представление, в котором пользовательский Интерфейс каталога становится видимым. Пользователи могут добавлять элементы управления на страницу из каталога доступных элементов управления.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|Представление, в котором подключение пользовательского интерфейса становится видимым. пользователей можно подключиться, управление или завершить соединения между элементами управления.|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Элемент управления также содержит ряд событий, которые являются критическими жизненного цикла страниц веб-частей и элементов управления. Эти события предоставляют полный программный контроль над поведением элементов управления веб-частей. Большинство методов относятся непосредственно к <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления (или другим сервером или пользовательской элементы, помещенные в <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зоны, чтобы они ведут себя как <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления). Однако некоторые события относятся к состоянию страницы или подключений на странице. В следующей таблице перечислены доступные события и описаны их назначение.  
  
> [!NOTE]
>  Во всех случаях в таблице ниже со словом «элемент управления» ссылается на <xref:System.Web.UI.WebControls.WebParts.WebPart> управления или любой серверный элемент управления, который находится в зоне и заключается в оболочку с <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> объекта во время выполнения.  
  
|событие|Описание:|  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|Происходит непосредственно перед элемент управления добавлен на страницу, чтобы проверить, что он является.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|Происходит после активации всех подключений на странице.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|Происходит перед активацией подключений на странице.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|Происходит после изменения текущего режима отображения страницы.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|Происходит перед процесс изменения режима отображения страницы.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|Происходит после отмены выбора элемента управления.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|Происходит перед отменой выбора элемента управления.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|Происходит после добавления элемента управления зоны.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|Происходит перед Добавление элемента управления зоны.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|Происходит после закрытия элемента управления (удаления со страницы).|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|Происходит перед закрытием элемента управления.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|Происходит после экземпляр динамического элемента управления (один, который был создан программно или добавлен из каталога) был удален без возможности восстановления.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|Происходит перед удалением динамического элемента управления.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|Происходит после перемещения элемента управления в зоне или в другую зону.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|Происходит перед перемещением элемента управления.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|Происходит после двух элементов управления, выбранные для участия в подключении установлено соединение.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|Происходит перед процесс подключения двух элементов управления.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|Происходит после отключения двух подключенных элементов управления.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|Происходит перед отключением двух элементов управления.|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Элемент управления имеет множество методов для управления веб-частей страницы. Большой набор методов, не перечисленных здесь, являются методы, имена в виде*EventName*. Эти методы обычно их связанных событие и предоставить событие с обработчиком типа <xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>. Большинство этих методов может быть переопределено разработчиков, которые наследуют от <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класса. Кроме того разработчики страниц могут предоставлять пользовательские обработчики для событий, связанных с помощью этих методов. Например, в случае использования <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> событий, разработчик может добавить `OnWebPartAdded` атрибут `<asp:webpartmanager>` элемент в разметке веб-страницы и затем назначьте пользовательский метод имя атрибута для предоставления обычной обработки события. Атрибут соответствует атрибуту <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> метод и этот базовый шаблон подходит для большинства событий веб-частей и их связанные методы обработки событий.  
  
 Кроме того <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления есть методы, относящиеся к задачу управления <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления (и использовать элементы управления сервера или пользователя в качестве <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления). К этим методам относятся <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>, и <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>.  
  
 Другой набор методов, специально для подключений. Это включает методы, такие как <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>, и <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>.  
  
 Наконец, некоторые <xref:System.Web.UI.WebControls.WebParts.WebPartManager> методы сосредоточиться на функциональные возможности персонализации. К ним относятся <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>, и <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>.  
  
 Дополнительные сведения о других <xref:System.Web.UI.WebControls.WebParts.WebPartManager> методы, которые доступны через <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> свойства, см. в документации для <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> класса.  
  
   
  
## Examples  
 В следующем примере кода показано использование декларативного и программного <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления.  
  
 В примере кода состоит из четырех частей:  
  
-   Пользовательский элемент управления, позволяющий изменять режимы отображения на веб-странице.  
  
-   Веб-страницы, который содержит две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, которые могут быть подключены, и `<asp:webpartmanager>` элемента.  
  
-   Файл исходного кода, который содержит две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления и пользовательского интерфейса.  
  
-   Пояснения к работе примера в браузере.  
  
 Пользовательский элемент управления имеет элемент управления раскрывающегося списка, который показывает возможные режимы отображения страницы, учитывая элементы управления веб-частей, которые присутствуют на странице. На веб-странице в этом примере кода этот пользовательский элемент управления объявлен непосредственно под <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемент в разметке страницы и `Register` директив в верхней части веб-страницы, чтобы зарегистрировать элемент управления. Сведения о режимах отображения и описание исходного кода в этом элементе управления, см. в разделе [Пошаговое руководство: изменение режима отображения страницы](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 Декларативная разметка для веб-страницы содержит `Register` директивы для пользовательского элемента управления и пользовательские элементы управления. Отсутствует `<asp:webpartmanager>` элемент, `<asp:webpartzone>` элемент содержит пользовательские элементы управления и `<asp:connectionszone>` элемента. Данная страница также содержит некоторые встроенный код, обрабатывающий события, относящиеся к соединению для <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления; вы увидите результат использования этого кода, как подключать и отключать элементы управления.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 Третья часть примера приведен исходный код для элементов управления. Обратите внимание, что интерфейс с именем `IZipCode`, и этот интерфейс реализуется в `ZipCodeWebPart` класса. Этот класс содержит специальный метод обратного вызова с именем `ProvideIZipCode` , служит в качестве поставщика. Другой тип с именем `WeatherWebPart`, также реализуется с помощью специальный метод с именем `GetIZipCode`, который позволяет элементу управления действовать в качестве получателя другого элемента управления.  
  
 Для выполнения примера кода необходимо скомпилировать этот исходный код. Можно выполнить явную компиляцию и поместить результирующую сборку в папку Bin веб-сайта или в глобальном кэше сборок. Кроме того можно поместить исходный код в папку App_Code веб-узла, где он будет динамически компилироваться во время выполнения. Данный пример кода предполагает, что был скомпилирован в сборку, источник и `Register` директивы в веб-страница ссылается на имя сборки. Пошаговое руководство по компиляции см. в разделе [Пошаговое руководство: разработка и с помощью элемента управления пользовательского](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 После загрузки веб-страницы в браузере, щелкните **режим отображения** управления раскрывающегося списка и выберите **Connect** для переключения страницы в режим подключения. Подключение использует режим `<asp:connectionszone>` элемент, чтобы можно было создавать подключения между элементами управления. В режиме подключения, щелкните стрелку вниз в строке заголовка **ПОЧТОВЫЙ индекс** управления активировать соответствующее меню команд и нажмите кнопку **Connect**. После подключения пользовательского интерфейса, выберите пункт **создать соединение с потребителем** ссылку. Появится ячейка с элементом управления раскрывающегося списка. Выберите **Weather Control** в раскрывающемся списке, а затем выберите **Connect** для завершения подключения между двумя элементами управления. Нажмите кнопку **закрыть**, а затем используйте **режим отображения** раскрывающегося списка, чтобы вернуться в обычный режим просмотра. Можно ввести ПОЧТОВЫЙ индекс, и управления получателя обновляется с введенное значение. Поскольку `ZipCode` свойство был помечен атрибутом `Personalizable` атрибут в исходном коде, значение этого свойства будет сохраняться между сеансами браузера, тем самым экономя введенное пользователем значение. Более сложный элемент управления получателя может принимать сведения о ПОЧТОВОМ индексе, поиск сведений о погоде в код и его отображения для пользователя.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Управления должен быть расширен. Так как он является центральным в приложениях веб-частей, если вы хотите расширить определенного типа или элемента управления в наборе элементов управления веб-части, во многих случаях вы должны также расширить <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> класса, так как это может иметь некоторые свойства или метода, который требуется выполнить  пользовательский тип работать в контексте приложения веб-частей. Веб-части справочную документацию (см. <see cref="N:System.Web.UI.WebControls.WebParts" />), при обсуждении способы расширения веб-частей типа, часто упоминания о том, что необходимо сделать для расширения <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> класса также или показано, как расширить ее в примере кода.</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A> Конструктор инициализирует несколько важных переменных, используемых в <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления. Одно назначение, напрямую влияет на все страницы веб-частей является тот факт, что режим отображения страницы по умолчанию установлено в режим просмотра (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Делает все неактивные подключения на веб-странице активными.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> Метод вызывается при каждом запросе страницы для активации существующие соединения между <xref:System.Web.UI.WebControls.WebParts.WebPart> и других серверных элементов управления, находящихся в <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зоны. В некоторых случаях для экземпляра, если возникает конфликт в подключениях к активации, этот метод в свою очередь вызывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> метод для завершения проблемы подключения. Во время процесса отключения <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> события. Как правило, разработчики могут отменить это событие, но в случае там, где существует конфликт между подключениями, не может быть отменено, так как <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемент управления должен разрешить конфликт для завершения процесса активации подключений. Дополнительные сведения см. в разделе <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> событий.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (или серверный или пользовательский элемент управления), который необходимо добавить на веб-страницу или открыть на странице.</param>
        <param name="zone">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />, в который добавляется <c>webPart</c>.</param>
        <param name="zoneIndex">Целое число, представляющее порядковый номер позиции, которую объект <c>webPart</c> занимает в <c>zone</c> относительно других элементов управления в <c>zone</c>.</param>
        <summary>Предоставляет стандартный программный метод для добавления элементов управления на веб-странице <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <returns>Элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, который был добавлен на страницу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> Метод используется как для добавления новых динамических <xref:System.Web.UI.WebControls.WebParts.WebPart> элементы управления на страницу и повторное открытие статические или динамические элементы управления, которые ранее были закрыты на странице. При вызове метода для добавления нового элемента управления, фактически создает копию элемента управления, на который ссылается `webPart` параметра. Для копирования элемент управления создается новый идентификатор, поэтому разработчики должны ссылаться <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления, возвращенный из метода для получения значения нового идентификатора. При вызове метода для повторного открытия ранее закрытый элемент управления возвращается прямую ссылку на элемент управления, на который указывает `webPart` параметра.  
  
> [!IMPORTANT]
>  Следует всегда использовать <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> метода, а не <xref:System.Web.UI.ControlCollection.Add%2A> метод коллекции элементов управления, на который указывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType> свойство, чтобы добавить <xref:System.Web.UI.WebControls.WebParts.WebPart> элементы управления программными средствами на страницу, так как с помощью <xref:System.Web.UI.ControlCollection.Add%2A> метод создает исключение. Чтобы добавить элемент управления, который не является <xref:System.Web.UI.WebControls.WebParts.WebPart> управления (другими словами, элемент управления сервера, который будет заключена в <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> управления во время выполнения), следует вначале вызвать <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> способ создания элемента управления, а затем вызвать <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> метод, чтобы добавить элемент управления. Для демонстрации этого подхода см. в разделе.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> метод программное добавление серверного элемента управления на страницу. Разметка страницы содержит пустой `<asp:webpartzone>` элемент и `<asp:webpartmanager>` элемента. В первый раз **добавить календарь** нажатии кнопки код в создает обработчик событий <xref:System.Web.UI.WebControls.Calendar> управления и добавляет ее к области, как <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> объекта, вызов <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> метод.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="webPart" /> имеет значение <see langword="null" />.  
  
 \- или -  
  
 Свойство <paramref name="zone" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="zone" /> не зарегистрирован в коллекции зон элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.  
  
 \- или -  
  
 Параметр <paramref name="webPart" /> уже находится в <paramref name="zone" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="zoneIndex" /> меньше нуля.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при вызове метода <see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> для определения, можно ли добавить на страницу объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или серверный элемент управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> Каждый раз, когда происходит событие <xref:System.Web.UI.WebControls.WebParts.WebPart> элемент управления добавляется на страницу. Существует несколько распространенных сценариях, где можно добавить элемент управления на страницу. Полное описание этих, см в разделе "Примечания" <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> метод. При добавлении элемента управления, его необходимо выбрать для просмотра ли его <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> свойства, и в этом случае ли элемент управления авторизации для добавления на страницу.  
  
 Разработчики могут создавать обработчики событий для <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> события, обеспечивающие фильтрацию для элементов управления. Если элемент управления <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> значение свойства не соответствует условиям, заданным в коде обработчиков событий, элемент управления не добавляется на страницу.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать пользовательский обработчик событий для <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> события, который переопределяет значение по умолчанию автоматически <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> метод.  
  
 Код в `mgr1_AuthorizeWebPart` метод проверяет, имеют ли соответствующие элементы управления на странице <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> присваивать значения свойства `user` и, если это так, возвращает `true`, что означает, что они будут авторизованных и поместить на страницу. Предполагается, что по умолчанию подход — разрешить пользователям просматривать элементы управления на странице в области персонализации пользователя. Обратите внимание, что в примере один из элементов управления имеет его <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> присвоено значение свойства `admin`. Разработчики могут поместить этот фильтр в специализированном элементе управления, разработанной для только пользователи с правами администратора для просмотра. Этот элемент управления сможет выполнить проверку авторизации во время <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> события и не будет отображаться. Учтите, что элементы управления, которые имеют набор свойств отображаться также; они считаются не могут входить в сценарий фильтрации, так как их <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> свойства не установлены.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию объектов <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />, которые доступны для использования при создании подключений веб-частей между серверными элементами управления.</summary>
        <value>Коллекция <see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" />, в которой содержится набор объектов <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство использует <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A> метод для создания коллекции. По умолчанию она считывает доступные преобразователи из файла конфигурации приложения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Элемент управления, для которого создается подключение.</param>
        <summary>Запускает подключение двух элементов управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> друг к другу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> Существует метод, поэтому процесс формирования подключений между элементами управления можно сделать в несколько различных этапов, предоставляя разработчикам больший контроль над процессом соединения. Этот метод выполняет набор исходных проверок, чтобы убедиться, что `webPart` находится в состоянии, когда соединение является допустимым. Если `webPart` проходит все проверки, затем он задан как текущего выбранного элемента управления (см. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> свойства), и можно продолжить процесс подключения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="webPart" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий режим отображения на странице не равен <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> закрыт.  
  
 \- или -  
  
 <paramref name="webPart" /> не является частью коллекции <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
 -или-  
  
 <paramref name="webPart" /> равен элементу управления <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />.</exception>
        <block subset="none" type="overrides">
          <para>Разработчики, чтобы расширить <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> управления может потребоваться переопределить этот метод в производном классе. Один из подходов, можно вызвать базовый метод, а затем добавьте некоторой пользовательской обработки; или может потребоваться полностью настроить процесс запуска подключения между элементами управления. Например можно проверить доступность определенных данных до создания подключения.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Редактируемый элемент управления.</param>
        <summary>Запускает редактирование элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> Существует метод, поэтому процесс изменения элементов управления можно сделать в несколько различных этапов, предоставляя разработчикам больший контроль над процессом. Этот метод выполняет набор исходных проверок, чтобы убедиться, что `webPart` находится в состоянии, в котором ее можно редактировать. Если `webPart` проходит все проверки, затем он задан как текущего выбранного элемента управления (см. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> свойства), и продолжает процесс редактирования.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="webPart" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий режим отображения на странице не равен <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> закрыт.  
  
 \- или -  
  
 <paramref name="webPart" /> не является частью коллекции <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
 -или-  
  
 <paramref name="webPart" /> равен элементу управления <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет режим отображения по умолчанию для страниц, которые содержат элементы управления веб-частей. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> Ссылается настраиваемый <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> объекта, который создается и содержащиеся в <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления. Поскольку это статический объект, можно ссылаться на него напрямую с помощью <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класс без необходимости экземпляр элемента управления.  
  
 При первой загрузке определяет, страницу, которая содержит веб-частей, он находится в <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (режим просмотра) по умолчанию. При простом просмотре, как обычные веб-страницы, страница остается в режиме просмотра. Если пользователи хотят настраивать макет страницы, элементы управления, внешний вид или поведение, их необходимо переключить страницу в один из режимов отображения специализированные через <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано, как работать с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> поле программными средствами. Код заполнение раскрывающегося списка поддерживаемых режимах отображения, которые в этом случае конструктора и просмотра. Обратите внимание, что в `Page_PreRender` метод, этот код проверяет ли текущий <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> свойству <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>. В этом случае `Label1` будет отображаться Если нет, `Label1` будет скрыта.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 После загрузки страницы в браузере, вы находитесь в режиме просмотра по умолчанию. Обратите внимание на подпись на странице, которая указывает, что вы находитесь в режиме просмотра. Используйте элемент управления раскрывающегося списка для переключения страницы в режим конструктора. Обратите внимание, что из-за кода в `Page_PreRender` метод метки теперь является скрытым.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Проверяет элементы управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, которые будут участвовать в подключении, для определения, способны ли они подключаться друг к другу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> Метод используется для определения двух <xref:System.Web.UI.WebControls.WebParts.WebPart> можно подключить элементы управления. Метод обычно используется в качестве условную проверку до вызова метода <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> метод.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> Метод проверяет число критерии, которые должны быть выполнены перед формирования соединение двух элементов управления. В следующем списке перечислены основные критерии для установления соединения. Если выполняются все эти критерии (а также дополнительные внутренние условия), метод возвращает `true`, это означает, что элементы управления могут быть подключены:  
  
-   Элементы управления поставщика и потребителя не может быть `null`, и они должны быть включены в коллекцию элементов управления, на который указывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> свойство.  
  
-   Поставщик и получатель не может быть тот же элемент управления. Другими словами <xref:System.Web.UI.WebControls.WebParts.WebPart> управления не удается подключиться к самому себе.  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint> Объектов (точки подключения) для поставщика и потребителя не может быть `null`.  
  
-   Не удается закрыть поставщика и потребителя (ни один из элемента управления <xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A> свойство может быть `true`).  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A> Свойства элемента управления точки соединения должен соответствовать типу элемента управления потребителя и поставщика.  
  
-   Точки подключения должны быть включены (их <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A> методы возвращали `true`).  
  
-   Каждая точка подключения не должна должен пытаться создавать дополнительные подключений, чем заданное в отдельном <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A> свойство.  
  
-   Если <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> подключение несовместимых элементов управления требуется объект (преобразователем), он не может быть `null`. Тем не менее, если элементы управления уже совместимы, преобразователь должен быть `null`.  
  
-   Преобразователь (если используется) должна иметься ссылка в <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A> коллекции.  
  
-   Преобразователь (если используется) должен иметь интерфейсы, совместимые с поставщиком и получателем, чтобы он мог преобразовывать данные между двумя элементами управления. Дополнительные интерфейсы потребителя и поставщика, также должны быть совместимы.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">Элемент управления, который предоставляет данные для <c>consumer</c> при подключении элементов управления.</param>
        <param name="providerConnectionPoint">Точка подключения <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />, которая позволяет поставщику <c>provider</c> участвовать в подключении.</param>
        <param name="consumer">Элемент управления, который получает данные из <c>provider</c> при подключении элементов управления.</param>
        <param name="consumerConnectionPoint">Точка подключения <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />, которая выполняет функцию метода обратного вызова, чтобы объект <c>consumer</c> мог участвовать в подключении.</param>
        <summary>Проверяет элементы управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, которые будут участвовать в подключении, для определения, способны ли они подключаться друг к другу, если элементы управления поставщика и получателя имеют совместимые интерфейсы, а объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> не требуется.</summary>
        <returns>Логическое значение, указывающее, можно ли подключить друг к другу <paramref name="provider" /> и <paramref name="consumer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для подключения `provider` и `consumer` при обоих элементов управления имеют совместимые точка типов подключения, чтобы <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> объекта не требуется. Вы можете использовать этот метод для проверки подключении двух элементов управления перед вызовом метода <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> для создания программное подключение.  
  
 Эта перегрузка использует ту же реализацию как <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> перегрузка метода, с единственным исключением является, что эта перегрузка не требуется преобразователь.  
  
   
  
## Examples  
 В следующем примере кода показано, как с помощью этого метода.  
  
 В примере кода состоит из четырех частей:  
  
-   Пользовательский элемент управления, позволяющий изменять режимы отображения на веб-странице.  
  
-   Веб-страницы, который содержит две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, которые могут быть подключены, `<asp:webpartmanager>` элемент и код обработки событий, который создает соединение с использованием <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> метод.  
  
-   Файл исходного кода, который содержит две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления и пользовательского интерфейса.  
  
-   Пояснения к работе примера в браузере.  
  
 Первая часть примера кода — это пользовательский элемент управления для изменения режима отображения. Исходный код для пользовательского элемента управления можно получить из примера <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе. Дополнительные сведения о режимах отображения и принципах работы пользовательского элемента управления см. в разделе [Пошаговое руководство: изменение режима отображения страницы](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Декларативная разметка для веб-страницы содержит `Register` директивы для пользовательского элемента управления и пользовательские элементы управления. Отсутствует `<asp:webpartmanager>` элемент, `<asp:webpartzone>` элемент содержит пользовательские элементы управления и `<asp:connectionszone>` элемента. Обратите внимание, что в `Page_Load` метода, код проверяет ли соединения могут быть созданы и, если да, определяется поставщик, получатель и соответствующие точки подключения, а затем добавляет новое соединение в набор статических подключений, на которые <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>свойство.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 Третья часть примера приведен исходный код для элементов управления. Он содержит интерфейс и пользовательских <xref:System.Web.UI.WebControls.WebParts.WebPart> управляет один выступает в роли поставщика, а другая — как получатель. Из-за наличия точки подключения, совместимый (обе из них распознают `IZipCode` интерфейса), преобразователь не требуется для подключения. Для выполнения примера кода необходимо скомпилировать этот исходный код. Можно выполнить явную компиляцию и поместить результирующую сборку в папку Bin веб-сайта или в глобальном кэше сборок. Кроме того можно поместить исходный код в папку App_Code веб-узла, где он будет динамически компилироваться во время выполнения. Пошаговое руководство по компиляции см. в разделе [Пошаговое руководство: разработка и с помощью элемента управления пользовательского](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 После загрузки веб-страницы в браузере, щелкните **режим отображения** управления раскрывающегося списка и выберите **Connect** для переключения страницы в режим подключения. Подключение использует режим `<asp:connectionszone>` элемент, чтобы можно было создавать подключения между элементами управления. В режиме подключения, щелкните стрелку вниз в строке заголовка **ПОЧТОВЫЙ индекс** управления активировать соответствующее меню команд и нажмите кнопку **Connect**. После появления подключения пользовательский интерфейс (UI), обратите внимание, что соединение уже был создан с кода, содержащегося в `Page_Load` метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">Элемент управления, который предоставляет данные для <c>consumer</c> при подключении элементов управления.</param>
        <param name="providerConnectionPoint">Точка подключения <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />, которая выполняет функцию метода обратного вызова, чтобы объект <c>provider</c> мог участвовать в подключении.</param>
        <param name="consumer">Элемент управления, который получает данные из <c>provider</c> при подключении элементов управления.</param>
        <param name="consumerConnectionPoint">Точка подключения <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />, которая выполняет функцию метода обратного вызова, чтобы объект <c>consumer</c> мог участвовать в подключении.</param>
        <param name="transformer">Веб-часть <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />, обеспечивающая подключение несовместимых объектов <c>provider</c> и <c>consumer</c>.</param>
        <summary>Проверяет элементы управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, которые будут участвовать в подключении, для определения, смогут ли они подключаться, а также использует объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> для создания подключения между несовместимыми поставщиками и получателями.</summary>
        <returns>Логическое значение, указывающее, можно ли подключить друг к другу <paramref name="provider" /> и <paramref name="consumer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для подключения `provider` и `consumer` при обоих элементов управления имеют несовместимые точка типов подключения, чтобы <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> требуется объект. Вы можете использовать этот метод для проверки подключении двух элементов управления перед вызовом метода <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> для создания программное подключение.  
  
 Эта перегрузка использует ту же реализацию как <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> перегрузка метода, с единственным исключением является, что эта перегрузка требует преобразователя.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет режим отображения, используемый для добавления серверных элементов управления из каталога элементов управления на веб-страницу. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> Ссылается настраиваемый <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> объекта, который создается и содержащиеся в <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления. Поскольку это статический объект, можно ссылаться на него напрямую с помощью <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класс без необходимости экземпляр элемента управления.  
  
 Если требуется добавить элементы управления на страницу, если доступен каталог серверных элементов управления страницы, чтобы перейти <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> (режим каталога), и появится каталог пользовательский интерфейс (UI). Пользовательский Интерфейс для каталога веб-частей обеспечивается <xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase> элемент управления зоной. Разработчики добавляют эту зону страницы во время разработки и добавить серверные элементы управления в зону, чтобы пользователи смогут добавлять эти элементы управления с ними страницы во время выполнения. После добавления этих элементов управления разработчик режим каталога становится поддерживаемым режимом отображения на странице, так как необходимые элементы управления имеются в наличии для включения режима каталога.  
  
 Когда пользователь переключает страницу в режиме, зона и все серверные элементы управления, добавленные к ней становятся видимыми в каталог, и пользователь может выбрать элементы управления из каталога, который следует добавить на страницу или удалять элементы управления на странице. После добавления элементов управления на страницу, они отображаются в обычном режиме просмотра и обновления страницы.  
  
   
  
## Examples  
 В следующем примере кода показано, как работать с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> поле программными средствами. Код заполнение раскрывающегося списка поддерживаемых режимах отображения страницы, которые в данном случае являются обзора, разработки и каталог. Режим каталога доступен из-за `<asp:CatalogZone>` и его дочерних элементов в веб-странице. Обратите внимание, что в `Page_PreRender` метод, этот код проверяет ли текущий <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> свойству <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>. В этом случае `Label1` будет отображаться Если нет, `Label1` будет скрыта.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 После загрузки страницы в браузере, вы находитесь в режиме просмотра по умолчанию. Обратите внимание, что метка на странице скрыта. Используйте элемент управления раскрывающегося списка для переключения страницы в режим каталога. Обратите внимание, что из-за кода в `Page_PreRender` , метка теперь является видимым. Можно выбрать элемент управления в каталоге и добавить его в одну из двух зон на странице.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Проверяет возможности браузера, делающего запрос, а также значение свойства <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" /> для определения необходимости обработки клиентского скрипта.</summary>
        <returns>Логическое значение, указывающее, следует ли обрабатывать клиентский скрипт.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает предупреждение, которое отображается при закрытии пользователем элемента управления, функционирующего в качестве поставщика для других элементов управления в подключении.</summary>
        <value>Строка, содержащая предупреждение. Используемым по умолчанию текстом является соответствующее конкретному языку сообщение, которое предоставляется платформой .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда пользователь закрывает <xref:System.Web.UI.WebControls.WebParts.WebPart> управления, обычно сообщения не отображается. Дополнительные сведения о том, что для закрытия элемента управления см. в разделе <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> метод.  
  
 Тем не менее когда элемент управления подключен к другому элементу управления и используется в качестве поставщика данных к другому элементу управления, по умолчанию предупреждающее сообщение отображается при попытке закрытия элемента управления. В сообщении указывается пользователей, управления поставщика собирается закрыть, которая означает, что элементы управления подключена к этому поставщику как потребители больше не будет данных для получения. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> Свойство позволяет разработчикам настраивать предупреждающее сообщение, отображаемое для пользователя.  
  
 Если разработчик страницы присваивает значение пусто или равно null для этого свойства, окно предупреждение отображается, когда пользователь закрывает <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления, который является поставщиком.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> свойство для отображения пользовательского предупреждения для пользователей.  
  
 В примере кода состоит из четырех частей:  
  
-   Пользовательский элемент управления, позволяющий изменять режимы отображения на веб-странице.  
  
-   Файл исходного кода, который содержит две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления и пользовательского интерфейса.  
  
-   Веб-страницы, который содержит две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, которые могут быть подключены и `<asp:webpartmanager>` элемента.  
  
-   Пояснения к работе примера в браузере.  
  
 Следующий код содержит только часть примера веб-страницы. Также необходим пользовательский элемент управления и исходный код для пользовательских элементов управления, упомянутых выше. Для получения этих двух компонентов из примера <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе.  
  
 В следующем примере кода веб-странице показано, как назначить предупреждение сообщение, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> свойство в декларативная разметка в `<asp:webpartmanager>` элемент.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 После загрузки веб-страницы в браузере, щелкните **режим отображения** управления раскрывающегося списка и выберите **Connect** для переключения страницы в режим подключения. Подключение использует режим `<asp:connectionszone>` элемент, чтобы можно было создавать подключения между элементами управления. В режиме подключения, щелкните стрелку вниз в строке заголовка **ПОЧТОВЫЙ индекс** управления активировать соответствующее меню команд и нажмите кнопку **Connect**. После подключения пользовательский интерфейс (UI), выберите пункт **создать соединение с потребителем** ссылку. Появится ячейка с элементом управления раскрывающегося списка. Выберите **Weather Control** в раскрывающемся списке, а затем выберите **Connect** для завершения подключения между двумя элементами управления. Нажмите кнопку **закрыть**, а затем используйте **режим отображения** раскрывающегося списка, чтобы вернуться в обычный режим просмотра. Наконец, щелкните меню команд для **ПОЧТОВЫЙ индекс** управления (который является элементом управления поставщика в этом случае) и выберите **закрыть**. Пользовательское сообщение Вы назначены <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> свойство отображается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или серверный элемент управления, который закрывается в <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</param>
        <summary>Закройте элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> таким образом, чтобы он больше не отображался на веб-странице, но мог быть повторно открыт.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> Удаляет метод <xref:System.Web.UI.WebControls.WebParts.WebPart> или другой сервер управления, чтобы он не отображается на веб-странице, который изначально содержал. Закрытый элемент управления добавляется <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> объекта, который хранит ссылку на закрытый элемент управления и делает возможным для элемента управления для восстановления на страницу. Закрытый <xref:System.Web.UI.WebControls.WebParts.WebPart> управления по-прежнему отображается в коллекции, на который указывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> свойство.  
  
 Закрытие элемента управления отличается от его удаления. Закрытые элементы управления по-прежнему доступны для восстановления на странице, но удаленный экземпляр элемента управления удаляется окончательно и не может быть восстановлена. Независимо от того, следует ли <xref:System.Web.UI.WebControls.WebParts.WebPart> или серверный элемент управления не является статическим (объявленным в разметке страницы) или динамическим (добавленным на страницу программным способом или пользователем из каталога веб-частей), закрытии и повторном открытии на странице.  
  
 Как правило, чтобы закрыть <xref:System.Web.UI.WebControls.WebParts.WebPart> управления, щелкнув его команд меню и выбрав команду закрытия. Элемент управления может быть закрыто путем прямого вызова <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> метод и передает его ссылку на `webPart`.  
  
 На странице где <xref:System.Web.UI.WebControls.WebParts.WebPart> элементы управления были закрыты, если разработчик объявляет `<asp:catalogzone>` элемент и в нем добавляет `<asp:pagecatalogpart>` элемент, он предоставляет простой пользовательский интерфейс (UI) для пользователей восстановить закрытые элементы управления на страницу во время выполнения. Пользователей можно переключить в режим отображения каталога и закрытые элементы управления будут отображаться в каталоге страницы. Пользователи могут выбрать закрытые элементы управления и добавьте их обратно на страницу в любой позиции, что пожелает, а затем восстановить на странице и подготовке к просмотру в обычном режиме выбранных элементов управления.  
  
 Когда <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> метод вызывается, он создает несколько событий: <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> (если существует несколько элементов управления), и <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> (при наличии подключенных элементов управления). Как правило, разработчики могут отменить эти события, но в некоторых случаях не удается отменить их. Дополнительные сведения см. в документации для <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>, и <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> события.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>.  
  
 В примере кода состоит из четырех частей:  
  
-   Пользовательский элемент управления, позволяющий изменять режимы отображения страницы.  
  
-   Настраиваемый <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления.  
  
-   Веб-страница.  
  
-   Пояснения к работе примера в браузере.  
  
 Первая часть примера кода — это пользовательский элемент управления для изменения режима отображения. Исходный код для пользовательского элемента управления можно получить из примера <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе. Дополнительные сведения о режимах отображения и принципах работы пользовательского элемента управления см. в разделе [Пошаговое руководство: изменение режима отображения страницы](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Вторая часть примера кода — пользовательский <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления. Для выполнения примера кода необходимо скомпилировать этот исходный код. Можно выполнить явную компиляцию и поместить результирующую сборку в папку Bin веб-сайта или в глобальном кэше сборок. Кроме того можно поместить исходный код в папку App_Code веб-узла, где он будет динамически компилироваться во время выполнения. В этом примере используется метод динамической компиляции; Таким образом — не `Assembly` атрибута в `Register` директив для этого элемента управления в верхней части веб-страницы. Пошаговое руководство по компиляции см. в разделе [Пошаговое руководство: разработка и с помощью элемента управления пользовательского](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 Третья часть примера кода — веб-страница. На этой странице содержатся <xref:System.Web.UI.WebControls.WebParts.CatalogZone> зоны с <`asp:pagecatalogpart>` элемент объявлен внутри него. Это то, что будет содержать закрытого <xref:System.Web.UI.WebControls.WebParts.WebPart> управления и возможности для пользователей добавить его на страницу. `Button1_Click` Напрямую вызывает метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> метод закрытия пользовательский <xref:System.Web.UI.WebControls.WebParts.WebPart> управления, несмотря на то, что пользователь также может закрыть управления через меню команд.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 После загрузки страницы в браузере, закройте пользовательский <xref:System.Web.UI.WebControls.WebParts.WebPart> управления, щелкнув меню команд (знак стрелки) в заголовке элемента управления и щелкнув **закрыть**. Теперь измените страницы в режим каталога, выбрав **каталога** в **режим отображения** раскрывающемся списке элемента управления. Закрытый элемент управления отображается в каталог страницы. Установите флажок рядом с закрытого элемента управления, нажмите кнопку **добавить** добавить на страницу, и нажмите кнопку **закрыть** для возврата страницы в режим просмотра. Элемент управления восстанавливается на страницу. Теперь закройте его снова, это время, щелкнув **закрыть веб-части** кнопки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="webPart" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Элемент <paramref name="webPart" /> отсутствует в коллекции <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
 \- или -  
  
 <paramref name="webPart" /> является общим элементом управления и уже был закрыт другим пользователем.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет режим отображения, используемый для отображения специального пользовательского интерфейса для пользователей в целях управления подключениями между элементами управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> Ссылается настраиваемый <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> объекта, который создается и содержащиеся в <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления. Поскольку это статический объект, можно ссылаться на него напрямую с помощью <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класс без необходимости экземпляр элемента управления.  
  
 Если пользователи хотят управлять соединениями между <xref:System.Web.UI.WebControls.WebParts.WebPart> элементы управления на веб-странице, если <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> зоны был объявлен на странице, их можно переключить страницу в <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> режиме. Режим отображения подключения отображается специальный пользовательский Интерфейс для управления подключениями, который включает возможность подключать или отключать элементы управления, а также для изменения сведений о существующих соединений.  
  
 Если вы хотите предоставить пользователям возможность управлять подключениями с помощью пользовательского интерфейса, предоставляемые в наборе элементов управления веб-частей, необходимо объявить `<asp:connectionszone>` элемент в разметке страницы. В отличие от элементов для других типов <xref:System.Web.UI.WebControls.WebParts.WebZone> зоны, необходимо добавить другие теги внутри этого элемента; сам по себе просто объявления элемента.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> режим.  
  
 В примере кода состоит из трех частей:  
  
-   Исходный файл, который содержит пользовательский интерфейс и <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, которые могут стать соединение.  
  
-   Веб-страницы, которая предоставляет пользовательский Интерфейс для подключения и демонстрируется работа с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> режим.  
  
-   Пояснения по запуску этого примера.  
  
 Первая часть пример кода является исходный файл, содержащий интерфейс и пользовательских <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, которые разработаны, поэтому они могут быть соединены. Для выполнения примера кода необходимо скомпилировать этот исходный код. Можно выполнить явную компиляцию и поместить результирующую сборку в папку Bin веб-сайта или в глобальном кэше сборок. Кроме того можно поместить исходный код в папку App_Code веб-узла, где он будет динамически компилироваться во время выполнения. Данный пример кода использует метод динамической компиляции. Пошаговое руководство по компиляции см. в разделе [Пошаговое руководство: разработка и с помощью элемента управления пользовательского](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 Во второй части примера является веб-страницы, на котором размещены пользовательские элементы управления. В пределах сервера `<script>` теги на странице несколькими способами для заполнения раскрывающегося списка режимами отображения на странице. Пользователь может выбрать из раскрывающегося списка, чтобы изменить режим отображения страницы. Один из доступных режимов отображения является режим отображения подключения, так как `<asp:connectionszone>` в разметке страницы объявлен элемент. Обратите внимание, что этот элемент не содержит других дочерних элементов; он существует только для того, чтобы включить управление соединениями пользовательского интерфейса для пользователей.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> Режиме отображается в этом примере в двух местах. Во-первых, в `Page_Init` , режим отображения подключения добавляется метод в раскрывающемся списке режимов отображения, как код выполняет цикл по коллекции, на которые ссылается <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> свойство. Во-вторых, `Page_PreRender` метод проверяет текущий режим отображения на странице, и если текущий режим <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>, сообщение отображается в <xref:System.Web.UI.WebControls.Label> элемента управления.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 После загрузки страницы в браузере, нажмите кнопку раскрывающегося списка и выберите **Connect** для переключения страницы в режим отображения подключения. Обратите внимание, что появляется сообщение о том, что страница находится в режим отображения подключения. Теперь щелкните меню команд (значок стрелки) в заголовке окна одного из <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, а затем щелкните **Connect** в меню команд. После установления соединения пользовательский Интерфейс отображается, щелкните ссылку, чтобы создать подключение. Использование раскрывающегося списка в соединении пользовательского интерфейса, который отображается, выберите элемент управления, который будет участвовать в соединении и нажмите кнопку **Connect** кнопки. Соединение установлено. Нажмите кнопку **закрыть** кнопку, а затем использовать раскрывающегося списка в верхней части страницы, чтобы вернуться в режим просмотра.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ссылку на коллекцию текущих подключений на веб-странице.</summary>
        <value>Коллекция <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />, в которой содержится набор объектов <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> Свойство предоставляет способ доступа к текущий набор подключений на странице. Сама коллекция только для чтения, и разработчики, которым необходимо управлять конкретного подключения из коллекции следует использовать <xref:System.Web.UI.WebControls.WebParts.WebPartManager> методов, таких как <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> и <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано использование декларативного и программного <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления.  
  
 В примере кода состоит из четырех частей:  
  
-   Пользовательский элемент управления, позволяющий изменять режимы отображения на веб-странице.  
  
-   Веб-страницы, который содержит две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, которые могут быть подключены, и `<asp:webpartmanager>` элемента.  
  
-   Файл исходного кода, который содержит две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления и пользовательского интерфейса.  
  
-   Пояснения к работе примера в браузере.  
  
 Следующий код содержит только часть примера веб-страницы. Также необходим пользовательский элемент управления и исходный код для пользовательских элементов управления, упомянутых выше. Для получения этих двух компонентов из примера <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе.  
  
 В следующем примере кода веб-страницы демонстрируется использование <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> программным образом, чтобы получить число текущих подключений на странице. Обратите внимание, что в `<script>` раздел тег, код для обработки два события для <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления доступов <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> свойство для получения числа.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 После загрузки веб-страницы в браузере, щелкните **режим отображения** управления раскрывающегося списка и выберите **Connect** для переключения страницы в режим подключения. Подключение использует режим `<asp:connectionszone>` элемент, чтобы можно было создавать подключения между элементами управления. В режиме подключения, щелкните стрелку вниз в строке заголовка **ПОЧТОВЫЙ индекс** управления активировать соответствующее меню команд и нажмите кнопку **Connect**. Отобразить окно пользовательского интерфейса (UI) подключения, нажмите кнопку **создать соединение с потребителем** ссылку. Появится ячейка с элементом управления раскрывающегося списка. Выберите **Weather Control** в раскрывающемся списке, а затем выберите **Connect** для завершения подключения между двумя элементами управления. Нажмите кнопку **закрыть**, а затем используйте **режим отображения** раскрывающегося списка, чтобы вернуться в обычный режим просмотра. Обратите внимание, что метки теперь отображает число соединений и количество <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления. Если вернуться в режим подключения и отключения двух элементов управления, при возвращении в режим просмотра содержимое метки должны быть обновлены, и должен быть подключения отсутствуют.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после того, как все текущие подключения веб-частей на странице не только будут подключены, но и начнут активно обмениваться данными между элементами управления поставщиков и получателей в каждом подключении.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В жизненном цикле подключений это событие возникает после завершения загрузки страницы. Она также происходит после <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> событие, которое означает только то, что <xref:System.Web.UI.WebControls.WebParts.WebPart> или серверных элементов управления, включенных в конкретных подключение успешно подключились. В случае если существуют несколько подключений на странице, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> метод означает, что все допустимых подключений веб-частей на странице теперь активных и обмениваются данными. Зная, что все соединения являются активными, разработчики могут выполнить любое количество задач, включая уведомление пользователей о состоянии всех подключений, уведомление элементов управления получателя для обработки и отображения данных из своих служб и т. д.  
  
 Это событие связано с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> метод, который вызывает события и позволяет разработчикам создавать пользовательские обработчики для события.  
  
 Разработчики страниц могут создать пользовательский обработчик для события, добавив `OnConnectionsActivated` атрибут `<asp:webpartmanager>` элемент на странице и последующим назначением атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит во время активации всех установленных подключений веб-частей на веб-странице.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В жизненном цикле подключений, это событие возникает, как страница завершает его процесс загрузки непосредственно перед <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> вызывается метод. Оно отличается от <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> событие, которое включает в себя определенного соединения между <xref:System.Web.UI.WebControls.WebParts.WebPart> или других серверных элементов управления. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> Событие происходит, когда все возможные соединения на странице были подключены и должны быть активированы.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> Событие связано с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> метод, который вызывает событие. Разработчики элементов управления, которые хотят расширить тип соединения, которые можно добавить на страницу может переопределить защищенный <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> метод и активируйте дополнительные типы подключений.  
  
 Разработчики страниц могут создать пользовательский обработчик для события, добавив `OnConnectionsActivating` атрибут `<asp:webpartmanager>` элемент на странице и последующим назначением атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает подключение между двумя элементами управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (или другими серверными элементами управления, способными создавать подключения), которые находятся в зоне <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> Метод forms соединения между любыми двумя <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, которые могут быть подключены. Перед вызовом этого метода для создания соединения, можно также вызвать <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> метод в проверку условия, чтобы убедиться, что элементы управления соответствуют требованиям для формирования подключения.  
  
> [!NOTE]
>  Можно также создать подключение между двумя серверными элементами управления, которые не являются <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления. Как правило, два элемента управления следует осуществить пользовательских серверных элементов управления (например, элементы управления, которые наследуют от <xref:System.Web.UI.WebControls.WebControl> или существующие элементы управления сервера ASP.NET) так, чтобы можно было добавить требуемые элементы. Элементы управления будут также должны соответствовать указанным ниже требованиям.  
  
 Любой тип сценария подключения между двумя элементами управления должен соответствовать следующим требованиям, чтобы иметь возможность подключения:  
  
-   Каждый элемент управления находится в <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зоны (оно не обязательно должно той же зоны).  
  
-   Реализованное в наборе элементов управления веб-частей управления поставщика в подключении реализует интерфейс в качестве открытый метод, который выступает в качестве обратный вызов поставщика и имеет `ConnectionProvider` атрибут метаданных для метода, чтобы идентифицировать его в качестве соединения поставщика точка. Поскольку <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> метод является виртуальным, извлекает точки подключения поставщика, который является производным <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления не обязательно использовать один и тот же атрибут метаданных.  
  
-   Реализованное в наборе элементов управления веб-частей управления потребителя в подключении также имеет специальный метод, который позволяет получить ссылку на интерфейс, предоставляемый в методе обратного вызова поставщика и потребителя `ConnectionConsumer` атрибут метаданных Укажите метод, чтобы идентифицировать его в качестве соединения с потребителем. Поскольку <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> , точки подключения потребителя извлекает виртуальный метод, который является производным <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления не обязательно использовать один и тот же атрибут метаданных.  
  
-   Методы обратного вызова должны быть совместимыми, необходимо использовать в том, что потребитель может использовать тип интерфейса, предоставляемый в методе обратного вызова поставщика (это означает, что получатель и поставщик могут совместно использовать данные напрямую), или же разработчик <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> объект преобразования данных от поставщика в форму, потребитель может использовать.  
  
    > [!IMPORTANT]
    >  Если вам не требуется преобразователь, используйте <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> перегрузки метода. При необходимости преобразователь, используйте <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> перегрузки метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">Элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, который играет роль передачи данных в другой подключенный элемент управления.</param>
        <param name="providerConnectionPoint">Метод, который служит в качестве метода обратного вызова для этого подключения. В соответствии с реализацией в наборе элементов управления веб-частей это открытый метод в <c>provider</c>, который отмечен с помощью атрибута метаданных <see langword="ConnectionProvider" />.</param>
        <param name="consumer">Элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, выполняющий функцию получения данных из <c>provider</c> с последующей их обработкой и отображением.</param>
        <param name="consumerConnectionPoint">Метод, который подключается к точке <c>providerConnectionPoint</c> для получения данных для подключения. В соответствии с реализацией в наборе элементов управления веб-частей это открытый метод в <c>consumer</c>, который отмечен с помощью атрибута метаданных <see langword="ConnectionConsumer" />.</param>
        <summary>Создает подключение между двумя элементами управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> с использованием только ссылок на элементы управления и их определенные объекты <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />.</summary>
        <returns>Подключение <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />, которое содержит различные необходимые для подключения сведения о поставщике и получателе.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данная перегрузка используется для подключения элементов управления при их точек подключения достаточно совместимы, что они могут подключаться без использования <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> объекта. При вызове перегруженного метода, он просто передает этот вызов к перегруженной версии метода и передает `null` параметра, которое требуется <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> объекта.  
  
 При попытке подключения двух элементов управления программными средствами, можно использовать <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> метода в проверку условия, чтобы определить, является ли элементы управления могут подключаться непосредственно.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать этот метод для программного создания подключения. Полный код, необходимый для запуска этого примера, см в разделе примеров <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе. Из этого примера потребуется исходный код для пользовательского элемента управления, позволяющий изменять режимы отображения на странице и исходный код для двух пользовательских <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления.  
  
 Код веб-страницы, содержащей два управляет следующим образом. На странице используется `Register` директивы в начале объявления пользовательского элемента управления и пользовательские элементы управления. Пользовательские элементы управления будут использоваться далее декларативно в `<asp:webpartzone>` элемент. Код, который обрабатывает `Button1_Click` метод создает подключение между элементами управления с помощью <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> метод.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 После загрузки страницы в браузере, щелкните **подключения элементов управления веб-части** кнопки для подключения. Затем можно ввести некоторые данные в текстовом поле и нажмите кнопку **введите ПОЧТОВЫЙ индекс из 5 цифр** кнопку, чтобы продемонстрировать подключенных элементах управления, что данные, введенные в первый элемент управления обновляется в течение секунды.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Коллекция элемента подключения <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, принадлежащая динамическим коллекциям, доступна только для чтения.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">Элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, который играет роль передачи данных в другой подключенный элемент управления.</param>
        <param name="providerConnectionPoint">Открытый метод в <c>provider</c>, который помечен атрибутом метаданных <see langword="ConnectionProvider" /> и служит в качестве метода обратного вызова для подключения.</param>
        <param name="consumer">Веб-часть <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, выполняющая функцию получения данных из <c>provider</c> или <c>transformer</c> с последующей их обработкой и отображением.</param>
        <param name="consumerConnectionPoint">Открытый метод в <c>consumer</c>, который помечен атрибутом метаданных <see langword="ConnectionConsumer" /> и подключается к <c>providerConnectionPoint</c> с целью получения данных для подключения.</param>
        <param name="transformer">Веб-часть <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />, которая позволяет создать подключение между двумя элементами управления путем преобразования данных поставщика <c>provider</c> в формат, который может быть обработан получателем <c>consumer</c>.</param>
        <summary>Создает подключение между двумя элементами управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> с использованием только ссылок на элементы управления и их определенные объекты <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />, а также объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />.</summary>
        <returns>Подключение <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />, которое содержит различные необходимые для подключения сведения о поставщике, получателе и преобразователе.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данная перегрузка используется для подключения элементов управления при их точек соединения несовместимы. Эта несовместимость происходит при `consumer` реализует другой интерфейс, чем `provider` точкой подключения. Преобразователь преобразует данные в тип, который может быть понятным `consumer`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Подключения уже были активированы в событии <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, серверных или пользовательских элементов управления, которые содержатся в зонах <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> на веб-странице и управляются элементом управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Коллекция <see cref="T:System.Web.UI.ControlCollection" />, которая содержит все элементы управления, управляемые элементом управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A> Свойства не ссылается на другие элементы управления, на которые ссылается <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления, такие как различных элементов управления, зоны <xref:System.Web.UI.WebControls.WebParts.EditorPart> или <xref:System.Web.UI.WebControls.WebParts.CatalogPart> и другие элементы управления.  
  
 Это свойство используется набором элементов управления веб-частей и в большинстве случаев разработки не предназначен для непосредственного вызова из кода. По этой причине несмотря на то, что свойство является общим, он скрыт из IntelliSense. Разработчики, которым требуется доступ к коллекции из <xref:System.Web.UI.WebControls.WebParts.WebPart> или других серверных элементов управления под управлением <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемент управления должен использовать его <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Копируемый объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или серверный элемент управления.</param>
        <summary>Используется набором элементов управления веб-частей для создания копии <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или серверного элемента управления для добавления элемента управления на веб-страницу.</summary>
        <returns>Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, добавляемый на страницу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не удается вызвать <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> метод непосредственно из программного кода. Этот метод вызывается внутренним образом <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления в процессе добавления нового динамического <xref:System.Web.UI.WebControls.WebParts.WebPart> или серверный элемент управления на страницу. Динамический элемент управления добавляется на страницу программно или через веб-частей пользовательский интерфейс (UI), например добавление элемента управления из каталога элементов управления, а не статический элемент управления, который объявляется напрямую в разметке страницы пользователем.  
  
> [!NOTE]
>  Метод можно переопределить в производном классе, если разработчикам необходимо включить этот метод для обработки дополнительных сценариев копирования элементов управления. Дополнительные сведения см. в разделе "примечания к наследующим объектам".  
  
 При добавлении нового динамического элемента управления, если это <xref:System.Web.UI.WebControls.WebParts.WebPart> управления <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> метод возвращает новый экземпляр элемента управления. Если добавляемый элемент управления принадлежит другому типу серверного элемента управления (например, пользовательский элемент управления, пользовательский элемент управления или элемент управления ASP.NET), элемент управления будет уже были изолированы с <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> объекта набором элементов управления веб-частей. При <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> встречает метод <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> управления, он возвращает новый экземпляр <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> элемента управления для нового экземпляра дочернего элемента управления в оболочку внутри него.  
  
 Когда <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> метод создает новую копию элемента управления для возврата, он также возвращает значения всех свойств, значения по умолчанию. Обратите внимание, что, если вы хотите сохранить значения настраиваемых свойств и иметь их копируются в новый экземпляр элемента управления, следует вызвать метод <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A> также метод. Последний шаг, выполняемый службой <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> метод заключается в вызове <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A> метод, чтобы получить новый идентификатор для элемента управления.  
  
> [!NOTE]
>  Поскольку метод получает новый идентификатор для скопированного элемента управления, не следует полагаться на создание ссылок на динамический элемент управления, который добавляется на страницу с использованием исходного идентификатора. Вместо этого следует ссылаться на новый экземпляр элемента управления, возвращенный методом.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Метод объявляется как <see langword="virtual" /> , чтобы разработчики могут наследовать от <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> класса и переопределить метод предоставлять дополнительные сценарии, в которых следует создавать копии элементов управления. Например метод может получить в качестве входных данных элемент управления, который был сериализован в XML-файл. Метод может десериализовать XML (при его наличии), а затем вызвать базовый метод для обработки существующих вариантов и возвращать новый экземпляр <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> элемента управления.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает набор преобразователей, указанный в файле конфигурации веб-сайта, и добавляет эти преобразователи в коллекцию преобразователей, на которую ссылается свойство <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />.</summary>
        <returns>Коллекция преобразователей, указанные в файле конфигурации веб-сайта.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Этот метод может быть переопределен для добавления дополнительных преобразователей, которые могут использоваться приложением. Например метод написать для получения списка доступных преобразователей из веб-службы.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию всех элементов управления, которые управляются на веб-странице с помощью элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />. Этот класс не наследуется.</summary>
        <returns>Коллекция <see cref="T:System.Web.UI.ControlCollection" />, которая состоит из различных элементов управления веб-частей, управляемых с помощью элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Так как этот метод является защищенным и запечатанными, она доступна как классы, производные от <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> класс, но он не может быть переопределен.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает набор всех возможных режимов отображения для приложения веб-частей.</summary>
        <returns>Коллекция <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />, которая содержит все поддерживаемые режимы отображения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает список всех возможных режимов отображения, не только режимов отображения, поддерживаемых на определенной странице. Дополнительные сведения о поддерживаемых режимах отображения см. в разделе <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> свойство.  
  
 По умолчанию в наборе элементов управления веб-частей создает следующий набор режимов отображения для использования на страницах веб-частей:  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 Разработчики могут создавать пользовательские режимы отображения, с указанием или без сообщения, сопровождающие настраиваемые зоны, которые являются производными от <xref:System.Web.UI.WebControls.WebParts.WebZone> или <xref:System.Web.UI.WebControls.WebParts.ToolZone> классы. Для создания пользовательского режима отображения, должен наследовать из <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> класса, и для добавления в режим отображения как поддерживаемый режим на странице, должен наследовать из <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класса и переопределить <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> метод.  
  
 При добавлении режимы отображения с помощью <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A> метода, следует добавить их в порядке их отображения в любые пользовательские элементы управления пользовательского интерфейса (например, <xref:System.Web.UI.WebControls.ListBox> управления), обеспечивающие пользователям возможные режимы отображения на странице.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>.  
  
 В примере кода состоит из пяти частей.  
  
-   Пользовательский элемент управления, позволяющий изменять режимы отображения на веб-странице.  
  
-   Веб-страница, на которой размещены другие элементы управления.  
  
-   Пользовательский элемент управления, который находится в <xref:System.Web.UI.WebControls.WebParts.WebPartZone> зоны на веб-странице и дает возможность ввода и отображения текста в метке.  
  
-   Файл исходного кода, содержащий два элемента управления. Один является пользовательским <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления, а другой — пользовательский <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> объект для добавления режимы отображения по умолчанию.  
  
-   Файл исходного кода, который содержит две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления и пользовательского интерфейса.  
  
-   Пояснения к работе примера в браузере.  
  
 Первая часть примера кода — это пользовательский элемент управления для изменения режима отображения. Исходный код для пользовательского элемента управления можно получить из примера <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе. Дополнительные сведения о режимах отображения и принципах работы пользовательского элемента управления см. в разделе [Пошаговое руководство: изменение режима отображения страницы](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Во второй части примера — веб-страница. Он содержит два <xref:System.Web.UI.WebControls.WebParts.WebPartZone> элементов управления, пользовательские элементы управления и пользовательского <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления. Обратите внимание `Register` директивы в верхней части страницы для ссылки на пользовательские элементы управления и пространство имен для скомпилированных элементов управления.  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 В третьей части примера представлен пользовательский элемент управления для ввода и отображения текста. Она использует <xref:System.Web.UI.WebControls.MultiView> управления для создания нескольких представлений пользовательского интерфейса. Первое представление отображается с `Button1` кнопки без. Обратите внимание, что в переопределенном `OnPreRender` метод, код проверяет ли страница в настоящее время в пользовательском режиме отображения и, если да, отображается первое представление пользовательского элемента управления, включая кнопки. Если страница не находится в пользовательском режиме отображения, например, если страница находится в режиме просмотра или конструктора, кнопка является скрытой.  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 Четвертая часть примера является исходный файл для двух пользовательских классов. Обратите внимание, что пользовательский <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класса переопределения <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> метод и что он сначала вызывает базовый метод, чтобы добавить все режимы отображения по умолчанию, а затем добавляет пользовательском режиме отображения. Класс режиме пользовательское отображаемое `InLineEditDisplayMode`, просто наследует от <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>, задает имя режима отображения в конструкторе и переопределяет число базовые свойства для установления характеристики настройки отображения.  
  
 Для выполнения примера кода необходимо скомпилировать этот исходный код. Можно выполнить явную компиляцию и поместить результирующую сборку в папку Bin веб-сайта или в глобальном кэше сборок. Кроме того можно поместить исходный код в папку App_Code веб-узла, где он будет динамически компилироваться во время выполнения. Пошаговое руководство по компиляции см. в разделе [Пошаговое руководство: разработка и с помощью элемента управления пользовательского](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 Чтобы запустить пример кода, загрузите страницу в браузере. Обратите внимание, что страница в настоящее время находится в режиме просмотра, кнопка не отображается. С помощью **режим отображения** раскрывающемся списке элемента управления, измените страницу, чтобы **Inline Edit Display** режим и обратите внимание, что теперь `Button1` кнопка отображается в нижнем пользовательском элементе управления. Добавьте текст и нажмите кнопку, чтобы обновить элемент управления. Обратите внимание, что страница возвращается в режим просмотра, теперь отображается введенный текст, кнопки снова становится скрытой, так как страница больше не находится в пользовательском режиме отображения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает уникальное значение, которое будет служить в качестве идентификатора для динамического подключения.</summary>
        <returns>Строка, которая содержит уникальный идентификатор для подключения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A> Метод формирует идентификатор GUID и преобразует его в строку в качестве уникальный идентификатор соединения. Метод вызывается каждый раз при создании динамического подключения.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Разработчики могут переопределить этот метод в производном <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> классе, чтобы изменить реализацию для создания уникального идентификатора.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">Тип <see cref="T:System.Type" /> элемента управления, для которого создается идентификатор.</param>
        <summary>Создает уникальные идентификатор для динамического элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <returns>Строка, содержащая уникальный идентификатор для элемента управления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Web.UI.WebControls.WebParts.WebPart> добавлены элементы управления на веб-страницу, они могут быть статическими (то есть, объявляются в разметке страницы) или динамическими (программным способом добавляются). В любом сценарии, где <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления создает новые динамические элементы управления, чтобы добавить на страницу, он вызывает этот метод для создания уникального идентификатора.  
  
 Метод является виртуальным, чтобы разработчики могли переопределять его при необходимости предоставить собственную реализацию для создания идентификатора.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="webPartType" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">Строка, которая представляет идентификатор элемента управления со сбоем. Если элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> связан со сбоем, идентификатор является идентификатором его дочернего серверного элемента управления.</param>
        <param name="originalTypeName">Строка, содержащая имя <see cref="T:System.Type" /> элемента управления со сбоем. Если элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> связан со сбоем, имя типа — это тип его дочернего серверного элемента управления.</param>
        <param name="originalPath">Строка, содержащая путь к пользовательскому элементу управления, если элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />, содержащий дочерний пользовательский элемент управления, связан со сбоем.</param>
        <param name="genericWebPartID">Строка, возвращающая идентификатор элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />, если этот тип элемента управления связан со сбоем загрузки или создания элемента управления.</param>
        <param name="errorMessage">Строка, содержащая сообщение об ошибке для отображения на странице.</param>
        <summary>Создает специальный элемент управления, который вставляется на страницу и отображается для конечных пользователей при завершении со сбоем попытки загрузки или создания динамического элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> по какой-либо причине.</summary>
        <returns>Объект <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />, который вставляется на странице вместо элемента управления, загрузка или создание которого завершилась со сбоем.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> Метод вызывается, когда набор пытается загрузить или создать экземпляр динамического управления веб-частей <xref:System.Web.UI.WebControls.WebParts.WebPart> или серверный элемент управления и он не по какой-либо причине. Этот метод создает <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> объекта, присваивает ему сообщение об ошибке и возвращает его. <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> Управления вставляется вместо элемента управления, вызвавшего сбой, и на странице отображается сообщение об ошибке.  
  
 Не удается вызвать <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> метод непосредственно из программного кода. Тем не менее, можно наследовать от <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класса и метода расширения. Дополнительные сведения см. примечания для наследующих объектов раздела.  
  
 Конечные пользователи могут работать с <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> управлять на странице, как это было бы обычной <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления. Чтобы удалить сообщение об ошибке, они закрытия элемента управления, щелкнув команду закрытия, после чего добавляется элемент управления <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> объекта, как и любой другой закрытый элемент управления. Если конечный пользователь удаляет <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> сервера управления, не удалось загрузить на странице также будут удалены.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Если вы хотите настроить сведения, которые возвращаются в <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> управления, можно переопределить <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" /> метод, вызвать базовый метод, назначить разные значения параметров, передаваемых в базовый метод и затем возвращают результирующий <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />элемента управления. Например, если не хотите, чтобы конечные пользователи <paramref name="originalPath" /> значение (которое показывает путь к виртуальному каталогу пользовательского элемента управления), при вызове метода базового класса можно передать пустую строку ("») для этого параметра.  
  
 Также можно настроить поведение <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> самого, элемента управления путем наследования от него. Например, может потребоваться переопределить его <see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" /> или <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" /> свойства.</para>
        </block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект персонализации, который должен содержать пользовательские данные персонализации для текущей веб-страницы.</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />, который должен содержать пользовательские данные персонализации.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A> Метод возвращает объект для хранения и управления параметры персонализации пользователя для текущей страницы. <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Управления управляет этого объекта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, который не является элементом управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</param>
        <summary>Помещает серверный элемент управления, который не является элементом управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, в оболочку из объекта <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />, чтобы этот элемент управления имел функциональные возможности веб-частей.</summary>
        <returns>Объект <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />, который служит оболочкой для параметра <paramref name="control" /> и позволяет последнему функционировать как настоящий элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> Метод — это основной механизм для включения серверных элементов управления, которые не являются <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, чтобы взять на себя те же функциональные возможности, как <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления и, следовательно, полностью участвовать в приложениях веб-частей. С помощью этого метода разработчики значительно расширить число серверных элементов управления, их можно использовать в приложении веб-частей, поскольку практически любой тип серверного элемента управления — можно использовать стандартные элементы управления ASP.NET, пользовательские элементы управления и пользовательские элементы управления--.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Управления также использует этот метод в двух сценариях программы-оболочки для серверных элементов управления с <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> объекта. При добавлении серверных элементов управления на страницу с помощью <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> управления, если импортированного элемента управления не <xref:System.Web.UI.WebControls.WebParts.WebPart> управления <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> вызывается метод. Кроме того, когда серверных элементов управления объявляются в постоянном формате в <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зоны на веб-странице, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> метод вызывается для всех элементов управления, которые не являются <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления.  
  
 При добавлении серверного элемента управления в зону программными средствами, типичный подход заключается в использовании <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> метод программы-оболочки для элемента управления с <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> объекта, а затем вызвать <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> метод, чтобы добавить элемент управления к коллекции всех <xref:System.Web.UI.WebControls.WebParts.WebPart> элементы управления на странице, на который указывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> метода. В `Button2_Click method`, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> метод вызывается для создания оболочки <xref:System.Web.UI.WebControls.Calendar> управления <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> объекта перед его добавлением в зоне.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Этот метод может быть переопределен для использования производным <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> класса вместо базового класса, в состав веб-части набора элементов управления.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает пользовательское предупреждение, отображаемое для конечных пользователей, которые удаляют элемент управления.</summary>
        <value>Строка, содержащая текст предупреждения. Значением по умолчанию является локализованное предупреждение.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При удалении <xref:System.Web.UI.WebControls.WebParts.WebPart> управления, обычно отображается предупреждающее сообщение по умолчанию. Оно предупреждает пользователя, что при удалении этого экземпляра элемента управления, не подлежат восстановлению. Разработчик может предоставить пользователям способ добавления нового экземпляра элемента управления на страницу (такие как через каталог <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, или некоторых программных способов), но текущий экземпляр элемента управления, который будет удален без возможности восстановления будут удалены. Диалоговое окно, отображает предупреждение, содержит кнопки для пользователя, для отмены удаления, при необходимости.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> Свойство дает разработчикам возможность задать предупреждающее сообщение, отображаемое для пользователя.  
  
 Если разработчик страницы назначает пустая строка ("») будет отображаться значение этого свойства, диалоговое окно предупреждение, когда пользователь удаляет <xref:System.Web.UI.WebControls.WebParts.WebPart> управления.  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> Свойство не отображается в случае статического <xref:System.Web.UI.WebControls.WebParts.WebPart> и серверных элементов управления. Статические элементы управления, серверные элементы управления, которые объявлены в <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зоны в разметке веб-страницы. Поскольку такие элементы управления являются статическими, их невозможно удалить, поэтому удаленное предупреждение в этом случае никогда не отображается. Пользователь может быть закрыт, статические элементы управления, но закрытый элемент управления добавляется в каталог страницы, откуда его можно добавить на страницу пользователем, в то время как удаленный элемент управления не может быть восстановлен.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> свойство декларативно и программно.  
  
 Состоит из четырех частей в примере кода:  
  
-   Пользовательский элемент управления, позволяющий изменять режимы отображения страницы.  
  
-   Настраиваемый <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления.  
  
-   Веб-страница.  
  
-   Пояснения к работе примера в браузере.  
  
 Первая часть примера кода — это пользовательский элемент управления для изменения режима отображения. Исходный код для пользовательского элемента управления можно получить из примера <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе. Дополнительные сведения о режимах отображения и принципах работы пользовательского элемента управления см. в разделе [Пошаговое руководство: изменение режима отображения страницы](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Вторая часть примера кода — пользовательский <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления. Для выполнения примера кода необходимо скомпилировать этот исходный код. Можно выполнить явную компиляцию и поместить результирующую сборку в папку Bin веб-сайта или в глобальном кэше сборок. Кроме того можно поместить исходный код в папку App_Code веб-узла, где он будет динамически компилироваться во время выполнения. В этом примере используется метод динамической компиляции; Таким образом — не `Assembly` атрибута в `Register` директив для этого элемента управления в верхней части веб-страницы. Пошаговое руководство по компиляции см. в разделе [Пошаговое руководство: разработка и с помощью элемента управления пользовательского](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 Третья часть примера кода — веб-страница. На этой странице содержатся <xref:System.Web.UI.WebControls.WebParts.CatalogZone> зоны с пользовательским <xref:System.Web.UI.WebControls.WebParts.WebPart> управления объявлен в зоне, чтобы пользователь может добавить его на страницу во время выполнения. Обратите внимание, что только динамические элементы управления (элементы управления, добавляемые на страницу программно или из каталога такого рода) может быть удален из страницы. Статические элементы управления (элементы управления, которые объявлены в <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зоны в разметке страницы) может быть закрыто, но никогда не удаляются. `<asp:webpartmanager>` Элемент объявляет пользовательское значение <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> свойства с помощью `DeleteWarning` атрибута. `Button1_Click` Метод присваивает другой пользовательской значение <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> свойства.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 После загрузки страницы в браузере, необходимо добавить <xref:System.Web.UI.WebControls.WebParts.WebPart> на страницу элемент управления. С помощью **режим отображения** раскрывающемся списке элемента управления, выбора режима каталога. При появлении каталога, установите флажок рядом с пользовательский элемент управления, нажмите кнопку **добавить** добавить на страницу, и нажмите кнопку **закрыть** для возврата страницы в режим просмотра. Теперь, когда элемент управления является видимым, его можно удалить. С помощью **режим отображения** управления снова, переключитесь в режим конструктора (пока страница находится в режиме просмотра, нельзя удалять элементы управления). Щелкните меню команд (знак стрелки) в заголовке <xref:System.Web.UI.WebControls.WebParts.WebPart> управления и выберите **удалить**. Предупреждения, установленного на `DeleteWarning` появится атрибут. Нажмите кнопку **отменить**. Теперь нажмите кнопку с многоточием **Change Delete Warning**, какие изменения значения свойства программным способом. В меню команд для элемента управления, выберите **удалить** еще раз и обратите внимание, что в данный момент отображается предупреждающее сообщение.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Удаляемый серверный элемент управления.</param>
        <summary>Окончательно удаляет динамический экземпляр элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> с веб-страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> Метод окончательно удаляет элемент управления, представленный `webPart` параметра со страницы. В отличие от закрытого элемента управления, который добавляется <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> управления и может быть добавлена на страницу никогда не удаленный экземпляр элемента управления можно добавить на страницу.  
  
> [!NOTE]
>  Как осуществляется с помощью элемента управления веб-частей задано, возможность пользователям удалять динамический <xref:System.Web.UI.WebControls.WebParts.WebPart> управления зависит от пользователя и области персонализации, в котором элемент управления был добавлен на страницу. Если элемент управления добавляется при нахождении страницы в общей области (от пользователя, имеющего разрешения), затем элемент управления нельзя удалить отдельными пользователями при нахождении страницы в пользовательской области.  
  
 Динамические элементы управления могут быть удалены. Динамические элементы управления добавляются на страницу программным способом или пользователи, добавление элементов управления из каталога. Статические элементы управления добавляются на страницу декларативно в разметке или в постоянном формате. Так как декларативные теги постоянно присутствуют в разметке, статические элементы управления не могут быть удалены, но закрыт и открыт повторно.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>. В первый раз **добавить календарь** нажатии кнопки код в создает обработчик событий <xref:System.Web.UI.WebControls.Calendar> управления и добавляет ее к области, как <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> объект. Так как элемент управления добавляется программно, это динамический элемент управления и таким образом могут быть удалены. Когда пользователь щелкает **удалить календарь** кнопки, код гарантирует, что элемент управления существует, а затем удаляет его, вызвав <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> метод.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет режим отображения, используемый для изменения макета веб-страниц, содержащих элементы управления веб-частей. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> Ссылается настраиваемый <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> объекта, который создается и содержащиеся в <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления. Поскольку это статический объект, можно ссылаться на него напрямую с помощью <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класс без необходимости экземпляр элемента управления.  
  
 При первой загрузке определяет, страницу, которая содержит веб-частей, он находится в <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (режим просмотра) по умолчанию. Если требуется изменить макет страницы путем перемещения элементов управления в различных зонах или в пределах текущей зоны, они сначала переключения страницы в <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> (режим конструктора). В режиме конструктора появится пользовательский интерфейс (UI) для различных зон, и пользователи могут перетаскивать элементы управления для изменения макета.  
  
   
  
## Examples  
 В следующем примере кода показано, как работать с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> поле программными средствами. Код заполнение раскрывающегося списка поддерживаемых режимах отображения страницы, которые в этом случае конструктора и просмотра. Обратите внимание, что в `Page_PreRender` метод, этот код проверяет ли текущий <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> свойству <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>. В этом случае `Label1` будет отображаться Если нет, `Label1` будет скрыта.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 После загрузки страницы в браузере, вы находитесь в режиме просмотра по умолчанию. Обратите внимание, что метка на странице скрыта. Используйте элемент управления раскрывающегося списка для переключения страницы в режим конструктора. Обратите внимание, что из-за кода в `Page_PreRender` , метка теперь является видимым.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Отключаемый элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</param>
        <summary>Удаляет <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или серверный элемент управления, который закрывается или удаляется из любого подключения, в котором принимал участие.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> Метод можно вызвать изнутри с помощью элемента управления веб-частей при закрыт на странице или удален из страницы элемента управления. В этом случае метод вызывается для удаления элемента управления из любого подключения включающих как поставщик или потребитель. Если элемент управления удаляется из любого соединения, этот метод также вызывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> метод, чтобы завершить все соединения, в котором `webPart` был указан.  
  
 Когда <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> вызывается метод, он выдает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> событий. Обычно это событие может быть отменено, однако в двух случаях не может быть отменено. Один вариант происходит во время запросов на страницу при <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> вызывается метод. При наличии конфликта между существующие подключения <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> метод будет вызван, чтобы закрыть один из конфликтующих подключений, а также в данном экземпляре <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> событий не может быть отменено, так как конфликт, должны быть устранены.  
  
 Другой случай возникает тогда, когда <xref:System.Web.UI.WebControls.WebParts.WebPart> или серверный элемент управления, подключенных в данный момент закрыт или удален. В этом случае из-за управления удаляется со страницы его подключения должен завершаться, поэтому проектирования, невозможно отменить <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> событий для прерывания процесса разрыв соединения. Дополнительные сведения см. в описании события <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>. С помощью пользовательских <xref:System.Web.UI.WebControls.WebParts.WebPart> элементы управления, веб-странице можно создать подключение между элементами управления путем нажатия кнопки, в то время как другая кнопка позволяет отключать элементы управления. После закрытия элемента управления, пока страница находится в режиме обзора и подключенных элементах управления, переопределение <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> метод отключает закрытый элемент управления, Завершение подключения и отображает сообщение.  
  
 В примере кода состоит из четырех частей:  
  
-   Пользовательский элемент управления для изменения режима отображения.  
  
-   Исходный файл, содержащий пользовательский <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления.  
  
-   Веб-страница для размещения элементов управления.  
  
-   Пояснения к работе примера в браузере.  
  
 Первая часть примера кода — это пользовательский элемент управления для изменения режима отображения. Исходный код для пользовательского элемента управления можно получить из примера <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе. Дополнительные сведения о режимах отображения и принципах работы пользовательского элемента управления см. в разделе [Пошаговое руководство: изменение режима отображения страницы](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Вторая часть — файл, содержащий исходный код для двух пользовательских <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, которые будут подключены, а пользовательский <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления. Для выполнения примера кода необходимо скомпилировать этот исходный код. Можно выполнить явную компиляцию и поместить результирующую сборку в папку Bin веб-сайта или в глобальном кэше сборок. Кроме того можно поместить исходный код в папку App_Code веб-узла, где он будет динамически компилироваться во время выполнения. В этом примере используется динамическая компиляция, поэтому `Register` директиву, которая ссылается на эти компоненты в веб-страницы, объявляется соответствующим образом в верхней части веб-страницы. Пошаговое руководство возможностям компиляции см. в разделе [Пошаговое руководство: разработка и с помощью элемента управления пользовательского](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 В исходном коде Обратите внимание, наследуемый элемент управления `MyWebPartManager` , переопределяющий <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> метод. Этот метод проверяет каждое подключение в страницу, чтобы проверить, выполняется ли элемент управления закрывается участвует в соединении, если да, вызывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> метод для завершения подключения. Этот подход аналогичен базовую реализацию метода в <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления. Затем переопределенный метод настраивает базовую реализацию, записав сообщение на страницу.  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 Третья часть примера кода — веб-страница. Обратите внимание, что в верхней его `Register` директивы для регистрации пользовательского элемента управления, а также динамически скомпилированная сборка с <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления. На странице имеются два основных способа. `Button1_Click` Метод создает подключение между элементами управления, пока `Button2_Click` метод отключает элементы управления.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 После загрузки страницы нажмите кнопку **Connect** кнопку для подключения элементов управления. Затем щелкните меню команд в одном из элементов управления (стрелка вниз в заголовке элемента управления) и выберите **закрыть** меню команд. При попытке закрытия элемента управления вызывается переопределенный метод, подключение завершается и сообщение записывается на страницу. Если вы хотите сбросить страницу для восстановления закрытого элемента управления и поэкспериментировать с другими параметрами, нажмите кнопку **сбросить состояние пользователя** ссылку, чтобы удалить данные персонализации и восстановление исходного состояния страницы.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />, предоставляющее подключение между серверными элементами управления.</param>
        <summary>Выполняет отключение серверных элементов управления, которые подключены на веб-странице.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> Метод выполняет полный разрыв соединения между <xref:System.Web.UI.WebControls.WebParts.WebPart> или серверных элементов управления, при его передаче `connection` параметра.  
  
 Этот метод используется для отключения элементов управления при размещении `<asp:connectionszone>` элемент на веб-странице, чтобы предоставить пользовательский интерфейс (UI) для управления подключениями. Когда страница находится в режиме отображения подключения (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>) и текущее соединение, нажав кнопку, которая вызывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> метод для завершения подключения.  
  
 Можно также вызвать <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> метод непосредственно из кода, если вы хотите отключить элементы управления программным путем и без добавления `<asp:connectionszone>` элемента на страницу.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>. С помощью пользовательских <xref:System.Web.UI.WebControls.WebParts.WebPart> элементы управления, веб-странице можно создать подключение между элементами управления путем нажатия кнопки, в то время как другая кнопка позволяет отключать элементы управления.  
  
 В примере кода состоит из четырех частей:  
  
-   Пользовательский элемент управления для изменения режима отображения.  
  
-   Исходный файл, содержащий пользовательский <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления.  
  
-   Веб-страница для размещения элементов управления.  
  
-   Пояснения к работе примера в браузере.  
  
 Первая часть примера кода — это пользовательский элемент управления для изменения режима отображения. Исходный код для пользовательского элемента управления можно получить из примера <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе. Дополнительные сведения о режимах отображения и принципах работы пользовательского элемента управления см. в разделе [Пошаговое руководство: изменение режима отображения страницы](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Вторая часть — файл, содержащий исходный код для двух пользовательских <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, которые будут подключены. Для выполнения примера кода необходимо скомпилировать этот исходный код. Можно выполнить явную компиляцию и поместить результирующую сборку в папку Bin веб-сайта или в глобальном кэше сборок. Кроме того можно поместить исходный код в папку App_Code веб-узла, где он будет динамически компилироваться во время выполнения. В этом примере используется динамическая компиляция, поэтому `Register` директиву, которая ссылается на эти компоненты в веб-страницы, объявляется соответствующим образом в верхней части веб-страницы. Пошаговое руководство возможностям компиляции см. в разделе [Пошаговое руководство: разработка и с помощью элемента управления пользовательского](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 Третья часть примера кода — веб-страница. Обратите внимание, что в верхней его `Register` директивы для регистрации пользовательского элемента управления и динамически компилируемую сборку с <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления. На странице имеются два основных способа. `Button1_Click` Метод создает подключение между элементами управления и `Button2_Click` метод отключает элементы управления.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 После загрузки страницы, можно щелкнуть **Connect** кнопку для подключения элементов управления. Введите текст в элементе текстового поля и нажмите кнопку **ввод** кнопки, текст будет отображаться в подключенном элементе управления (он не будет отображен, если элементы управления были отключены). Если щелкнуть **Disconnect** кнопки, элементы управления будут отключены. Можно проверить состояние подключения элементов управления с помощью **режим отображения** управления раскрывающегося списка, чтобы переключить страницу в **Connect** режим. После этого щелкните меню команд (представленное стрелка) в заголовке окна одного из элементов управления и выберите **Connect** элемента. Отображается пользовательский Интерфейс подключения; она доступна, так как отсутствует `<asp:connectionszone>` элемент объявлен на странице. Кроме того, могут подключаться и отключаться элементы управления из этого интерфейса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="connection" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" /> не содержится в <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> или <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          Свойство <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> доступно только для чтения.  
  
 \- или -  
  
 <paramref name="connection" /> уже было отключено от <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />.  
  
 \- или -  
  
 Свойство <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> доступно только для чтения.  
  
 \- или -  
  
 <paramref name="connection" /> уже было отключено от <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />.</exception>
        <block subset="none" type="overrides">
          <para>Можно переопределить <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" /> метод, если вы хотите изменить реализацию по умолчанию для отключения <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> элементов управления. Если вы хотите просто добавить реализацию существующего метода Переопределите метод, можно вызвать базовый метод до выполнения собственного кода.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает активный режим отображения для веб-страницы, на которой содержатся элементы управления веб-частей.</summary>
        <value>Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />, который определяет режим отображения страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 На странице, содержащей элементы управления веб-частей всегда находится в одном из нескольких возможных режимов отображения. Дополнительные сведения о режимах отображения см. в разделе [режимах отображения страницы Web частей](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4).  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Класс создает режимов отображения для веб-страницы. С помощью базового <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> класса, <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемент управления создает несколько объектов стандартный режим, которые можно использовать на страницах, содержащих элементы управления веб-частей. Эти режимы отображения Стандартная описаны в <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> Общие сведения о классе.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Управления также управляет режимов отображения для страниц, использующих элементы управления веб-частей. С помощью <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> свойства <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления хранит ссылки на текущий режим отображения на странице. Можно также использовать <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> свойства, чтобы переключить страницу в различных режимах. Пример изменения режимов отображения на странице, которая использует элементы управления веб-частей см. в разделе [Пошаговое руководство: изменение режима отображения страницы](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 В процессе управления режим отображения <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления также предоставляет события и обработчики событий, относящихся к режимы отображения, такие как <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> метод и <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> метод. Эти методы предоставляют механизм для настройки поведения страницы и даже для добавления пользовательского режима отображения.  
  
   
  
## Examples  
 В следующем примере кода показано программное использование <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> свойство. После загрузки страницы в браузере, можно использовать для переключения между режимами отображения кнопок в нижней части страницы. Страница находится в режиме просмотра по умолчанию во время загрузки. При переключении в режим конструктора перетащите серверных элементов управления в одном часовом поясе, или переместить два элемента управления в одной зоне. При переключении в режим редактирования, можно щелкнуть меню команд в заголовке серверные элементы управления, выберите **изменить**и элемент управления, с помощью предоставленного редактирования пользовательского интерфейса (UI).  
  
> [!NOTE]
>  Переключение между режимами отображения в приложении веб-частей является очень распространенным и может потребоваться для обеспечения согласованной, многократно используемых способ сделать это на всех страницах, содержащих элементы управления веб-частей. Пример пользовательского элемента управления, изменения режимы отображения и который можно повторно использовать на многих страницах, см. в разделе [Пошаговое руководство: изменение режима отображения страницы](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />, который назначается для этого свойства, равен <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />, назначаемый для этого свойства, не является одним из поддерживаемых режимов отображения.  
  
 \- или -  
  
 Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />, который назначается для этого свойства, отключен.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после изменения текущего режима отображения на странице веб-частей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Режимы отображения являются неотъемлемой частью приложений веб-частей. Когда пользователи переходят в другой режим отображения веб-страницы, страница может выглядеть сильно отличается внешний вид, в зависимости от назначения нового режима отображения. После изменения режима отображения, возможно требуется внести определенные изменения в пользовательском интерфейсе (UI), таких как скрытие или отображение определенных элементов, изменение внешнего вида выбранного элементы пользовательского интерфейса и так далее.  
  
> [!NOTE]
>  Дополнительные сведения о режимах отображения см. в разделе [режимах отображения страницы Web частей](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4). Дополнительные сведения о событиях см. в разделе [как: прием событий в приложениях Web Forms](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после щелчка пользователем команды на веб-странице, которая запускает процесс переключения в другой режим отображения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Режимы отображения являются неотъемлемой частью приложений веб-частей. Когда пользователи переходят в другой режим отображения веб-страницы, страница может выглядеть сильно отличается внешний вид, в зависимости от назначения нового режима отображения. После пользователь инициирует процесс изменения в новый режим отображения путем щелчка команды, может потребоваться внести определенные изменения в пользовательском интерфейсе (UI) с помощью <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A> свойства, чтобы определить, каким будет новый режим отображения и затем изменив различных пользовательского интерфейса элементы соответствующим образом. Для этого удобно для переопределения <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> метод для настройки пользовательского интерфейса.  
  
> [!NOTE]
>  Дополнительные сведения о режимах отображения см. в разделе [режимах отображения страницы Web частей](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4). Дополнительные сведения о событиях см. в разделе [как: прием событий в приложениях Web Forms](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает доступную только для чтения коллекцию всех режимов отображения, сопоставленных с элементом управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Коллекция <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />, которая содержит набор объектов <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />, сопоставленных с элементом управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> Ссылок на свойства, все связанные режимы отображения, в отличие от с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> свойства, которое ссылается режимы отображения доступных (поддерживается) на текущей странице.  
  
 Два из режимов отображения предоставленный, обзора и разработки, всегда поддерживается на странице. Другие режимы отображения три, редактирования, каталога и подключения, поддерживаются только в том случае, если на странице соответствующего типа зона, который необходим для определенного режима отображения для работы. Например, если вы не входят <xref:System.Web.UI.WebControls.WebParts.EditorZone> зоны, изменить режим отображения должен отображаться в коллекции, на который указывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> свойства, но не будет отображаться в коллекции, на который указывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано программное использование <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> свойство. Код использует это свойство для заполнения списка всех режимов отображения, доступных в наборе элементов управления веб-частей, даже те, которые не поддерживаются на текущей странице. В этом случае каталога и подключения отображения режимы не поддерживаются, так как соответствующие требуемые зоны не содержатся на странице.  
  
 Остальные три режима отображения, обзора, разработки и редактирование, поддерживаются на странице. Изменить режим поддерживается, поскольку страница содержит <xref:System.Web.UI.WebControls.WebParts.EditorZone> зон, во время просмотра и всегда поддерживаются режима разработки.  
  
 После загрузки страницы в браузере, можно использовать элемент управления раскрывающегося списка для переключения из режима просмотра страницы в режим конструктора, а затем в режим редактирования. В режиме редактирования, можно щелкнуть меню команд раскрывающегося списка в заголовке одного из серверных элементов управления и выберите **изменить** для редактирования элемента управления. Обратите внимание, что при выборе **каталога** или **Connect** в раскрывающемся списке, создается страница ошибки.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию всех динамических подключений, которые в настоящее время существуют на веб-странице.</summary>
        <value>Коллекция <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />, которая содержит ссылки на все динамические подключения на странице.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Динамические подключения — подключений, созданных программным образом, в отличие от статически. Статические подключения создаются путем их объявления в разметке страницы веб-форм. Динамические подключения формируются или программно, или посредством создания пользователем подключения с помощью пользовательского интерфейса (UI) подключения.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> Коллекции, то, что он доступен только для чтения и не может изменить ее содержимое, обеспечивает программный доступ к каждому объекту динамического подключения.  
  
> [!NOTE]
>  Для выполнения общих операций, таких как подключения или отключения <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, разработчикам следует использовать открытые методы на <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класса, такие как <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> и <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, вместо того чтобы напрямую изменить соединение объекты в <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> коллекции.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет режим отображения, в котором конечные пользователи смогут изменять серверные элементы управления. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> Ссылается настраиваемый <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> объекта, который создается и содержащиеся в <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления. Поскольку это статический объект, можно ссылаться на него напрямую с помощью <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класс без необходимости экземпляр элемента управления.  
  
 При первой загрузке определяет, страницу, которая содержит веб-частей, он находится в <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (режим просмотра) по умолчанию. Если требуется изменить или изменить серверного элемента управления, они сначала переключения страницы в <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> (режим редактирования). Во-вторых они должны выбрать определенный серверный элемент управления посредством щелчка команды редактирования в меню команд в заголовке элемента управления. После элемент управления находится в режиме редактирования, редактирования пользовательский интерфейс (UI) появляется для редактирования выбранного элемента управления.  
  
 Чтобы включить режим редактирования на странице, страница должна содержать по крайней мере один <xref:System.Web.UI.WebControls.WebParts.EditorZone> зоны, который включает один или несколько указанных редактирования элементы управления, такие как <xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart> управления или пользовательские элементы управления для редактирования.  
  
   
  
## Examples  
 В следующем примере кода показано, как работать с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> поле программными средствами. Код заполнение раскрывающегося списка поддерживаемых режимах отображения страницы, которые в данном случае являются обзора, разработки и изменения. Чтобы обеспечить редактирование, `<asp:EditorZone>` элемент находятся на странице. Обратите внимание, что в `Page_PreRender` метод, этот код проверяет ли текущий <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> свойству <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>. В этом случае `Label1` будет отображаться Если нет, `Label1` будет скрыта.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 После загрузки страницы в браузере, вы находитесь в режиме просмотра по умолчанию. Обратите внимание, что метка на странице скрыта. Используйте элемент управления раскрывающегося списка для переключения страницы в режим редактирования. Обратите внимание, что из-за кода в `Page_PreRender` , метка теперь является видимым. Нажмите кнопку **изменить** команды в меню команд для одного из элементов управления, чтобы включить редактирование этого элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, которое определяет, включено ли создание скриптов на стороне клиента для веб-странице, на которой содержится элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Логическое значение, указывающее, можно ли выполнять на странице клиентские скрипты. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> Свойство позволяет разработчикам отключить клиентских скриптов. Вы можете отключить клиентских скриптов в целях безопасности или обеспечить аналогичные пользователем страницы в различных браузерах.  
  
 Можно отключить клиентских сценариев, добавив `EnableClientScript` атрибут <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента на веб-страницы, как декларативный код следующую строку:  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 Кроме того, разработчики могут исключить это свойство путем наследования от <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класс и установив значение по умолчанию равно `false`.  
  
 Набор элементов управления веб-частей использует клиентские скрипты для предоставления некоторых клиентских возможностей персонализации и пользовательского интерфейса (UI). При отключении клиента сценариев веб-части элементов управления по-прежнему работать, но некоторые функции будут отключены. Возможность перетаскивать элементы управления в другие зоны отключена вместе с возможностью отображать команды в меню команд раскрывающегося списка в заголовке окна элемента управления (вместо этого команды отображаются в заголовке окна элемента управления как ссылки).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, что использование тем на веб-странице включено.</summary>
        <value>Логическое значение, которое указывает, включены ли темы. Значение <see langword="true" /> во всех случаях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Управления переопределяет базовый <xref:System.Web.UI.Control.EnableTheming%2A> свойство, чтобы убедиться, что он всегда возвращает значение `true`. Это делается потому, что набор элементов управления требуется использование тем для отображения веб-частей, элементы управления, веб-частей, дочерние элементы управления <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления, которые образуют пользовательский интерфейс (UI) на веб-странице. Например, темы используются для визуализации различных зон и элементов управления, которые находятся в зонах, включая различные виды часть элементов управления (элементы управления, которые наследуют от <xref:System.Web.UI.WebControls.WebParts.Part> класса), пользовательские элементы управления, серверные элементы управления ASP.NET и пользовательского сервера элементы управления.  
  
 Несмотря на то что переопределенный <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A> свойство реализуется как свойство чтения/записи в соответствии с его базовым свойством, нельзя задать свойство, поскольку намеренно оно должно всегда возвращать значение `true`. При попытке задать свойство, <xref:System.NotSupportedException> исключения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Предпринята попытка присвоить значение свойству.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершает процесс подключения элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> к другому элементу управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> Метода завершения процесса подключения <xref:System.Web.UI.WebControls.WebParts.WebPart> управления на другой элемент управления. Он является аналогом <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> метод.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> Метод гарантирует, что объект персонализации ссылается <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> свойство является изменяемым, которой необходима, так как формирования подключения сам по себе является типом персонализации. Метод затем гарантирует, что <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> объект не `null`и наконец вызывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Элемент управления, на который ссылается свойство <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />, равен <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Разработчики, чтобы расширить <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> управления может потребоваться переопределить этот метод в производном классе. Один из подходов, можно вызвать базовый метод, а затем добавьте некоторой пользовательской обработки, или может потребоваться полностью настроить весь процесс завершения подключения между элементами управления.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершает редактирование элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> Метод завершает процесс редактирования <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления. Он является аналогом <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> метод.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> Метод гарантирует, что объект персонализации ссылается <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> свойство является изменяемым, которой необходима, так как изменение элемента управления — процесс, который требует изменения персонализации. Метод затем гарантирует, что <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> объект не `null`таким образом, выбранного в данный момент <xref:System.Web.UI.WebControls.WebParts.WebPart> управления можно изменить, и наконец он вызывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Элемент управления, на который ссылается свойство <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />, равен <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Разработчики, чтобы расширить <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> управления может потребоваться переопределить этот метод в производном классе. Один из подходов, можно вызвать базовый метод, а затем добавьте некоторой пользовательской обработки, или может потребоваться полностью настроить весь процесс завершения редактирования элемента управления. Например в методе переопределения может сначала вызвать базовый метод и затем добавить некоторый код, который определяет, какие изменения были внесены и отображает список изменений обратно конечному пользователю как подтверждение.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает текст предупреждения, которое отображается при попытке пользователем экспортировать конфиденциальные данные состояния из элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <value>Строка, содержащая предупреждение. Сообщением по умолчанию является соответствующее конкретному языку значение, которое предоставляется платформой .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда пользователь пытается экспортировать конфиденциальные данные состояния из <xref:System.Web.UI.WebControls.WebParts.WebPart> управления, если любой из экспортируемых данных поступают из члена, который был отмечен как конфиденциальные, в исходном коде, предупреждающее сообщение отображается для пользователя в окне сообщения, уведомляющее о том, выполняется экспорт конфиденциальных данных и предоставляет пользователям возможность отменить экспорт. Разработчики могут пометить конкретный элемент данных как конфиденциальные, задав `isSensitive` параметр `[Personalizable]` атрибут `true` в элементе. Дополнительные сведения об этом атрибуте и параметре см. в разделе <xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute> класса.  
  
> [!IMPORTANT]
>  При использовании функцию экспорта веб-частей, конфиденциальные данные потенциально могут быть экспортированы неавторизованных пользователей. Дополнительные сведения о способах защиты от этой угрозы см. в разделе [Защита страниц веб-частей](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 Каждый раз, когда пользователи пытаются экспортировать, отображается сообщение по умолчанию. Тем не менее, путем присвоения значения <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> можно предоставить пользовательское сообщение предупреждения.  
  
   
  
## Examples  
 В следующем примере кода показано использование декларативного <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> свойство.  
  
 Код для следующей веб-странице использует стандартное <xref:System.Web.UI.WebControls.BulletedList> управления и помещает его в зоне. Элемент управления будет заключена в <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> управления во время выполнения, что позволяет ему в качестве подлинный <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления. Чтобы сделать элемент управления может быть экспортирован, `ExportMode` добавляется атрибут `<asp:bulletedlist>` элемент, значение атрибута имеет значение <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>, означающее, конфиденциальные и неконфиденциальные данные можно экспортировать. Обратите внимание, что в `<asp:webpartmanager>` элемент, `ExportSensitiveDataWarning` атрибут получает пользовательское значение.  
  
 Обратите внимание, что для работы этого примера кода, имеется параметр, который необходимо добавить в файл Web.config, чтобы разрешить экспорт файлов описания веб-части. Убедитесь, что файл Web.config в том же каталоге, как веб-страницу для этого примера кода. В пределах `<system.web>` статьи, убедитесь, что `<webParts>` элемент с `enableExport` атрибут `true`, как показано в следующей разметкой.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 После загрузки страницы в браузере, щелкните меню команд (представленное стрелка вниз) в заголовке окна элемента управления, содержащий ссылки. Выберите в меню команд **Экспорт**, обратите внимание, что появляется окно сообщения с предупреждением пользовательских. Если вы хотите продолжить выполнение экспорта, щелкните **ОК**, который позволит вам сохранить локальную копию описание XML-файла с данными об элементе управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">Элемент управления, из которого будут экспортированы данные.</param>
        <param name="writer">Средство записи <see cref="T:System.Xml.XmlWriter" />, которое записывает экспортированные из <c>webPart</c> данные в XML-файл описания.</param>
        <summary>Создает XML-файл описания, который содержит состояние и данные свойства для серверного элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> Метод собирает различные данные состояния и свойств из `webPart` в XML-файл. Данные содержат сведения об элементе управления, включая его сборку, данные о состоянии и данные свойства. Пользователь, запускающий экспорта можно сохранить XML-файл на диск на локальном компьютере или в сети. Другие пользователи затем импортировать файл описания другой страницы или веб-сайт и применить данные состояния и свойств другой экземпляр `webPart`. Это обеспечивает быстрый и удобный механизм для пользователей, для совместного использования и повторного использования параметров для серверных элементов управления, а также дает разработчикам возможность управлять внешнего вида и поведения экспортированных и импортированных элементов управления.  
  
 Свойства `webPart` не экспортируются по умолчанию. Чтобы разрешить экспорт свойства, необходимо отметить его с `[Personalizable]` атрибут в исходном коде. Можно также дополнительно пометить экспортируемое свойство как содержащие конфиденциальные данные, задав `isSensitive` параметр `[Personalizable]` атрибут `true`. По умолчанию `isSensitive` — `false`. Разработчики могут задавать параметр `true` означает конфиденциальные данные.  
  
 Для включения `webPart` для экспорта, разработчик устанавливает его <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> значение свойства, либо <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All> (включает все свойства настраиваемых и конфиденциальные), или <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>, который экспортирует все, за исключением конфиденциальных свойств .  
  
> [!IMPORTANT]
>  Разрешение пользователям экспортировать данные из элементов управления, а также для импорта данных в другие элементы управления, включает некоторые риски безопасности. Разработчикам следует использовать подход, описанный выше, для защиты конфиденциальных данных, а также если необходимо избежать риска предоставления всех данных, их не следует включать экспорта на `webPart` вообще. Дополнительные сведения о вопросах безопасности веб-частей см. в разделе [Защита страниц веб-частей](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="webPart" /> имеет значение <see langword="null" />.  
  
 \- или -  
  
 Свойство <paramref name="writer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> не содержится в коллекции элементов управления, на которую ссылается свойство <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
 \- или -  
  
 Значение свойства <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />, принадлежащее <paramref name="webPart" />, задано равным <see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" />, что означает отключение экспорта для <paramref name="webPart" />.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Переопределен для предотвращения перевода фокуса на элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, так как для последнего отсутствует пользовательский интерфейс.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A> Метод переопределяет базовый <xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType> метода и вызывает исключение, если вызывающий объект вызывает метод. Поскольку <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления без пользовательского интерфейса и никогда не отображается для пользователей, она никогда не позволяет сама по себе установлен фокус.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вызывающий объект пытается вызвать метод <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />, который не поддерживается в элементе управления, не имеющем пользовательского интерфейса.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Серверный элемент управления, который выполняет роль получателя в подключении.</param>
        <summary>Получает коллекцию объектов <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />, которые могут функционировать в качестве точек подключения серверного элемента управления, выполняющего роль получателя в подключении веб-частей.</summary>
        <returns>Коллекция <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" />, которая содержит все точки подключения в получателе.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подключение веб-частей всегда происходит между двумя элементами управления, один из которых является поставщиком данных, других действующего в качестве объекта-получателя данных. Каждый элемент управления должен иметь один или несколько методов, которые определены как точки подключения. В случае с элементом управления получателя свои точки подключения, <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> объектов. Получение точек подключения получателя является необходимым этапом при создании подключения веб-частей.  
  
 Потребитель всегда должен иметь хотя бы одно подключение точку, чтобы иметь возможность установить соединение. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> Метод проверяет управления получателя и возвращает коллекцию свои точки подключения. Если <xref:System.Web.UI.WebControls.WebParts.WebPart> управления имеет без точек подключения, то метод возвращает пустую коллекцию.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>.  
  
 В примере кода состоит из четырех частей:  
  
-   Пользовательский элемент управления, позволяющий изменять режимы отображения на веб-странице.  
  
-   Веб-страницы, который содержит две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, которые могут быть подключены, и `<asp:webpartmanager>` элемента.  
  
-   Файл исходного кода, который содержит две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления и пользовательского интерфейса.  
  
-   Пояснения к работе примера в браузере.  
  
 Первая часть примера кода — это пользовательский элемент управления для изменения режима отображения. Исходный код для пользовательского элемента управления можно получить из примера <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе. Дополнительные сведения о режимах отображения и принципах работы пользовательского элемента управления, см. в разделе [Пошаговое руководство: изменение режима отображения страницы](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Декларативная разметка для веб-страницы содержит `Register` директивы для пользовательского элемента управления и пользовательские элементы управления. Отсутствует `<asp:webpartmanager>` элемент, `<asp:webpartzone>` элемент содержит пользовательские элементы управления и `<asp:connectionszone>` элемента. Обратите внимание, что в `Page_Load` метода, код проверяет, является ли соединение уже существует и, если это не так, определяет поставщик, объект-получатель и соответствующие точки подключения, а затем добавляет новое соединение в набор статических подключений, на которые имеются ссылки <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> свойство. Обратите внимание, что <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection> объект, который извлекается с помощью <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> передается в метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> метод, чтобы определить, могут ли быть созданы подключения между двумя элементами управления.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 Третья часть примера приведен исходный код для элементов управления. Можно получить этот код и инструкции по компиляции, в разделе примеров <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе.  
  
 После загрузки веб-страницы в браузере, щелкните **режим отображения** управления раскрывающегося списка и выберите **Connect** для переключения страницы в режим подключения. Подключение использует режим `<asp:connectionszone>` элемент, чтобы можно было создавать подключения между элементами управления. В режиме подключения, щелкните стрелку вниз в строке заголовка **ПОЧТОВЫЙ индекс** управления активировать соответствующее меню команд и нажмите кнопку **Connect**. После появления подключения пользовательский интерфейс (UI), обратите внимание, что соединение уже был создан с кода, содержащегося в `Page_Load` метод. Если вернуться на эту страницу в следующем сеансе браузера, это статическое подключение уже будет установлено и не должны быть повторно при каждой загрузке страницы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="webPart" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">Веб-страница, содержащая экземпляр <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</param>
        <summary>Получает ссылку на текущий экземпляр элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> на странице.</summary>
        <returns>Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, который ссылается на текущий экземпляр элемента управления на странице.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> Метод полезен в контекстах, в которой вы хотите получить ссылку на текущий <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления. Является распространенным сценарием, где это может произойти при создании пользовательского элемента управления, не знает, какой идентификатор во время разработки <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления на странице.  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> Метод является статическим, поэтому его можно вызвать напрямую, без необходимости экземпляр <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления.  
  
 Некоторые элементы управления веб-частей управления набором, такие как <xref:System.Web.UI.WebControls.WebParts.WebPart> элементы управления, имеют <xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A> свойство, которое можно получить ссылку на текущий <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления. Таким образом при работе с такими элементами управления, следует использовать это свойство для извлечения ссылки.  
  
 Если вы программируете в контексте, где вы знаете идентификатор <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления, например написание встроенный код на веб-странице, он является простейшим и наиболее эффективным способом ссылаться непосредственно на <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления с помощью его идентификатора.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>. Пример состоит из двух частей: пользовательского серверного элемента управления и веб-страницы, на котором размещается элемент управления.  
  
 Пользовательский <xref:System.Web.UI.WebControls.Label> управления использует <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> метод для получения идентификатора <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления на текущей странице, а затем отображает идентификатор.  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 В следующем примере кода предоставляет веб-страницы, на котором размещается элемент управления в <xref:System.Web.UI.WebControls.WebParts.WebPartZone> зоны.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 После загрузки страницы в браузере, обратите внимание, что идентификатор текущего <xref:System.Web.UI.WebControls.WebParts.WebPartManager> отображается элемент управления в пределах пользовательского <xref:System.Web.UI.WebControls.Label> элемента управления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="page" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Элемент управления, для которого этот метод возвращает значение свойства <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />.</param>
        <summary>Возвращает строку, содержащую значение для свойства <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <returns>Строка, которая содержит вычисленное значение свойства <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> для параметра <paramref name="webPart" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращает вычисленное значение <xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A> свойство `webPart`. Когда разработчики не присвоить значение <xref:System.Web.UI.WebControls.WebParts.Part.Title%2A> свойства <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления, этот метод создает значение для отображения в качестве заголовка. Вычисленное значение для элементов управления без названия состоит из нескольких дополненная в строку, число, определяющее порядок элемента управления в текущей зоны.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="webPart" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Элемент <paramref name="webPart" /> отсутствует в коллекции <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.</exception>
        <block subset="none" type="overrides">
          <para>Чтобы изменить способ вычисления отображения заголовка по умолчанию можно переопределить этот метод.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Экспортируемый объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</param>
        <summary>Возвращает относительный виртуальный путь и строку запроса, которые являются частью запроса, если пользователь пытается экспортировать элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <returns>Строка, которая содержит относительный виртуальный путь и строку запроса, которые вмести формируют запрос на экспорт элемента управления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> метод относительный виртуальный путь к расположению сервера страницы, содержащей элемент управления, а также добавленный запрос строковое значение, которое формирует запрос на экспорт отправки на сервер. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> Метод кодирует строку, прежде чем разрешить запрос для отправки, чтобы защититься от атак вредоносного сценария.  
  
> [!NOTE]
>  Дополнительные сведения о безопасности приложений веб-частей см. в разделе [Защита страниц веб-частей](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, который существует в <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> и помещен в оболочку в качестве дочернего элемента управления для объекта <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> во время выполнения.</param>
        <summary>Возвращает ссылку на экземпляр элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />, содержащий серверный элемент управления.</summary>
        <returns>Объект <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />,который служит оболочкой для параметра <paramref name="control" /> в качестве дочернего элемента управления. Этот метод возвращает значение <see langword="null" />, если параметр <paramref name="control" /> не содержится в объекте <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило, существует две категории элементов управления, которые разработчики поместить в <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зоны для участия в приложениях веб-частей: <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, которые наследуют от <xref:System.Web.UI.WebControls.WebParts.WebPart> базовый класс и другие серверные элементы управления, которые могут быть standard Элементы управления ASP.NET, пользовательские элементы управления и пользовательские элементы управления. При помещении любой из этих элементов управления в <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зоны, он получает функциональные возможности <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления. Объект <xref:System.Web.UI.WebControls.WebParts.WebPart> элемент управления имеет эта функция по своей природе, а другие виды серверные элементы управления — нет. Чтобы включить другие серверные элементы управления в качестве <xref:System.Web.UI.WebControls.WebParts.WebPart> управляет при помещении в <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зоны, ASP.NET создает оболочку для их с <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> элемента управления. Поскольку <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> управления наследует непосредственно от <xref:System.Web.UI.WebControls.WebParts.WebPart> класса, он предоставляет его дочерних элементов управления значение true, функции веб-частей.  
  
 Часто во время выполнения, разработчики страниц может потребоваться получить ссылку на <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> элемент управления, который содержит один из серверных элементов управления в зоне. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> Метод позволяет получить ссылку на <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> элемента управления.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> метода. Пример кода содержит <xref:System.Web.UI.WebControls.Calendar> управления объявленная внутри <xref:System.Web.UI.WebControls.WebParts.WebPartZone> зоны. `Button1_Click` Метод сначала выводится идентификатор <xref:System.Web.UI.WebControls.Calendar> управления метки, а затем использует <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> метод, чтобы получить ссылку на <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> элемента управления, которая служит оболочкой для календаря. Идентификатор <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> управления и идентификатор его дочернего элемента управления (который является <xref:System.Web.UI.WebControls.Calendar> управления), выводятся на второй метки.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="control" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Серверный элемент управления, который выполняет роль поставщика в подключении.</param>
        <summary>Получает коллекцию объектов <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />, которые могут функционировать в качестве точек подключения серверного элемента управления, выполняющего роль поставщика в подключении веб-частей.</summary>
        <returns>Коллекция <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" />, которая содержит все точки подключения в поставщике.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подключение веб-частей всегда происходит между двумя элементами управления, один из которых является поставщиком данных, других действующего в качестве объекта-получателя данных. Каждый элемент управления должен иметь один или несколько методов, которые определены как точки подключения. В случае с элементом управления поставщика свои точки подключения, <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> объектов.  
  
 Поставщик всегда должен иметь по крайней мере одну точку подключения для установления соединения. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> Метод проверяет управления поставщика и возвращает коллекцию свои точки подключения. Получение точек подключения поставщика является необходимым этапом при создании подключения веб-частей.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>.  
  
 Пример состоит из четырех частей.  
  
-   Пользовательский элемент управления, позволяющий изменять режимы отображения на веб-странице.  
  
-   Веб-страницы, который содержит две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, которые могут быть подключены, и `<asp:webpartmanager>` элемента.  
  
-   Файл исходного кода, который содержит две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления и пользовательского интерфейса.  
  
-   Пояснения к работе примера в браузере.  
  
 Первая часть примера кода — это пользовательский элемент управления для изменения режима отображения. Исходный код для пользовательского элемента управления можно получить из примера <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе. Дополнительные сведения о режимах отображения и принципах работы пользовательского элемента управления см. в разделе [Пошаговое руководство: изменение режима отображения страницы](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Декларативная разметка для веб-страницы содержит `Register` директивы для пользовательского элемента управления и пользовательские элементы управления. Отсутствует `<asp:webpartmanager>` элемент, `<asp:webpartzone>` элемент содержит пользовательские элементы управления и `<asp:connectionszone>` элемента. Обратите внимание, что в `Page_Load` метода, код проверяет, является ли соединение уже существует и, если это не так, определяет поставщик, объект-получатель и соответствующие точки подключения, а затем добавляет новое соединение в набор статических подключений, на которые имеются ссылки <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> свойство. Обратите внимание, что <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection> объект, который извлекается с помощью <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> передается в метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> метод, чтобы определить, могут ли быть созданы подключения между двумя элементами управления.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 Третья часть примера приведен исходный код для элементов управления. Можно получить этот код и инструкции по компиляции, в разделе примеров <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе.  
  
 После загрузки веб-страницы в браузере, щелкните **режим отображения** управления раскрывающегося списка и выберите **Connect** для переключения страницы в режим подключения. Подключение использует режим `<asp:connectionszone>` элемент, чтобы можно было создавать подключения между элементами управления. В режиме подключения, щелкните стрелку вниз в строке заголовка **ПОЧТОВЫЙ индекс** управления активировать соответствующее меню команд и нажмите кнопку **Connect**. После появления подключения пользовательский интерфейс (UI), обратите внимание, что соединение уже был создан с кода, содержащегося в `Page_Load` метод. Если вернуться на эту страницу в следующем сеансе браузера, это статическое подключение уже будет установлено и не должны быть повторно при каждой загрузке страницы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="webPart" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения <see cref="T:System.Xml.XmlReader" />, которое считывает данные состояния и свойств из импортируемого XML-файла описания.</param>
        <param name="errorMessage">Строка <see cref="T:System.String" />, которая отображается для пользователей, если во время импорта возникает ошибка.</param>
        <summary>Импортирует XML-файл описания, который содержит данные состояния и свойств для элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> и применяет эти данные к элементу управления.</summary>
        <returns>Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (или серверный элемент управления, оболочкой для которого является <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />, и поэтому он воспринимается как <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />), на который имеется ссылка в импортированном XML-файле описания.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> Метод импортирует файл описания XML, которая была создана с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> метода для серверного элемента управления. Это не фактический серверный элемент управления, который импортируется, но файл описания, содержащий данные состояния и свойств элемента управления. Элемент управления и сборку, указанную в файле описания уже должны быть доступны на сервере, когда пользователь пытается импортировать файл описания.  
  
 Чтобы включить импорт элемента управления, разработчик должен добавить <xref:System.Web.UI.WebControls.WebParts.CatalogZone> управления на странице, где будет включаться импорта. В этой зоне <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> необходимо добавить элемент управления. Этот элемент управления предоставляет диалоговое окно файла, который позволяет пользователям просматривать и найдите импортируемый файл описания.  
  
 Пользователь начинает импорта файла описания, считывается файл описания <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> метод. Если ошибок нет, и при обнаружении сборки и элемента управления серверный элемент управления добавляется в каталог в <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> управления и различные данные свойств и состояния, указанные в файле описания применяются к элементу управления. Пользователь может затем выберите элемент управления и добавить его на страницу.  
  
> [!IMPORTANT]
>  Как <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> метода <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> метод имеет некоторые потенциальные угрозы безопасности. Так как он содержит, импорт данных в веб-сайта, пользователь-злоумышленник может попытаться вставить данные или даже код скрипта в файле description, который импортируется. Затем недопустимые данные отображаются на странице или в базе данных или вставленный скрипт. Обзор возможных рисков, связанных с импортом файлов описания и способов устранения этих рисков см. в разделе [Защита страниц веб-частей](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="reader" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.EndOfStreamException">
          <paramref name="reader" /> не может прочитать файл.  
  
 \- или -  
  
 <paramref name="reader" /> должен был отобразить сообщение об ошибке импорта, однако не нашел такого сообщения в файле.  
  
 \- или -  
  
 <paramref name="reader" /> достиг конца файла и не нашел XML-элемент, содержащий экспортированные данные.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ссылку на класс <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />, который используется для объединения и отделения набора методов, которые фактически реализованы в классе <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, но предназначены преимущественно для разработчиков элементов управления.</summary>
        <value>Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />, через который объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> может ссылаться на различные методы, которые были отдельно вынесены в <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> Свойство предоставляет API для вызова в набор <xref:System.Web.UI.WebControls.WebParts.WebPartManager> методы, используемые в основном в случаях расширяемости.  
  
 Является спроектированный способ использования этих внутренние методы для доступа к ним через <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> свойство. Так как свойство защищен, могут только доступ к нему и вызывать методы в рамках экземпляра <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> класса путем наследования от <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класса.  
  
> [!NOTE]
>  Это свойство скрыто из IntelliSense в [!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]. Однако в производном <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класса, по-прежнему доступны свойства и его различных элементов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, можно ли добавить на страницу объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или другой серверный элемент управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Часть гибкие средства для веб-частей — возможность добавления серверных элементов управления на веб-страницы во время выполнения. Существует несколько распространенных сценариев, в которых к серверному элементу управления (который может быть пользовательский <xref:System.Web.UI.WebControls.WebParts.WebPart> управления, серверного элемента управления, пользовательский элемент управления или элемент управления ASP.NET) могут быть добавлены.  
  
 В следующих распространенных сценариев веб-частей контролировать набор попытки добавления серверных элементов управления на страницу и <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> метод вызывается для авторизации их:  
  
-   При добавлении серверного элемента управления, объявив его в разметке веб-страницы в пределах <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зоны.  
  
-   Когда серверный элемент управления добавляется программными средствами в зону.  
  
-   Если пользователь импортирует серверного элемента управления в каталога элементов управления веб-частей.  
  
-   Если в имеющемся серверный элемент управления загружается из хранилища данных персонализации.  
  
-   При добавлении серверного элемента управления <xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart> управления, чтобы сделать его доступным в каталоге серверных элементов управления.  
  
 В каждом сценарии, где добавляются элементы управления <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> метод вызывается для обеспечения, чтобы добавить элемент управления выполнены все условия авторизации. Если элемент управления авторизован, он добавляется обычным способом, как было бы при отсутствии сценария фильтрации. Если элемент управления не авторизован, набор элементов управления веб-частей может ответить несколькими способами, в зависимости от контекста. Набор элементов управления можно автоматически произошел сбой при добавлении неавторизованной части (если нет необходимости для информирования пользователей), он может отображать сообщение об ошибке или его можно добавить экземпляр <xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart> класса в качестве заполнителя. Этот объект-местозаполнитель не отображается на странице, но виден в исходном коде страницы, чтобы указать, что неавторизованного элемента управления был исключен.  
  
 Определитель авторизован ли элемент управления — это фильтр авторизации. Фильтр авторизации — это функция в наборе элементов управления веб-частей, которая позволяет разработчикам исключать из страницы любые элементы управления, которые не соответствуют указанным критериям.  
  
 Чтобы создать сценарий фильтрации, разработчики должны выполнить два действия. Во-первых, необходимо назначить строковое значение (значение может быть произвольной) <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> каждого экземпляра <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления, которые планируется использовать в сценарии. Они также присвоить значение этому свойству для других типов серверных элементов управления, которые не являются <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, поскольку если они помещаются в <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зон, такие элементы управления упаковываются с <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> элемента управления во время выполнения и этот элемент управления наследует <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> свойство.  
  
 Второй шаг, необходимые для создания сценария фильтрации является либо переопределения <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> метод, или, чтобы создать обработчик событий для <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> события. В этих методов, можно проверить разработчик <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> свойство, и если значение указывает, что элемент управления не удалось авторизовать, разработчик гарантирует, что <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> метод возвращает значение `false`.  
  
> [!NOTE]
>  Примеры кода и описание того, как настроить настраиваемые фильтрации сценария с помощью <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> метода, см. в разделах, для перегруженных версий метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или другой серверный элемент управления, для которого проверяется авторизация.</param>
        <summary>Выполняет начальные действия по определению, авторизован ли элемент управления для добавления на страницу.</summary>
        <returns>Логическое значение, указывающее, можно ли добавить на страницу параметр <paramref name="webPart" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> — Исходный метод вызывается элементом управления веб-частей, которые заданы для проверки авторизации для <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления. Он принимает `webPart` как параметр и начинает процесс, который определяет, будет ли элемент управления быть добавлен на страницу. Этот метод в коде непосредственно при необходимо определить, авторизован ли данный элемент управления.  
  
 Этот метод выполняет задачи начальной определения того, является ли элемент управления наследуется от <xref:System.Web.UI.WebControls.WebParts.WebPart> класса или является <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> управления, и если да, какой тип дочернего элемента управления, он содержит. Для выполнения задач авторизации, он вызывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> перегрузки метода.  
  
   
  
## Examples  
 В следующем примере кода показано, как вызвать <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> метода из кода, чтобы определить, разрешено ли элемент управления добавлен на страницу.  
  
 В примере кода состоит из трех частей:  
  
-   Настраиваемый <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления, который переопределяет <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> метод.  
  
-   Веб-страницы, которая создается фильтр для <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления.  
  
-   Объяснение того, как запустить пример кода.  
  
 Данный пример кода использует пользовательский <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления, который переопределяет <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> перегрузки метода для предоставления обычной обработки <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> свойство. Этот элемент управления проверяет значение свойства `admin` и, если значение присутствует, авторизует элемент управления. Если элемент управления имеет другое значение, это не авторизовано; элементы управления без значения свойства авторизованы, в том, что они не должны быть частью сценария фильтрации.  
  
 Для запуска этого примера кода необходимо скомпилировать этот исходный код. Можно выполнить явную компиляцию и поместить результирующую сборку в папку Bin веб-сайта или в глобальном кэше сборок. Кроме того можно поместить исходный код в папку App_Code веб-узла, где он будет динамически компилироваться во время выполнения. Данный пример кода использует метод динамической компиляции. Пошаговое руководство по компиляции см. в разделе [Пошаговое руководство: разработка и с помощью элемента управления пользовательского](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 Во второй части примера кода создается фильтр, который способен исключить элемент управления. Следующие веб-страница содержит три элемента управления сервера ASP.NET в `<asp:webpartzone>` элемент. Обратите внимание, что первый и второй элементы управления имеют свои <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> свойства заданы разные значения, а третий не назначает свойство. Это значение авторизации может быть проверено во время выполнения и управления можно добавить на страницу, если фильтр будет соответствовать критерию, заданных разработчиком. Обратите внимание, что в `Page_Load` метод, этот код вызывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> метод, чтобы определить, авторизован ли каждого элемента управления и если да, он устанавливает каждый элемент управления <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> свойство.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 Обратите внимание, что для работы примера кода необходимо добавить параметр в файле Web.config, чтобы разрешить экспорт файлов описания веб-части. Убедитесь, что файл Web.config в том же каталоге, как веб-страницу для этого примера кода. В пределах `<system.web>` статьи, убедитесь, что `<webParts>` элемент с `enableExport` атрибут `true`, как показано в следующей разметкой.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 После загрузки страницы в браузере, обратите внимание, что первый элемент управления отображается, так как он соответствует критерию в переопределенном методе. Второй элемент управления не добавляется на страницу, поскольку он исключен с помощью фильтра. Третий элемент управления также добавлен, так как он не имеет его <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> набор свойств. Обратите внимание, что если щелкнуть значок меню команд в заголовке окна любого элемента управления, они могут оба экспортировать, так как соответствующие <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> были присвоены значения свойства.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="webPart" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Этот метод вызывается напрямую из кода приложения. Если вы хотите получить больший программный контроль над процесс авторизации, можно переопределить <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" /> перегрузки метода.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> элемента управления, для которого проверяется авторизация.</param>
        <param name="path">Путь относительно приложения к файлу исходного кода для элемента управления, проходящего авторизацию, если он является пользовательским элементом управления.</param>
        <param name="authorizationFilter">Произвольное строковое значение, которое присваивается свойству <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> и используется для авторизации добавления элемента управления на страницу.</param>
        <param name="isShared">Показывает, является ли общим элемент управления, проходящий авторизацию, что означает, что он отображается для многих или для всех пользователей приложения, а его свойство <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> имеет значение <see langword="true" />.</param>
        <summary>Выполняет завершающие действия по определению, авторизован ли элемент управления для добавления на страницу.</summary>
        <returns>Логическое значение, указывающее, авторизован ли элемент управления для добавления на страницу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> Перегруженный метод выполняет окончательного действия для определения, разрешен ли элемент управления добавлен на страницу. Метод гарантирует, что `type` является допустимым типом, и что `path` имеет значение, только если проверяемых элемент управления пользовательского элемента управления. Затем он вызывает критически важные <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> метод, который вызывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> событий.  
  
   
  
## Examples  
 В следующем примере кода показано, как переопределить <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> метод, чтобы определить, разрешено ли элемент управления добавлен на страницу.  
  
 Первым шагом является создание фильтра, который способен исключить элемент управления. Следующие веб-страница содержит три элемента управления сервера ASP.NET в `<asp:webpartzone>` элемент. Обратите внимание, что первый и второй элементы управления имеют свои <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> свойства заданы разные значения, а третий не назначает свойство. Это значение авторизации может быть проверено во время выполнения и управления можно добавить на страницу, если фильтр будет соответствовать критерию, заданных разработчиком.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 Второй шаг — для переопределения <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> метода и создавать настраиваемые фильтры авторизации обработки. Обратите внимание, что код сначала проверяет, имеет ли свойство значение, так что любой элемент управления, который не назначает <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> свойство будет автоматически добавляться. Если элемент управления содержит фильтр, этот код возвращает `true` только в том случае, если значение фильтра равно `admin`. Этот пример демонстрирует простой механизм, который можно использовать для отображения определенных элементов управления для определенных пользователей, в зависимости от их роли. Хотя полный пример использования ролей выходит за рамки этого раздела, можно использовать ту же логику как переопределенный метод в этом примере кода, за исключением того, чтобы можно было проверить, выполняется ли текущий пользователь в роли, которые соответствуют значению фильтра авторизации , а затем добавьте элемент управления только для этого пользователя. Это позволит создавать страницы, где некоторые пользователи будут видеть все элементы управления, а другие пользователи будут видеть только выбранные элементы управления. Вот как может выглядеть логика проверки фильтра при использовании ролей:  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 Для выполнения примера кода необходимо скомпилировать этот исходный код. Можно выполнить явную компиляцию и поместить результирующую сборку в папку Bin веб-сайта или в глобальном кэше сборок. Кроме того можно поместить исходный код в папку App_Code веб-узла, где он будет динамически компилироваться во время выполнения. Данный пример кода использует метод динамической компиляции. Пошаговое руководство по компиляции см. в разделе [Пошаговое руководство: разработка и с помощью элемента управления пользовательского](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 После загрузки страницы в браузере, обратите внимание, что первый элемент управления отображается, так как он соответствует критерию в переопределенном методе. Второй элемент управления не добавляется на страницу, так как его значение фильтра исключено. Третий элемент управления добавляется, так как он не имеет его <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> набор свойств. Если изменить значение свойства на втором элементе управления совпадали с первого элемента управления, а затем снова запустите страницу, также добавляется второй элемент управления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="type" /> — это пользовательский элемент управления, а <paramref name="path" /> равен или <see langword="null" /> или пустой строке ("").  
  
 \- или -  
  
 <paramref name="type" /> не является пользовательским элементом управления, а <paramref name="path" /> содержит назначенное для него значение.</exception>
        <block subset="none" type="overrides">
          <para>Этот метод может быть переопределен путем наследования от <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> класса, если вы хотите предоставить дополнительную обработку проверки авторизации. Переопределите метод для возврата для некоторых значений может потребоваться <paramref name="authorizationFilter" /> параметра и на основе значения, возвращают логическое значение, определяющее, будет ли элемент управления быть добавлен на страницу.  
  
 Для разработчиков страниц, которым необходимо проверить наличие фильтров авторизации и предоставить пользовательскую обработку имеется возможность добавления этих функций в страницы ASPX или в файле кода, без необходимости наследования от классов. Можно объявить обработчик альтернативный событий на странице <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> метод <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> элемента управления. Дополнительные сведения и пример см. в разделе <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> метод.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, были ли сделаны изменения персонализации, затронувшие персонализацию на уровне страницы, управляемой элементом управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Логическое значение, указывающее, были ли внесены изменения персонализации. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Управления использует <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> измененное свойство, чтобы отслеживать ли какие-либо данные персонализации на уровне страницы, который им управляет. Данные персонализации изменяются, если пользователи выполняют определенные действия персонализации на уровне страницы, такие как добавление или удаление <xref:System.Web.UI.WebControls.WebParts.WebPart> элементы управления, подключение или отключение элементов управления, изменение макета страницы путем перемещения элементов управления и других действий.  
  
> [!NOTE]
>  Пользователи также могут выполнять персонализацию на уровне управления, это означает, что внесение изменений персонализации для определенного элемента управления, и эти изменения влияют на этот элемент управления. Пример следует изменять элемент управления и изменение его текста заголовка или цвета фона. Персонализация на уровне элемента управления не влияет на данные персонализации страницам, отслеживается <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления и поэтому <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> значение свойства не будет изменено на `true` при возникновении Персонализация на уровне элемента управления.  
  
 Несмотря на то, что метод является защищенным и не доступны непосредственно для вызывающего объекта, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> свойство можно получить доступ напрямую вызывающие объекты, и возвращает значение этого свойства.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">Содержит постоянные данные состояния, которые должны быть загружены.</param>
        <summary>Загружает данные состояния элемента управления, которые были сохранены после предыдущего запроса страницы и должны быть восстановлены в последующем запросе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A> Метод полезен для восстановления данных свойств, которые должны сохраняться во время обратной передачи страницы, даже если <xref:System.Web.UI.Control.EnableViewState%2A> свойству `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="savedState" /> не является допустимым <see cref="P:System.Web.UI.PageStatePersister.ControlState" />.</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">Объект <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />, содержащий данные о состоянии для загрузки.</param>
        <summary>Сохраняет пользовательские данные персонализации, переданные объектами персонализации в элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> для использования в будущем процессе инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> Метод предоставляет сохраненное состояние данных в виде <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> объекта. Эти данные в конце концов используется для загрузки данных персонализации в элементы управления веб-частей и выполнить другие задачи инициализации.  
  
> [!NOTE]
>  Этот метод вызывается с помощью последовательности из методов, начинается при <xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A> метод изначально запрашивает связанного <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> объект для предоставления данных персонализации <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления.  
  
 Этот метод невозможно вызвать непосредственно из программного кода. Можно Однако непосредственно вызвать <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A> метод, который в свою очередь вызывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> метод и возвращает данные персонализации.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Разработчики могут переопределить <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> метод в производном <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> класса.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Security.PermissionSet" />, допускающий только разрешение <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> и разрешение <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" />.</summary>
        <value>Объект <see cref="T:System.Security.PermissionSet" />, допускающий только разрешение <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> и разрешение <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> Объект, возвращаемый этим свойством, используется для десериализации типа во время импорта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Security.PermissionSet" />, допускающий только разрешение <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> и разрешение <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" />.</summary>
        <value>Получает объект <see cref="T:System.Security.PermissionSet" />, допускающий только разрешение <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> и разрешение <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> Объект, возвращаемый этим свойством, используется во время импорта для всех типов десериализации, за исключением.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">Элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или другой перемещаемый серверный элемент управления.</param>
        <param name="zone">Целевой объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />, в который перемещается объект <c>webPart</c>.</param>
        <param name="zoneIndex">Целое число, указывающее индекс объекта <c>webPart</c> относительно других элементов управления в пределах зоны <c>zone</c>.</param>
        <summary>Перемещает объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или серверный элемент управления из одной зоны <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> в другую или в новую позицию в той же зоне.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Управления использует <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> метод для перемещения `webPart` на новое место в той же зоны или в другую зону. Этот метод можно вызывать непосредственно из кода, а также он вызывается, когда пользователь перемещает элемент управления на новое место с помощью различных параметров в пользовательском интерфейсе (UI) веб-частей.  
  
 Количество условий, которые должны быть выполнены перед `webPart` можно переместить, и большинство из них определяется элементов, перечисленных в раздел "исключения" этого раздела. Если `webPart` не содержалась в <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зоны начинается с ее нельзя переместить в зону.  
  
 Происходит после условия выполнены, следующую последовательность действий для перемещения `webPart`:  
  
1.  Метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> вызывает событие <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>.  
  
2.  `webPart` удаляется из текущей зоны (при необходимости) и добавить новую зону или в новое положение в текущей зоны.  
  
3.  Метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> вызывает событие <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>.  
  
4.  `zoneIndex` Из каждого <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления в источнике и целевой зоны сбрасывается в соответствии с перемещенного элемента управления.  
  
   
  
## Examples  
 В следующем примере кода показано, как вызвать <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> метод непосредственно из кода, чтобы переместить <xref:System.Web.UI.WebControls.WebParts.WebPart> управления в одном часовом поясе.  
  
 В примере кода состоит из трех частей:  
  
-   Пользовательский элемент управления для изменения режима отображения.  
  
-   Веб-страница для размещения элементов управления.  
  
-   Объяснение того, как запустить пример кода.  
  
 Первая часть примера кода — это пользовательский элемент управления для изменения режима отображения. Исходный код для пользовательского элемента управления можно получить из примера <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе. Дополнительные сведения о режимах отображения и принципах работы пользовательского элемента управления см. в разделе [Пошаговое руководство: изменение режима отображения страницы](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Во второй части примера является веб-страницы, содержащий две зоны, каждая из которых содержит два серверных элементов управления. Когда пользователь щелкает **Move WebPart** кнопку на странице кода в `Button1_Click` метод перемещает элемент управления из первой зоны в новое положение во второй зоне. Обратите внимание, что код сначала должен вызывать <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> метод для извлечения <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> объекты, образующие `list1` элемента управления. Это необходимо, так как первый параметр <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> метод требует <xref:System.Web.UI.WebControls.WebParts.WebPart> управления, тогда как `list1` серверный элемент управления ASP.NET.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 После загрузки страницы, нажмите кнопку **Move WebPart** кнопки и обратите внимание, что элемент управления, содержащий ссылки перемещаются в среднее положение во второй зоне. Такое перемещение элемента управления программным образом достигается посредством вызова <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> метод. Можно также использовать **режим отображения** раскрывающемся списке элемента управления для переключения страницы в режим конструктора и в режиме конструктора можно перетаскивать элементы разных зон или других позициях в их зонах. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> Метод также вызывается <xref:System.Web.UI.WebControls.WebParts.WebPartManager> перемещает элемент управления для обработки таких инициированной пользователем.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> не содержится в коллекции <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.  
  
 \- или -  
  
 <paramref name="zone" /> не содержится в коллекции <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.  
  
 \- или -  
  
 Зона, на которую ссылается свойство <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> элемента управления <paramref name="webPart" /> равна <see langword="null" />. Это означает, что <paramref name="webPart" /> в настоящее время не содержится в зоне.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="webPart" /> или <paramref name="zone" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="zoneIndex" /> меньше нуля.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> и вызывает обработчик для этого события, если таковой существует.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> Метод вызывается методом <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> метод, когда <xref:System.Web.UI.WebControls.WebParts.WebPart> управления выполняется проверка на наличие авторизации должны быть добавлены на страницу. Когда <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> вызывается метод, он выдает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> события, и если имеется метод обработчика для события, он вызывает обработчик.  
  
 Процесс авторизации <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления является важной функцией веб-частей. Каждый <xref:System.Web.UI.WebControls.WebParts.WebPart> или серверный элемент управления, который добавляется в зону, <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемент управления проходит через процесс авторизации для определения добавления элемента управления. По умолчанию в наборе элементов управления веб-частей не предоставляет критериям фильтрации для предотвращения добавления в зону элементов управления. Однако в наборе элементов управления предоставляют механизмы, необходимые разработчикам для создания собственных критериев фильтрации. С помощью этих механизмов можно создать пользовательские скрипты фильтрации. Например можно создать фильтр, чтобы, если пользователь входит в роль администратора, некоторые элементы управления добавляется в зону при отображении страницы, а также если пользователь входит в роль пользователя, не следует добавить эти элементы управления.  
  
 Средства для фильтрации элементов управления в процессе авторизации <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> свойство <xref:System.Web.UI.WebControls.WebParts.WebPart> элементы управления, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> и <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> методы и <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> события <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления.  
  
 Чтобы создать сценарий фильтрации, существует две задачи. Во-первых, назначить строки для <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> каждого экземпляра <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления, который необходимо отфильтровать. Эти строковые значения, может быть произвольным, но они должны содержать условие, по которому нужно выполнить фильтрацию по. Например, если требуется, чтобы данный элемент управления для добавления зоны, только если администратор при просмотре страницы, то можно назначить строковое значение `admin` к свойству. Затем может использовать функциональные возможности ролей ASP.NET и добавить всех пользователей веб-узла для различных ролей, таких как администратор, диспетчер и пользователя. Во время загрузки страницы фильтрации кода следует проверить, какую роль у пользователя в, сравните их со значением фильтра авторизации для элемента управления и если, к примеру, пользователь с ролью администратора и элемента управления было задано <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> значение `admin`, элемент управления может быть добавлен.  
  
 Вторым шагом в создании сценария фильтрации заключается в написании кода для проверки <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> значения свойств на <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов, а также определить, авторизован ли каждый элемент управления, перед добавлением в зоне. Существует два варианта для размещения этого кода фильтрации. Первый вариант является предпочтительным для разработчиков страниц. Можно создать метод для обработки <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> событие непосредственно в коде сценария сервера веб-странице или в файле разделение кода. При связывании методов с событием, добавив `OnAuthorizeWebPart` в тег для <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления на странице, как показано в следующем образце кода разметки.  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 Пользовательский метод должна быть выполнена всего проверку каждого <xref:System.Web.UI.WebControls.WebParts.WebPart> управления в критериях фильтрации, а затем, основываясь на результатах назначить логическое значение, <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A> свойство <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs> объекте, чтобы указать ли <xref:System.Web.UI.WebControls.WebParts.WebPart> элемент управления может быть добавлен. В следующем примере кода показано, как это сделать.  
  
 Второй параметр для фильтрации кода размещения должен наследовать <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класса и переопределить метод для проверки условия фильтра. Два метода, можно переопределить для этого <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> метода или <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> метод. Несмотря на то, что оба этих метода будут работать, в большинстве случаев лучше переопределить <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> метода, так как он предоставляет больший программный контроль над процесс целиком авторизации, тогда как <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> метод выполняет только одна специальная задача , который представляет собой вызов события и проверьте обработчика. Пример кода настраиваемого <xref:System.Web.UI.WebControls.WebParts.WebPartManager> класс, который переопределяет <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> метода, см. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> перегрузка метода.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать пользовательский обработчик событий для <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> события, чтобы обработчик может предоставить пользовательский код фильтрации для <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> метод. В этом примере будет стандартный способ предоставления сценария фильтрации и авторизации разработчиком страницы <xref:System.Web.UI.WebControls.WebParts.WebPart> Добавление на страницу элементов управления.  
  
 Обратите внимание, что на веб-странице `<asp:webpartmanager>` элемент имеет `OnAuthorizeWebPart` атрибута с именем обработчика событий, назначенного ей. Метод проверяет, имеют ли соответствующие элементы управления на странице <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> присваивать значения свойства `admin` и, если это так, возвращает `true`, что означает, что они будут авторизованных и поместить на страницу.  
  
> [!NOTE]
>  Обратите внимание, что элементы управления, имеют значение, присвоенное <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> свойства добавляются, так как они считаются не могут входить в сценарий фильтрации. Это может быть общим подходом в сценариях фильтрации: некоторые элементы управления будут отфильтрованы и другие не будет, так как они предположительно являются доступными для всех пользователей.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 Так как при настройке пользователей в роли выходит за рамки этого раздела, этот пример кода не проверяет роли пользователей при фильтрации. Однако сценарий фильтрации элементов управления в соответствии с ролями пользователей будет одним из наиболее распространенных способов использования этой функциональной возможности фильтрации. Если имеются роли на узле, а для проверки ролей пользователей в этом методе для фильтрации элементов управления, метод будет выглядеть следующим образом (а не более простой подход в предыдущем примере кода, который не использует ролей) следующий блок кода.  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> для указания загрузки страницы и ее элементов управления, а также активации подключений на странице, что означает готовность к началу совместного использования данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> Вызывает метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> событий после завершения процесса загрузки страницы. Метод предоставляет способ добавления обработчика для события.  
  
 Разработчики страниц можно добавить пользовательский обработчик для события, добавив `OnConnectionsActivated` атрибут `<asp:webpartmanager>` элемент на странице и последующим назначением атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Разработчики могут переопределить <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" /> метод в производном <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> класса.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> для указания загрузки страницы и ее элементов управления, а также возможности активации подключений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> Вызывает метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> событие, которое предоставляет разработчикам механизм для настройки процесса активации подключений программными средствами.  
  
 Разработчики страниц можно добавить пользовательский обработчик для события, добавив `OnConnectionsActivating` атрибут `<asp:webpartmanager>` элемент на странице и последующим назначением атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Разработчики могут переопределить <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" /> метод в производном <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> класса.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />, который содержит данные события, сопоставленные с измененным режимом отображения.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> для указания того, что элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> завершил переключение на веб-странице из одного режима отображения в другой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> Метод в своей основе форме просто вызывает исключение <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged> событий.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Можно переопределить <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" /> метод. Например, после изменения режима отображения может потребоваться изменить некоторые внешний вид пользовательского интерфейса (UI), в зависимости от какого дисплея режим содержится в <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" /> свойство. Или может потребоваться скрыть определенное содержимое или отобразить определенный элемент управления.  
  
 При переопределении метода следует обычно вызывать базовый метод в качестве последнего шага переопределения метода, чтобы пользовательский код выполняется первой, и, наконец, вызывается событие, указывающее, что изменение режима завершена.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, который содержит данные события, сопоставленные с изменением режима отображения.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> для указания того, что элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> находится в процессе переключения из одного режима отображения в другой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> Метод в своей основе форме просто вызывает исключение <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging> событий.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Можно переопределить <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" /> метод. Например, как изменить режим отображения, может потребоваться проверить новый режим отображения, которые будет (с помощью <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" /> свойства) и изменить некоторые интерфейс пользователя (ИП) в зависимости от нового режима отображения, которые будут. При наличии пользовательского режима отображения может потребоваться внести некоторые элементы управления, если предполагается, что пользовательский режим будет новый режим отображения.  
  
 При переопределении этого метода следует обычно вызывать базовый метод в качестве первого шага переопределения метода, чтобы события означает, что начало изменения режима отображения. Затем пользовательский код можно внести изменения в пользовательский интерфейс (UI), прежде чем фактически отображается новый режим отображения.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.Control.Init" />, которое является первым событием в жизненном цикле элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> Метод вызывает базовый метод, который вызывает <xref:System.Web.UI.Control.Init> событий для элемента управления, а затем выполняет подготовительных действий, например убедиться, что имеется только один экземпляр <xref:System.Web.UI.WebControls.WebParts.WebPartManager> на странице и загрузки данные персонализации.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">На странице существует другой элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /></exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.Control.PreRender" />, которое происходит перед визуализацией элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> на веб-странице.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A> Метод вызывает базовый метод, который вызывает <xref:System.Web.UI.Control.PreRender> событий для элемента управления, а затем регистрирует управляет несколько клиентских скриптов, необходимых на страницах, содержащих веб-частей.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />, которое происходит после выбора элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или отмены выбора этого элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> Вызывает метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> событие, которое обычно является точкой времени, когда разработчик может потребоваться изменить внешний вид пользовательского интерфейса (UI). Например, при создании нового <xref:System.Web.UI.WebControls.WebParts.WebPart> управления установлен, установить элемент управления веб-частей, изменения для подготовки к просмотру вновь выбранный элемент управления. После отмены выбора элемента управления отрисовка возвращается в обычный режим.  
  
 Когда пользователь выбирает определенный <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления для редактирования, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> вызывается метод. Когда пользователь заканчивает редактирование элемента управления и закрывает его, с результатом, снять Выбор элемента управления, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> метод будет вызван повторно.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Существует несколько параметров, связанных с <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> события позволяют разработчикам настраивать отрисовку, которая происходит после изменения выбранного элемента управления. В объявляющем коде в <see langword="&lt;asp:webpartmanager&gt;" /> можно задать элемент <see langword="OnSelectedWebPartChanged" /> атрибут и присвойте ему имя пользовательского метода. В пользовательском методе можно изменить отрисовку элементов управления при возникновении события. Другой вариант — наследовать <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> класса и переопределить данный метод. Третий вариант — для настройки обработки на уровне зоны; Например, можно наследовать от <see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" /> класса и переопределить его <see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" /> метод для настройки отображения элементов управления включается и отключается в процессе редактирования.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />, которое происходит во время изменения текущего выбора элементов управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> Вызывает метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> событие, возникающее во время изменения которого <xref:System.Web.UI.WebControls.WebParts.WebPart> выбранного элемента управления.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Элемент управления использует этот метод и связанные события, для обеспечения возможности отменить процесс, в котором изменяется выбранного элемента управления. Например, метод вызывается внутри <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> метода, а также в <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> метод предоставляет способ для отмены процесса. Если пользователь щелкает команду отмены в элемент управления, который редактируется, элемент управления теряет фокус и любого изменения не сохраняются, так как <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> метод дает возможность отменить внесения изменений.  
  
> [!NOTE]
>  Аналогично метод вызывается во время работы методов, которые начинают и завершают процесс подключения <xref:System.Web.UI.WebControls.WebParts.WebPart> управления на другой элемент управления, для отмены этого процесса.  
  
 Разработчики страниц могут создать пользовательский обработчик для <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> событие, добавив `OnSelectedWebPartChanging` атрибут `<asp:webpartmanager>` элемент в разметке страницы декларативный и присвоения атрибуту имя пользовательского метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события, сопоставленные с удалением элемента управления.</param>
        <summary>Создает базовое событие <see cref="E:System.Web.UI.Control.Unload" /> и удаляет экземпляр <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> с веб-страницы.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />, которое происходит после добавления на страницу элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> Метод вызывается в процессе добавления <xref:System.Web.UI.WebControls.WebParts.WebPart> управления (или другого серверного элемента управления, который добавляется <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зоны) на страницу.  
  
 Разработчики страниц могут создать пользовательский обработчик для <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> событие, добавив `OnWebPartAdded` атрибут <`asp:webpartmanager>` элемента и присвоения атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />, которое происходит во время процесса добавления элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (или серверного, или пользовательского элемента управления) в зону <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> Вызывает метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> событие, указывающее, что элемент управления находится в процессе добавления. Этот метод также предоставляет возможность отмены процесса добавления. Если элемент управления успешно добавлен, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> событие соответствует.  
  
 Разработчики страниц могут предоставить пользовательский обработчик связанного события путем добавления `OnWebPartAdding` атрибут `<asp:webpartmanager>` элемента на веб-страницы, а затем добавляют имени пользовательского метода с атрибутом.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Разработчики производных <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> классы могут переопределять <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" /> метод для обработки событий.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> для оповещение об удалении элемента управления со страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> Вызывает метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> событий, чтобы указать, что <xref:System.Web.UI.WebControls.WebParts.WebPart> управления (или другого серверного или пользовательского элемента управления) был успешно закрыт на странице.  
  
 Чтобы закрыть <xref:System.Web.UI.WebControls.WebParts.WebPart> означает элемента управления удалить его со страницы, чтобы он не отображается, а также чтобы поместить его в специальном объекте хранения, который называется каталогом страницы. Каталог страницы, который соответствует <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> управления, обслуживает ссылки на закрытое <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления для каждой страницы. Если <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> на странице объявляется элемент управления <xref:System.Web.UI.WebControls.WebParts.CatalogZone> зоны, пользователи могут переключитесь в режим отображения каталога и добавьте на страницу, все элементы управления, которые ранее были закрыты.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> Метод дает возможность разработчикам создавать пользовательские обработчики для <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> события. Разработчики страниц можно добавить пользовательский обработчик для события, добавив `OnWebPartClosed` атрибут `<asp:webpartmanager>` элемент на странице и последующим назначением атрибуту имени пользовательского метода. Одна полезны, разработчик может выполнить в этом методе заключается в отображении местозаполнителя вместо закрытого элемента управления, завершить с всплывающей подсказки, которая оповещает пользователей о том, как добавить элемент управления на страницу.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />, которое происходит во время удаления со страницы серверного элемента управления или объекта <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> Вызывает метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> событие, указывающее, что элемент управления находится в процессе, закрывается или удалена со страницы. Этот метод также предоставляет возможность отмены процесса закрытия. Если элемент успешно удален из страницы, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> событие соответствует.  
  
 Разработчики страниц могут предоставить пользовательский обработчик связанного события путем добавления `OnWebPartClosinging` атрибут `<asp:webpartmanager>` элемента на веб-страницы, а затем добавляют имени пользовательского метода с атрибутом.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Разработчики производных <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> классы могут переопределять <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> метод для обработки событий.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />, которое происходит после окончательного удаления со страницы элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> Метод вызывается в процессе удаления <xref:System.Web.UI.WebControls.WebParts.WebPart> управления (или другого серверного элемента управления, который добавляется <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зоны) со страницы.  
  
 Разработчики страниц могут создать пользовательский обработчик для <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> событие, добавив `OnWebPartDeleted` атрибут <`asp:webpartmanager>` элемента и присвоения атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />, которое указывает, что динамический элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (или серверный, или пользовательский элемент управления, содержащийся в зоне <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />) находится в процессе удаления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Только динамические <xref:System.Web.UI.WebControls.WebParts.WebPart> элементы управления могут быть удалены, а при удалении элемента управления экземпляр элемента управления окончательно удаляется со страницы и не могут быть восстановлены. Динамические <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, которые были добавлены программно или из каталога веб-частей, в отличие от статических элементов управления, которые были объявлены в разметке веб-страницы.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> Вызывает метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> событие, указывающее, что элемент управления безвозвратно удаляется из зоны. Этот метод также предоставляет возможность отменить процесс удаления. Если элемент успешно удален из страницы, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> событие соответствует.  
  
 Разработчики страниц могут предоставить пользовательский обработчик связанного события путем добавления `OnWebPartDeleting` атрибут `<asp:webpartmanager>` элемента на веб-страницы, а затем добавляют имени пользовательского метода с атрибутом.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Разработчики производных <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> классы могут переопределять <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> метод для обработки событий.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />, которое происходит после перемещения элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> в другое место на странице.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> Вызывает метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> событий в самом конце <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> метод, который обеспечивает завершение процесс перемещения элемента управления перед любой код в событии запустится обработчик.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> Событие возникает при перемещении элемента управления в пределах текущей зоны или в другую зону, а не важно, перемещение осуществляется программно или с пользователем, перетащив элемент управления.  
  
 Разработчики страниц могут создать пользовательский обработчик для <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> событие, добавив `OnWebPartMoved` атрибут <`asp:webpartmanager>` элемента и присвоения атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />, которое указывает, что <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или серверный, или пользовательский элемент управления в зоне <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> находится в процессе перемещения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> Вызывает метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> событие, возникающее при <xref:System.Web.UI.WebControls.WebParts.WebPart> или другого серверного элемента управления перемещен в зоне или в другую зону. Этот метод также предоставляет возможность отмены процесса перемещения. Если перемещение успешно завершена, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> событие соответствует.  
  
 Разработчики страниц могут предоставить пользовательский обработчик связанного события путем добавления `OnWebPartMoving` атрибут `<asp:webpartmanager>` элемента на веб-страницы, а затем добавляют имени пользовательского метода с атрибутом.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Разработчики производных <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> классы могут переопределять <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" /> метод для обработки событий.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />, которое происходит после установки подключения между элементами управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> Метод выдает соответствующего события в самом конце <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> метод, который обеспечивает завершение действия, необходимые для подключения двух элементов управления до выполнения кода в обработчик событий.  
  
 Этот метод предоставляет программный контроль над процессом создания подключений и соответствующее событие является удобным моментом для обновления пользовательского интерфейса (UI), или уведомить пользователя, что соединение было установлено.  
  
 Разработчики страниц могут создать пользовательский обработчик для <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> событие, добавив `OnWebPartsConnected` атрибут <`asp:webpartmanager>` элемента и присвоения атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />, которое происходит во время установки подключения между двумя <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или серверными, или пользовательскими элементами управления, содержащимися в зоне <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> Вызывает метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> событие, возникающее при попытке установить соединение двух элементов управления. Этот метод предоставляет возможность отмены попытки подключения. Если соединение установлено успешно, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> событие соответствует.  
  
 Разработчики страниц могут предоставить пользовательский обработчик связанного события путем добавления `OnWebPartsConnecting` атрибут `<asp:webpartmanager>` элемента на веб-страницы, а затем добавляют имени пользовательского метода с атрибутом.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Разработчики производных <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> классы могут переопределять <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> метод для обработки событий.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />, которое происходит после завершения подключения между элементами управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> Метод выдает соответствующего события в самом конце <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> метод, который выполняет процесс завершения подключения между двумя элементами управления.  
  
 Этот метод предоставляет программный контроль над процессом разрыв соединения, и разработчики могут уведомить пользователя, внести изменения в пользовательский интерфейс (UI) или внести другие изменения в приложение.  
  
 Разработчики страниц могут создать пользовательский обработчик для <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> событие, добавив `OnWebPartsDisconnected` атрибут <`asp:webpartmanager>` элемента и присвоения атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />, которое указывает, что два объекта <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или серверных, или пользовательских элементов управления в зоне <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> находятся в процессе завершения подключения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> Вызывает метод <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> событие, возникающее при двух элементов управления Разрыв соединения. Этот метод предоставляет возможность отмены процесса отключения. Если подключение успешно удалено, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> событие соответствует.  
  
 Разработчики страниц могут предоставить пользовательский обработчик связанного события путем добавления `OnWebPartsDisconnecting` атрибут `<asp:webpartmanager>` элемента на веб-страницы, а затем добавляют имени пользовательского метода с атрибутом.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Разработчики производных <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> классы могут переопределять <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> метод для обработки событий.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ссылку на объект, который содержит данные персонализации для веб-страницы.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />, содержащий данные персонализации.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> Свойство предоставляет доступ к <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> объект, связанный со страницей через <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления. С помощью этого свойства, доступны различные члены объекта, персонализацию. Например, можно использовать <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> общий метод переключение область персонализации из области пользователя или наоборот. Также можно узнать текущую область персонализации страницы ли персонализация включена даже на странице, какой поставщик используется для данных персонализации и многое другое.  
  
 Обратите внимание, что данные ссылается <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> свойство доступно только данные персонализации страницам, отслеживаемой <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления. Данные персонализации элемента управления, такие как значения настраиваемых свойств <xref:System.Web.UI.WebControls.WebParts.WebPart> определяет, является не является частью <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> свойство.  
  
> [!NOTE]
>  Дополнительные сведения о персонализации веб-частей см. в разделе [Общие сведения о персонализации частей Web](http://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> свойство программными средствами.  
  
 Следующие веб-страницы позволяет пользователю режим редактирования для изменения определенных аспектов <xref:System.Web.UI.WebControls.Calendar> элемента управления. **Переключить область** кнопка для переключения страницы для пользователя или общую область персонализации. **Режим изменения** и **режим просмотра** кнопки служат для переключения страницы в соответствующий режим отображения. Обратите внимание, что в `<script>` тег раздел файла, два метода, которые обрабатывают события используйте <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> свойство для доступа к членам полезные базового объекта. В частности, эти методы используют <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> метод и <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> свойства объекта, доступных через <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> свойство.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 Для выполнения примера кода также необходимо включить пользователя или пользователей, для страниц в общую область персонализации. Добавьте запись в файл Web.config в `<system.web>` раздел, который выглядит как приведенная ниже разметка.  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 После загрузки страницы в браузере, щелкните **Переключить область** кнопки и обратите внимание, что на странице теперь говорится область является общим. Нажмите кнопку **режим изменения** Чтобы изменить режим отображения, щелкните меню команд отображаемого элемента управления и выберите **изменить** в меню. Обратите внимание, что отображается пользовательский интерфейс (UI) для обоих элементов управления редактирования. Теперь щелкните **режим просмотра** для возврата в обычный режим просмотра. Если на странице указано, он находится в общей области, нажмите кнопку **Переключить область** еще раз, чтобы убедиться в пользовательской области страницы. После этого выполните те же действия, снова измените элемент управления, но Обратите внимание, что теперь в пользовательском Интерфейсе редактирования <xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart> управления не отображается. Это, так как этот элемент управления работает, только когда страница находится в общую область персонализации.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Разрешает элементу управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> запустить скрипт на стороне клиента, который используется для различных функциональных возможностей персонализации, таких как перетаскивание элементов управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> на веб-странице.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.Web.UI.HtmlTextWriter" />, получающий содержимое элемента управления, для записи на страницу.</param>
        <summary>Переопределен, чтобы не дать элементу управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> отрисовать какое-либо содержимое.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сохраняет данные состояния для элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, так что данные могут быть восстановлены при будущих запросах веб-страницы, содержащей элемент управления.</summary>
        <returns>Объект <see cref="T:System.Object" />, который должен содержать сохраненные данные состояния элемента управления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A> Метод сохраняет данные о состоянии для свойств, которые должны сохраняться во время обратной передачи страницы, даже если <xref:System.Web.UI.Control.EnableViewState%2A> свойству `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">Объект <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />, содержащий данные о состоянии для загрузки.</param>
        <summary>Сохраняет данные состояния пользовательской персонализации, поддерживаемые элементом управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, чтобы эти данные могли быть повторно загружены при повторной загрузке страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A> Метод важен в процессе персонализации, так как он включает настроенные пользователем параметры хранения для будущих сеансов браузера и посещает на страницу. Этот метод сохраняет данные состояния пользовательской персонализации, которые включают следующие: динамические <xref:System.Web.UI.WebControls.WebParts.WebPart> или серверные элементы управления, которые были добавлены на страницу или удаляются из страницы; элементы управления, которые были перемещены на странице; и динамических подключений, которые имеют были созданы или удалены.  
  
 Этот метод невозможно вызвать непосредственно из программного кода. Можно Однако, вызывать <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> метод, который в свою очередь вызывает этот метод для сохранения данных персонализации.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Разработчики могут переопределить этот метод в производном <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> класс, чтобы настроить процесс сохранения данных персонализации.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ссылку на элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или другой серверный элемент управления, который в настоящее время выбран для редактирования или для создания подключения к другому элементу управления.</summary>
        <value>Элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, который выбран в настоящее время для редактирования или создания подключения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> Свойство возвращает ссылку на <xref:System.Web.UI.WebControls.WebParts.WebPart> или другого серверного элемента управления, выбранного в данный момент для редактирования или для создания соединения с другим элементом управления.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Элемент управления предоставляет несколько полезных методов и событий для обработки процесс выбора элемента управления. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> Событие происходит сразу после выбранного элемента управления, но перед внесением изменений. Для выполнения некоторых действий в элементе управления после его выбора, переопределение <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> метод. Например можно изменить внешний вид элемента управления, который выбран, но не изменилось, чтобы визуально подчеркнуть какой элемент управления выбран.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> Событие происходит сразу после выбранного элемента управления был изменен. Для выполнения некоторых действий в элементе управления после его изменения, переопределите <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после изменение и перемещения выбранного элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> в другой элемент управления на веб-странице.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие может использоваться в сочетании с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> метод, чтобы изменить пользовательский интерфейс (UI) выбранного элемента управления. Например, если пользователь переключает страницу в режиме конструктора (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>) и затем выбирает <xref:System.Web.UI.WebControls.WebParts.WebPart> управления с целью перетаскивания его в новое положение, чаще всего изменение отрисовки выбранного элемента управления, например, изменив цвет его границу или фон при его выборе.  
  
> [!NOTE]
>  Дополнительные сведения о событиях см. в разделе [как: прием событий в приложениях Web Forms](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит во время изменения текущего выбора на странице элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или серверного элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие может использоваться в сочетании с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> метод. Разработчики страниц могут создать обработчик событий в своем коде, добавив `OnSelectedWebPartChanging` атрибут `<asp:webpartmanager>` элемент на страницы и значение атрибута имя пользовательский метод, обрабатывающий событие.  
  
 Это событие возникает во время запуска или завершения подключения между элементами управления, а также при запуске или завершении редактирования элемента управления. Дополнительные сведения см. в разделе <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> метод.  
  
 Как правило, когда <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> событие возникает в результате действия пользователя, которое изменяет выбранного элемента управления, это событие может быть отменено. Однако есть ситуации, в котором события не может быть отменено. Если <xref:System.Web.UI.WebControls.WebParts.WebPartZone> управления должен быть удален, <xref:System.Web.UI.WebControls.WebParts.WebPart> он содержит элементы управления должны быть закрыты все, в противном случае они будут потеряны. В этом случае <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления закрывается <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, не пользователем и его необходимо определить, какой элемент управления выбран в данный момент, а когда их изменять без прерывания, возможность, чтобы его можно завершить процесс очистки все элементы управления. Таким образом, намеренно <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> метод не может быть отменено в этом сценарии. Связанные события, которые могут быть отменены, в разделе <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> событий.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Задает флаг, указывающий, что пользовательские данные персонализации для элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> были изменены.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> Метод устанавливает флаг, который в конечном итоге приводит компоненты персонализации в наборе для сохранения данных персонализации обновленных элементов управления веб-частей. Дополнительные сведения об этих сценариях, которые могут вызвать изменения в данные персонализации, отслеживаемых <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления см. в разделе <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> свойство.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> Метод не может вызываться напрямую из кода приложения и не может быть переопределен, поскольку он используется внутри элемента управления веб-частей заданы как часть персонализация веб-частей.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Метод может вызываться с производным <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> класса. Это может потребоваться, если вы хотите настроить персонализации установить компоненты управления веб-частей и таким образом требуется контролировать процесс установки флажков для данных персонализации.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Выбранный объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или серверный элемент управления.</param>
        <summary>Задает значение свойства <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> равным выбранному в настоящий момент <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или серверному элементу управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> Метод вызывается во время процессов, которые может начинаться или заканчиваться редактирования элемента управления, определяемое `webPart` параметр, а те, которые может начинаться или заканчиваться подключение, которое включает в себя `webPart`.  
  
 В начале процесса изменения и соединений `webPart` элемент управления, который был выбран для редактирования или для установки подключения.  
  
 В конце процессы изменения и соединений `null` передается <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> метод, который приводит к снять выделение выбранного элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает пустую строку (""), чтобы к элементу управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> можно было применить обложку.</summary>
        <value>Пустая строка, которая препятствует назначению обложки для элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A> Свойство переопределяет унаследованный <xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType> свойство, чтобы предотвратить <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления, который является невидимом элементе управления, с помощью обложки. Реализация этого свойства предотвращает назначение обложки, присваиваемого методом всегда возвращает пустую строку из `get` метод доступа и всегда выбрасывает исключение при попытке задать значение в `set` метода доступа.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Предпринята попытка присвоить значение свойству.</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ссылку на коллекцию всех объектов <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> на веб-странице, которые определены как статические подключения.</summary>
        <value>Коллекция <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />, которая содержит все статические подключения на странице.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> Используется свойство <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления для отслеживания и управления всех статических подключений на странице. Статические подключения, в отличие от динамического подключения, необходимо добавить на страницу каждый раз при отображении страницы.  
  
 Коллекция ссылается это свойство содержит все статические соединений, которые существуют на странице ли они программными средствами или указан с `<asp:webpartconnection>` элемент в разметке страницы.  
  
   
  
## Examples  
 В следующем примере кода показано программное использование <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> свойство.  
  
 В примере кода состоит из четырех частей:  
  
-   Пользовательский элемент управления, позволяющий изменять режимы отображения на веб-странице.  
  
-   Файл исходного кода, который содержит две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления и пользовательского интерфейса.  
  
-   Веб-страницы, который содержит две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, которые могут быть подключены, и `<asp:webpartmanager>` элемента.  
  
-   Пояснения к работе примера в браузере.  
  
 Следующий код содержит только часть примера веб-страницы. Кроме того, нужно получить первые две части примера — пользовательский элемент управления и исходный код для пользовательских элементов управления и интерфейса — из примера <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе. Этот раздел также рассмотрены варианты компиляции <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления.  
  
 Третья часть примера кода — веб-страница. Декларативная разметка страницы содержит `Register` директивы для пользовательского элемента управления и пользовательские элементы управления. Отсутствует `<asp:webpartmanager>` элемент, `<asp:webpartzone>` элемент содержит пользовательские элементы управления и `<asp:connectionszone>` элемента. Обратите внимание, что в `Page_Load` метода, код проверяет, является ли соединение уже существует и, если это не так, определяет поставщик, объект-получатель и соответствующие точки подключения, а затем добавляет новое соединение в набор статических подключений, на которые имеются ссылки <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> свойство.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 После загрузки веб-страницы в браузере, щелкните **режим отображения** управления раскрывающегося списка и выберите **Connect** для переключения страницы в режим подключения. Подключение использует режим `<asp:connectionszone>` элемент, чтобы можно было создавать подключения между элементами управления. В режиме подключения, щелкните стрелку вниз в строке заголовка **ПОЧТОВЫЙ индекс** управления активировать соответствующее меню команд и нажмите кнопку **Connect**. После появления подключения пользовательский интерфейс (UI), обратите внимание, что соединение уже был создан с кода, содержащегося в `Page_Load` метод. Если вернуться на эту страницу в следующем сеансе браузера, это статическое подключение уже будет установлено и не должны быть повторно при каждой загрузке страницы.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает доступную только для чтения коллекцию всех режимов отображения, которые доступны на определенной веб-странице.</summary>
        <value>Коллекция <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />, которая содержит набор объектов <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />, доступных на определенной веб-странице.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> Свойство содержит только режимы отображения, которые фактически доступны на страницы, учитывая типы элементов управления зоны присутствуют на странице.  
  
> [!NOTE]
>  Режимы отображения можно отключить, а при отключении режима отображения, он не добавляется <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> коллекции, даже при наличии соответствующего типа зоны, поддерживающей этот режим для отображения на странице.  
  
 Режим просмотра и в режиме конструктора всегда поддерживаются. Режимы отображения, которые могут изменяться в — это изменение, каталога и режимов подключения. Каждый из этих режимов отображения связан определенный тип <xref:System.Web.UI.WebControls.WebParts.ToolZone> элемента управления. Он является наличие этой специально типизированные зоны на веб-странице, выполнение определенного режима отображения для добавления в коллекцию ссылается <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> свойство. Например, если веб-страница содержит <xref:System.Web.UI.WebControls.WebParts.EditorZone> зоны, но не <xref:System.Web.UI.WebControls.WebParts.CatalogZone> зону, а затем изменить режим отображения является одним из поддерживаемых режимов на этой странице, но не поддерживается режим отображения каталога.  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> Свойство отличается от <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> свойство, которое ссылается на коллекцию, содержащую все режимы отображения, которые доступны текущему <xref:System.Web.UI.WebControls.WebParts.WebPartManager> контролировать, даже те, которые не поддерживаются на определенной странице.  
  
   
  
## Examples  
 В следующем примере кода показано программное использование <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> свойство. Код использует это свойство для заполнения списка только режимами отображения, доступных в текущей веб-страницы.  
  
 Существуют три поддерживаемых режимы отображения на этой странице: просмотр, конструктор и редактирование. Первые два всегда доступны, и режим редактирования доступен в этом примере кода, поскольку страница содержит <xref:System.Web.UI.WebControls.WebParts.EditorZone> элемента управления. Каталог и подключите отображения режимы не отображаются, так как соответствующие зоны не на этой странице.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 После загрузки страницы в браузере, можно использовать элемент управления раскрывающегося списка для переключения из режима просмотра страницы в режим конструктора, а затем в режим редактирования. В режиме редактирования, можно щелкнуть меню команд раскрывающегося списка в заголовке одного из серверных элементов управления и выберите **изменить** для редактирования элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, были ли изменены на веб-страницы данные состояния персонализации, управляемые элементом управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Логическое значение, которое указывает, были ли изменены данные состояния персонализации.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> Свойство позволяет вызывающим объектам определить ли персонализации состояния данных под управлением <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемент управления был изменен. Когда пользователи персонализировать сведения на уровне страницы, например, изменение макета страницы, создание или удаление подключений и добавление или удаление элементов управления, данные персонализации, которыми управляет <xref:System.Web.UI.WebControls.WebParts.WebPartManager> контроля изменений. Это сквозной метод, возвращающий значение защищенный вызывающим объектам <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> свойства, которое не может получить доступ напрямую вызывающие объекты.  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> Свойство указывает, является ли настраиваемых значений свойств или отдельные свойства, которые влияют на внешний вид отдельных <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, были изменены. Персонализация на уровне элементов управления отслеживается отдельно для каждого элемента управления. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> Свойство указывает только ли данные персонализации, на уровне страниц и управляется <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемент управления был изменен.  
  
 В следующем списке описаны некоторые распространенные экземпляров персонализации, приводящие к <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> значение возвращаемого свойства `true`, означающее, <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемент управления имеет некоторые персонализации измененные данные:  
  
-   Закрытие статический <xref:System.Web.UI.WebControls.WebParts.WebPart> (или сервера или пользователя) элемент управления на странице.  
  
-   Восстановление закрытого статического <xref:System.Web.UI.WebControls.WebParts.WebPart> из каталога страницы обратно на страницу элемента управления.  
  
-   Перемещение любого элемента управления в зоне или в другую зону.  
  
-   Добавление элемента управления из каталога <xref:System.Web.UI.WebControls.WebParts.WebPart> или серверных элементов управления или программным путем добавления элемента управления.  
  
-   Создание соединения между двумя <xref:System.Web.UI.WebControls.WebParts.WebPart> управляет программно или с помощью пользовательского интерфейса (UI) подключения.  
  
-   Удаление соединения между двумя <xref:System.Web.UI.WebControls.WebParts.WebPart> управляет программно или с помощью пользовательского интерфейса подключения.  
  
 Для доступа к этому значению свойства, необходимо привести <xref:System.Web.UI.WebControls.WebParts.WebPartManager> экземпляра элемента управления для <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> интерфейса; можно затем прочитать <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> значение свойства.  
  
   
  
## Examples  
 В следующем примере кода показано простое использование элемента <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> свойство, чтобы указать некоторые распространенные персонализации страницы экземпляров, которые приводят <xref:System.Web.UI.WebControls.WebParts.WebPartManager> данные персонализации элемента управления для изменения.  
  
 В примере кода состоит из четырех частей:  
  
-   Пользовательский элемент управления, позволяющий изменять режимы отображения на странице, содержащей элементы управления веб-частей.  
  
-   Исходный файл, который содержит код для двух пользовательских <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, которые могут быть подключены и интерфейс.  
  
-   Веб-страницы, содержащей элемент управления.  
  
-   Описание принципов работы в примере кода.  
  
 Первая часть примера кода — это пользовательский элемент управления для изменения режима отображения. Исходный код для пользовательского элемента управления можно получить из примера <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Общие сведения о классе. Сведения о режимах отображения и принципах работы пользовательского элемента управления в разделе [Пошаговое руководство: изменение режима отображения страницы](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Во второй части примера является исходным файлом с пользовательскими элементами управления и интерфейса. Обратите внимание, что `IZipCode` интерфейс предоставляет один метод, и реализация этого метода, как в пользовательских `ZipCodeWebPart` управления служит в качестве метода обратного вызова для включения `ZipCodeWebPart` в качестве поставщика в сценарии подключения. Другие управляющие `WeatherWebPart`, управления действует как потребитель в подключении; он может получать определенный интерфейс, предоставляемый `ZipCodeWebPart`. В реальном приложении `WeatherWebPart` может получать персонализированные ПОЧТОВЫЙ индекс значение от поставщика и введите сведения о графических погоды для пользователей.  
  
 Для выполнения примера кода необходимо скомпилировать этот исходный код. Можно выполнить явную компиляцию и поместить результирующую сборку в папку Bin веб-сайта или в глобальном кэше сборок. Кроме того можно поместить исходный код в папку App_Code веб-узла, где он будет динамически компилироваться во время выполнения. Данный пример кода использует динамической компиляции; Таким образом, обратите внимание, что `Register` директива для этого компонента в верхней части веб-страница содержит только `TagPrefix` и `Namespace` атрибуты без `Assembly` атрибута. Пошаговое руководство по компиляции см. в разделе [Пошаговое руководство: разработка и с помощью элемента управления пользовательского](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 Третья часть примера кода — веб-страница. Обратите внимание, что он содержит два <xref:System.Web.UI.WebControls.WebParts.WebPartZone> зон, и первый, содержащий две пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления. Имеется также <xref:System.Web.UI.WebControls.WebParts.CatalogZone> зону, содержащую стандартного <xref:System.Web.UI.WebControls.Calendar> элемент управления, который пользователи могут добавлять на страницу. `<asp:connectionszone>` Элемент предоставляет пользовательский Интерфейс для создания подключений между элементами управления соединения. В `Page_PreRender` метод, обратите внимание, что он проверяет, является ли изменения данных персонализации и если да, то обновляет текст `Label1`.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 После загрузки страницы в браузере, попробуйте создать некоторые из сценариев, приведенных в разделе "Примечания" этого раздела, приведет к изменению данных персонализации. При внесении различных изменений, когда изменение включает в себя один из сценариев персонализации, отслеживаемых <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления текст `Label1` отображается элемент управления, чтобы указать, что изменения данных персонализации. Например, с их помощью можно выполнять следующее.  
  
-   Создать подключение между элементами управления, щелкнув **подключения элементов управления веб-части** кнопки.  
  
-   Используйте **режим отображения** управления раскрывающегося списка для переключения страницы в режим каталога и добавьте **календарю** управления второй <xref:System.Web.UI.WebControls.WebParts.WebPartZone> зоны.  
  
-   Изменение страницы обратно в режим просмотра щелкните меню команд (отображается со значком стрелки в заголовке окна) для **календарю** управления и выберите **закрыть** закройте его и добавить его в каталог страницы.  
  
-   Вернитесь в режим каталога и добавьте **календарю** обратно на страницу элемент управления.  
  
-   Используйте **режим отображения** управления для переключения в режим конструктора страницы и изменение макета элементов управления, перетащив один или несколько из них в другую зону или в другое место в той же зоны.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">Объект <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />, содержащий данные о состоянии для загрузки.</param>
        <summary>Возвращает сохраненные данные о состоянии пользовательской персонализации, которые требуется загрузить в элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является реализацией <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType> метод, который предоставляет способ для управления веб-частей, задайте доступ непосредственно защищенный <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType> метод. При вызове этого метода он сохраняет пользовательские данные персонализации, который управляется <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления и который был ранее сохранен в долговременном хранилище данных для дальнейшего использования в процессе инициализации.  
  
> [!NOTE]
>  В большинстве случаев код разработки страниц и элементов управления не нужно вызывать этот метод, так как в основном используется элементом управления веб-частей задать в качестве механизма для получения данных персонализации.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Один сценарий, в которой разработчики могут использовать этот метод при разработке инфраструктуры пользовательской персонализации, следует использовать вместо того, предоставляется набор элементов управления веб-частей. В таких случаях разработчики могут наследовать от <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> класса и переопределить <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> метод возвращал пользовательскую реализацию <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> объекта. Пользовательский <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> объекта вызывается реализация <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> метода в подходящее время для загрузки данных пользовательской персонализации.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">Словарь <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />, который содержит сохраняемые данные о состоянии.</param>
        <summary>Сохраняет пользовательские данные состояния персонализации, которые управляются элементом управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> Метод является реализацией <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType> метод, который предоставляет способ для управления веб-частей, задайте доступ непосредственно защищенный <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType> метод. При вызове этого метода он сохраняет все личные данные, которые управляются <xref:System.Web.UI.WebControls.WebParts.WebPartManager> элемента управления в хранилище постоянных данных, настроенного для приложения веб-частей.  
  
> [!NOTE]
>  В большинстве случаев код разработки страниц и элементов управления не нужно вызывать этот метод, так как в основном используется элементом управления веб-частей задать в качестве механизма для сохранения данных персонализации.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Один сценарий, в которой разработчики могут использовать этот метод при разработке инфраструктуры пользовательской персонализации, следует использовать вместо того, предоставляется набор элементов управления веб-частей. В таких случаях разработчики могут наследовать от <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> класса и переопределить <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> метод возвращал пользовательскую реализацию <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> объекта. Пользовательский <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> объекта вызывается реализация <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> метода в нужное время, чтобы сохранить пользовательские данные персонализации.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Применяет данные состояния персонализации к элементу управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> и вызывает базовый метод для разрешения отслеживания изменений данных состояния просмотра для этого элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Изменения данных состояния представления, хранятся в <xref:System.Web.UI.StateBag> объекта и можно получить с помощью элемента управления <xref:System.Web.UI.Control.ViewState%2A> свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое делает видимыми дочерними элементы управления.</summary>
        <value>Логическое значение, которое указывает, являются ли видимыми элемент управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> и его дочерние элементы управления. Значение <see langword="true" /> во всех случаях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Управления переопределяет базовый <xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType> свойство всегда возвращает значение `true` для <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> свойства. Несмотря на то что <xref:System.Web.UI.WebControls.WebParts.WebPartManager> сам элемент управления не отображается, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> свойство должно иметь значение `true` , чтобы все дочерние элементы управления отображаются по умолчанию.  
  
 При попытке задать значение <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> свойство, он всегда выдает ошибку, так как <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления переопределяет базовое свойство поведение и предотвращает назначением любого значения свойства.  
  
 Это свойство не может быть связано в визуальных конструкторах, но может быть связано во время выполнения. Дополнительные сведения см. в разделе <xref:System.ComponentModel.BindableAttribute>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Предпринята попытка присвоить значение свойству.</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после добавления динамического или другого элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> в зону <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> для указания успешного добавления элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> Событие полезно для указания, что динамический элемент управления (элемент управления добавлен программными средствами, в отличие от, объявляемых в разметке страницы) успешно добавлен в зону. В сочетании с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> метода, это событие предоставляет разработчикам способ обновления пользовательского интерфейса (UI) или в противном случае уведомить пользователей, что элемент управления был успешно добавлен.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит во время процесса добавления динамического <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или другого серверного элемента управления в зону <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> Событие <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> метод после начала процесса добавления элемента управления в зону. Это событие предоставляет возможность отменить этот процесс до его завершения. Если добавление процесс прошел успешно, это событие сопровождается <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> событий.  
  
 Разработчики страниц могут предоставлять пользовательские обработчики для события, добавив `OnWebPartAdding` атрибут `<asp:webpartmanager>` элемент на странице и присвоения атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при удалении со страницы элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (или серверный, или пользовательский элемент управления).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> Событие означает, что элемент управления был успешно закрыт, пользователем или программным путем. Чтобы закрыть <xref:System.Web.UI.WebControls.WebParts.WebPart> означает элемента управления удалить его со страницы, чтобы он не отображается, а также чтобы поместить его в специальном объекте хранения, который называется каталогом страницы. Каталог страницы, который соответствует <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> управления, обслуживает ссылки на закрытое <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления для каждой страницы. Если <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> на странице объявляется элемент управления <xref:System.Web.UI.WebControls.WebParts.CatalogZone> зоны, пользователи могут переключить страницу в режим отображения каталога и добавьте любые элементы управления, которые ранее были закрыты, обратно на страницу.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> Событие связано с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> метод, который вызывает событие и предоставляет обработчик для него.  
  
 Разработчики страниц можно добавить пользовательский обработчик для события, добавив `OnWebPartClosed` атрибут `<asp:webpartmanager>` элемент на странице и последующим назначением атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит во время удаления элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> control (или серверного, или пользовательского элемента управления) со страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> Событие <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> метод при <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления находится в процессе закрытия элемента управления. При успешном удалении элемента управления это событие сопровождается <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> событий.  
  
 Разработчики страниц могут предоставить пользовательский обработчик для события, добавив `OnWebPartClosed` атрибут <`asp:webpartmanager>` элемент на странице и присвоения атрибуту имени пользовательского метода.  
  
 Как правило, когда <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> событие возникает в результате закрытия пользователем <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления, это событие может быть отменено. Однако есть ситуации, в котором события не может быть отменено. Если <xref:System.Web.UI.WebControls.WebParts.WebPartZone> управления должен быть удален, <xref:System.Web.UI.WebControls.WebParts.WebPart> он содержит элементы управления должны быть закрыты все, в противном случае они будут потеряны. В этом случае <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления закрывается <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, не пользователя. И когда <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления находится в процессе вызова <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> метод закрытия каждого элемента управления и <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> события, события не может быть отменено (так предусмотрено разработчиками), так как <xref:System.Web.UI.WebControls.WebParts.WebPartManager> необходимых для выполнения задач очистки элементы управления зоны.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после удаления элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или другого серверного элемента управления из зоны <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> Событие полезно для указания, что динамический элемент управления (элемент управления добавлен программными средствами, в отличие от, объявляемых в разметке страницы) успешно удален из зоны. В сочетании с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> метода, это событие предоставляет разработчикам способ обновления пользовательского интерфейса (UI) или в противном случае уведомить пользователей, что элемент управления был успешно удален.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит во время процесса окончательного удаления экземпляра динамического <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или другого серверного элемента управления из зоны <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> Событие <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> метод во время удаления динамического элемента управления (один, который был добавлен программными средствами или пользователем через пользовательский интерфейс веб-частей). Это событие предоставляет возможность отменить процесс до его завершения. Если процесс удаления завершается успешно, это событие сопровождается <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> событий.  
  
 Разработчики страниц могут предоставлять пользовательские обработчики для события, добавив `OnWebPartDeleting` атрибут `<asp:webpartmanager>` элемент на странице и присвоения атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после перемещения в другое место веб-страницы элемента управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или серверного элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие применяется к статическим (объявленным в разметке веб-страницы) и динамические элементы управления. Он связан, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> метод. Так как это событие возникает после перемещения, разработчики могут включать обработчик событий для предоставления уведомлений пользователям, некоторые проверки или других действий. Чтобы добавить обработчик событий, можно добавить `OnWebPartMoved` атрибут `<asp:webpartmanager>` элемента страницы, и назначьте имя используемой пользовательский метод с атрибутом.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит во время процесса перемещения <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или другого серверного элемента, содержащегося в зоне <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> Событие возникает при <xref:System.Web.UI.WebControls.WebParts.WebPart> или другого серверного элемента управления перемещен в его собственной зоны или в другую зону. Это может произойти, когда пользователь перетаскивает элемент управления и при отсутствии программным методом.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> Событие <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> метода и предоставляет возможность отмены процесса перемещения до его завершения. Если для завершения перемещения и управления, размещаемым в новое положение, это событие сопровождается <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> событий.  
  
 Разработчики страниц могут создать пользовательский обработчик для события, добавив `OnWebPartMoving` атрибут `<asp:webpartmanager>` элемента и присвоения атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ссылку на все элементы управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, отслеживаемые элементом управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> на веб-странице.</summary>
        <value>Объект <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" />, содержащий ссылки на набор элементов управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> Используется свойство <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления для отслеживания всех <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, содержащихся в <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зоны на странице. Несмотря на то, что коллекция доступна только для чтения, можно открыть отдельных <xref:System.Web.UI.WebControls.WebParts.WebPart> элементы управления через коллекцию и внести изменения их программными средствами.  
  
> [!NOTE]
>  Можно иметь <xref:System.Web.UI.WebControls.WebParts.WebPart> управления, размещенные на странице за пределами <xref:System.Web.UI.WebControls.WebParts.WebPartZone> зоны, что позволяет использовать в элементе управления, не отслеживается <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления или на которые ссылается его <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> коллекции. Тем не менее, практически не существует причин для использования <xref:System.Web.UI.WebControls.WebParts.WebPart> управления за пределами зоны, так как он теряет его функциональность веб-частей и действует как обычный серверный элемент управления.  
  
 Любой тип элемента управления, который можно поместить в зоне, является ли настраиваемый <xref:System.Web.UI.WebControls.WebParts.WebPart> управления, стандартный элемент управления, пользовательский элемент управления или серверного элемента управления, могут рассматриваться как <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления во время выполнения. Если элемент управления, не <xref:System.Web.UI.WebControls.WebParts.WebPart> управления помещается в <xref:System.Web.UI.WebControls.WebParts.WebPartZone> зоны, во время выполнения ASP.NET создает оболочку для элемента управления с <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> объекта, чтобы элемент управления может действовать как с обычным <xref:System.Web.UI.WebControls.WebParts.WebPart> элемента управления. Таким образом, с помощью <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> свойства <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления можно отслеживать любого типа серверного элемента управления, независимо от того, является ли он является производным от <xref:System.Web.UI.WebControls.WebParts.WebPart> класса.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> свойство программным способом в отдельных доступа <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления. Обратите внимание, что в декларативная разметка для веб-страницы в `<asp:webpartzone>` элемент существует, два стандартных ASP.NET серверных элементов управления. Несмотря на то, что они не наследуются от <xref:System.Web.UI.WebControls.WebParts.WebPart> класса, поскольку они находятся в зоне, они будут помещены с <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> объекта во время выполнения и таким образом, будут включены в коллекции, на который указывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> свойство. Можно также добавить пользовательские <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, пользовательские элементы управления или пользовательских серверных элементов управления в этой зоне, и они будут обрабатываться так же, как.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 Обратите внимание, что для работы примера кода необходимо добавить параметр в файле Web.config, чтобы разрешить экспорт файлов описания веб-части. Убедитесь, что файл Web.config в том же каталоге, как веб-страницу для этого примера кода. В пределах `<system.web>` статьи, убедитесь, что `<webParts>` элемент с `enableExport` атрибут `true`, как показано в следующей разметкой.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 После загрузки страницы в браузере, если щелкнуть **число веб-части** кнопки, код использует <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> свойство для возврата счетчика элементов в коллекции. Если щелкнуть **скрыть заголовка календаря** кнопку код изменит календарь таким образом, чтобы отобразить ее с его границы, но не заголовок.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после установки определенного подключения между элементами управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (или серверными, или пользовательскими элементами управления).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> Событие связано с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> метод. Это событие полезно, так как после известно, что соединение установлено, может потребоваться информировать пользователей об этом или даже изменить пользовательский интерфейс (UI) страницы. Например может потребоваться отобразить графическое изображение, которое предлагает успешного подключения между двумя элементами управления, или отобразить краткое сообщение, а затем измените режим отображения страницы обратно в режим просмотра.  
  
 Разработчики страниц могут сопоставить пользовательский обработчик событий с этим событием, добавив `OnWebPartsConnected` атрибут `<asp:webpartmanager>` элемент на странице и присвоения атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит во время процесса создания подключения между элементами управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (или серверными, или пользовательскими элементами управления, размещенными в зоне <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> Событие <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> метода, и сообщает о начале процесса подключения (например, пользователь выбранного элемента управления и щелкнул команду подключения), но еще не завершено. Это событие предоставляет возможность отменить соединение до его завершения. Если соединение успешно завершена, это событие сопровождается <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> событий.  
  
 Разработчики страниц можно добавить пользовательский обработчик для события, добавив `OnWebPartsConnecting` атрибут `<asp:webpartmanager>` элемента и присвоения атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после разрыва подключения между двумя элементами управления <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или серверными элементами управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> Событие связано с <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> метод. Это событие полезно, так как после известно, что соединение будет разорвано, может потребоваться информировать пользователей, выполнить некоторые действия по очистке в коде или внести другие изменения в пользовательском интерфейсе (UI).  
  
 Разработчики страниц могут сопоставить пользовательский обработчик событий с этим событием, добавив `OnWebPartsDisConnected` атрибут `<asp:webpartmanager>` элемент на странице и присвоения атрибуту имени пользовательского метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит во время процесса завершения подключения между ранее подключенными <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> или серверными элементами управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> Событие <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> метод, который сигнализирует тот факт, пользователь щелкнул команду отключения, или <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> в противном случае будет вызван метод. Это событие предоставляет возможность отменить разрыв соединения до его завершения. Если подключение завершается успешно, это событие сопровождается <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> событий.  
  
 Разработчики страниц можно добавить пользовательский обработчик для события, добавив `OnWebPartsDisconnecting` атрибут `<asp:webpartmanager>` элемента и присвоения атрибуту имени пользовательского метода.  
  
 Как правило, когда <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> событие возникает в результате действия пользователя, которое завершает соединение, это событие может быть отменено. Однако существует несколько сценариев, в которых события не может быть отменено. Первый сценарий относится, если <xref:System.Web.UI.WebControls.WebParts.WebPartZone> управления должен быть удален, <xref:System.Web.UI.WebControls.WebParts.WebPart> он содержит элементы управления должны быть закрыты все, в противном случае они будут потеряны. В этом случае <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления закрывается <xref:System.Web.UI.WebControls.WebParts.WebPart> элементов управления, не пользователем и она также должны быть видимы для завершения подключения всех подключенных элементов управления, без прерывания, возможность, чтобы его можно завершить процесс очистки и закрытие все элементы управления. Таким образом, намеренно <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> метод не может быть отменено в этом сценарии. Связанные события, которые могут быть отменены, в разделе <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> событий.  
  
 Во втором сценарии, в котором <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> событие не может быть отменено при <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> (это называется во время каждого запроса страницы, например) вызывается метод, и есть некоторые тип конфликта в существующих подключений на странице. Например предположим, пользователь подключает элемент управления x y элемента управления, но другой пользователь подключает элемент управления x к элементу управления z и еще управления x не разрешается создавать несколько подключений. В этом случае параметры отдельного пользователя для соединения имеют приоритет и <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления устраняет конфликт путем вызова <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> метод и завершение подключения между x и z для конкретного пользователя. Так как это отключение важно для разрешения конфликта, намеренно <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> событие не может быть отменено в этом сценарии.  
  
 Третий сценарий, в котором <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> метод не может быть отменено при <xref:System.Web.UI.WebControls.WebParts.WebPart> или серверный элемент управления, который в настоящее время подключен удаляется или закрыт. Так как элемент управления определенно будет удален со страницы, он является логическим действием будет удаление его подключения. Таким образом, когда <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления вызывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> метод, который в свою очередь вызывает <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> событие, намеренно не является возможность отмены события.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ссылку на коллекцию всех зон <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> на веб-странице.</summary>
        <value>Коллекция <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" />, которая ссылается на набор зон <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> Используется свойство <xref:System.Web.UI.WebControls.WebParts.WebPartManager> управления для отслеживания <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> зоны на веб-странице. Обратите внимание, что свойство ссылки не все типы зон; он ссылается только зоны, которые являются производными от <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> класса, включая <xref:System.Web.UI.WebControls.WebParts.WebPartZone> зоны.  
  
 Несмотря на то, что коллекция ссылается это свойство доступно только для чтения, его можно использовать для доступа к отдельным объектам в коллекции и работать с ними программными средствами.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> свойство программным способом в отдельных доступа <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> элементов управления зоны. Обратите внимание, что в декларативная разметка для веб-страницы, имеются два `<asp:webpartzone>` элементов, каждый из которых содержит серверный элемент управления. В `<script>` раздел страницы, код использует <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> свойство для доступа к на отдельные зоны вывод все идентификаторы зоны и затем Изменение цвета фона на второй зоне.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 Обратите внимание, что для работы примера кода необходимо добавить параметр в файле Web.config, чтобы разрешить экспорт файлов описания веб-части. Убедитесь, что файл Web.config в том же каталоге, как веб-страницу для этого примера кода. В пределах `<system.web>` статьи, убедитесь, что `<webParts>` элемент с `enableExport` атрибут `true`, как показано в следующей разметкой.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 После загрузки страницы в браузере, если щелкнуть **идентификаторы список зон** кнопки, код использует <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> свойство для перечисления идентификаторов всех зон в коллекции. Если щелкнуть **Change Zone BackColor** кнопку код изменяет цвет фона второго элемента управления.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>