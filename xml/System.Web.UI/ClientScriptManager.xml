<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e19ff5181caa07c458ad6ff38334f4d37a7d0917" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31910626" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Определяет методы для управления клиентскими скриптами в веб-приложениях.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager> Класс используется для управления клиентских скриптов и добавить их к веб-приложениям. Можно получить ссылку на <xref:System.Web.UI.ClientScriptManager> класса из <xref:System.Web.UI.Page.ClientScript%2A> свойство <xref:System.Web.UI.Page> объекта.  
  
 Можно добавить клиентский сценарий на веб-страницу декларативно, включая описание скрипта в разметке HTML страницы. Однако существуют ситуации, когда необходимо добавить клиентский сценарий динамически. Чтобы добавить сценарий динамически, используйте <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метода <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метод, <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод, или <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метод в зависимости от того, когда и как вы хотите добавить скрипт. Дополнительные сведения см. в разделе [как: Добавление клиентского скрипта динамически для веб-страниц ASP.NET](http://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666).  
  
 <xref:System.Web.UI.ClientScriptManager> Класс однозначно определяет сценарии ключом <xref:System.String> и <xref:System.Type>. Сценарии с одним и тем же ключом и типом считаются дубликатами. Использование типа скрипта помогает избежать путаницы с похожими скриптами разных пользовательских элементов управления, которые могут использоваться на странице.  
  
 <xref:System.Web.UI.ClientScriptManager> Класс может использоваться для обратных вызовов клиентов в ситуациях, когда желательно, чтобы запустить код сервера из клиента без выполнения обратной передачи. Это называется выполняет обратный вызов по каналу на сервер. При обратном вызове клиента функция клиентского скрипта отправляет асинхронный запрос веб-страницу ASP.NET. Веб-страница запускает измененную версию обычного жизненного цикла для обработки обратного вызова. Используйте <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод для получения ссылки на клиентская функция, которая при вызове инициализирует обратный вызов клиента для событий сервера. Дополнительные сведения см. в разделе [реализация клиента обратные вызовы без обратной передачи](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Обратные вызовы скрипта не будут работать в старых браузерах, которые не поддерживают объектной модели документа (DOM), и они требуют включения ECMAScript на стороне клиента. Для проверки, если браузер поддерживает обратные вызовы, используйте <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> свойство, которое доступно через <xref:System.Web.HttpRequest.Browser%2A> свойство ASP.NET встроенная функция <xref:System.Web.HttpContext.Request%2A> объекта.  
  
 Используйте <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метод и <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> метод для определения события обратной передачи клиента. Эти методы позволяют функций клиентского скрипта, при вызове, чтобы заставить сервер для обратной передачи страницы. Событие обратной передачи клиента отличается от обратного вызова клиента в том, что веб-страница завершает нормальный жизненный цикл для обработки события обратной передачи клиента.  
  
> [!NOTE]
>  При использовании <xref:System.Web.UI.WebControls.Button> управления и <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> свойству `false`, можно использовать <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метод для возврата клиента обратной передачи событий для <xref:System.Web.UI.WebControls.Button> элемента управления.  
  
 <xref:System.Web.UI.WebControls.Button.OnClientClick%2A> Свойство <xref:System.Web.UI.WebControls.Button> управления <xref:System.Web.UI.WebControls.ImageButton> управления, и <xref:System.Web.UI.WebControls.LinkButton> элемент управления может использоваться для запуска клиентского скрипта.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод <xref:System.Web.UI.ClientScriptManager> класса. Два клиентских сценария определены на странице: `PopupScript`, который отображает предупреждение при загрузке страницы, и `ButtonClickScript`, определяющий клиентский обработчик для HTML-кнопка `onClick` событий.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает ссылку на клиентскую функцию, которая при вызове инициализирует обратный вызов клиента к событию сервера.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Сервер <see cref="T:System.Web.UI.Control" />, обрабатывающий обратные вызовы клиента. Элемент управления должен реализовать интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" /> и предоставить метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Аргумент, передаваемый от клиентского скрипта серверу.  
  
 Метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="clientCallback">Имя клиентского обработчика событий, который принимает результаты успешно выполненного события сервера.</param>
        <param name="context">Клиентский скрипт, оцениваемый на стороне клиента до инициализации обратного вызова. Результат скрипта отправляется обратно клиентскому обработчику событий.</param>
        <summary>Получает ссылку на клиентскую функцию, которая при вызове инициализирует обратный вызов клиента к событию сервера. Клиентская функция для перегруженного метода включает указанный элемент управления, аргумент, клиентский скрипт и контекст.</summary>
        <returns>Имя клиентской функции, осуществляющей обратный вызов клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> Метод выполняет обратный вызов по каналу для сервера, являющегося измененную версию обычного жизненного цикла страницы. Дополнительные сведения см. в разделе [реализация клиента обратные вызовы без обратной передачи](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  При использовании обозревателя Microsoft Internet Explorer (5.0 или более поздней версии), механизм обратного вызова сценарий реализуется с помощью Microsoft.XmlHttp COM-объекта и требуется браузер, чтобы задать выполнение элементов управления ActiveX. В других браузерах используется XMLHttpRequest, с помощью браузера локального объекта модели (DOM). Чтобы проверить, поддерживает ли браузер клиента обратные вызовы, используйте <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> свойство. Чтобы проверить, поддерживает ли браузер XML по протоколу HTTP, используйте <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A> свойство. Оба свойства, доступны через <xref:System.Web.HttpRequest.Browser%2A> свойство встроенная функция ASP.NET <xref:System.Web.HttpContext.Request%2A> объекта.  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод выполняет обратный вызов синхронно с помощью XML по протоколу HTTP. Синхронно посылая данные в сценарии обратного вызова, синхронные обратные вызовы немедленный возврат, а не блокируют браузер. В то же время, в браузере может выполняться без два синхронных обратных вызова. Если второй синхронный обратный вызов инициируется, пока один находится в состоянии ожидания, второй синхронный обратный вызов отменяет первый, и будет возвращать только второй обратного вызова.  
  
 Чтобы асинхронно отправлять данные, используйте одну из перегрузок, принимающих `useAsync` параметра, который является логическое значение, определяющее, это поведение. В асинхронном сценарии можно иметь несколько обратных вызовов, ожидающих; Однако порядок, в котором они возвращаются в соответствии с порядком, в котором они были инициированы не гарантируется.  
  
 Кроме того, эта перегрузка <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод задает функции клиента для обработки случая условие ошибки, созданные <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> метод. Чтобы указать обработчик ошибок обратного вызова клиента, используйте одну из перегрузок, принимающих `clientErrorCallback` параметра.  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> Метод принимает необязательную строку `argument` параметр и возвращает строку. Чтобы передать или получить несколько значений, объединять значения входных данных или выходной строки соответственно.  
  
> [!NOTE]
>  Избегайте использования состояния представления при реализации свойств страницы или элемента управления, которые необходимо обновлять во время операций обратного вызова скрипта. Если свойства должны существовать после запросов страницы, можно использовать состояние сеанса.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать две перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод в сценарии обратного вызова клиента, который увеличивает целых чисел.  
  
 Показаны два механизма обратного вызова; различие между ними является использование класса `context` параметра. Объект `ReceiveServerData1` функция обратного вызова клиента обеспечивается с помощью `context` параметра. Напротив `ReceiveServerData2` функция обратного вызова клиента определяется в `<script>` блок на странице. Объект <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> метод является обработчиком сервера, которая увеличивает значение, которое передается в него и <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> метод возвращает увеличенное значение как строка. Если <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> метод возвращает ошибку, а затем `ProcessCallBackError` функция клиента.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <see cref="T:System.Web.UI.Control" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный элемент управления <see cref="T:System.Web.UI.Control" /> не реализует интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Сервер <see cref="T:System.Web.UI.Control" />, обрабатывающий обратные вызовы клиента. Элемент управления должен реализовать интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" /> и предоставить метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Аргумент, передаваемый от клиентского скрипта серверу.  
  
 Метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="clientCallback">Имя клиентского обработчика событий, который принимает результаты успешно выполненного события сервера.</param>
        <param name="context">Клиентский скрипт, оцениваемый на стороне клиента до инициализации обратного вызова. Результат скрипта отправляется обратно клиентскому обработчику событий.</param>
        <param name="useAsync">
          <see langword="true" /> для выполнения обратного вызова асинхронно; <see langword="false" /> для выполнения обратного вызова синхронно.</param>
        <summary>Получает ссылку на клиентскую функцию, которая при вызове инициализирует обратный вызов клиента к событиям сервера. Клиентская функция для перегруженного метода включает указанный элемент управления, аргумент, клиентский скрипт, контекст и логическое значение.</summary>
        <returns>Имя клиентской функции, осуществляющей обратный вызов клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод требует `useAsync` параметр, который позволяет асинхронно выполнять обратный вызов клиента, задав значение `true`. Версии перегрузки этого метода, не требующие `useAsync` установите значение параметра `false` по умолчанию.  
  
 Дополнительные сведения в этом методе см. заметки для перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <see cref="T:System.Web.UI.Control" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный элемент управления <see cref="T:System.Web.UI.Control" /> не реализует интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">Имя сервера <see cref="T:System.Web.UI.Control" />, обрабатывающего обратный вызов клиента. Элемент управления должен реализовать интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" /> и предоставить метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Аргумент, передаваемый от клиентского скрипта серверу.  
  
 Метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="clientCallback">Имя клиентского обработчика событий, который принимает результаты успешно выполненного события сервера.</param>
        <param name="context">Клиентский скрипт, оцениваемый на стороне клиента до инициализации обратного вызова. Результат скрипта отправляется обратно клиентскому обработчику событий.</param>
        <param name="clientErrorCallback">Имя клиентского обработчика событий, принимающего результат, когда в обработчике событий сервера возникает ошибка.</param>
        <param name="useAsync">
          <see langword="true" /> для выполнения обратного вызова асинхронно; <see langword="false" /> для выполнения обратного вызова синхронно.</param>
        <summary>Получает ссылку на клиентскую функцию, которая при вызове инициализирует обратный вызов клиента к событиям сервера. Клиентская функция для перегруженного метода включает указанную цель, аргумент, клиентский скрипт, контекст, обработчик ошибок и логическое значение.</summary>
        <returns>Имя клиентской функции, осуществляющей обратный вызов клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> принимает `target` строковый параметр, а не <xref:System.Web.UI.Control> параметра. Используйте этот перегруженный метод обратного вызова, чтобы вернуться назад, отличные от строка, содержащая <xref:System.Web.UI.Control.UniqueID%2A> элемента управления.  
  
 Кроме того, эта перегрузка <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод требует `useAsync` и `clientErrorCallback` параметр. `useAsync` Позволяет асинхронно выполнять обратный вызов клиента, задав значение `true`. Версии перегрузки этого метода, не требующие `useAsync` установите значение параметра `false` по умолчанию. `clientErrorCallback` Позволяет определить имя клиентская функция, которая вызывается, если обработчик сервера <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> , возвращает ошибку. Версии перегрузки этого метода, не требующие `clientErrorCallback` параметр значение равно null.  
  
 Дополнительные сведения в этом методе см. заметки для перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать две перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод в сценарии обратного вызова клиента, который увеличивает целых чисел.  
  
 Показаны два механизма обратного вызова; различие между ними является использование класса `context` параметра. Объект `ReceiveServerData1` функция обратного вызова клиента обеспечивается с помощью `context` параметра. Напротив `ReceiveServerData2` функция обратного вызова клиента определяется в `<script>` блок на странице. Объект <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> метод является обработчиком сервера, которая увеличивает значение, которое передается в него и <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> метод возвращает увеличенное значение как строка. Если <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> метод возвращает ошибку, а затем клиентская функция `ProcessCallBackError` вызывается.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Сервер <see cref="T:System.Web.UI.Control" />, обрабатывающий обратные вызовы клиента. Элемент управления должен реализовать интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" /> и предоставить метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Аргумент, передаваемый от клиентского скрипта методу <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> сервера.</param>
        <param name="clientCallback">Имя клиентского обработчика событий, который принимает результаты успешно выполненного события сервера.</param>
        <param name="context">Клиентский скрипт, оцениваемый на стороне клиента до инициализации обратного вызова. Результат скрипта отправляется обратно клиентскому обработчику событий.</param>
        <param name="clientErrorCallback">Имя клиентского обработчика событий, принимающего результат, когда в обработчике событий сервера возникает ошибка.</param>
        <param name="useAsync">
          <see langword="true" /> для выполнения обратного вызова асинхронно; <see langword="false" /> для выполнения обратного вызова синхронно.</param>
        <summary>Получает ссылку на клиентскую функцию, которая при вызове инициализирует обратный вызов клиента к событиям сервера. Клиентская функция для перегруженного метода включает указанный элемент управления, аргумент, клиентский скрипт, контекст, обработчик ошибок и логическое значение.</summary>
        <returns>Имя клиентской функции, осуществляющей обратный вызов клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод требует `useAsync` и `clientErrorCallback` параметр. `useAsync` Позволяет асинхронно выполнять обратный вызов клиента, задав значение `true`. Версии перегрузки этого метода, не требующие `useAsync` установите значение параметра `false` по умолчанию. `clientErrorCallback` Позволяет определить имя клиентская функция, которая вызывается, если обработчик сервера ( <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> метод) возвращает сообщение об ошибке. Версии перегрузки этого метода, не требующие `clientErrorCallback` параметр значение равно null.  
  
 Дополнительные сведения в этом методе см. заметки для перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <see cref="T:System.Web.UI.Control" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный элемент управления <see cref="T:System.Web.UI.Control" /> не реализует интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает ссылку с добавленным <see langword="javascript:" /> в начале, которую можно использовать в клиентском событии для обратной передачи серверу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, обрабатывающий обратную передачу.</param>
        <param name="argument">Параметр, передаваемый серверному элементу управления.</param>
        <summary>Возвращает ссылку, с <see langword="javascript:" /> в начале, которую можно использовать в клиентском событии для обратной передачи серверу указанного элемента управления с указанными аргументами события.</summary>
        <returns>Строка, представляющая вызов JavaScript функции обратной передачи, включающей идентификатор целевого элемента управления и аргументы события.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С помощью <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метод требует элемента управления, который обрабатывает обратной передачи для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейса. Для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейс для <xref:System.Web.UI.Page>, используйте директиву.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> метода. Пользовательский элемент управления `MyControl`, реализующий <xref:System.Web.UI.IPostBackEventHandler> интерфейса. При щелчке элемент привязки HTML на странице <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> будет вызван метод пользовательского элемента управления.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 В следующем примере кода имеет аналогичен предыдущему, но вместо пользовательского элемента управления <xref:System.Web.UI.Page> класс реализует <xref:System.Web.UI.IPostBackEventHandler> интерфейса.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, обрабатывающий обратную передачу.</param>
        <param name="argument">Параметр, передаваемый серверному элементу управления.</param>
        <param name="registerForEventValidation">
          <see langword="true" />, чтобы регистрировать событие обратной передачи для проверки; <see langword="false" />, чтобы не регистрировать событие обратной передачи для проверки.</param>
        <summary>Возвращает ссылку с добавленным <see langword="javascript:" /> в начале, которую можно использовать в клиентском событии для обратной передачи серверу для указанного элемента управления с указанными аргументами события и логическим обозначением, следует ли регистрировать обратную передачу для проверки события.</summary>
        <returns>Строка, представляющая вызов JavaScript функции обратной передачи, включающей идентификатор целевого элемента управления и аргументы события.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С помощью <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метод требует элемента управления, который обрабатывает обратной передачи для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейса. Для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейс для <xref:System.Web.UI.Page>, используйте директиву.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">
          <see cref="T:System.Web.UI.PostBackOptions" />, определяющий обратную передачу.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным экземпляром <see cref="T:System.Web.UI.PostBackOptions" />.</summary>
        <returns>Строка, инициирующая клиентскую обратную передачу (при рассмотрении строки в качестве клиентского скрипта).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейс для <xref:System.Web.UI.Page>, используйте директиву.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Метод может использоваться с <xref:System.Web.UI.WebControls.Button> управления <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> свойство `false`. В этом сценарии <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> клиентскую обратную передачу событий для возвращения метода <xref:System.Web.UI.WebControls.Button> элемента управления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <see cref="T:System.Web.UI.PostBackOptions" /> равно <see langword="null" /></exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления <see cref="T:System.Web.UI.Control" />, обрабатывающий обратную передачу на сервер.</param>
        <param name="argument">Строка необязательных аргументов для передачи элементу управления, обрабатывающему обратную передачу.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным элементом управления, обрабатывающим обратную передачу, и строчным аргументом с дополнительной информацией о событии.</summary>
        <returns>Строка, инициирующая — при рассмотрении ее в качестве скрипта на стороне клиента — обратную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейс для <xref:System.Web.UI.Page>, используйте директиву.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Метод может использоваться с <xref:System.Web.UI.WebControls.Button> управления <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> свойство `false`. В этом сценарии <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> клиентскую обратную передачу событий для возвращения метода <xref:System.Web.UI.WebControls.Button> элемента управления.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метода. Пользовательский элемент управления `MyControl`, реализующий <xref:System.Web.UI.IPostBackEventHandler> интерфейса. При нажатии кнопки на странице <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> будет вызван метод пользовательского элемента управления.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 В следующем примере кода имеет аналогичен предыдущему, но вместо пользовательского элемента управления <xref:System.Web.UI.Page> класс реализует <xref:System.Web.UI.IPostBackEventHandler> интерфейса.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <see cref="T:System.Web.UI.Control" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options">
          <see cref="T:System.Web.UI.PostBackOptions" />, определяющий обратную передачу.</param>
        <param name="registerForEventValidation">
          <see langword="true" /> для регистрации ссылки на событие для проверки; в противном случае — <see langword="false" />.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным объектом <see cref="T:System.Web.UI.PostBackOptions" />. По выбору регистрирует ссылку на событие для проверки.</summary>
        <returns>Строка, инициирующая клиентскую обратную передачу (при рассмотрении строки в качестве клиентского скрипта).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейс для <xref:System.Web.UI.Page> , используйте директиву.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Метод может использоваться с <xref:System.Web.UI.WebControls.Button> управления <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> свойство `false`. В этом сценарии <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> клиентскую обратную передачу событий для возвращения метода <xref:System.Web.UI.WebControls.Button> элемента управления.  
  
 Если `registerForEventValidation` — `true`, <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> вызовы метода <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> метода для регистрации ссылки на событие для проверки с уникальным ИД элемента управления, представляющий клиентский элемент управления, который создает событие.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <see cref="T:System.Web.UI.PostBackOptions" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления <see cref="T:System.Web.UI.Control" />, обрабатывающий обратную передачу на сервер.</param>
        <param name="argument">Строка необязательных аргументов для передачи элементу управления <c>control</c>.</param>
        <param name="registerForEventValidation">
          <see langword="true" /> для регистрации ссылки на событие для проверки; в противном случае — <see langword="false" />.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным элементом управления, обрабатывающим обратную передачу, и строчным аргументом с дополнительной информацией о событии. По выбору регистрирует ссылку на событие для проверки.</summary>
        <returns>Строка, инициирующая — при рассмотрении ее в качестве скрипта на стороне клиента — обратную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейс для <xref:System.Web.UI.Page>, используйте директиву.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Метод может использоваться с <xref:System.Web.UI.WebControls.Button> управления <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> свойство `false`. В этом сценарии <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> клиентскую обратную передачу событий для возвращения метода <xref:System.Web.UI.WebControls.Button> элемента управления.  
  
 Если `registerForEventValidation` имеет значение true, <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> вызовы метода <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> метода для регистрации ссылки на событие для проверки с уникальным ИД элемента управления, представляющий клиентский элемент управления, который создает событие.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <see cref="T:System.Web.UI.Control" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип ресурса.</param>
        <param name="resourceName">Полное имя ресурса в сборке.</param>
        <summary>Возвращает ссылку URL-адреса на ресурс в сборке.</summary>
        <returns>Ссылка URL-адреса на ресурс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> Метод возвращает ссылку URL-адрес ресурса, внедренного в сборку. Возвращаемая ссылка не является URL-кодированием. Ресурсы можно файлов скриптов, изображения или статическим. Необходимо указать тип на основе объекта, который будет осуществлять доступ к ресурсу.  
  
 Веб-ресурс, который зарегистрирован на странице однозначно идентифицируется его имя и тип. Страница может быть зарегистрирован только один ресурс с заданным типом и пару "имя". При попытке регистрации ресурса, который уже зарегистрирован создается дубликат зарегистрированного ресурса.  
  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> Метод используется в сочетании с <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> метод для доступа к ресурсам, внедренных в сборки. Дополнительные сведения об использовании ресурсов в приложениях см. в разделе [Общие сведения о ресурсах веб-страницы ASP.NET](http://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd).  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> метода. *Типа* в этом примере имеет параметр типа класса в сборке, содержащей ресурс. `resourceName` Параметр указан полный путь к ресурсу, включающим пространство имен по умолчанию.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 В следующем примере кода показано, как программно применять <xref:System.Web.UI.WebResourceAttribute> атрибут метаданных для отметки сборки для ресурсов, которые будут обслуживаться. Скомпилируйте следующий класс в библиотеке классов пространства имен по умолчанию, равным `Samples.AspNet.CS.Controls` или `Samples.AspNet.VB.Controls`, в зависимости от языка, который вы используете.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 В этом примере требуется файл JavaScript с именем `Script_include.js`. JS-файла, являющегося встроенным ресурсом в сборке, которая содержит `ClientScriptResourceLabel` объекта. Если вы используете Visual Studio], в окне «Свойства» проекта библиотеки классов, задайте **действие при построении** для **внедренный ресурс** при выборе файла скрипта. При компиляции библиотеки из командной строки, используйте параметр для внедрения ресурса.  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Имя веб-ресурса — <see langword="null" />.  
  
 \- или -  
  
 Длина имени веб-ресурса равна 0.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, зарегистрирован ли блок клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ключ блока клиентского скрипта, используемый для поиска.</param>
        <summary>Определяет, зарегистрирован ли блок клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя указанный ключ.</summary>
        <returns>
          <see langword="true" />, если блок клиентского скрипта зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод перед вызовом метода <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод, чтобы исключить регистрацию повторяющиеся скриптов. Это особенно важно, если сценарий требует большой объем серверных ресурсов.  
  
 Клиентский сценарий однозначно идентифицируется ключом и типом. Сценарии с одним и тем же ключом и типом считаются дубликатами.  
  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> метод вызывает перегрузку, принимающую оба `key` и `type` назначить параметр с типом <xref:System.Web.UI.Page> объекта  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип блока клиентского скрипта, используемый для поиска.</param>
        <param name="key">Ключ блока клиентского скрипта, используемый для поиска.</param>
        <summary>Определяет, зарегистрирован ли блок клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя ключ и тип.</summary>
        <returns>
          <see langword="true" />, если блок клиентского скрипта зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод перед вызовом метода <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод, чтобы исключить регистрацию повторяющиеся скриптов. Это особенно важно, если сценарий требует большой объем серверных ресурсов.  
  
 Клиентский сценарий однозначно идентифицируется ключом и типом. Сценарии с одним и тем же ключом и типом считаются дубликатами. Необходимо указать тип на основе объекта, который будет осуществлять доступ к ресурсу. Например при использовании `Page` экземпляр доступа к ресурсам, можно указать `Page` типа.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> метода. Обратите внимание, что, если логика для проверки существующего блок клиентского скрипта были удалены, то не бы два повторяющихся клиентских скриптов в исходный код HTML, отображаемой страницы из-за <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод проверяет наличие дубликатов. Проверка преимущество заключается в сокращении ненужных вычислений.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип клиентского скрипта — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, зарегистрировано ли включение клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ключ включения клиентского скрипта, используемый для поиска.</param>
        <summary>Определяет, зарегистрировано ли включение клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя указанный ключ.</summary>
        <returns>
          <see langword="true" />, если включение клиентского скрипта зарегистрировано; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод перед вызовом метода <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метод, чтобы исключить регистрацию повторяющиеся скриптов. Это особенно важно, если сценарий требует большой объем серверных ресурсов.  
  
 Включение клиентского скрипта однозначно идентифицируется ключом и типом. Сценарии с одним и тем же ключом и типом считаются дубликатами.  
  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> метод вызывает перегрузку, принимающую оба `key` и `type` назначить параметр с типом <xref:System.Web.UI.Page> объекта.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип включения клиентского скрипта, используемый для поиска.</param>
        <param name="key">Ключ включения клиентского скрипта, используемый для поиска.</param>
        <summary>Определяет, зарегистрировано ли включение клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя ключ и тип.</summary>
        <returns>
          <see langword="true" />, если включение клиентского скрипта зарегистрировано; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод перед вызовом метода <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> включает метод, чтобы исключить регистрацию повторяющиеся клиентского скрипта. Это особенно важно, если сценарий требует большой объем серверных ресурсов.  
  
 Включение клиентского скрипта однозначно идентифицируется ключом и типом. Сценарии с одним и тем же ключом и типом считаются дубликатами. Необходимо указать тип на основе объекта, который будет осуществлять доступ к ресурсу. Например, при использовании экземпляра Page для доступа к ресурсу, указывается `Page` типа.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> метода. Обратите внимание, что, если были удалены логику для проверки наличия Включение существующего клиентского скрипта, будут не два повторяющихся клиентских скриптов в исходный код HTML, отображаемой страницы из-за <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метод проверяет наличие дубликатов. Проверка преимущество заключается в сокращении ненужных вычислений.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 В этом примере требуется файл JavaScript с именем `Script_include.js`, со следующим содержимым:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип включения клиентского скрипта — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, зарегистрирован ли оператор OnSubmit с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ключ оператора OnSubmit, используемый для поиска.</param>
        <summary>Определяет, зарегистрирован ли оператор OnSubmit с объектом <see cref="T:System.Web.UI.Page" />, используя указанный ключ.</summary>
        <returns>
          <see langword="true" />, если оператор OnSubmit зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод перед вызовом метода <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метод, чтобы избежать повторяющихся инструкций OnSubmit регистрации. Это особенно важно в том случае, если оператор требует большой объем серверных ресурсов.  
  
 Оператор однозначно идентифицируется ключом и типом. Операторы с тем же ключом и типом считаются дубликатами.  
  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> метод вызывает перегрузку, принимающую оба `key` и `type` назначить параметр с типом <xref:System.Web.UI.Page> объекта  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип оператора OnSubmit, используемый для поиска.</param>
        <param name="key">Ключ оператора OnSubmit, используемый для поиска.</param>
        <summary>Определяет, зарегистрирован ли оператор OnSubmit с объектом <see cref="T:System.Web.UI.Page" />, используя указанные ключ и тип.</summary>
        <returns>
          <see langword="true" />, если оператор OnSubmit зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод перед вызовом метода <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метод, чтобы исключить регистрацию повторяющихся инструкций. Это особенно важно в том случае, если оператор требует большой объем серверных ресурсов.  
  
 Оператор однозначно идентифицируется ключом и типом. Операторы с тем же ключом и типом считаются дубликатами. Необходимо указать тип на основе объекта, который будет осуществлять доступ к ресурсу. Например при использовании `Page` экземпляр доступа к ресурсам, можно указать `Page` типа.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> метода. Сценарий с именем `OnSubmitScript` зарегистрирован <xref:System.Web.UI.Page> , чтобы при форму на странице отправке вызывается сценарий.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип оператора OnSubmit — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, зарегистрирован ли скрипт, активизируемый при запуске, с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ключ скрипта, активизируемого при запуске, для поиска.</param>
        <summary>Определяет, зарегистрирован ли скрипт, активизируемый при запуске, с объектом <see cref="T:System.Web.UI.Page" />, используя указанный ключ.</summary>
        <returns>
          <see langword="true" />, если скрипт, активизируемый при запуске, зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод перед вызовом метода <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод, чтобы исключить регистрацию повторяющиеся скриптов. Это особенно важно, если сценарий требует большой объем серверных ресурсов.  
  
 Сценарий запуска однозначно идентифицируется ключом и типом. Сценарии с одним и тем же ключом и типом считаются дубликатами.  
  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> метод вызывает перегрузку, которая принимает строку в обоих `key` и `type` назначить параметр с типом <xref:System.Web.UI.Page> объекта  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип скрипта запуска, используемый при поиске.</param>
        <param name="key">Ключ скрипта, активизируемого при запуске, для поиска.</param>
        <summary>Определяет, зарегистрирован ли скрипт, активизируемый при запуске, с объектом <see cref="T:System.Web.UI.Page" />, используя указанные ключ и тип.</summary>
        <returns>
          <see langword="true" />, если скрипт, активизируемый при запуске, зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод перед вызовом метода <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод, чтобы исключить регистрацию повторяющиеся скриптов. Это особенно важно, если сценарий требует большой объем серверных ресурсов.  
  
 Клиентский сценарий запуска однозначно идентифицируется ключом и типом. Сценарии с одним и тем же ключом и типом считаются дубликатами.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> метода. Обратите внимание, что, если логика для проверки существующего стартовый блок скрипта были удалены, то не бы два повторяющихся запуска скрипта в исходный код HTML, отображаемой страницы из-за <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод проверяет наличие дубликатов. Проверка преимущество заключается в сокращении ненужных вычислений.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип скрипта, активизируемого при запуске, — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Имя массива для регистрации.</param>
        <param name="arrayValue">Значение или значения массива для регистрации.</param>
        <summary>Регистрирует объявление массива JavaScript с объектом <see cref="T:System.Web.UI.Page" />, используя имя массива и значение массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> Проверяет, существует ли зарегистрированный массив с тем же именем, как имя, указанное в `arrayName` параметр и если да, добавляет значения, указанные в `arrayValue` параметра. Так как базовый механизм хранения основана на <xref:System.Collections.ArrayList>, дубликаты разрешены. Если зарегистрированный массив с тем же именем, что `arrayName` параметр не существует, оно создается и значения в `arrayValue` добавляется параметр.  
  
 Если строковые литералы результирующего массива JavaScript, используйте одиночные кавычки (') или двойные кавычки в escape-последовательность (\\») в `arrayValue` параметра. Значение `arrayValue` параметр должен быть один элемент. Если более одного значения должен быть добавлен в массив, сделать несколько вызовов с помощью <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> и <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> методы. В примере регистрируется массив и скрытые значения и определяет `OnClick` событие `<input>` кнопку, чтобы вычислить сумму двух значений массива и скрытого значения.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="arrayName" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого клиентского скрипта.</param>
        <param name="key">Ключ регистрируемого клиентского скрипта.</param>
        <param name="script">Константа регистрируемого клиентского скрипта.</param>
        <summary>Регистрирует клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ и константу скрипта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентский сценарий однозначно идентифицируется ключом и типом. Сценарии с одним и тем же ключом и типом считаются дубликатами. Страница может быть зарегистрирован только один скрипт с заданным типом и пару ключей. При попытке регистрации скрипта, который уже зарегистрирован создается дубликат скрипта.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> метод, чтобы определить, зарегистрирован ли клиентский скрипт с данной пары ключа и типа и избежать ненужной попытки добавления скрипта.  
  
 В этой перегрузке <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод, убедитесь, что в сценарий обеспечивается `script` параметра упаковывается в `<script>` блока элементов.  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Метод добавляет блок скрипта в верхнюю часть отображаемой страницы. Блоки скриптов не обязательно будут выводиться в порядке, в котором они зарегистрированы. Если важен порядок блоков сценария, используйте <xref:System.Text.StringBuilder> объекта для сбора скриптов вместе на одной строке, а затем зарегистрировать их в один блок клиентского скрипта.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метода.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого клиентского скрипта.</param>
        <param name="key">Ключ регистрируемого клиентского скрипта.</param>
        <param name="script">Константа регистрируемого клиентского скрипта.</param>
        <param name="addScriptTags">Логическое значение, указывающее, требуется ли добавление тегов скрипта.</param>
        <summary>Регистрирует клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ, константу скрипта и логическое значение, указывающее следует ли добавление тегов скрипта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентский сценарий однозначно идентифицируется ключом и типом. Сценарии с одним и тем же ключом и типом считаются дубликатами. Страница может быть зарегистрирован только один скрипт с заданным типом и пару ключей. При попытке регистрации скрипта, который уже зарегистрирован создается дубликат скрипта.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> метод, чтобы определить, зарегистрирован ли клиентский скрипт с данной пары ключа и типа. Это позволяет избежать ненужной попытки добавления скрипта.  
  
 В этой перегрузке <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод, можно указать, предоставлен ли скрипт в `script` параметра заключается в оболочку с `<script>` блока элементов с помощью `addScriptTags` параметра. Установка `addScriptTags` для `true` указывает, что теги сценариев будет автоматически добавляться.  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Метод добавляет блок скрипта в верхнюю часть отображаемой страницы. Блоки скриптов не обязательно будут выводиться в порядке, в котором они зарегистрированы. Если важен порядок блоков сценария, используйте <xref:System.Text.StringBuilder> объекта для сбора скриптов вместе на одной строке, а затем зарегистрировать их в один блок клиентского скрипта.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метода. Обратите внимание, что `addScriptTags` параметра равным `true` так что начальный и закрывающий теги скрипта не включены `script` параметра.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип блока клиентского скрипта — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует включение клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ключ регистрируемого включения клиентского скрипта.</param>
        <param name="url">URL-адрес регистрируемого включения клиентского скрипта.</param>
        <summary>Регистрирует клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />, используя ключ и URL-адрес, который позволяет вызывать скрипт из клиента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Включение клиентского скрипта однозначно идентифицируется ключом и типом. Сценарии с одним и тем же ключом и типом считаются дубликатами. Страница может быть зарегистрирован только один скрипт с заданным типом и пару ключей. При попытке регистрации скрипта, который уже зарегистрирован создается дубликат скрипта.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> метод для определения включение клиентского скрипта с помощью данного ключа и типа пары уже зарегистрирован и избежать ненужной попытки добавления скрипта.  
  
> [!NOTE]
>  Чтобы разрешить URL-адрес клиента, используйте <xref:System.Web.UI.Control.ResolveClientUrl%2A> метод. Этот метод использует контекст URL-адрес, на котором он вызван для разрешения пути.  
  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метод вызывает перегрузку, которая принимает `key`, `URL`и `type` параметра.  
  
 Метод добавляет блок скрипта в верхней части отображаемой страницы.  
  
   
  
## Examples  
 Дополнительные сведения, включая синтаксис, использование и пример см. в разделе <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого включения клиентского скрипта.</param>
        <param name="key">Ключ регистрируемого включения клиентского скрипта.</param>
        <param name="url">URL-адрес регистрируемого включения клиентского скрипта.</param>
        <summary>Регистрирует включение клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ и URL-адрес.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> принимает *ключ* и *URL-адрес* параметры для определения скрипта, а также `type` включать параметр, чтобы указать идентификатор клиентского скрипта. Необходимо указать тип на основе объекта, который будет осуществлять доступ к ресурсу. Например при использовании `Page` экземпляр доступа к ресурсам, можно указать `Page` типа.  
  
> [!NOTE]
>  Чтобы разрешить URL-адрес клиента, используйте <xref:System.Web.UI.Control.ResolveClientUrl%2A> метод. Этот метод использует контекст URL-адрес, на котором он вызван для разрешения пути.  
  
 Этот метод добавляет блок скрипта в верхней части отображаемой страницы.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метода. Обратите внимание, что если были удалены логику для проверки наличия Включение существующего клиентского скрипта, будут по-прежнему не повторяющихся клиентских скриптов в отображаемой странице из-за <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метод проверяет наличие дубликатов. Проверка преимущество заключается в сокращении ненужных вычислений.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 В этом примере требуется файл JavaScript с именем и со следующим содержимым:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип включения клиентского скрипта — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">URL-адрес имеет значение <see langword="null" />.  
  
 \- или -  
  
 URL пуст.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого ресурса клиентского скрипта.</param>
        <param name="resourceName">Имя регистрируемого ресурса клиентского скрипта.</param>
        <summary>Регистрирует ресурс клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя тип и имя ресурса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> Метод используется, когда доступ к ресурсам в компиляции из сборок посредством обработчика WebResource.axd HTTP. <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> Метод регистрирует скрипт с <xref:System.Web.UI.Page> объекта и запрещает повторяющиеся сценариев. Этот метод обертывает содержимое URL-адрес ресурса с `<script>` блока элементов.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> метода.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 В следующем примере кода показано, как программно применять <xref:System.Web.UI.WebResourceAttribute> атрибут метаданных для отметки сборки для ресурсов, которые будут обслуживаться.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 В этом примере требуется файл JavaScript с именем `Script_include.js`, со следующим содержимым:  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 Скомпилируйте `Script_include.js` файл в качестве ресурса в `Samples.AspNet.CS.Controls` сборки, содержащей `ClientScriptResourceLabel` класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Имя клиентского ресурса — <see langword="null" />.  
  
 \- или -  
  
 Длина имени клиентского ресурса равна 0.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует пару "имя-значение" как пользовательский (expando) атрибут указанного элемента управления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId">Элемент управления <see cref="T:System.Web.UI.Control" /> на странице, содержащей пользовательский атрибут.</param>
        <param name="attributeName">Имя регистрируемого пользовательского атрибута.</param>
        <param name="attributeValue">Значение пользовательского атрибута.</param>
        <summary>Регистрирует пару "имя-значение" как пользовательский (expando) атрибут указанного элемента управления с указанными идентификатором, именем атрибута и значением атрибута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Метод регистрирует пару имя значение как пользовательский (expando) атрибут в указанном <xref:System.Web.UI.Control>. Атрибут expando динамически задать в коде JavaScript для сохранения совместимости XHTML разметки Отрисованный элемент управления. Escape-кавычек и пользовательский (expando) атрибут значения. Если вы не хотите запретить использование кавычек и символов обратной косой черты, вызовите <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> перегрузки метода и задайте `encode` параметр `false`.  
  
 Если атрибут expando не обнаружен или элемент управления для добавления атрибута expando, клиентский скрипт по-прежнему создается, но это не повлияет на элементе управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId">Элемент управления <see cref="T:System.Web.UI.Control" /> на странице, содержащей пользовательский атрибут.</param>
        <param name="attributeName">Имя регистрируемого пользовательского атрибута.</param>
        <param name="attributeValue">Значение пользовательского атрибута.</param>
        <param name="encode">Логическое значение, указывающее будет ли кодироваться регистрируемый пользовательский атрибут.</param>
        <summary>Регистрирует пару "имя-значение" как пользовательский (expando) атрибут указанного элемента управления с указанными идентификатором, именем атрибута, значением атрибута и логическим значением, определяющим, будет ли кодироваться значение атрибута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Метод регистрирует пару имя значение как пользовательский (expando) атрибут в указанном <xref:System.Web.UI.Control>. Атрибут expando динамически задать в коде JavaScript для сохранения совместимости XHTML разметки Отрисованный элемент управления. Задать `encode` параметр `true` для экранирования кавычек и значение атрибута expando.  
  
 Если атрибут expando не обнаружен или элемент управления для добавления атрибута expando, клиентский скрипт по-прежнему создается, но это не повлияет на элементе управления.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> метод <xref:System.Web.UI.ClientScriptManager> класса. Клиентский сценарий в отображаемой странице наборы `title` атрибут `<span>` элемента.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует ссылку на событие для проверки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Уникальный ИД, представляющий клиентский элемент управления, генерирующий событие.</param>
        <summary>Регистрирует ссылку на событие для проверки с уникальным ИД элемента управления, представляющим клиентский элемент управления, генерирующий событие.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения и примеры см. в разделе <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метод.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метод и <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> метода для регистрации обратного вызова для проверки, а также способы проверки, что был начат обратного вызова со страницы.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">Объект <see cref="T:System.Web.UI.PostBackOptions" />, определяющий, как создается клиентский скрипт JavaScript для инициации обратной передачи.</param>
        <summary>Регистрирует ссылку на событие для проверки с <see cref="T:System.Web.UI.PostBackOptions" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения и примеры см. в разделе <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Уникальный ИД, представляющий клиентский элемент управления, генерирующий событие.</param>
        <param name="argument">Аргументы события, переданные вместе с клиентским событием.</param>
        <summary>Регистрирует ссылку на событие для проверки с уникальным ИД элемента управления, представляющим клиентский элемент управления, генерирующий событие, и аргументами события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метод и <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> метода для регистрации обратного вызова для проверки и проверить, что был начат обратного вызова со страницы. Для улучшения проверки, показано в примере, можно изменить проверки `argument` параметр, содержащий сведения, относящиеся к пользователю, например удостоверение или роль.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метода для регистрации обратного вызова для проверки.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод вызывается до метода <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Имя регистрируемого скрытого поля.</param>
        <param name="hiddenFieldInitialValue">Начальное значение регистрируемого поля.</param>
        <summary>Регистрирует скрытое значение с объектом <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> Метод создает скрытый `<input>` элемент на этой странице HTML.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> и <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> методы. В примере регистрируется массив и скрытые значения и определяет `OnClick` событие `<input>` кнопку, чтобы вычислить сумму двух значений массива и скрытого значения.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="hiddenFieldName" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого оператора OnSubmit.</param>
        <param name="key">Ключ регистрируемого оператора OnSubmit.</param>
        <param name="script">Константа скрипта регистрируемого оператора OnSubmit.</param>
        <summary>Регистрирует оператор OnSubmit с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ и константу скрипта. Оператор выполняется, если <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> представляется на рассмотрение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Оператор OnSubmit однозначно идентифицируется ключом и типом. Операторы с тем же ключом и типом считаются дубликатами. Страница может быть зарегистрирован только один оператор с заданным типом и пару ключей. При попытке регистрации инструкцию, которая уже зарегистрирована не создает дубликат оператора.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> метод, чтобы определить, является ли оператор OnSubmit уже зарегистрирован с данной пары ключа и типа и избежать ненужной попытки добавления скрипта.  
  
 `script` Параметр <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метод может содержать несколько команд скриптов, при условии, что они правильно разделенные точкой с запятой (;).  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> Добавляет скрипт, который выполняется перед отправкой страницы и дает возможность отменить отправку.  
  
 Дополнительные сведения о HTML-форм и `OnSubmit` см. в разделе [веб-сайте консорциума World Wide Web (W3C)](http://go.microsoft.com/fwlink/?linkid=37125).  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метода.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует скрипт, активизируемый при запуске, с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого скрипта, активизируемого при запуске.</param>
        <param name="key">Ключ регистрируемого скрипта, активизируемого при запуске.</param>
        <param name="script">Константа регистрируемого скрипта, активизируемого при запуске.</param>
        <summary>Регистрирует скрипт, активизируемый при запуске, с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ и константу скрипта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентский сценарий однозначно идентифицируется ключом и типом. Сценарии с одним и тем же ключом и типом считаются дубликатами. Страница может быть зарегистрирован только один скрипт с заданным типом и пару ключей. При попытке регистрации скрипта, который уже зарегистрирован создается дубликат скрипта.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> способ определить ли уже зарегистрирован сценарий запуска с данной пары ключа и типа и избежать ненужной попытки добавления скрипта.  
  
 В этой перегрузке <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод, убедитесь, что в сценарий обеспечивается `script` параметра заключается в оболочку с `<script>` блока элементов.  
  
 Блок сценария, добавленные <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод выполняется, когда страница уже загружена, но до передачи страницы <xref:System.Web.UI.Control.OnLoad%2A> события. Блоки скриптов не обязательно будут выводиться в порядке, в котором они зарегистрированы. Если важен порядок блоков сценария, используйте <xref:System.Text.StringBuilder> объекта для сбора скриптов вместе на одной строке, а затем зарегистрировать их в один блок клиентского скрипта.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метода. Обратите внимание, что начальный и закрывающий теги сценариев включаются в `script` параметра. Чтобы скрипт теги добавленные на основе параметра дополнительный параметр в разделе <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого скрипта, активизируемого при запуске.</param>
        <param name="key">Ключ регистрируемого скрипта, активизируемого при запуске.</param>
        <param name="script">Константа регистрируемого скрипта, активизируемого при запуске.</param>
        <param name="addScriptTags">Логическое значение, указывающее, требуется ли добавление тегов скрипта.</param>
        <summary>Регистрирует клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ, константу скрипта и логическое значение, указывающее следует ли добавлять теги скрипта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сценарий запуска однозначно идентифицируется ключом и типом. Сценарии с одним и тем же ключом и типом считаются дубликатами. Страница может быть зарегистрирован только один скрипт с заданным типом и пару ключей. При попытке регистрации скрипта, который уже зарегистрирован создается дубликат скрипта.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> способ определить ли уже зарегистрирован сценарий запуска с данной пары ключа и типа и избежать ненужной попытки добавления скрипта.  
  
 В этой перегрузке <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод, можно указать, предоставлен ли скрипт в `script` параметра заключается в оболочку с `<script>` блока элементов с помощью `addScriptTags` параметра. Установка `addScriptTags` для `true` указывает, что теги сценариев будет автоматически добавляться.  
  
 Блок сценария, добавленные <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод выполняется, когда страница уже загружена, но до передачи страницы <xref:System.Web.UI.Control.OnLoad%2A> события. Блоки скриптов не обязательно будут выводиться в порядке, в котором они зарегистрированы. Если важен порядок блоков сценария, используйте <xref:System.Text.StringBuilder> объекта для сбора скриптов вместе на одной строке, а затем зарегистрировать их в один блок клиентского скрипта.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метода. Обратите внимание, что `addScriptTags` параметра равным `false` так что начальный и закрывающий теги скрипта не включены `script` параметра.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Проверяет клиентское событие.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Уникальный ИД, представляющий клиентский элемент управления, генерирующий событие.</param>
        <summary>Проверяет клиентское событие, зарегистрированное для проверки, используя метод <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Уникальный ИД, представляющий клиентский элемент управления, генерирующий событие.</param>
        <param name="argument">Аргументы события, переданные вместе с клиентским событием.</param>
        <summary>Проверяет клиентское событие, зарегистрированное для проверки, используя метод <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метод и <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> метода для регистрации обратного вызова для проверки и проверить, что был начат обратного вызова со страницы. Для улучшения проверки, показанный здесь, можно изменить проверки `argument` параметр, содержащий сведения, относящиеся к пользователю, например удостоверение или роль.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="uniqueId" /> имеет значение <see langword="null" /> или равен пустой строке ("").</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>