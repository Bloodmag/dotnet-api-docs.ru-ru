<Type Name="Page" FullName="System.Web.UI.Page">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="57ad865c267961e0b64c7a4656688a27eb6c1487" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34311418" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Page : System.Web.UI.TemplateControl, System.Web.IHttpHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Web.UI.TemplateControl implements class System.Web.IHttpHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Page" />
  <TypeSignature Language="VB.NET" Value="Public Class Page&#xA;Inherits TemplateControl&#xA;Implements IHttpHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class Page : System::Web::UI::TemplateControl, System::Web::IHttpHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.TemplateControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.IHttpHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.WebFormCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.TypeCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Web.WebForms.WebFormDesigner, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("ASPXCodeBehind")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет ASCX-файл, также называемый страницей веб-форм, запрашиваемый с сервера, на котором размещается веб-приложение ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page> Класс связывается с файлами, имеющими расширение .aspx. Эти файлы компилируются во время выполнения как <xref:System.Web.UI.Page> объектов и кэшируются в памяти сервера.  
  
 Если вы хотите создать страницу Web Forms, используя метод кода, являются производными от этого класса. Конструкторы быстрой разработка приложений (RAD), таких как Microsoft Visual Studio автоматически использовать эту модель для создания страницы веб-форм.  
  
 <xref:System.Web.UI.Page> Объекта служит контейнером для всех серверных элементов управления на странице, за исключением тех, которые реализуют <xref:System.Web.UI.INamingContainer> интерфейс или дочерние элементы элементов управления, реализующих этот интерфейс.  
  
 <xref:System.Web.UI.Page> Элемент управления, который выступает в качестве пользовательского интерфейса для веб-приложения и таким образом следует проверять на вносить убедитесь, что рекомендации за написание безопасного кода и защите приложений. Общие сведения об этих темах см. в разделе [Общие сведения о безопасности приложения Web угроз](http://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a), [NIB: рекомендации по обеспечению безопасности политики](http://msdn.microsoft.com/library/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05), и [основные понятия безопасности](~/docs/standard/security/key-security-concepts.md). Дополнительные сведения см. в разделе [защита стандартных элементов управления](http://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8), [как: ошибках](http://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa), [как: защита от скриптов в веб-приложении путем применения HTML К строкам кодирование](http://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b), и [введение в проверяющие элементы управления](http://msdn.microsoft.com/library/3c0e7514-cff2-4bed-936d-ee3f7b740190).  
  
   
  
## Examples  
 Проект Visual Studio Web сайта с исходным кодом доступен по следующему адресу: [загрузить](http://go.microsoft.com/fwlink/?LinkId=192425).  
  
 В следующем примере кода показано, как <xref:System.Web.UI.Page> класс используется модель страницы с выделенным кодом. Обратите внимание, что в файле исходного кода объявляет разделяемый класс, наследующий от базового класса страницы. Базовый класс страницы может быть <xref:System.Web.UI.Page>, или он может быть другой класс, производный от <xref:System.Web.UI.Page>. Кроме того Обратите внимание, что разделяемый класс позволяет использовать элементы управления на странице, без необходимости определять их как элементы поля файл кода.  
  
 [!code-csharp[System.Web.UI.Page_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx.cs#2)]
 [!code-vb[System.Web.UI.Page_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx.vb#2)]  
  
 В следующем примере кода показан файл .aspx, соответствующий выше файл исходного кода.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx#1)]  
  
 Необходимо использовать директиву и использовать `Inherits` и `CodeFile` атрибуты, чтобы связать файл кода ASPX-файл. В этом примере `Inherits` атрибут указывает `MyCodeBehind` класса и `CodeFile` атрибут указывает путь к файлу конкретного языка, которая содержит класс.  
  
 В следующем примере кода демонстрируется модель веб-архива и как получить доступ к <xref:System.Web.UI.Page.IsPostBack%2A> свойство и <xref:System.Web.UI.Page.Response%2A> свойство <xref:System.Web.UI.Page>.  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/vb/pageexample.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Page();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструктор по умолчанию инициализирует все поля значениями по умолчанию.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddContentTemplate">
      <MemberSignature Language="C#" Value="protected internal void AddContentTemplate (string templateName, System.Web.UI.ITemplate template);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddContentTemplate(string templateName, class System.Web.UI.ITemplate template) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddContentTemplate(System.String,System.Web.UI.ITemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddContentTemplate (templateName As String, template As ITemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddContentTemplate(System::String ^ templateName, System::Web::UI::ITemplate ^ template);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="templateName" Type="System.String" />
        <Parameter Name="template" Type="System.Web.UI.ITemplate" />
      </Parameters>
      <Docs>
        <param name="templateName">Имя добавляемого шаблона содержимого.</param>
        <param name="template">Шаблон содержимого.</param>
        <summary>Вызывается во время инициализации страницы для создания коллекции содержимого (из элементов управления содержимым), передаваемого эталонной странице, если текущая страница или эталонная страница ссылаются на эталонную страницу.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">Шаблон содержимого с этим именем уже существует.</exception>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOnPreRenderCompleteAsync">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует делегаты обработчика начального и конечного событий для асинхронной страницы.</summary>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOnPreRenderCompleteAsync (beginHandler As BeginEventHandler, endHandler As EndEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOnPreRenderCompleteAsync(System::Web::BeginEventHandler ^ beginHandler, System::Web::EndEventHandler ^ endHandler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
      </Parameters>
      <Docs>
        <param name="beginHandler">Делегат для метода <see cref="T:System.Web.BeginEventHandler" />.</param>
        <param name="endHandler">Делегат для метода <see cref="T:System.Web.EndEventHandler" />.</param>
        <summary>Регистрирует делегаты, не требующих информации о состоянии, обработчика начального и конечного событий для асинхронной страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> метод для добавления обработчиков асинхронных веб-странице.  
  
 Можно зарегистрировать несколько асинхронных обработчиков; Тем не менее одновременно выполняется только один обработчик. Если вы хотите одновременно обрабатывать несколько асинхронных методов, следует использовать один <xref:System.Web.BeginEventHandler> метод и запустить несколько асинхронных операций в этом обработчике.  
  
 Асинхронные обработчики вызываются между <xref:System.Web.UI.Control.PreRender> и <xref:System.Web.UI.Page.PreRenderComplete> события.  
  
 Во-первых, все <xref:System.Web.UI.Page> события (через <xref:System.Web.UI.Control.PreRender> событий) выполнения и затем каждый зарегистрированных <xref:System.Web.BeginEventHandler> вызывается метод. Обработчик завершения, соответствующий <xref:System.Web.EndEventHandler> вызывается метод. Если есть несколько асинхронных обработчиков, вызывается следующий обработчик.  
  
 После вызова зарегистрированные асинхронные обработчики событий вызываются остальная часть событий страницы, начиная с версии <xref:System.Web.UI.Page.PreRenderComplete> событий.  
  
   
  
## Examples  
 В следующем примере кода используется выполнение асинхронного запроса для отображения исходного кода HTML страницы по умолчанию на локальном веб-сервере в <xref:System.Web.UI.WebControls.TextBox> элемента управления.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Директива <see langword="&lt;async&gt;" /> страницы не установлена в <see langword="true" />.  \- или - Метод <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> вызывается после события <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> или <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </Member>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOnPreRenderCompleteAsync (beginHandler As BeginEventHandler, endHandler As EndEventHandler, state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOnPreRenderCompleteAsync(System::Web::BeginEventHandler ^ beginHandler, System::Web::EndEventHandler ^ endHandler, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginHandler">Делегат для метода <see cref="T:System.Web.BeginEventHandler" />.</param>
        <param name="endHandler">Делегат для метода <see cref="T:System.Web.EndEventHandler" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии обработчиков событий.</param>
        <summary>Регистрирует делегаты обработчика начального и конечного событий для асинхронной страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> метод для добавления обработчиков, которые требуются сведения о состоянии асинхронного веб-странице. Объект, передаваемый в `state` параметр может быть любой объект, который приложение требует передачи информации между делегатов обработчиков событий, указанного в `beginHandler` и `endHandler` параметров.  
  
 Можно зарегистрировать несколько асинхронных обработчиков; Тем не менее одновременно выполняется только один обработчик. Если вы хотите одновременно обрабатывать несколько асинхронных методов, следует использовать один <xref:System.Web.BeginEventHandler> метод и запустить несколько асинхронных операций в этом обработчике.  
  
 Асинхронные обработчики вызываются между <xref:System.Web.UI.Control.PreRender> и <xref:System.Web.UI.Page.PreRenderComplete> события.  
  
 Во-первых, все <xref:System.Web.UI.Page> события (через <xref:System.Web.UI.Control.PreRender> событий) выполнения и затем каждый зарегистрированных <xref:System.Web.BeginEventHandler> вызывается метод. Обработчик завершения, соответствующий <xref:System.Web.EndEventHandler> вызывается метод. Если есть несколько асинхронных обработчиков, вызывается следующий обработчик.  
  
 После вызова зарегистрированные асинхронные обработчики событий вызываются остальная часть событий страницы, начиная с версии <xref:System.Web.UI.Page.PreRenderComplete> событий.  
  
   
  
## Examples  
 В следующем примере кода используется выполнение асинхронного запроса для отображения исходного кода HTML страницы по умолчанию на локальном веб-сервере в <xref:System.Web.UI.WebControls.TextBox> элемента управления.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Директива <see langword="&lt;async&gt;" /> страницы не установлена в <see langword="true" />.  \- или - Метод <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> вызывается после события <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> или <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected internal void AddWrappedFileDependencies (object virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddWrappedFileDependencies(object virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddWrappedFileDependencies(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddWrappedFileDependencies (virtualFileDependencies As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddWrappedFileDependencies(System::Object ^ virtualFileDependencies);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">Объект <see cref="T:System.Object" />, содержащий список имен файлов.</param>
        <summary>Добавляет список зависимых файлов, составляющих текущую страницу. Класс используется внутри платформы страницы ASP.NET и не предназначен для использования в коде.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.AddWrappedFileDependencies%2A> Метод добавляет список файлов, таких как файлы пользовательских элементов управления, составляющих текущую страницу. Если любой из этих страниц изменяется, вся страница компилируется в следующий раз, когда он запрашивается. Этот метод поддерживает инфраструктуру .NET Framework и не предназначен для использования непосредственно из программного кода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.HttpApplicationState" /> для текущего веб-запроса.</summary>
        <value>Текущие данные в классе <see cref="T:System.Web.HttpApplicationState" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page.Application_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Application_Sample1/CS/applicationcs.aspx#1)]
 [!code-vb[Page.Application_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Application_Sample1/VB/applicationvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpApplicationState" />
      </Docs>
    </Member>
    <Member MemberName="AspCompatBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AspCompatBeginProcessRequest (System.Web.HttpContext context, AsyncCallback cb, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AspCompatBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback cb, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function AspCompatBeginProcessRequest (context As HttpContext, cb As AsyncCallback, extraData As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IAsyncResult ^ AspCompatBeginProcessRequest(System::Web::HttpContext ^ context, AsyncCallback ^ cb, System::Object ^ extraData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="cb" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">Объект <see cref="T:System.Web.HttpContext" /> с информацией о текущем запросе.</param>
        <param name="cb">Метод обратного вызова.</param>
        <param name="extraData">Дополнительные данные, необходимые для обработки запроса таким же образом, как в ASP.</param>
        <summary>Инициирует запрос на ресурсы Active Server Page (ASP). Метод, предоставляется для совместимости с предыдущими приложениями ASP.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не следует вызывать.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AspCompatEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AspCompatEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatEndProcessRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AspCompatEndProcessRequest (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AspCompatEndProcessRequest(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Страница ASP, созданная по запросу.</param>
        <summary>Завершает запрос на ресурсы Active Server Page (ASP). Метод, предоставляется для совместимости с предыдущими приложениями ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не следует вызывать.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatMode">
      <MemberSignature Language="C#" Value="protected bool AspCompatMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AspCompatMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AspCompatMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property AspCompatMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AspCompatMode { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает значение, указывающее, может ли страница выполняться в однопотоковом апартаменте.</summary>
        <value>
          <see langword="true" />, если страница поддерживает код Active Server Pages (ASP); в противном случае ─ <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если задано значение `true`, это свойство позволяет странице выполняться в потоке однопотокового подразделения (STA). Это позволяет странице вызывать STA компонентов, таких как компоненты, разработанные с помощью Visual Basic 6.0. Присвоение этому свойству `true` также позволяет странице вызывать компоненты COM +, которым требуется доступ к неуправляемым встроенным объектам ASP. Они доступны через ВНУТРЕННИЙ `ObjectContext` объекта или `OnStartPage` метод.  
  
 В большинстве случаев это свойство не задано в коде. Задать `aspcompat` атрибут `true` с помощью директивы в ASPX-файле. При запросе страницы динамически создаваемый класс задает свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncMode">
      <MemberSignature Language="C#" Value="protected bool AsyncMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsyncMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property AsyncMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AsyncMode { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, как обрабатывается страница ─ синхронно или асинхронно.</summary>
        <value>Значение <see langword="true" />, если страница обрабатывается асинхронно; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.AsyncMode%2A> Свойство задается <xref:System.Web.UI.Page> средство синтаксического анализа при генерации кода для страницы. Используйте `Async` атрибута в директиве задайте соответствующее значение.  
  
 Асинхронные страницы не работают при `AspCompat` атрибута задано значение `true` или `Transaction` атрибута задано значение, отличное от `Disabled` в директиве.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AsyncPageBeginProcessRequest (System.Web.HttpContext context, AsyncCallback callback, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AsyncPageBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback callback, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function AsyncPageBeginProcessRequest (context As HttpContext, callback As AsyncCallback, extraData As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IAsyncResult ^ AsyncPageBeginProcessRequest(System::Web::HttpContext ^ context, AsyncCallback ^ callback, System::Object ^ extraData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">Информация <see cref="T:System.Web.HttpContext" /> для запроса.</param>
        <param name="callback">Метод обратного вызова для оповещении об окончании процесса.</param>
        <param name="extraData">Данные о состоянии для асинхронного метода.</param>
        <summary>Начинает обработку запроса асинхронной страницы.</summary>
        <returns>Класс <see cref="T:System.IAsyncResult" />, ссылающийся на асинхронный запрос.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AsyncPageEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AsyncPageEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageEndProcessRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AsyncPageEndProcessRequest (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AsyncPageEndProcessRequest(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Класс <see cref="T:System.IAsyncResult" />, ссылающийся на отложенный асинхронный запрос.</param>
        <summary>Заканчивает обработку запроса асинхронной страницы.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan AsyncTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AsyncTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan AsyncTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее лимит времени при обработке асинхронных задач.</summary>
        <value>Объект <see cref="T:System.TimeSpan" />, содержащий разрешенный временной интервал для асинхронной задачи. Значение интервала по умолчанию составляет 45 секунд.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронный лимит времени страницы представляет количество времени, страница будет ожидать выполнения асинхронных задач. В большинстве случаев это свойство не задано в коде. Установка интервала времени ожидания асинхронного страницы с помощью файла конфигурации веб- или в директиве. Значения, заданные в разделе конфигурации страницы перезаписываются директивы страницы.  
  
 Определение асинхронных задач с помощью <xref:System.Web.UI.PageAsyncTask> класса и регистрации начало, завершение и обработчик времени ожидания. Если асинхронная задача не завершается в заданном интервале времени, будет вызван обработчик времени ожидания.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.Page.AsyncTimeout%2A> свойство с <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> и <xref:System.Web.UI.Page.RegisterAsyncTask%2A> методы. Обратите внимание на использование обработчиков начала, окончания и время ожидания. В примере вводится искусственная задержка для демонстрации ситуации асинхронной задачи превышение времени, выделенного для задачи, как указано в <xref:System.Web.UI.Page.AsyncTimeout%2A> свойство. В реальном сценарии асинхронная задача может использоваться для выполнения вызовов базы данных или создания изображений, например, и обработчик тайм-аута предоставляет постепенного ухудшения качества обслуживания, если задача не выполняется в определенное время. Обратите внимание, что <xref:System.Web.UI.Page.AsyncTimeout%2A> в директиве page задано свойство.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Свойству присвоено отрицательное значение.</exception>
        <altmember cref="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
        <altmember cref="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
      </Docs>
    </Member>
    <Member MemberName="AutoPostBackControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control AutoPostBackControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control AutoPostBackControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AutoPostBackControl" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoPostBackControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ AutoPostBackControl { System::Web::UI::Control ^ get(); void set(System::Web::UI::Control ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает страничный элемент управления, используемый для выполнения обратной передачи.</summary>
        <value>Элемент управления, используемый для выполнения обратной передачи.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, буферизуется ли вывод страницы.</summary>
        <value>
          <see langword="true" />, если вывод страницы буферизован; в противном случае ─ <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задать <xref:System.Web.UI.Page.Buffer%2A> атрибут `true` с помощью директивы в ASPX-файле. При запросе страницы динамически создаваемый класс задает свойство.  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.Buffer%2A> Свойство возвращает и задает <xref:System.Web.HttpResponse.BufferOutput%2A> свойства.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.Caching.Cache" />, связанный приложением, в котором находится страница.</summary>
        <value>Объект <see cref="T:System.Web.Caching.Cache" />, связанный с содержащим страницу приложением.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложения <xref:System.Web.Caching.Cache> объект позволяет сохранять и извлекать произвольные данные при последующих запросах. Кэш не связанный с страницы или пользовательского сеанса. Он используется в основном для повышения производительности приложения. Дополнительные сведения см. в разделе [кэширование данных приложений](http://msdn.microsoft.com/library/206f977d-7860-4d20-bdd5-c3b3d8479f3d). Дополнительные сведения о разнице между кэшированием приложения и кэширование вывода страниц см. в разделе [Обзор технологии кэширования ASP.NET](http://msdn.microsoft.com/library/5ec28012-4972-4dc3-b3e8-9d20401fe11d).  
  
   
  
## Examples  
 В следующем примере кода вставляет сумму двух целых чисел в <xref:System.Web.Caching.Cache?displayProperty=nameWithType> с помощью <xref:System.Web.UI.Page.Cache%2A?displayProperty=nameWithType> свойство. Затем извлекается значение с помощью <xref:System.Web.Caching.Cache.Get%2A?displayProperty=nameWithType> метод и записывает его в <xref:System.Web.UI.WebControls.Label> управления веб-сервера.  
  
 [!code-csharp[System.Web.Page.Cache_Replacement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/CS/pagecachecs.aspx#1)]
 [!code-vb[System.Web.Page.Cache_Replacement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/VB/pagecachevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Экземпляр объекта <see cref="T:System.Web.Caching.Cache" /> не создается.</exception>
        <altmember cref="T:System.Web.Caching.Cache" />
      </Docs>
    </Member>
    <Member MemberName="ClientQueryString">
      <MemberSignature Language="C#" Value="public string ClientQueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientQueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientQueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientQueryString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientQueryString { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает часть строки с запрошенным URL-адресом.</summary>
        <value>Возвращает часть строки с запрошенным URL-адресом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.ClientQueryString%2A> Свойство содержит часть строки запроса URL-адрес запроса обозревателем. Например, если запрошенный URL-адрес "http://www.contoso.com/default.aspx?id=100», <xref:System.Web.UI.Page.ClientQueryString%2A> свойство будет содержать «id = 100». <xref:System.Web.UI.Page.ClientQueryString%2A> Свойство кодируется; используйте <xref:System.Web.HttpServerUtility.UrlDecode%2A?displayProperty=nameWithType> метод Декодируемая строка запроса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.ClientScriptManager ClientScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ClientScriptManager ClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientScript" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientScript As ClientScriptManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ClientScriptManager ^ ClientScript { System::Web::UI::ClientScriptManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientScriptManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.UI.ClientScriptManager" />, используемый для управления, регистрации и добавления скрипта к странице.</summary>
        <value>Объект <see cref="T:System.Web.UI.ClientScriptManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.ClientScript%2A> свойства <xref:System.Web.UI.ClientScriptManager> объекта, который может использоваться для управления, зарегистрировать и добавить скрипт на веб-страницу. Дополнительные сведения см. в описании класса <xref:System.Web.UI.ClientScriptManager>.  
  
 <xref:System.Web.UI.ClientScriptManager> Класс впервые появился в [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] и заменяет <xref:System.Web.UI.Page> класса методы для управления сценариями, которые теперь устарели.  
  
   
  
## Examples  
 Пример см. в разделе <xref:System.Web.UI.ClientScriptManager> класс обзорной статье.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="ClientTarget">
      <MemberSignature Language="C#" Value="public string ClientTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientTarget" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientTarget As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientTarget { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, позволяющее переопределить автоматическое обнаружение характеристик браузера и задать способ отображения страницы для конкретного браузера клиента.</summary>
        <value>Значение <see cref="T:System.String" />, задающее переопределяемые характеристики браузера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не установите <xref:System.Web.UI.Page.ClientTarget%2A> свойства <xref:System.Web.HttpBrowserCapabilities> объекта, связанного с <xref:System.Web.UI.Page.Request%2A?displayProperty=nameWithType> свойство отражает возможности клиентского браузера. Если это свойство задано, определение браузера клиента отключено и на странице будут использоваться возможности браузера, связанные со значением (псевдоним), который предоставляется.  
  
 Корневой файл конфигурации Web.config на компьютере веб-сервера определяет следующие псевдонимы по умолчанию, которые можно использовать как сокращенную запись для часто используемых строк пользовательского агента:  
  
-   `uplevel`, который определяет возможности браузера эквивалентные Internet Explorer 6.0.  
  
-   `downlevel`, которое указывает возможности браузера эквивалентные старых браузерах, которые не поддерживают клиентского скрипта. Чтобы определить, каким образом будет работать веб-страницы в браузер, в котором отключен клиентский скрипт можно использовать этот псевдоним.  
  
 Можно задать псевдоним, программно с помощью этого свойства, или можно задать декларативно, используя `ClientTarget` атрибута директивы.  
  
 Можно определить Дополнительные псевдонимы в `clientTarget` раздел файла Web.config уровня приложения. Дополнительные сведения см. в разделе [clientTarget элемент (схема параметров ASP.NET)](http://msdn.microsoft.com/library/17a0fa6e-a065-49cc-b900-ef73eda6a922).  
  
   
  
## Examples  
 В следующем примере кода определяется `ie302` псевдоним и включает разделы, необходимые для настройки приложения в файле Web.config. Используя этот псевдоним, можно задать <xref:System.Web.UI.Page.ClientTarget%2A> свойства `ie302` и настройка страниц специально для браузеров Internet Explorer 3.02.  
  
```  
<configuration>  
  <system.web>  
   <clientTarget>  
    <add alias="ie302" useragent="Mozilla/2.0 (compatible; MSIE 3.02; Windows NT 3.5)" />  
   </clientTarget>  
  </system.web>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public int CodePage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CodePage { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает идентификатор кодовой страницы для текущего объекта <see cref="T:System.Web.UI.Page" />.</summary>
        <value>Целое значение, представляющее идентификатора страницы кода для текущего объекта <see cref="T:System.Web.UI.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задать `CodePage` атрибуту нужное значение с помощью директивы в ASPX-файле. При запросе страницы динамически создаваемый класс задает свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает тип MIME HTTP для объекта <see cref="T:System.Web.HttpResponse" />, связанного со страницей.</summary>
        <value>Тип MIME HTTP, связанный с текущей страницей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задать `ContentType` атрибута с помощью директивы в ASPX-файле. При запросе страницы динамически создаваемый класс задает свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected internal override System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Context" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property Context As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.HttpContext" />, связанный со страницей.</summary>
        <value>Объект <see cref="T:System.Web.HttpContext" />, содержащий связанные с текущей страницей сведения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство обеспечивает программный доступ к контексту, страница выполняется в, включая информацию о запросе, ответ, сеанса и приложения.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Web.UI.Page.Context%2A> свойство для доступа к <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> и <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> методы и <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> свойства. В примере создаются три настраиваемых исключения при помощи <xref:System.Web.HttpContext.AddError%2A> метод и использует <xref:System.Web.HttpContext.AllErrors%2A> свойство для загрузки этих исключений в массив. Он записывает в него массив страницы, содержащей и использует <xref:System.Web.HttpContext.ClearError%2A> метод, чтобы удалить все ошибки <xref:System.Web.UI.Page.Context%2A> свойство.  
  
 [!code-csharp[System.Web.UI.Page.Context#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Context/CS/pagecontextcs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Context#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Context/VB/pagecontextvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriter">
      <MemberSignature Language="C#" Value="protected internal virtual System.Web.UI.HtmlTextWriter CreateHtmlTextWriter (System.IO.TextWriter tw);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Web.UI.HtmlTextWriter CreateHtmlTextWriter(class System.IO.TextWriter tw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateHtmlTextWriter (tw As TextWriter) As HtmlTextWriter" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Web::UI::HtmlTextWriter ^ CreateHtmlTextWriter(System::IO::TextWriter ^ tw);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="tw">Экземпляр класса <see cref="T:System.IO.TextWriter" />, используемый для создания <see cref="T:System.Web.UI.HtmlTextWriter" />.</param>
        <summary>Создает объект <see cref="T:System.Web.UI.HtmlTextWriter" /> для отображения содержимого страницы.</summary>
        <returns>
          <see cref="T:System.Web.UI.HtmlTextWriter" /> или <see cref="T:System.Web.UI.Html32TextWriter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> Метод создает <xref:System.IO.TextWriter> через <xref:System.Web.HttpRequest.Browser%2A> свойство <xref:System.Web.HttpContext.Request%2A> объекта, связанного с запросом к странице. Можно добавить ссылку на <xref:System.Web.UI.HtmlTextWriter> в `browserCaps` раздел конфигурации. Переопределить <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> метод для выполнения выборочного поиска.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> метод для создания экземпляра настраиваемого <xref:System.Web.UI.HtmlTextWriter> объект с именем `MyHtmlTextWriter`. <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> Метод переопределяется в `MyPage` класс, который является производным от <xref:System.Web.UI.Page>, после чего `MyHtmlTextWriter` отображает ASP.NET серверных элементов управления при запросе страницы. Обратите внимание, что в этом примере будет препятствовать адаптера <xref:System.IO.TextWriter> поведение.  
  
 [!code-csharp[Page_CreateHtmlTextWriter#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/CS/page_createhtmltextwriter.cs#2)]
 [!code-vb[Page_CreateHtmlTextWriter#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/VB/page_createhtmltextwriter.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Html32TextWriter" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriterFromType">
      <MemberSignature Language="C#" Value="public static System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType (System.IO.TextWriter tw, Type writerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType(class System.IO.TextWriter tw, class System.Type writerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateHtmlTextWriterFromType (tw As TextWriter, writerType As Type) As HtmlTextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::HtmlTextWriter ^ CreateHtmlTextWriterFromType(System::IO::TextWriter ^ tw, Type ^ writerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
        <Parameter Name="writerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="tw">Экземпляр класса <see cref="T:System.IO.TextWriter" />, используемый для создания <see cref="T:System.Web.UI.HtmlTextWriter" />.</param>
        <param name="writerType">Тип создаваемого компонента для записи текста.</param>
        <summary>Создает указанный объект <see cref="T:System.Web.UI.HtmlTextWriter" /> для отображения содержимого страницы.</summary>
        <returns>Объект <see cref="T:System.Web.UI.HtmlTextWriter" />, отображающий содержимое страницы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется внутренне в адаптерах страниц.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Параметр <paramref name="writerType" /> установлен в недействительный тип.</exception>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public string Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Culture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Culture { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает идентификатор языка и региональных параметров объекта <see cref="T:System.Threading.Thread" />, связанного со страницей.</summary>
        <value>Идентификатор языка и региональных параметров.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задать `Culture` атрибут в директиве в ASPX-файле. При запросе страницы динамически создаваемый класс устанавливает значение этого свойства. Кроме того, можно также задать значение <xref:System.Web.UI.Page.Culture%2A> свойства программным способом или в элементе файла Web.config-файле.  
  
 <xref:System.Web.UI.Page.Culture%2A> Свойство используется для локализации содержимого страницы. Можно задать идентификатор любой допустимый язык и региональные параметры. Например `en-us` идентификатор языка и региональных параметров задается страницы для американского английского языка, время `fr` идентификатор языка и региональных параметров задает страницу на французский. Можно также присвоить значение `auto` которого будет выполнять автоматическое обнаружение браузера предпочтительный язык и задать для него. Автоматическое обнаружение языка может быть задано со значением по умолчанию, например `auto:en-us`.  
  
 Дополнительные сведения см. в разделе <xref:System.Globalization.CultureInfo> Общие сведения о классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.LCID" />
      </Docs>
    </Member>
    <Member MemberName="DesignerInitialize">
      <MemberSignature Language="C#" Value="public void DesignerInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DesignerInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DesignerInitialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub DesignerInitialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DesignerInitialize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Производит инициализацию экземпляра класса <see cref="T:System.Web.UI.Page" />, необходимую для конструкторов RAD. Этот метод используется только во время разработки.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.UserControl.DesignerInitialize" />
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackMode">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.Specialized.NameValueCollection DeterminePostBackMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function DeterminePostBackMode () As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Collections::Specialized::NameValueCollection ^ DeterminePostBackMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию <see cref="T:System.Collections.Specialized.NameValueCollection" /> данных, переданных обратно странице, используя команду POST или GET.</summary>
        <returns>Объект <see cref="T:System.Collections.Specialized.NameValueCollection" />, содержащий данные формы. Если обратная передача использовала команду POST, информация о форме возвращается из объекта <see cref="P:System.Web.UI.Page.Context" />. Если обратная передача использовала команду GET, возвращается информация из строки запроса. Если страница запрашивается в первый раз, возвращается значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.DeterminePostBackMode%2A> Возвращает <xref:System.Collections.Specialized.NameValueCollection> передается объект, содержащий данные обратно на страницу. Наличие страницы скрытые поля, VIEWSTATE и EVENTTARGET используется для определения, произошло ли событие обратной передачи. <xref:System.Web.UI.Page.IsPostBack%2A> Свойство устанавливается, когда <xref:System.Web.UI.Page.DeterminePostBackMode%2A> вызывается метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackModeUnvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackModeUnvalidated" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function DeterminePostBackModeUnvalidated () As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Collections::Specialized::NameValueCollection ^ DeterminePostBackModeUnvalidated();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию данных имя-значение, отправленную на страницу с помощью команды GET или POST, и без выполнения проверки запросов ASP.NET в запросе.</summary>
        <returns>Объект, содержащий непроверенные данные формы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в описании класса <xref:System.Web.UnvalidatedRequestValues>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableEventValidation">
      <MemberSignature Language="C#" Value="public virtual bool EnableEventValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableEventValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableEventValidation" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableEventValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableEventValidation { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, проверяет ли страница события обратной передачи и обратного вызова.</summary>
        <value>Значения <see langword="true" />, если страница проверяет события обратной передачи и обратного вызова; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Web.UI.Page.EnableEventValidation%2A> свойству `true`, ASP.NET проверяет, что событие элемента управления получен из отображения, этот элемент управления пользовательского интерфейса. Элемент управления регистрирует события при отрисовке и затем проверяет их при обработке обратной передачи или обратного вызова. Например если элемент управления списком включает параметры номерами 1, 2 или 3 при отображении страницы, а также если поступает запрос обратной передачи, указав параметр номер 4, ASP.NET вызывает исключение. По умолчанию все элементы управления на основе событий в ASP.NET использовать эту функцию.  
  
 При написании клиентский скрипт, который изменяет элемент управления на стороне клиента во время выполнения, может потребоваться использовать <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метод, чтобы избежать ошибок проверки, false событий.  
  
> [!IMPORTANT]
>  Это снижает вероятность несанкционированного или злонамеренного обратных запросов и обратных вызовов. Настоятельно рекомендуется не отключать проверку событий.  
  
 Задать <xref:System.Web.UI.Page.EnableEventValidation%2A> свойство, задав `enableEventValidation` атрибута директивы или `enableEventValidation` атрибута элемента в файле Web.config. Если значение этого свойства в коде, необходимо задать до инициализации страницы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Web.UI.Page.EnableEventValidation" /> было установлено после инициализации страницы.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
        <altmember cref="T:System.Web.UI.SupportsEventValidationAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public override bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewState" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableViewState { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, поддерживает ли страница свое состояние отображения и состояние отображения всех содержащихся в ней серверных элементов управления по окончании текущего запроса страницы.</summary>
        <value>
          <see langword="true" />, если страница поддерживает состояние представления; в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сведения о том, почему может потребоваться отключить состояние просмотра см. в разделе <xref:System.Web.UI.Control.EnableViewState%2A?displayProperty=nameWithType>.  
  
 Даже если <xref:System.Web.UI.Page.EnableViewState%2A> — `false`, страница может содержать скрытом поле состояния представления, используемого ASP.NET для обнаружения обратную передачу.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Web.UI.Page.EnableViewState%2A> свойства `false` при загрузке страницы. Это приведет к отключению состояния представления для <xref:System.Web.UI.Page> объекта, это означает, что ни информации состояния представления для страницы, ни всех элементов управления, содержащихся на странице сохраняются.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/CS/page_enableviewstate.cs#1)]
 [!code-vb[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/VB/page_enableviewstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.EnableViewStateMac" />
      </Docs>
    </Member>
    <Member MemberName="EnableViewStateMac">
      <MemberSignature Language="C#" Value="public bool EnableViewStateMac { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewStateMac" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewStateMac" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableViewStateMac As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableViewStateMac { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должна ли платформа ASP.NET проверять коды проверки подлинности сообщений (MAC) в состоянии просмотра страницы, когда страница передается обратно от клиента.</summary>
        <value>Значение <see langword="true" />, если состояние представления должно проходить контроль подлинности сообщения и шифроваться; в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 MAC состояния представления является зашифрованной версией скрытой переменной, в которой сохраняется состояние представления страницы для при отправке страницы в браузере. Если значение этого свойства `true`, состояние зашифрованное представление проверяется, чтобы убедиться, что он не незаконно на стороне клиента.  
  
 Это свойство не задано в коде. Задать `EnableViewStateMac` атрибута с помощью директивы в ASPX-файле. При запросе страницы динамически создаваемый класс задает свойство.  
  
> [!IMPORTANT]
>  Этот атрибут никогда не должно быть присвоено `false` в рабочей среде веб-сайта, даже если приложение или страница не использует состояние просмотра. Состояние представления MAC помогает обеспечить безопасность других функций ASP.NET, кроме состояния просмотра.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.EnableViewState" />
      </Docs>
    </Member>
    <Member MemberName="ErrorPage">
      <MemberSignature Language="C#" Value="public string ErrorPage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ErrorPage" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorPage As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ErrorPage { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает страницу ошибок, на которую переадресуется запрашивающий браузер в случае возникновения необработанного исключения страницы.</summary>
        <value>Страница ошибок, на которую переадресуется браузер.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page_ErrorPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_ErrorPage/CS/page_errorpage.cs.aspx#1)]
 [!code-vb[Page_ErrorPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_ErrorPage/VB/page_errorpage.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteRegisteredAsyncTasks">
      <MemberSignature Language="C#" Value="public void ExecuteRegisteredAsyncTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecuteRegisteredAsyncTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExecuteRegisteredAsyncTasks ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExecuteRegisteredAsyncTasks();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает выполнение асинхронной задачи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Определение асинхронных задач с помощью <xref:System.Web.UI.PageAsyncTask> класса. После выполнения задачи определяется и регистрируется с помощью страницы <xref:System.Web.UI.Page.RegisterAsyncTask%2A> метода <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> метод может вызываться для начала асинхронной задачи.  
  
 <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> Метод автоматически вызывается в момент обработки страницы, когда все зарегистрированные асинхронные задачи, если они существуют, вызываются для-асинхронные страницы. Автоматический вызов <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> возникает непосредственно перед <xref:System.Web.UI.Page.PreRenderComplete> событий. Вызовите <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> метод для задачи требуется вызывать в некоторых случаях кроме автоматического вызова этого метода. Обратите внимание, что асинхронных задач выполняется только один раз, даже если <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> может вызываться несколько раз.  
  
 <xref:System.Web.UI.Page.AsyncTimeout%2A> Свойства сбрасывается при каждом вызове <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> метода. Последнее значение <xref:System.Web.UI.Page.AsyncTimeout%2A> до вызова <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> метод имеет больший приоритет. Если асинхронная задача принимает больше, чем <xref:System.Web.UI.Page.AsyncTimeout%2A>, вызывается в процессе, последующие задачи <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> немедленно истекло вызова.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.Page.AsyncTimeout%2A> свойство с <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> и <xref:System.Web.UI.Page.RegisterAsyncTask%2A> методы. Обратите внимание на использование обработчиков начала, окончания и время ожидания. В примере вводится искусственная задержка для демонстрации ситуации асинхронной задачи превышение времени, выделенного для задачи, как указано в <xref:System.Web.UI.Page.AsyncTimeout%2A> свойство. В реальном сценарии асинхронная задача может использоваться для выполнения вызовов базы данных или создания изображений, например, и обработчик тайм-аута предоставляет постепенного ухудшения качества обслуживания, если задача не выполняется в определенное время.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Возникло исключение в асинхронной задаче:</exception>
        <altmember cref="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
        <altmember cref="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
    <Member MemberName="FileDependencies">
      <MemberSignature Language="C#" Value="protected System.Collections.ArrayList FileDependencies { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList FileDependencies" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.FileDependencies" />
      <MemberSignature Language="VB.NET" Value="Protected Property FileDependencies As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::ArrayList ^ FileDependencies {  void set(System::Collections::ArrayList ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is HttpResponse.AddFileDependencies. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает массив файлов, от которых зависит объект <see cref="T:System.Web.HttpResponse" />.</summary>
        <value>Массив файлов, от которых зависит объект <see cref="T:System.Web.HttpResponse" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство использовать не рекомендуется. Используйте <xref:System.Web.HttpResponse.AddFileDependencies%2A> метода или <xref:System.Web.HttpResponse.AddFileDependency%2A> метод <xref:System.Web.HttpResponse> вместо этого класс.  
  
 В большинстве случаев это свойство не задано в коде. Задать `FileDependencies` атрибут `true` с помощью директивы в ASPX-файле. При запросе страницы динамически создаваемый класс задает свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public override System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FindControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FindControl (id As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Web::UI::Control ^ FindControl(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Идентификатор искомого элемента управления.</param>
        <summary>Ищет контейнер именования страниц для указанного серверного элемента управления с указанным идентификатором.</summary>
        <returns>Указанный элемент управления или <see langword="null" />, если указанный элемент управления не существует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.FindControl%2A> Метод может использоваться для управления доступом к которого <xref:System.Web.UI.Control.ID%2A> доступен не во время разработки. Метод выполняет поиск только страницы немедленно или верхнего уровня, контейнер; он не выполняет рекурсивного поиска для элементов управления в контейнерах именования, содержащихся на странице. Для доступа к элементам управления в контейнере именования, подчиненных, вызовите `FindControl` метод этого контейнера.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.Page.FindControl%2A> метод для поиска элементов управления внутри шаблонов. В этом примере два <xref:System.Web.UI.WebControls.Repeater> определяются элементы управления, каждый показан другой способ перехватывать <xref:System.Web.UI.WebControls.LinkButton.Click> событие <xref:System.Web.UI.WebControls.LinkButton> внутри элемента шаблон повторителя.  
  
 [!code-aspx-csharp[System.Web.UI.Page_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/cs/pagefindcontrolcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/vb/pagefindcontrolvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlForm Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlForm Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Form" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Form As HtmlForm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::HtmlControls::HtmlForm ^ Form { System::Web::UI::HtmlControls::HtmlForm ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlForm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает форму HTML для страницы.</summary>
        <value>Объект <see cref="T:System.Web.UI.HtmlControls.HtmlForm" />, связанный со страницей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.Form%2A> свойство для доступа к методам и свойствам <xref:System.Web.UI.HtmlControls.HtmlForm> объект, который является базовым по иерархии элементов управления на странице.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
      </Docs>
    </Member>
    <Member MemberName="FrameworkInitialize">
      <MemberSignature Language="C#" Value="protected override void FrameworkInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void FrameworkInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FrameworkInitialize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub FrameworkInitialize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void FrameworkInitialize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициализирует дерево элементов управления во время генерации страницы, на основе декларативной природы страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.FrameworkInitialize%2A> Инициализирует метод <xref:System.Web.UI.Page> объекта и создает дерево элементов управления, на основе декларативной природе страницы. <xref:System.Web.UI.Page.FrameworkInitialize%2A> Метод переопределяется страницы синтаксического анализа и создания кода для <xref:System.Web.UI.Page> класс для декларативной страницы. Как правило следует не по необходимости переопределять этот метод. Для переопределения, необходимо вызвать базовый класс <xref:System.Web.UI.Page.FrameworkInitialize%2A> метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
    <Member MemberName="GetDataItem">
      <MemberSignature Language="C#" Value="public object GetDataItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetDataItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetDataItem" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDataItem () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetDataItem();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает элемент данных на верху стека контекста привязки данных.</summary>
        <returns>Объект на верху стека контекста привязки данных.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Контекст привязки для страницы отсутствует.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientEvent">
      <MemberSignature Language="C#" Value="public string GetPostBackClientEvent (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientEvent(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientEvent(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientEvent(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, который получает события обратной передачи клиента.</param>
        <param name="argument">
          <see cref="T:System.String" /> — передается в <see cref="M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)" />.</param>
        <summary>Возвращает ссылку, которая может использоваться в клиентском событии при обратной передаче на сервер для указанного элемента управления с указанными аргументами события.</summary>
        <returns>Строка, которая представляет событие клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В разделе <xref:System.Web.UI.ClientScriptManager> класс альтернативные варианты этот член не рекомендуется.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.Button.OnClientClick" />
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackClientHyperlink. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, обрабатывающий обратную передачу.</param>
        <param name="argument">Параметр, передаваемый серверному элементу управления.</param>
        <summary>Возвращает ссылку, с <see langword="javascript:" /> в начале, которую можно использовать в клиентском событии для обратной передачи серверу указанного элемента управления с указанными аргументами события.</summary>
        <returns>Строка, представляющая вызов JavaScript функции обратной передачи, включающей идентификатор целевого элемента управления и аргументы события.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В разделе <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> метод альтернативный способ этот член не рекомендуется.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Этот метод использовать не рекомендуется. Вместо него следует использовать метод <see cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" /> класса <see cref="T:System.Web.UI.ClientScriptManager" />.</summary>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, обрабатывающий обратную передачу на сервере.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным объектом <see cref="T:System.Web.UI.Control" />.</summary>
        <returns>Строка, инициирующая — при рассмотрении ее в качестве скрипта на стороне клиента — обратную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использовать не рекомендуется. Вместо него следует использовать метод <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> класса <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#2)]
 [!code-vb[Page_GetPostBackEventReference#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, обрабатывающий обратную передачу.</param>
        <param name="argument">Параметр, передаваемый серверному элементу управления.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным элементом управления, обрабатывающим обратную передачу, и строчным аргументом с дополнительной информацией о событии.</summary>
        <returns>Строка, инициирующая — при рассмотрении ее в качестве скрипта на стороне клиента — обратную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использовать не рекомендуется. Вместо него следует использовать метод <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> класса <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#1)]
 [!code-vb[Page_GetPostBackEventReference#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetTypeHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetTypeHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetTypeHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetTypeHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает хэш-код, создаваемый объектами <see cref="T:System.Web.UI.Page" />, порождаемыми во время выполнения. Этот хэш-код уникален для иерархии элементов управления объекта <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Хэш-код, создаваемый во время выполнения. Значение по умолчанию — 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не следует переопределять этот метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValidators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection GetValidators (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.ValidatorCollection GetValidators(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetValidators(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValidators (validationGroup As String) As ValidatorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::ValidatorCollection ^ GetValidators(System::String ^ validationGroup);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">Возвращаемая группа проверки или <see langword="null" /> для возврата группы проверки по умолчанию.</param>
        <summary>Возвращает коллекцию проверяющих элементов управления для указанной группы проверки.</summary>
        <returns>Коллекция <see cref="T:System.Web.UI.ValidatorCollection" />, содержащая проверяющие элементы управления для указанной группы проверки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.GetValidators%2A> Метод возвращает все объекты проверки, связанные с группой проверки. Можно возвратить группу проверки по умолчанию (все проверяющие элементы управления, связанные с элементами управления без `ValidationGroup` набор свойств), задав `validationGroup` параметр `null`.  
  
 Чтобы проверить элементы группы проверки, можно перечислить коллекцию и вызовите <xref:System.Web.UI.IValidator.Validate%2A> возвращается метод каждого проверяющего элемента управления.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Web.UI.Page.GetValidators%2A> метод для возврата группы проверки по умолчанию.  
  
 [!code-csharp[PageGetValidators#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageGetValidators/CS/pagegetvalidatorscs.aspx#1)]
 [!code-vb[PageGetValidators#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageGetValidators/VB/pagegetvalidatorsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.Validate(System.String)" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
      </Docs>
    </Member>
    <Member MemberName="GetWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected object GetWrappedFileDependencies (string[] virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetWrappedFileDependencies(string[] virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetWrappedFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetWrappedFileDependencies (virtualFileDependencies As String()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ GetWrappedFileDependencies(cli::array &lt;System::String ^&gt; ^ virtualFileDependencies);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">Строковый массив размещений виртуальных файлов.</param>
        <summary>Возвращает список имен физических файлов, соответствующих списку размещения виртуальных файлов.</summary>
        <returns>Объект, содержащий список размещения физических файлов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.GetWrappedFileDependencies%2A> Метод возвращает список файлов, таких как файлы пользовательских элементов управления, составляющих текущую страницу. Если любой из этих страниц изменяется, вся страница компилируется в следующий раз, когда он запрашивается. Не следует переопределять этот метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Header">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlHead Header { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlHead Header" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Header" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Header As HtmlHead" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::HtmlControls::HtmlHead ^ Header { System::Web::UI::HtmlControls::HtmlHead ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlHead</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает заголовок документа страницы, если элемент <see langword="head" /> определен с <see langword="runat=server" /> в объявлении страницы.</summary>
        <value>Объект <see cref="T:System.Web.UI.HtmlControls.HtmlHead" />, содержащий заголовок страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Header%2A> Свойство получает ссылку на <xref:System.Web.UI.HtmlControls.HtmlHead> , можно использовать для задания информации заголовка документа для страницы. <xref:System.Web.UI.HtmlControls.HtmlHead> Позволяет добавлять сведения, например таблицы стилей, правила стилей, заголовок и метаданных для `head` элемента.  
  
> [!NOTE]
>  Добавление стилей программно с помощью методов <xref:System.Web.UI.IStyleSheet> интерфейс во время асинхронных обратных передач не поддерживается. При добавлении функциональных возможностей AJAX на веб-страницу асинхронных обратных передач обновлять области страницы без обновления всей страницы. Дополнительные сведения см. в разделе [Обзор Microsoft Ajax](http://msdn.microsoft.com/library/be84d9b3-b7cd-47d7-8494-be4abfaad9cb).  
  
   
  
## Examples  
 В следующем примере кода показано, как получить доступ к <xref:System.Web.UI.HtmlControls.HtmlHead> управления программным путем с помощью <xref:System.Web.UI.Page.Header%2A> свойство. Объект `title` элемент и `style` добавлен элемент `head` элемента страницы.  
  
 [!code-aspx-csharp[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/CS/htmlheadclasscs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/VB/htmlheadclassvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlHead" />
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlLink" />
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public override string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает идентификатор для конкретного экземпляра класса <see cref="T:System.Web.UI.Page" />.</summary>
        <value>Идентификатор экземпляра класса <see cref="T:System.Web.UI.Page" />. По умолчанию используется значение '_Page'.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Page.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="public virtual char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IdSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IdSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char IdSeparator { char get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает символ, используемый для разделения идентификаторов элемента управления при построении уникального идентификатора элемента управления на странице.</summary>
        <value>Символ, используемый для разделения идентификаторов элементов управления. Значение по умолчанию устанавливается экземпляром <see cref="T:System.Web.UI.Adapters.PageAdapter" />, отображающим страницу. Свойство <see cref="P:System.Web.UI.Page.IdSeparator" /> является полем на стороне сервера и не должно изменяться.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Page.ID" />
      </Docs>
    </Member>
    <Member MemberName="InitComplete">
      <MemberSignature Language="C#" Value="public event EventHandler InitComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InitComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.InitComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InitComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ InitComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при завершении инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.InitComplete> Событие вызывается в конце этапа инициализации страницы. На этом этапе жизненного цикла страницы все объявленные элементы управления на странице инициализируются, но состояние страницы еще не заполнено. Можно получить доступ к серверным элементам управления, но они еще не содержат сведения, возвращаемые от пользователя.  
  
 Дополнительные сведения об обработке событий см. в разделе [NIB: Потребление событий](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Page.LoadComplete" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
      </Docs>
    </Member>
    <Member MemberName="InitializeCulture">
      <MemberSignature Language="C#" Value="protected virtual void InitializeCulture ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeCulture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitializeCulture" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeCulture ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeCulture();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Устанавливает свойства <see cref="P:System.Web.UI.Page.Culture" /> и <see cref="P:System.Web.UI.Page.UICulture" /> текущего потока страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.InitializeCulture%2A> Метод содержит логика кодирования. Разработчики при расширении функциональных возможностей управления <xref:System.Web.UI.Page> класс может переопределить <xref:System.Web.UI.Page.InitializeCulture%2A> метод для инициализации <xref:System.Web.UI.Page.Culture%2A> и <xref:System.Web.UI.Page.UICulture%2A> сведения для страницы.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.Web.UI.Page.FrameworkInitialize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InitOutputCache">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует кэш выходных данных для текущего запроса страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не предназначен для непосредственного использования в коде. Для включения и управления кэшированием вывода для страницы, используйте один из следующих подходов:  
  
-   Задайте параметры декларативно с помощью директивы в ASPX-файле.  
  
-   Использовать методы и свойства <xref:System.Web.HttpCachePolicy> класс, который предоставляется `Response.Cache` объект в код страницы.  
  
 Дополнительные сведения см. в разделе [кэширование страниц ASP.NET](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected internal virtual void InitOutputCache (System.Web.UI.OutputCacheParameters cacheSettings);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void InitOutputCache(class System.Web.UI.OutputCacheParameters cacheSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Web.UI.OutputCacheParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub InitOutputCache (cacheSettings As OutputCacheParameters)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void InitOutputCache(System::Web::UI::OutputCacheParameters ^ cacheSettings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheSettings" Type="System.Web.UI.OutputCacheParameters" />
      </Parameters>
      <Docs>
        <param name="cacheSettings">Объект <see cref="T:System.Web.UI.OutputCacheParameters" />, содержащий параметры кэша.</param>
        <summary>Инициализирует кэш выходных данных для текущего запроса страницы на основе объекта <see cref="T:System.Web.UI.OutputCacheParameters" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не следует вызывать этот метод. Для включения и управления кэшированием вывода для страницы, используйте директиву в ASCX-файл, или методы и свойства <xref:System.Web.HttpCachePolicy> класса. Доступ через `Response.Cache` синтаксиса в коде объявления блока или кода файла страницы. Дополнительные сведения см. в разделе [кэширование страниц ASP.NET](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Профиль кэша не найден.  \- или - Пропущенная директива или атрибут профиля параметров конфигурации.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Задано неверное значение для расположения кэша выходных данных.</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitOutputCache (duration As Integer, varyByHeader As String, varyByCustom As String, location As OutputCacheLocation, varyByParam As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitOutputCache(int duration, System::String ^ varyByHeader, System::String ^ varyByCustom, System::Web::UI::OutputCacheLocation location, System::String ^ varyByParam);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">Время, в течение которого объекты, сохраняемые в кэше выходных данных, верны.</param>
        <param name="varyByHeader">Список заголовков, разделенных точкой с запятой, по которым изменяется содержимое кэша выходных данных.</param>
        <param name="varyByCustom">НТТР-заголовок <see langword="Vary" />.</param>
        <param name="location">Одно из значений перечисления <see cref="T:System.Web.UI.OutputCacheLocation" />.</param>
        <param name="varyByParam">Список параметров, полученных методом GET или POST, разделенных точкой с запятой, по которым изменяется содержимое кэша выходных данных.</param>
        <summary>Инициализирует кэш выходных данных для текущего запроса страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не следует вызывать этот метод. Для включения и управления кэшированием вывода для страницы, используйте директиву в ASCX-файл, или методы и свойства <xref:System.Web.HttpCachePolicy> класса. Доступ через `Response.Cache` синтаксиса в коде страницы. Дополнительные сведения см. в разделе [кэширование страниц ASP.NET](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Задано недопустимое значение для <paramref name="location" />.</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitOutputCache (duration As Integer, varyByContentEncoding As String, varyByHeader As String, varyByCustom As String, location As OutputCacheLocation, varyByParam As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitOutputCache(int duration, System::String ^ varyByContentEncoding, System::String ^ varyByHeader, System::String ^ varyByCustom, System::Web::UI::OutputCacheLocation location, System::String ^ varyByParam);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByContentEncoding" Type="System.String" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">Время, в течение которого объекты, сохраняемые в кэше выходных данных, верны.</param>
        <param name="varyByContentEncoding">Список кодировок (кодирования содержимого), разделенных точкой с запятой, по которым изменяется содержимое кэша выходных данных.</param>
        <param name="varyByHeader">Список заголовков, разделенных точкой с запятой, по которым изменяется содержимое кэша выходных данных.</param>
        <param name="varyByCustom">НТТР-заголовок <see langword="Vary" />.</param>
        <param name="location">Одно из значений перечисления <see cref="T:System.Web.UI.OutputCacheLocation" />.</param>
        <param name="varyByParam">Список параметров, полученных методом GET или POST, разделенных точкой с запятой, по которым изменяется содержимое кэша выходных данных.</param>
        <summary>Инициализирует кэш выходных данных для текущего запроса страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не следует вызывать этот метод. Для включения и управления кэшированием вывода для страницы, используйте директиву в ASCX-файл, или методы и свойства <xref:System.Web.HttpCachePolicy> класса. Доступ через `Response.Cache` синтаксиса в коде страницы. Дополнительные сведения см. в разделе [кэширование страниц ASP.NET](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Задано недопустимое значение для <paramref name="location" />.</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAsync { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, обрабатывается ли страница асинхронно.</summary>
        <value>Значение <see langword="true" />, если страница обрабатывается асинхронно; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.IsAsync%2A> свойство, чтобы определить, выполняется ли веб-страницы в асинхронном режиме. Эта информация полезна в том случае, если элементы управления или код на странице должны изменять свое поведение в зависимости от того, является ли данная страница является асинхронной. Дополнительные сведения об асинхронном программировании см. в разделе [асинхронные операции](~/docs/framework/data/adonet/sql/asynchronous-operations.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCallback">
      <MemberSignature Language="C#" Value="public bool IsCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCallback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCallback { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли запрос страницы результатом обратного вызова.</summary>
        <value>Значение <see langword="true" />, если запрос страницы является результатом обратного вызова; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [реализация клиента обратные вызовы без обратной передачи](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsClientScriptBlockRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Искомый строковый ключ клиентского скрипта.</param>
        <summary>Определяет, зарегистрирован ли со страницей блок скрипта с указанным ключом.</summary>
        <returns>
          <see langword="true" />, если блок скрипта зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод перед вызовом метода <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A?displayProperty=nameWithType> во избежание без необходимости сборка клиентского скрипта. Это особенно важно, если сценарий требует большой объем серверных ресурсов.  
  
 Метод <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> не рекомендуется к использованию. Используйте <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> метод <xref:System.Web.UI.ClientScriptManager> класса.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> в сочетании с <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> метод. Если блок объявления кода на языке ECMAScript не уже был зарегистрирован, определяется <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>, то <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> вызов.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsCrossPagePostBack">
      <MemberSignature Language="C#" Value="public bool IsCrossPagePostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCrossPagePostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCrossPagePostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCrossPagePostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCrossPagePostBack { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, вовлечена ли страница в межстраничные обратные передачи.</summary>
        <value>
          <see langword="true" />, если страница участвует в межстраничных запросах; в противном случае ─ <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET предоставляет два механизма для передачи управления из одной страницы в другую. Можно использовать <xref:System.Web.HttpServerUtility.Transfer%2A> способ передачи обработки между страницами, или можно сделать запрос страницы между путем назначения URL-адрес страницы для <xref:System.Web.UI.WebControls.IButtonControl.PostBackUrl%2A> свойства элемента управления кнопки, который реализует <xref:System.Web.UI.WebControls.IButtonControl> интерфейса.  
  
 В любом случае <xref:System.Web.UI.Page.PreviousPage%2A> свойство страницы будет содержать объект, который представляет страницу предыдущего или инициатора. Если, например, страницы A отправляет страницу Б, A страницы <xref:System.Web.UI.Page.IsCrossPagePostBack%2A> свойство (доступного через <xref:System.Web.UI.Page.PreviousPage%2A> свойство) будет `true` и страница B <xref:System.Web.UI.Page.PreviousPage%2A> свойство будет иметь имя страницы A.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.IButtonControl.PostBackUrl" />
      </Docs>
    </Member>
    <Member MemberName="IsPostBack">
      <MemberSignature Language="C#" Value="public bool IsPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostBack { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, отрисовывается ли страница в первый раз или же загружается в ответ на обратную передачу.</summary>
        <value>
          <see langword="true" />, если страница загружается в ответ на обратный запрос клиента; иначе — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объяснение разницы между обратной передачи и обратных вызовов см. в разделе [реализация клиента обратные вызовы без обратной передачи](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
   
  
## Examples  
 Приведенный ниже показано, как проверить значение <xref:System.Web.UI.Page.IsPostBack%2A> свойства при загрузке страницы, чтобы определить ли страница готовится к просмотру в первый раз или в ответ на обратную передачу. Если страница отображается в первый раз, то код вызывает <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> метод.  
  
 Разметка страницы (не показано) содержит <xref:System.Web.UI.WebControls.RequiredFieldValidator> элементы управления, отображающие звездочки, если запись не будет произведена для обязательного поля ввода. Вызов <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> вызывает звездочки для отображения сразу же при отображении страницы, вместо ожидания, пока пользователь не щелкнет «отправить». После обратной передачи, не нужно вызывать <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>, так как этот метод вызывается как часть <xref:System.Web.UI.Page> жизненного цикла.  
  
 [!code-csharp[System.Web.UI.Page.Validate#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Validate#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
        <altmember cref="P:System.Web.UI.Page.IsCallback" />
      </Docs>
    </Member>
    <Member MemberName="IsPostBackEventControlRegistered">
      <MemberSignature Language="C#" Value="public bool IsPostBackEventControlRegistered { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBackEventControlRegistered" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBackEventControlRegistered" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostBackEventControlRegistered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostBackEventControlRegistered { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, зарегистрирован ли страничный элемент управления, выполняющий обратную передачу.</summary>
        <value>Значение <see langword="true" />, если элемент управления зарегистрирован; в противном случае — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReusable">
      <MemberSignature Language="C#" Value="public bool IsReusable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReusable" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsReusable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReusable { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.IHttpHandler.IsReusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, может ли объект <see cref="T:System.Web.UI.Page" /> быть повторно используемым.</summary>
        <value>Значение <see langword="false" /> во всех случаях.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.IHttpHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsStartupScriptRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Искомый строковый ключ скрипта запуска.</param>
        <summary>Определяет, зарегистрирован ли стартовый клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>
          <see langword="true" />, если скрипт, активизируемый при запуске, зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод перед вызовом метода <xref:System.Web.UI.Page.RegisterStartupScript%2A?displayProperty=nameWithType> во избежание без необходимости сборка клиентского скрипта. Это особенно важно, если сценарий требует большой объем серверных ресурсов.  
  
 Метод <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> не рекомендуется к использованию. Используйте <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> метод <xref:System.Web.UI.ClientScriptManager> класса.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.Page.RegisterStartupScript%2A> в сочетании с <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> метод. Если блок объявления кода на языке ECMAScript не уже был зарегистрирован, определяется <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A>, то <xref:System.Web.UI.Page.RegisterStartupScript%2A> вызов.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public bool IsValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValid" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValid { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, завершена ли проверка страницы успешно.</summary>
        <value>
          <see langword="true" />, если проверка завершена успешно; иначе — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для этого свойства для возврата `true`, серверных элементов управления проверки в текущей группе проверки успешно проверены. Это свойство следует проверять только после вызова <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> метода или набора `CausesValidation` свойства `true` в `OnServerClick` обработчик событий для элемента управления сервера ASP.NET, инициирующего обработку формы. Эти серверные элементы управления включают <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.HtmlControls.HtmlButton>, <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, <xref:System.Web.UI.WebControls.ImageButton>, и <xref:System.Web.UI.WebControls.LinkButton> классы.  
  
 Если принудительная проверка группы проверки с помощью <xref:System.Web.UI.Page.Validate%2A> метод, то все проверяющие элементы управления в группе проверки успешно проверены также.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.Page.IsValid%2A> свойство для задания условного оператора. Если свойство возвращает `true`, `Text` свойства `lblOutput` элемента управления задано значение «Страницы является допустимым!» В противном случае он имеет значение «Некоторые обязательные поля пусты.»  
  
 [!code-csharp[System.Web.UI.Page.Validate#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Validate#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Свойство <see cref="P:System.Web.UI.Page.IsValid" /> вызывается до начала проверки.</exception>
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="M:System.Web.UI.Page.Validate" />
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает список объектов, хранящихся в контексте страницы.</summary>
        <value>Ссылка на объект <see cref="T:System.Collections.IDictionary" />, содержащий объекты, хранящиеся в контексте страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.Items%2A> свойство для хранения объектов, содержащих одинаковое время существования как в запросе страницы. Это свойство доступно только для чтения; Тем не менее, можно добавлять объекты в <xref:System.Collections.IDictionary> объекта, он возвращает.  
  
 Объекты, добавленные <xref:System.Web.UI.Page.Items%2A> свойства доступны во время существования страницы, поэтому можно добавлять объекты <xref:System.Web.UI.Page.Items%2A> свойства событий в реальной жизни страницы переключать и обращаться к этим объектам в следующих событиях.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LCID">
      <MemberSignature Language="C#" Value="public int LCID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LCID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.LCID" />
      <MemberSignature Language="VB.NET" Value="Public Property LCID As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LCID { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает идентификатор языкового стандарта объекта <see cref="T:System.Threading.Thread" />, связанного со страницей.</summary>
        <value>Идентификатор языкового стандарта, передаваемых объекту <see cref="T:System.Threading.Thread" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. `LCID` Атрибут можно задать в директиве ASPX-файла, однако предпочтительный метод Задание идентификатора языкового стандарта является использования <xref:System.Web.UI.Page.Culture%2A> и <xref:System.Web.UI.Page.UICulture%2A> свойства.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="P:System.Web.UI.Page.Culture" />
        <altmember cref="P:System.Web.UI.Page.UICulture" />
      </Docs>
    </Member>
    <Member MemberName="LoadComplete">
      <MemberSignature Language="C#" Value="public event EventHandler LoadComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LoadComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.LoadComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LoadComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит в конце стадии загрузки жизненного цикла страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.LoadComplete> Событие возникает после всех обратной передачи данных и загрузки данных состояния представления в страницу и после <xref:System.Web.UI.Control.OnLoad%2A> метод был вызван для всех элементов управления на странице.  
  
 Дополнительные сведения об обработке событий см. в разделе [NIB: Потребление событий](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Page.InitComplete" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
      </Docs>
    </Member>
    <Member MemberName="LoadPageStateFromPersistenceMedium">
      <MemberSignature Language="C#" Value="protected internal virtual object LoadPageStateFromPersistenceMedium ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object LoadPageStateFromPersistenceMedium() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function LoadPageStateFromPersistenceMedium () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ LoadPageStateFromPersistenceMedium();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Загружает сохраненные сведения о состоянии отображения в объект <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Сохраненное состояние представления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> Использует метод <xref:System.Web.UI.PageStatePersister.Load%2A> метод <xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType> объект, упоминаемый в <xref:System.Web.UI.Page.PageStatePersister%2A> свойство для загрузки любого сохраненные сведения о состоянии представления для <xref:System.Web.UI.Page> объекта.  
  
 В ASP.NET есть два потомков <xref:System.Web.UI.PageStatePersister> класса, <xref:System.Web.UI.HiddenFieldPageStatePersister> класс, который сохраняет информацию о состоянии в скрытом поле, входящих в страницу ASP.NET и <xref:System.Web.UI.SessionPageStatePersister> класс, который сохраняет состояние в <xref:System.Web.UI.Page.Session%2A> объект, связанный с запрос.  
  
 Для сохранения состояния в выбранное расположение, вы создаете новый потомком <xref:System.Web.UI.PageStatePersister> класс, который сохраняет и загружает состояние в постоянной среде по своему усмотрению. Пример создания нового <xref:System.Web.UI.PageStatePersister> см. в разделе <xref:System.Web.UI.PageStatePersister> класса.  
  
 При использовании .NET Framework версии 1.0 или 1.1, переопределите этот метод, если вы хотите загрузить <xref:System.Web.UI.Page> состояния из ничего, кроме скрытого поля. Если вы решили сделать это, необходимо также переопределить <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
        <altmember cref="P:System.Web.UI.Page.PageStatePersister" />
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="MaintainScrollPositionOnPostBack">
      <MemberSignature Language="C#" Value="public bool MaintainScrollPositionOnPostBack { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="VB.NET" Value="Public Property MaintainScrollPositionOnPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaintainScrollPositionOnPostBack { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должен ли пользователь возвращаться в то же место в клиентском браузере после обратной передачи. Это свойство заменяет устаревшее свойство <see cref="P:System.Web.UI.Page.SmartNavigation" />.</summary>
        <value>
          <see langword="true" />, если позиция клиента сохраняется; в противном случае ─ <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда веб-страницы учитываются обратно на сервер, пользователь возвращается к верхней части страницы. Для длинных страниц это означает, что у пользователя выполнить прокрутку страницу последней позиции на странице.  
  
 Когда <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> свойству `true`, пользователь вместо этого возвращается к последней позиции на странице.  
  
 Задать <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> свойство в [@ Page](http://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) директивы.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Значение типа <see cref="T:System.String" />, содержащее виртуальный путь.</param>
        <summary>Извлекает физический путь, к которому ведет виртуальный путь (абсолютный или относительный), или путь, на который отображается относительный путь приложения.</summary>
        <returns>Физический путь, связанный с виртуальным путем или относительным путем приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Web.UI.Page.MapPath%2A> Свойство потенциально могут содержать конфиденциальные сведения о среде размещения. Возвращаемое значение не должно отображаться пользователям.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Web.UI.Page.MapPath%2A> метод, чтобы получить физический путь к вложенной папке. Затем он добавляет имя файла, которое считывается из <xref:System.Web.UI.WebControls.TextBox.Text%2A> свойства <xref:System.Web.UI.WebControls.TextBox> элемента управления. Результатом является абсолютный физический путь к этому файлу.  
  
 [!code-csharp[Page_MapPath_ResponseEncoding#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/CS/page_mappath_responseencoding.cs.aspx#1)]
 [!code-vb[Page_MapPath_ResponseEncoding#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/VB/page_mappath_responseencoding.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Master">
      <MemberSignature Language="C#" Value="public System.Web.UI.MasterPage Master { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.MasterPage Master" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Master" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Master As MasterPage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::MasterPage ^ Master { System::Web::UI::MasterPage ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.MasterPage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает эталонную страницу, определяющую общий вид таблицы.</summary>
        <value>Объект <see cref="T:System.Web.UI.MasterPage" />, связанный с этой страницей, если она существует; в противном случае ─ <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Master%2A> Возвращает свойство <xref:System.Web.UI.MasterPage> объекта, связанного с этой страницей. Это свойство доступно только для чтения; Тем не менее, можно задать свойства на <xref:System.Web.UI.MasterPage> объекта, он возвращает.  
  
 <xref:System.Web.UI.Page.Master%2A> Свойство допустимо только для страниц, которые ссылаются на главную страницу в <xref:System.Web.UI.Page.MasterPageFile%2A> свойство. При доступе к <xref:System.Web.UI.Page.Master%2A> свойство на странице, не ссылается на главной странице, `null` возвращается. Содержимое главной страницы недоступны до после <xref:System.Web.UI.Page.PreInit> события.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.MasterPageFile" />
      </Docs>
    </Member>
    <Member MemberName="MasterPageFile">
      <MemberSignature Language="C#" Value="public virtual string MasterPageFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MasterPageFile" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MasterPageFile" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MasterPageFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ MasterPageFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает виртуальный путь эталонной страницы.</summary>
        <value>Виртуальный путь к эталонной странице.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.MasterPageFile%2A> Свойство является виртуальный путь (от корневого каталога приложения) файл главной страницы, связанные с этой страницей. <xref:System.Web.UI.Page.MasterPageFile%2A> Свойство можно задать только в <xref:System.Web.UI.Page.PreInit> событий; попытка задать <xref:System.Web.UI.Page.MasterPageFile%2A> свойство после <xref:System.Web.UI.Page.PreInit> вызовет событие <xref:System.InvalidOperationException> исключение. Если <xref:System.Web.UI.Page.MasterPageFile%2A> недопустимое свойство исключение типа <xref:System.Web.HttpException> вызывается позднее в жизненном цикле страницы, но исключение не возникает, когда свойство имеет значение <xref:System.Web.UI.Page.PreInit> событий.  
  
 Страницы, которые имеют <xref:System.Web.UI.Page.MasterPageFile%2A> набор свойств страницы содержимого и поэтому могут содержать только верхнего уровня элементов управления, <xref:System.Web.UI.WebControls.Content> элементов управления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Web.UI.Page.MasterPageFile" /> устанавливается после завершения события <see cref="E:System.Web.UI.Page.PreInit" />.</exception>
        <exception cref="T:System.Web.HttpException">Файл, указанный в свойстве <see cref="P:System.Web.UI.Page.MasterPageFile" />, не существует.  \- или - Страница не имеет элемента управления <see cref="T:System.Web.UI.WebControls.Content" /> на верхнем уровне.</exception>
        <altmember cref="P:System.Web.UI.Page.Master" />
      </Docs>
    </Member>
    <Member MemberName="MaxPageStateFieldLength">
      <MemberSignature Language="C#" Value="public int MaxPageStateFieldLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPageStateFieldLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaxPageStateFieldLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPageStateFieldLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxPageStateFieldLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальную длину поля состояния страницы.</summary>
        <value>Максимальная длина, в байтах, поля состояния страницы. Значение по умолчанию — -1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> свойству присвоено значение положительное, состояние представления, отправляемого в браузер клиента разбивается на несколько скрытых полей и значение каждого поля меньше, чем размер, указанный в <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> свойство.  
  
 Параметр <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> отрицательное число (по умолчанию) указывает, что поле состояния просмотра не должны быть разделены на блоки. Параметр <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> небольшое число может привести к снижению производительности.  
  
 Установите для параметра <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> свойство в файле Web.config.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Свойство <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> не равно -1 или положительному числу.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> было установлено после инициализации страницы.</exception>
      </Docs>
    </Member>
    <Member MemberName="MetaDescription">
      <MemberSignature Language="C#" Value="public string MetaDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property MetaDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MetaDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает содержимое элемента <see langword="meta" /> свойства "description".</summary>
        <value>Содержимое элемента <see langword="meta" /> свойства "description".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML `meta` элементы, которые могут использоваться для улучшения вхождений поисковой системы. «description» `meta` элемента используется в некоторых поисковых для повышения предварительного просмотра списка.  
  
 Если отсутствует «описание» `meta` элемент в `head` элемент разметки страницы `meta` элемент добавляется к странице при отображении страницы. Если в разметке страницы уже есть «описание» `meta` элемент, это свойство Возвращает или задает `content` атрибут `meta` элемента.  
  
 Это свойство также можно задать в директиве.  
  
   
  
## Examples  
 Если задать <xref:System.Web.UI.Page.MetaDescription%2A> свойства страницы «Общие сведения о ASP.NET» следующий элемент будет отображаться в HTML:  
  
 `<meta name="description" content="ASP.NET Overview" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">На странице нет элемента управления "заголовок" (элемент <see langword="head" /> с атрибутом <see langword="runat" /> со значением "server").</exception>
        <altmember cref="P:System.Web.UI.Page.MetaKeywords" />
      </Docs>
    </Member>
    <Member MemberName="MetaKeywords">
      <MemberSignature Language="C#" Value="public string MetaKeywords { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaKeywords" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaKeywords" />
      <MemberSignature Language="VB.NET" Value="Public Property MetaKeywords As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MetaKeywords { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает содержимое <see langword="meta" />-элемента "keywords".</summary>
        <value>Содержимое <see langword="meta" />-элемента "keywords".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML `meta` элементы, которые могут использоваться для улучшения вхождений поисковой системы. «Ключевые слова» `meta` элемент не используется вообще или задается очень мало вес основные поисковые системы.  
  
 При наличии «ключевые слова не» `meta` элемент в `head` элемент разметки страницы `meta` элемент добавляется к странице при отображении страницы. Если разметке страницы уже есть «ключевые слова» `meta` элемент, это свойство Возвращает или задает `content` атрибут `meta` элемента.  
  
 Это свойство также можно задать в директиве.  
  
   
  
## Examples  
 Если задать <xref:System.Web.UI.Page.MetaKeywords%2A> свойства страницы «HTML, CSS, XML, JavaScript», следующий элемент будет отображаться в HTML:  
  
 `<meta name="keywords" content=" HTML,CSS,XML,JavaScript" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">На странице нет элемента управления "заголовок" (элемент <see langword="head" /> с атрибутом <see langword="runat" /> со значением "server").</exception>
        <altmember cref="P:System.Web.UI.Page.MetaDescription" />
      </Docs>
    </Member>
    <Member MemberName="ModelBindingExecutionContext">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelBindingExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModelBindingExecutionContext As ModelBindingExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ModelBinding::ModelBindingExecutionContext ^ ModelBindingExecutionContext { System::Web::ModelBinding::ModelBindingExecutionContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelBindingExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает контекст выполнения привязки модели.</summary>
        <value>Контекст выполнения привязки модели. Если контекст выполнения привязки модели — <see langword="null" />, создается и возвращается новый контекст.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModelState">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelStateDictionary ModelState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelStateDictionary ModelState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModelState As ModelStateDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ModelBinding::ModelStateDictionary ^ ModelState { System::Web::ModelBinding::ModelStateDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelStateDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект словаря состояния модели, содержащий состояние модели и проверку привязки модели.</summary>
        <value>Объект словаря состояния модели.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Учебник ряда на использование привязки модели для Web Forms, см. [привязки модели и веб-форм](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Web.UI.Control.Init" /> для инициализации страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnInit%2A> Метод выполняет шаги инициализации и настройки, необходимые для создания <xref:System.Web.UI.Page> экземпляра. На этом этапе жизненного цикла страницы инициализируются объявленный серверных элементов управления на странице состояние по умолчанию; Тем не менее состояние представления каждого элемента управления еще не заполнено. Элемент управления на странице не может получить доступ к других серверных элементов управления на странице во время `Page_Init` этап, независимо от других элементов управления дочерних или родительских элементов управления. Другие серверные элементы управления не обязательно будет создана и готова для доступа.  
  
 <xref:System.Web.UI.Page.OnInit%2A> Метод вызывается после <xref:System.Web.UI.Page.OnPreInit%2A> метода и перед <xref:System.Web.UI.Page.OnInitComplete%2A> метод.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Web.UI.Page.OnInit%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> метод, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInitComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnInitComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitComplete(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Web.UI.Page.InitComplete" /> после инициализации страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnInitComplete%2A> Метод вызывается после завершения инициализации страницы. На этом этапе жизненного цикла страницы все объявленные элементы управления на странице инициализируются, но состояние представления страницы еще не заполнено. Можно получить доступ к серверным элементам управления, но они еще не содержат сведения, возвращаемые от пользователя.  
  
 <xref:System.Web.UI.Page.OnInitComplete%2A> Метода происходит в конце <xref:System.Web.UI.Page> этап инициализации и до стадии загрузки.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Web.UI.Page.OnInitComplete%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> метод, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLoadComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadComplete(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Web.UI.Page.LoadComplete" /> в конце стадии инициализации страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnLoadComplete%2A> Метод вызывается в конце стадии загрузки страницы. На этом этапе жизненного цикла страницы, все данные обратной передачи и данных состояния представления загружаются в элементы управления на странице.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Web.UI.Page.OnLoadComplete%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> метод, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreInit">
      <MemberSignature Language="C#" Value="protected virtual void OnPreInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Web.UI.Page.PreInit" /> в начале инициализации страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnPreInit%2A> Метод вызывается в начале стадии инициализации страницы.  
  
 После <xref:System.Web.UI.Page.OnPreInit%2A> вызывается метод, загружаются сведения персонализации и тема страницы, если таковые имеются, инициализируется. Это также основной рабочей области, чтобы динамически определить <xref:System.Web.UI.PageTheme> или <xref:System.Web.UI.MasterPage> для страницы.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Web.UI.Page.OnPreInit%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> метод, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnPreLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreLoad(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает <see cref="E:System.Web.UI.Page.PreLoad" /> событие после загрузки данных обратной передачи в серверные управляющие элементы страницы, но до события <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnPreLoad%2A> Вызывается метод загружается после того как все обратной передачи данных, возвращаемых от пользователя. На этом этапе жизненного цикла страницы сведений о состоянии представления и данные обратной передачи для объявленные элементы управления и элементы управления, созданные на этапе инициализации загружаются в элементов управления на странице.  
  
 Элементы управления, созданные в <xref:System.Web.UI.Page.OnPreLoad%2A> метода также будет загружаться с помощью данных состояния представления и обратного вызова.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Web.UI.Page.OnPreLoad%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> метод, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreRenderComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnPreRenderComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreRenderComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreRenderComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreRenderComplete(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Web.UI.Page.PreRenderComplete" /> после события <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> и до визуализации страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnPreRenderComplete%2A> Метод вызывается после завершения стадии предварительной отрисовки жизненного цикла страницы. На этом этапе жизненного цикла страницы все элементы управления создаются и странице готов к просмотру.  
  
 Это последнее событие, вызываемое перед сохранением состояния просмотра страницы.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Web.UI.Page.OnPreRenderComplete%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> метод, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSaveStateComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnSaveStateComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSaveStateComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSaveStateComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSaveStateComplete(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, содержащий данные о событии.</param>
        <summary>Событие <see cref="E:System.Web.UI.Page.SaveStateComplete" /> возникает после того, как состояние страницы сохранено на постоянном носителе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnSaveStateComplete%2A> Метод вызывается, когда сведения о состоянии для элемента управления записан на носитель сохраняемости для страницы. Сведения о состоянии записываются в постоянной среде путем вызова <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> метод.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Web.UI.Page.OnSaveStateComplete%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> метод, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
        <altmember cref="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
        <altmember cref="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="public System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает адаптер, отображающий страницу для указанного запрашивающего браузера.</summary>
        <value>Объект <see cref="T:System.Web.UI.Adapters.PageAdapter" />, отображающий страницу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.PageAdapter%2A> Свойство возвращает конкретный <xref:System.Web.UI.Adapters.PageAdapter> объект, который изменяет поведение <xref:System.Web.UI.Page> объекта для запрашивающего браузера.  
  
 Конкретный <xref:System.Web.UI.Adapters.PageAdapter> объект определяется путем анализа характеристики входящего <xref:System.Web.UI.Page.Request%2A> объекта. Если адаптер выбирается для запроса, событий жизненного цикла на <xref:System.Web.UI.Adapters.PageAdapter> объекта переопределить соответствующие события на <xref:System.Web.UI.Page> объекта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageStatePersister">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.PageStatePersister PageStatePersister { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.PageStatePersister PageStatePersister" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageStatePersister" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property PageStatePersister As PageStatePersister" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Web::UI::PageStatePersister ^ PageStatePersister { System::Web::UI::PageStatePersister ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.PageStatePersister</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.UI.PageStatePersister" />, связанный со страницей.</summary>
        <value>Объект <see cref="T:System.Web.UI.PageStatePersister" />, связанный со страницей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTTP-запросы и ответы по своей природе без сохранения состояния. Чтобы сохранять состояние между HTTP-запросов, серверные страницы ASP.NET могут сохранять <xref:System.Web.UI.Page> состояния. Это состояние, называемое состоянием представления, состоит из страницы и параметры управления и данных, страницы и элементы управления отображаются, как будто они являются теми же самыми элементами, которые пользователь видел и взаимодействовать с ними их последнего цикла обработки страницы. Существует несколько механизмов для сохранения состояния представления между последующими запросами к той же странице. Абстрактный <xref:System.Web.UI.PageStatePersister> класс представляет базовый класс для таких механизмов хранения состояния.  
  
 Разработчики страниц обычно не требуется использовать <xref:System.Web.UI.Page.PageStatePersister%2A> свойства. <xref:System.Web.UI.Page.PageStatePersister%2A> Свойство используется преимущественно разработчиками элементов управления расширения функциональности служб <xref:System.Web.UI.Page> класса.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="postEventArgumentID">
      <MemberSignature Language="C#" Value="public const string postEventArgumentID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventArgumentID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventArgumentID" />
      <MemberSignature Language="VB.NET" Value="Public Const postEventArgumentID As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ postEventArgumentID;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Строка, определяющая скрытое поле EVENTARGUMENT в отображаемой странице.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="F:System.Web.UI.Page.postEventSourceID" />
      </Docs>
    </Member>
    <Member MemberName="postEventSourceID">
      <MemberSignature Language="C#" Value="public const string postEventSourceID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventSourceID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventSourceID" />
      <MemberSignature Language="VB.NET" Value="Public Const postEventSourceID As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ postEventSourceID;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Строка, определяющая скрытое поле EVENTTARGET в отображаемой странице.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="F:System.Web.UI.Page.postEventArgumentID" />
      </Docs>
    </Member>
    <Member MemberName="PreInit">
      <MemberSignature Language="C#" Value="public event EventHandler PreInit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreInit" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreInit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreInit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreInit;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит до инициализации страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие позволяет проверять условия запроса страницы, например загружается ли страница в ответ на обратный. Также можно проверить значения свойств профиля.  
  
 Это событие позволяет задавать значения, используемые позднее в жизненном цикле страницы. Можно динамически задать главной страницы или темы для запрашиваемой страницы и создавать элементы управления.  
  
 Дополнительные сведения о том, как <xref:System.Web.UI.Page.PreInit> события попадают жизненного цикла ASP.NET см. в разделе [Общие сведения о жизненном цикле страницы ASP.NET](http://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreLoad" />
      </Docs>
    </Member>
    <Member MemberName="PreLoad">
      <MemberSignature Language="C#" Value="public event EventHandler PreLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreLoad" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreLoad As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreLoad;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит до события <see cref="E:System.Web.UI.Control.Load" /> страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.PreLoad> Событие возникает после всех обратной передачи обработки данных и перед <xref:System.Web.UI.Control.Load> событий. Вторая попытка загрузки данных обратной передачи, прежде чем <xref:System.Web.UI.Page.OnLoadComplete%2A> событий. Дополнительные сведения об обработке событий см. в разделе [NIB: Потребление событий](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreInit" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
      </Docs>
    </Member>
    <Member MemberName="PreRenderComplete">
      <MemberSignature Language="C#" Value="public event EventHandler PreRenderComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRenderComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreRenderComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreRenderComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreRenderComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит до визуализации содержимого страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.PreRenderComplete> События по завершении стадии предварительной визуализации жизненного цикла страницы. На этом этапе жизненного цикла страницы все элементы управления создаются, завершить все запрошенные разбиения на страницы и страница готова к визуализации на выходе.  
  
 Это последнее событие, возникающее перед сохранением состояния просмотра страницы.  
  
 Дополнительные сведения об обработке событий см. в разделе [NIB: Потребление событий](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreLoad" />
        <altmember cref="E:System.Web.UI.Page.PreInit" />
      </Docs>
    </Member>
    <Member MemberName="PreviousPage">
      <MemberSignature Language="C#" Value="public System.Web.UI.Page PreviousPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page PreviousPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PreviousPage" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousPage As Page" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Page ^ PreviousPage { System::Web::UI::Page ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает страницу, передавшую управление текущей странице.</summary>
        <value>Объект <see cref="T:System.Web.UI.Page" />, представляющий страницу, передавшую управление текущей странице.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании <xref:System.Web.HttpServerUtility.Transfer%2A> метода или используйте страницы между учета для передачи обработки с одной страницы ASP.NET исходного страница содержит сведения о запросе, могут быть необходимы для целевой страницы. Можно использовать <xref:System.Web.UI.Page.PreviousPage%2A> свойство доступ к этим сведениям.  
  
 Если текущая страница готовится к просмотру в результате прямого запроса (не передачи или перекрестной рассылки с другой страницы), <xref:System.Web.UI.Page.PreviousPage%2A> свойство содержит `null`.  
  
   
  
## Examples  
 Следующий пример состоит из двух частей. Первый — страница ASP.NET, которая использует <xref:System.Web.HttpServerUtility.Transfer%2A> метод, представленные в виде модели страницы `Server.Transfer("path")`. Вторая часть — целевой страницы, которая использует <xref:System.Web.UI.Page.PreviousPage%2A> свойства заголовок первой страницы.  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Main.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Main.aspx#1)]  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Notify.aspx#2)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Notify.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущему пользователю не разрешен доступ к предыдущей странице.  -или- Используется маршрутизация ASP.NET, URL-адрес предыдущей страницы является маршрутизируемым URL-адресом. Когда ASP.NET проверяет разрешения на доступ, предполагается, что URL-адрес представляет собой фактический путь к файлу. Поскольку это не относится к случаю для маршрутизируемого URL-адреса, проверка завершится ошибкой.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessRequest">
      <MemberSignature Language="C#" Value="public virtual void ProcessRequest (System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessRequest(class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ProcessRequest (context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessRequest(System::Web::HttpContext ^ context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.IHttpHandler.ProcessRequest(System.Web.HttpContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="context">Объект <see cref="T:System.Web.HttpContext" />, предоставляющий ссылки к внутренним серверным объектам (например, <see cref="P:System.Web.HttpContext.Request" />, <see cref="P:System.Web.HttpContext.Response" /> и <see cref="P:System.Web.HttpContext.Session" />), используемым для обслуживания запросов HTTP.</param>
        <summary>Задает встроенные серверные объекты, относящиеся к объекту <see cref="T:System.Web.UI.Page" />, такие как свойства <see cref="P:System.Web.UI.Page.Context" />, <see cref="P:System.Web.UI.Page.Request" />, <see cref="P:System.Web.UI.Page.Response" /> и <see cref="P:System.Web.UI.Page.Application" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не следует вызывать этот метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Context" />
        <altmember cref="P:System.Web.UI.Page.Request" />
        <altmember cref="P:System.Web.UI.Page.Response" />
        <altmember cref="P:System.Web.UI.Page.Application" />
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(class System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RaisePostBackEvent(System.Web.UI.IPostBackEventHandler,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostBackEvent (sourceControl As IPostBackEventHandler, eventArgument As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostBackEvent(System::Web::UI::IPostBackEventHandler ^ sourceControl, System::String ^ eventArgument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceControl" Type="System.Web.UI.IPostBackEventHandler" />
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceControl">Серверный элемент управления ASP.NET, вызвавший обратную передачу. Этот элемент управления должен реализовывать интерфейс <see cref="T:System.Web.UI.IPostBackEventHandler" />.</param>
        <param name="eventArgument">Аргумент обратного запроса.</param>
        <summary>Оповещает серверный элемент управления, вызвавший обратный запрос, о необходимости обработки входящего события обратной передачи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page> Вызывает <xref:System.Web.UI.Page.RaisePostBackEvent%2A> метод при обратной передаче. Этот вызов происходит в жизненном цикле страницы после уведомления о загрузке и изменении, но до подготовки к отображению.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Web.UI.Page.RaisePostBackEvent%2A> метод для уведомления ASP.NET, что события обратного возникает, когда пользовательский `userButton` нажатии элемента управления сервера.  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterArrayDeclaration(string arrayName, string arrayValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Имя массива для объявления значения.</param>
        <param name="arrayValue">Значение, помещаемое в массив.</param>
        <summary>Объявляет значение, определяемое как массив ECMAScript при отображении страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может использоваться элементами управления на основе сценария для объявления их в массиве, чтобы библиотека клиентских сценариев могли работать со всеми элементами того же типа.  
  
 Метод <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> не рекомендуется к использованию. Используйте <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> метод <xref:System.Web.UI.ClientScriptManager> класса.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> метод, чтобы объявить массив, `myArray`, содержащий три объекта с именем `x`, `y`, и `z`. В примере определяется и регистрирует при запуске скрипта с помощью <xref:System.Web.UI.Page.RegisterStartupScript%2A> метод. Когда ECMAScript `doClick` функция вызывается из страницы, содержащей этот код, происходит инициализация массива и его объектов.  
  
 [!code-csharp[Page_RegisterArrayDeclaration#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/CS/page_registerarraydeclaration.cs.aspx#1)]
 [!code-vb[Page_RegisterArrayDeclaration#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/VB/page_registerarraydeclaration.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncTask">
      <MemberSignature Language="C#" Value="public void RegisterAsyncTask (System.Web.UI.PageAsyncTask task);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterAsyncTask(class System.Web.UI.PageAsyncTask task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAsyncTask (task As PageAsyncTask)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterAsyncTask(System::Web::UI::PageAsyncTask ^ task);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Web.UI.PageAsyncTask" />
      </Parameters>
      <Docs>
        <param name="task">Объект <see cref="T:System.Web.UI.PageAsyncTask" />, определяющий асинхронную задачу.</param>
        <summary>Регистрирует новую асинхронную задачу со страницей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Определение асинхронных задач с помощью <xref:System.Web.UI.PageAsyncTask> класса. При определении задачи используйте <xref:System.Web.UI.Page.RegisterAsyncTask%2A> метод для регистрации задачи на странице. После регистрации задачи, вызов <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> метод для начала асинхронной задачи.  
  
 <xref:System.Web.UI.Page.RegisterAsyncTask%2A> Метод можно использовать для синхронных и асинхронных страниц.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.Page.AsyncTimeout%2A> свойство с <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> и <xref:System.Web.UI.Page.RegisterAsyncTask%2A> методы. Обратите внимание на использование обработчиков начала, окончания и время ожидания. В примере вводится искусственная задержка для демонстрации ситуации асинхронной задачи превышение времени, выделенного для задачи, как указано в <xref:System.Web.UI.Page.AsyncTimeout%2A> свойство. В реальном сценарии асинхронная задача может использоваться для выполнения вызовов базы данных или создания изображений, например, и обработчик тайм-аута предоставляет постепенного ухудшения качества обслуживания, если задача не выполняется в определенное время.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Асинхронная задача равна <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public virtual void RegisterClientScriptBlock (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterClientScriptBlock(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterClientScriptBlock (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterClientScriptBlock(System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterClientScriptBlock(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный ключ, определяющий блок скрипта.</param>
        <param name="script">Содержимое скрипта, отправляемое клиенту.</param>
        <summary>Выпускает клиентские блоки скриптов в качестве ответа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентский сценарий создается сразу после открывающего тега элемента <xref:System.Web.UI.Page> объекта `<form runat= server>` элемент. Не забудьте включить открывающий и закрывающий `<script>` элементы вокруг скрипт блокировки строки, указанной в `script` параметра.  
  
 Так как этот метод использует ключ для идентификации блока, блок сценария не передается в выходной поток каждый раз, когда он запрашивается экземпляра элемента управления другой сервер. Использование ключа также уменьшает вероятность конфликта друг с другом блоки сценариев различных элементов управления.  
  
 Любые блоки сценариев с одинаковыми `key` значения параметров, считаются дубликатами.  
  
> [!NOTE]
>  Не забудьте включить комментарий HTML-теги скрипта, чтобы он не отображался, если запрашивающий обозреватель не поддерживает сценарии.  
  
 Метод <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> не рекомендуется к использованию. Вместо него следует использовать метод <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> класса <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> в сочетании с <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> метод. Если в блоке объявления кода ECMAScript не уже был зарегистрирован, определяется <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>, <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> вызов.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public virtual void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Уникальное имя отображаемого скрытого поля.</param>
        <param name="hiddenFieldInitialValue">Значение, порождаемое в скрытой форме.</param>
        <summary>Позволяет серверным элементам управления автоматически регистрировать скрытое поле на форме. Поле будет отправлено объекту <see cref="T:System.Web.UI.Page" /> при отображении серверного элемента управления <see cref="T:System.Web.UI.HtmlControls.HtmlForm" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Web.UI.Page.RegisterHiddenField%2A> не рекомендуется к использованию. Используйте <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> метод <xref:System.Web.UI.ClientScriptManager> класса.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Web.UI.Page.RegisterHiddenField%2A> метод для создания кода ECMAScript, который передает браузеру. Имя регистрируемого скрытого поля равно `myHiddenField` и его значение равно «Добро пожаловать в корпорацию Майкрософт!» <xref:System.Web.UI.Page.RegisterStartupScript%2A> Вызовы метода `myHiddenField` значение, когда пользователь нажимает кнопку на странице.  
  
> [!IMPORTANT]
>  В этом примере имеется скрытое поле, что является потенциальной угрозой безопасности. По умолчанию следует проверить значение скрытого поля, как и значение текстового поля. Веб-страницы ASP.NET проверить ввод пользователя на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterHiddenField#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#1)]
 [!code-vb[Page_RegisterHiddenField#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterOnSubmitStatement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterOnSubmitStatement (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterOnSubmitStatement(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный ключ, определяющий блок скрипта.</param>
        <param name="script">Клиентский скрипт, отправляемый клиенту.</param>
        <summary>Предоставляет странице доступ к клиентскому событию <see langword="OnSubmit" />. Скрипт должен являться обращением функции к клиентскому коду, зарегистрированному в другом месте.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> не рекомендуется к использованию. Используйте <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метод <xref:System.Web.UI.ClientScriptManager> класса.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> для доступа к скрипт, который реагирует при нажатии кнопки отправки клиентских. При возникновении этого события, зарегистрированный код ECMAScript выполняется на стороне клиента.  
  
> [!IMPORTANT]
>  В этом примере имеется скрытое поле, что является потенциальной угрозой безопасности. По умолчанию следует проверить значение скрытого поля, как и значение текстового поля. Веб-страницы ASP.NET проверить ввод пользователя на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterHiddenField#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#2)]
 [!code-vb[Page_RegisterHiddenField#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void RegisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Регистрируемый элемент управления.</param>
        <summary>Регистрирует элемент управления, как элемент управления с сохраняемым состоянием.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы управления сервера состояния элемента управления необходимо вызвать метод <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> метод при каждом запросе, так как регистрация состояния элемента управления не переносятся из запроса к запросу во время события обратной передачи. Рекомендуется возникновения регистрации в <xref:System.Web.UI.Control.Init> событий.  
  
   
  
## Examples  
 В следующем примере кода показано, вызывающую пользовательский сервер управления <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> метод.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Регистрируемый элемент управления имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" /> может вызываться только до или во время события <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <altmember cref="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresPostBack">
      <MemberSignature Language="C#" Value="public void RegisterRequiresPostBack (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresPostBack(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresPostBack(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Регистрируемый элемент управления.</param>
        <summary>Регистрирует элемент управления, как элемент требующий обработки обратной передачи, когда страница передается обратно на сервер.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Регистрируемый элемент управления должен реализовать <xref:System.Web.UI.IPostBackDataHandler> интерфейса или <xref:System.Web.HttpException> возникает. При реализации с помощью элемента управления <xref:System.Web.UI.IPostBackDataHandler> интерфейс включает обработку данных обратной передачи и возникновение любого post резервное события изменения данных. Дополнительные сведения о модели событий серверных элементов управления см. в разделе [модель событий серверного элемента управления ASP.NET Web Forms](http://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3).  
  
 Регистрирует элемент управления во время или до `Page_PreRender` события жизненного цикла страницы.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Web.UI.Page.RegisterRequiresPostBack%2A> метода требуется элемент управления текстовым полем `myTextBox`, чтобы до выполнения могут выполнять любой код, связанный с текстовым полем. <xref:System.Web.UI.WebControls.TextBox> элементы управления реализуют <xref:System.Web.UI.IPostBackDataHandler> интерфейса.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterRequiresPostBack#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/CS/page_registerrequirespostback.cs.aspx#1)]
 [!code-vb[Page_RegisterRequiresPostBack#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/VB/page_registerrequirespostback.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Регистрируемый элемент управления не реализует интерфейс <see cref="T:System.Web.UI.IPostBackDataHandler" />.</exception>
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresRaiseEvent">
      <MemberSignature Language="C#" Value="public virtual void RegisterRequiresRaiseEvent (System.Web.UI.IPostBackEventHandler control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterRequiresRaiseEvent(class System.Web.UI.IPostBackEventHandler control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresRaiseEvent(System.Web.UI.IPostBackEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterRequiresRaiseEvent (control As IPostBackEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterRequiresRaiseEvent(System::Web::UI::IPostBackEventHandler ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.IPostBackEventHandler" />
      </Parameters>
      <Docs>
        <param name="control">Регистрируемый элемент управления.</param>
        <summary>Регистрирует серверный элемент управления ASP.NET, как требующий возникновения события при его обработке в объекте <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для каждого запроса страницы может быть зарегистрирован только один сервер управления. <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> Необходимо использовать, когда элемент управления не содержит идентификатор в виде отправленные данные элемента управления. Кроме того, необходимо реализовать элемент управления, который зарегистрирован <xref:System.Web.UI.IPostBackEventHandler> интерфейса.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> метода для регистрации <xref:System.Web.UI.WebControls.Button> управления веб-сервера как требующее быть активизировано событие. После регистрации первого <xref:System.Web.UI.WebControls.Button> управления, может привести к второй <xref:System.Web.UI.WebControls.Button> элемента управления, объявленного в коде для учета результатов первой кнопки click-событие на страницу.  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresViewStateEncryption">
      <MemberSignature Language="C#" Value="public void RegisterRequiresViewStateEncryption ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresViewStateEncryption() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterRequiresViewStateEncryption ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresViewStateEncryption();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Регистрирует элемент управления со страницей, как требующий состояния элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы разрабатываете пользовательский элемент управления, который имеет дело с потенциально конфиденциальная информация, вызовите <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A> метода для регистрации на странице управления и обеспечения состояния представления, для шифрования элемента управления.  
  
 Состояние всей страницы будет шифроваться, если <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> равно <xref:System.Web.UI.ViewStateEncryptionMode.Auto> или <xref:System.Web.UI.ViewStateEncryptionMode.Always>.  
  
   
  
## Examples  
 В следующем примере кода показано задание режима шифрования состояния представления для <xref:System.Web.UI.Page> объекта и запрашивающего шифрования состояния представления через <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A>. В этом примере состояние представления будет шифроваться, если информация о заказчике извлекается из базы данных.  
  
 [!code-aspx-csharp[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/CS/encryptViewState.cs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/VB/encryptViewState.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" /> должен вызываться до или во время этапа <see langword="PreRender" /> жизненного цикла страницы.</exception>
        <altmember cref="P:System.Web.UI.Page.ViewStateEncryptionMode" />
        <altmember cref="T:System.Web.UI.WebControls.GridView" />
        <altmember cref="T:System.Web.UI.WebControls.DetailsView" />
        <altmember cref="T:System.Web.UI.WebControls.FormView" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public virtual void RegisterStartupScript (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterStartupScript(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterStartupScript (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterStartupScript(System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterStartupScript(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный ключ, определяющий блок скрипта.</param>
        <param name="script">Содержимое скрипта, отправляемое клиенту.</param>
        <summary>Порождает клиентские блоки скриптов в качестве реакции страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Аналогично <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> метода <xref:System.Web.UI.Page.RegisterStartupScript%2A> метод выдает сценарий непосредственно перед закрывающим тегом <xref:System.Web.UI.Page> объекта `<form runat= server>` элемент. Не забудьте включить открывающий и закрывающий `<script>` элементы вокруг скрипт блокировки строки, указанной в `script` параметра.  
  
 Так как этот метод использует ключ для идентификации блока, блок сценария не передается в выходной поток каждый раз, когда он запрашивается экземпляра элемента управления другой сервер  
  
 Любые блоки сценариев с одинаковыми `key` значения параметров, считаются дубликатами.  
  
> [!NOTE]
>  Не забудьте включить комментарий HTML-теги скрипта, чтобы он не отображался, если запрашивающий обозреватель не поддерживает сценарии.  
  
 Метод <xref:System.Web.UI.Page.RegisterStartupScript%2A> не рекомендуется к использованию. Вместо него следует использовать метод <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> класса <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.Page.RegisterStartupScript%2A> в сочетании с <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> метод. Если блок объявления кода на языке ECMAScript не уже был зарегистрирован, определяется <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> метод, то <xref:System.Web.UI.Page.RegisterStartupScript%2A> вызов.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterViewStateHandler">
      <MemberSignature Language="C#" Value="public void RegisterViewStateHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterViewStateHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterViewStateHandler" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterViewStateHandler ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterViewStateHandler();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает сохранение состояния отображения страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.RegisterViewStateHandler%2A> Метод автоматически вызывается через <xref:System.Web.UI.HtmlControls.HtmlForm> серверного элемента управления. Если этот метод не вызван, состояния просмотра страницы не будут сохранены.  
  
> [!NOTE]
>  Как правило только <xref:System.Web.UI.HtmlControls.HtmlForm> серверного элемента управления для страницы вызывает этот метод.  
  
   
  
## Examples  
 [!code-csharp[Page_RegisterViewStateHandler#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterViewStateHandler/CS/page_registerviewstatehandler.cs#1)]
 [!code-vb[Page_RegisterViewStateHandler#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterViewStateHandler/VB/page_registerviewstatehandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" />, получающий содержимое страницы.</param>
        <summary>Инициализирует объект <see cref="T:System.Web.UI.HtmlTextWriter" /> и вызывает дочерние элементы управления страницы <see cref="T:System.Web.UI.Page" /> для отображения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Render%2A> Метод отвечает за создание текст и разметку, которая отправляется в браузер клиента. Значение по умолчанию <xref:System.Web.UI.Page.Render%2A> вызовы метода <xref:System.Web.UI.Control.RenderChildren%2A> для записи текста и разметки для элементов управления, содержащихся на странице.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.HttpRequest" /> для запрашиваемой страницы.</summary>
        <value>Текущий объект <see cref="T:System.Web.HttpRequest" />, связанный со страницей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Web.HttpRequest> содержит сведения о текущем HTTP-запросе.  
  
   
  
## Examples  
 В следующем примере демонстрируется получение <xref:System.Web.HttpRequest.Headers%2A> коллекции из <xref:System.Web.HttpRequest> объекта и записи их на странице ASP.NET.  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Происходит, когда объект <see cref="T:System.Web.HttpRequest" /> недоступен.</exception>
        <altmember cref="T:System.Web.HttpException" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="RequiresControlState">
      <MemberSignature Language="C#" Value="public bool RequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Элемент управления <see cref="T:System.Web.UI.Control" /> для проверки требования состояния элемента управления.</param>
        <summary>Определяет, зарегистрирован ли указанный объект <see cref="T:System.Web.UI.Control" /> для участия в управлении состоянием элемента управления.</summary>
        <returns>
          <see langword="true" />, если указанный элемент управления <see cref="T:System.Web.UI.Control" /> требует использования состояния элемента управления; в противном случае ─ <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Состояние элемента управления — это объект, который состоит из важных данных состояния представления, веб-сервера управления требуется функция; он содержится в отдельном объекте из состояния в обычном режиме.  
  
 Пользовательские элементы управления, используя состояние элемента управления необходимо вызвать метод <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> метод перед сохранением состояния элемента управления. Используйте <xref:System.Web.UI.Page.RequiresControlState%2A> метод для проверки наличия элементов управления, которые зарегистрированы с помощью страницы, как они требуют состояние элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
        <altmember cref="P:System.Web.UI.PageStatePersister.ControlState" />
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.HttpResponse" />, связанный с объектом <see cref="T:System.Web.UI.Page" />. Этот объект позволяет отправлять клиенту данные HTTP-ответа и содержит сведения об этом ответе.</summary>
        <value>Текущий объект <see cref="T:System.Web.HttpResponse" />, связанный со страницей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано создание файла cookie и добавление его в выходные данные НТТР страницы с помощью <xref:System.Web.HttpResponse> объекта.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Объект <see cref="T:System.Web.HttpResponse" /> недоступен.</exception>
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="ResponseEncoding">
      <MemberSignature Language="C#" Value="public string ResponseEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ResponseEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ResponseEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ResponseEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает язык шифрования для текущего объекта <see cref="T:System.Web.HttpResponse" />.</summary>
        <value>Строка, содержащая язык шифрования для текущего объекта <see cref="T:System.Web.HttpResponse" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задать `ResponseEncoding` атрибуту нужное значение с помощью директивы в ASPX-файле. При запросе страницы динамически создаваемый класс задает свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData RouteData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteData RouteData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.RouteData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RouteData As RouteData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RouteData ^ RouteData { System::Web::Routing::RouteData ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение свойства <see cref="P:System.Web.Routing.RequestContext.RouteData" /> текущего экземпляра <see cref="T:System.Web.Routing.RequestContext" />.</summary>
        <value>Значение свойства <see cref="P:System.Web.Routing.RequestContext.RouteData" /> текущего экземпляра <see cref="T:System.Web.Routing.RequestContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если страница выполняется в ответ на запрос по маршрутизация ASP.NET, это свойство предоставляет доступ к URL-адрес значения параметров, которые были переданы в качестве данных маршрута. Если страница выполняется в ответ на физический URL-адрес вместо URL-адреса маршрута, это свойство является `null`. В следующем примере показано, как для извлечения значения параметра URL-адреса, которая называется `year`.  
  
```vb  
Dim year As Integer = Convert.ToInt32(Page.RouteData.Values("year"))  
```  
  
```csharp  
int year = Convert.ToInt32(Page.RouteData.Values["year"])  
```  
  
 Если маршрут определяется с помощью шаблона URL-адрес `{locale}/{year}` для домена `contoso.com`, и если запрошенный URL-адрес `contoso.com/US/2010`, `year` будет содержать значение «2010» при запуске этого кода.  
  
 Дополнительные сведения о маршрутизации ASP.NET см. в разделе [маршрутизация ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Routing.RequestContext.RouteData" />
      </Docs>
    </Member>
    <Member MemberName="SavePageStateToPersistenceMedium">
      <MemberSignature Language="C#" Value="protected internal virtual void SavePageStateToPersistenceMedium (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SavePageStateToPersistenceMedium(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub SavePageStateToPersistenceMedium (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void SavePageStateToPersistenceMedium(System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Объект <see cref="T:System.Object" /> для сохранения сведений о состоянии просмотра.</param>
        <summary>Сохраняет любые сведения о состоянии представления и информации о состоянии элемента управления страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> Использует метод <xref:System.Web.UI.PageStatePersister.Save%2A> метод <xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType> объект, упоминаемый в <xref:System.Web.UI.Page.PageStatePersister%2A> свойство для хранения сведений о состоянии представления и состояние элемента управления для страницы.  
  
 В ASP.NET есть два потомков <xref:System.Web.UI.PageStatePersister> класса, <xref:System.Web.UI.HiddenFieldPageStatePersister> класс, который сохраняет информацию о состоянии в скрытом поле, входящих в страницу ASP.NET и <xref:System.Web.UI.SessionPageStatePersister> класс, который сохраняет состояние в <xref:System.Web.UI.Page.Session%2A> объект, связанный с запрос. Обратите внимание, что при использовании <xref:System.Web.UI.SessionPageStatePersister> класс скрытое поле VIEWSTATE по-прежнему отображается, поскольку этот объект используется для определения обратной передачи.  
  
 Для сохранения состояния в выбранное расположение, вы создаете новый потомком <xref:System.Web.UI.PageStatePersister> класс, который сохраняет и загружает состояние в постоянной среде по своему усмотрению. Пример создания нового <xref:System.Web.UI.PageStatePersister> см. в разделе <xref:System.Web.UI.PageStatePersister> класса.  
  
 При использовании .NET Framework версии 1.0 или 1.1, переопределите этот метод, если вы хотите сохранить <xref:System.Web.UI.Page> состояния в ничего, кроме скрытого поля. Если вы решили сделать это, необходимо также переопределить <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
        <altmember cref="P:System.Web.UI.Page.PageStatePersister" />
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="SaveStateComplete">
      <MemberSignature Language="C#" Value="public event EventHandler SaveStateComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SaveStateComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.SaveStateComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SaveStateComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SaveStateComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после того, как страница завершила сохранение всех данных о состоянии представления и состоянии элементов управления для страницы и элементов управления на ней.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сведения о состоянии для элементов управления на веб-странице сохраняется после <xref:System.Web.UI.Page.PreRenderComplete> событий. <xref:System.Web.UI.Page.SaveStateComplete> Событие вызывается после состояния просмотра и управления состоянием страницы и элементы управления на странице сохраняются средний сохраняемости.  
  
 Это последнее событие, возникающее перед отображением страницы браузеру.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.InitComplete" />
        <altmember cref="E:System.Web.UI.Page.LoadComplete" />
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see langword="Server" />, являющийся экземпляром класса <see cref="T:System.Web.HttpServerUtility" />.</summary>
        <value>Текущий объект <see langword="Server" />, связанный со страницей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляет доступ к часто используемым <xref:System.Web.HttpServerUtility.HtmlEncode%2A> и <xref:System.Web.HttpServerUtility.MapPath%2A> методы среди других.  
  
   
  
## Examples  
 В следующем примере кода показано, как для получения сведений об ошибках с сервера с помощью `Server` объекта. В частности, в примере показано получение запрошенного URL-адреса из `Request` объект, наиболее часто встречающиеся ошибки из `Server` объекта (с помощью <xref:System.Web.HttpServerUtility.GetLastError%2A> метод) и преобразует их в строки, которые могут отображаться с помощью клиента. Один раз `message` переменной записывается на клиенте, ошибка удаляется с помощью <xref:System.Web.HttpServerUtility.ClearError%2A> метод.  
  
 [!code-csharp[System.Web.UI.Page_Error method#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Error method/CS/sourcecs.aspx#1)]
 [!code-vb[System.Web.UI.Page_Error method#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Error method/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpServerUtility" />
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public virtual System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Session" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущий объект <see langword="Session" />, предоставленный ASP.NET.</summary>
        <value>Текущие данные о состоянии сеанса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляет сведения о сеансе текущего запроса. Объект `Session` поддерживается для каждого пользователя, запрашивающего страницу или документ из приложения ASP.NET. Переменные сохраняются в `Session` объекта, не отбрасываются при переходе между страницами в приложении; вместо этого они сохраняются до тех пор, пока пользователь получает доступ к страниц в приложении. Дополнительные сведения о состоянии сеанса см. в разделе [Общие сведения о состоянии сеанса ASP.NET](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 В следующем примере кода создается `GetStyle` функция, извлекающая ключ, сохраненный в состоянии сеанса, страницы веб-форм и преобразует его значение в строку.  
  
 [!code-csharp[Page.Session_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Session_Samples1/CS/sessioncs.aspx#1)]
 [!code-vb[Page.Session_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Session_Samples1/VB/sessionvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Происходит, когда сведения о сеансе установлены в значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.HttpException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetFocus">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Устанавливает фокус ввода браузера на указанном элементе управления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFocus (clientID As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::String ^ clientID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">Идентификатор элемента управления, получающего фокус.</param>
        <summary>Устанавливает фокус браузера на элементе управления, с указанным идентификатором.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.SetFocus%2A> метод, чтобы сделать элемент управления с указанным Идентификатором строки активный элемент управления на веб-странице, отображаемой браузером. <xref:System.Web.UI.Page.SetFocus%2A> Метод должен вызываться перед страницы подготавливается для подготовки к просмотру клиенту в <xref:System.Web.UI.Control.PreRender> событий.  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.SetFocus%2A> Метод будет работать только в браузерах, поддерживающих ECMAScript версии 1.3 и более поздней версии.  
  
   
  
## Examples  
 В следующем примере кода устанавливает фокус на второе текстовое поле на веб-странице.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageSetFocus#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbyidcs.aspx#1)]
 [!code-aspx-vb[PageSetFocus#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbyidvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="clientID" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Web.UI.Page.SetFocus(System.String)" /> вызывается, когда элемент управления не является частью страницы веб-формы.  \- или - Метод <see cref="M:System.Web.UI.Page.SetFocus(System.String)" /> вызывается после события <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Элемент управления, получающий фокус ввода.</param>
        <summary>Устанавливает фокус ввода браузера на указанном элементе управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.SetFocus%2A> метод для приготовления указанный элемент управления активным элементом управления на веб-странице, отображаемой браузером. <xref:System.Web.UI.Page.SetFocus%2A> Метод должен вызываться перед страницы подготавливается для подготовки к просмотру клиенту в <xref:System.Web.UI.Control.PreRender> событий.  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.SetFocus%2A> Метод будет работать только в браузерах, поддерживающих ECMAScript версии 1.3 и более поздней версии.  
  
   
  
## Examples  
 В следующем примере кода устанавливает фокус на второе текстовое поле на веб-странице.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageSetFocus#2](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbycontrolcs.aspx#2)]
 [!code-aspx-vb[PageSetFocus#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbycontrolvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="control" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" /> вызывается, когда элемент управления не является частью страницы веб-формы.  \- или - Метод <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" /> вызывается после события <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipFormActionValidation">
      <MemberSignature Language="C#" Value="public bool SkipFormActionValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipFormActionValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SkipFormActionValidation" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipFormActionValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipFormActionValidation { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, проверяется ли значение строки запроса.</summary>
        <value>Значение <see langword="true" />, если проверка строки запроса должна быть пропущена (строка запроса не должна проверяться); в противном случае — значение <see langword="false" />, если проверка строки запроса должна производится обычным образом. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SmartNavigation">
      <MemberSignature Language="C#" Value="public bool SmartNavigation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SmartNavigation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SmartNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Property SmartNavigation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SmartNavigation { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is Page.SetFocus and Page.MaintainScrollPositionOnPostBack. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, включена ли интеллектуальная навигация. Это свойство использовать не рекомендуется.</summary>
        <value>
          <see langword="true" />, если навигация включена. В противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задать `SmartNavigation` атрибут `true` в директиве в ASPX-файле. При запросе страницы динамически создаваемый класс устанавливает это свойство.  
  
> [!NOTE]
>  В ASP.NET версии 2.0 <xref:System.Web.UI.Page.SmartNavigation%2A> свойство является устаревшим. Используйте <xref:System.Web.UI.Page.SetFocus%2A> метод и <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> свойство вместо него.  
  
 При запросе страницы обозревателем Microsoft Internet Explorer 5.5 или более поздней версии, смарт-навигации расширяет взаимодействие с пользователем страницы, выполняя следующие:  
  
-   Исключения, вызванные навигации флэш-памяти.  
  
-   Сохранение позиции прокрутки при переходе между страницами.  
  
-   Сохраняется фокус элемента между переходами.  
  
-   Сохраняется только последнее состояние страницы в журнале браузера.  
  
 Смарт-навигации лучше всего подходит для страниц ASP.NET, требующих частых обратных передач, но визуальное содержимое, которое не изменяющееся при возврате. Следует внимательно при принятии решения о присвойте этому свойству значение `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.Page.SetFocus" />
        <altmember cref="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      </Docs>
    </Member>
    <Member MemberName="StyleSheetTheme">
      <MemberSignature Language="C#" Value="public virtual string StyleSheetTheme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StyleSheetTheme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.StyleSheetTheme" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property StyleSheetTheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StyleSheetTheme { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя темы, применяемой к странице на ранних этапах жизненного цикла страницы.</summary>
        <value>Имя темы, применяемой к странице на ранних этапах жизненного цикла страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство не ссылается непосредственно на таблицы каскадных стилей (CSS). Свойство содержит имя темы ASP.NET, который может включать файлы CSS в нем.  
  
 <xref:System.Web.UI.Page.StyleSheetTheme%2A> Свойство задает имя темы, который применяется на страницу в начале жизненного цикла страницы, тогда как <xref:System.Web.UI.Page.Theme%2A> свойство задает имя темы, который применяется к странице позднее в жизненном цикле страницы. Это означает, что параметры на странице имеют приоритет над параметрами в тему таблицы стилей. Дополнительные сведения см. в разделе [ASP.NET тем и обложек](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 Значение для этого свойства обычно устанавливается в директиве страницы или путем переопределения свойства. Сведения в следующих разделах:  
  
-   [Как: применение тем ASP.NET](http://msdn.microsoft.com/library/f9d72364-4d77-4b73-84be-7630dc63e0fe)  
  
-   [Как: применение тем ASP.NET программными средствами](http://msdn.microsoft.com/library/02eed7c3-01e8-4e20-8358-df47dbd4f148))  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Предпринята попытка установить свойство <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> после вызова метода <see cref="M:System.Web.UI.Page.FrameworkInitialize" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> задано недействительное имя темы. Это исключение создается, когда вызывается метод <see cref="M:System.Web.UI.Page.FrameworkInitialize" />, а не метод задания свойства.</exception>
        <altmember cref="P:System.Web.UI.Page.Theme" />
      </Docs>
    </Member>
    <Member MemberName="Theme">
      <MemberSignature Language="C#" Value="public virtual string Theme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Theme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Theme" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Theme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Theme { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает тему страницы.</summary>
        <value>Имя темы страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Theme%2A> Свойство задает имя темы страницы. Параметры на странице имеют приоритет над параметрами в теме, используйте <xref:System.Web.UI.Page.StyleSheetTheme%2A> свойство. Дополнительные сведения см. в разделе [ASP.NET тем и обложек](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 <xref:System.Web.UI.Page.Theme%2A> Свойству необходимо присвоить до <xref:System.Web.UI.Page.PreInit> событий; параметр <xref:System.Web.UI.Page.Theme%2A> свойство после <xref:System.Web.UI.Page.PreInit> вызовет событие <xref:System.InvalidOperationException> исключение.  
  
 Указанная тема должна существовать приложения или глобальной темы. Если темы не существует, <xref:System.Web.HttpException> исключения.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Web.UI.Page.Theme%2A> свойство с именем, переданный в строке запроса.  
  
 [!code-csharp[PageTheme#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageTheme/CS/pagethemecs.aspx#1)]
 [!code-vb[PageTheme#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageTheme/VB/pagethemevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Была предпринята попытка установить свойство <see cref="P:System.Web.UI.Page.Theme" /> после того, как произошло событие <see cref="E:System.Web.UI.Page.PreInit" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see cref="P:System.Web.UI.Page.Theme" /> задано недействительное имя темы.</exception>
        <altmember cref="P:System.Web.UI.Page.StyleSheetTheme" />
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка заголовка страницы.</summary>
        <value>Заголовок страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.Title%2A> свойство для задания заголовка страницы в заголовке HTML, отправлено браузеру.  
  
> [!NOTE]
>  Страница должна содержать `head` элемент, имеющий атрибут `runat="server"`, в противном случае заголовок не будет подготовлен.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Web.UI.Page.Title" /> требует на странице элемент управления заголовком.</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlTitle" />
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.TraceContext" /> для текущего веб-запроса.</summary>
        <value>Данные из объекта <see cref="T:System.Web.TraceContext" /> для текущего веб-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При трассировке отслеживаются и подробности выполнения веб-запроса. Чтобы данные трассировки были видны на отображаемой странице необходимо включить трассировку на уровне страницы или приложения.  
  
 Трассировка на странице отключена по умолчанию. Чтобы включить трассировку для страницы, используйте директиву `<% @ Page trace="true" %>`. Чтобы включить трассировку для всего приложения, необходимо включить в файле конфигурации приложения Web.config, который находится в корневом каталоге приложения. Дополнительные сведения см. в разделе [Общие сведения о трассировке ASP.NET](http://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416).  
  
   
  
## Examples  
 В следующем примере кода показано обращение к <xref:System.Web.TraceContext.IsEnabled%2A?displayProperty=nameWithType> свойство и <xref:System.Web.TraceContext.Write%2A?displayProperty=nameWithType> метода с помощью <xref:System.Web.UI.Page.Trace%2A> свойство. Этот код вызывает <xref:System.Diagnostics.Trace.Write%2A> метод только в том случае, если трассировка включена для <xref:System.Web.UI.Page> объекта. Если не включена, этот код не будет запущен, которые могут помочь сократить расходы на для вашего приложения.  
  
 [!code-csharp[System.Web.UI.Page.Trace#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Trace/CS/trace1cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Trace#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Trace/VB/trace1vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TraceEnabled">
      <MemberSignature Language="C#" Value="public bool TraceEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TraceEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property TraceEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TraceEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает значение, указывающее, разрешена ли трассировка для объекта <see cref="T:System.Web.UI.Page" />.</summary>
        <value>Указывает, включена ли трассировка. Если трассировка включена, используется значение <see langword="true" />; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задать `Trace` атрибут `true` в директиве в ASPX-файле. При запросе страницы динамически создаваемый класс задает свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Trace" />
        <altmember cref="P:System.Web.UI.Page.TraceModeValue" />
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TraceModeValue">
      <MemberSignature Language="C#" Value="public System.Web.TraceMode TraceModeValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.TraceMode TraceModeValue" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceModeValue" />
      <MemberSignature Language="VB.NET" Value="Public Property TraceModeValue As TraceMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceMode TraceModeValue { System::Web::TraceMode get(); void set(System::Web::TraceMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает режим отображения операторов трассировке на странице.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Web.TraceMode" /> элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задать `TraceMode` атрибут в директиве в ASPX-файле. При запросе страницы динамически создаваемый класс задает свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Trace" />
        <altmember cref="P:System.Web.UI.Page.TraceEnabled" />
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TransactionMode">
      <MemberSignature Language="C#" Value="protected int TransactionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TransactionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TransactionMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property TransactionMode As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int TransactionMode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает уровень поддержки транзакций на странице.</summary>
        <value>Целое число, представляющее один из элементов перечисления <see cref="T:System.EnterpriseServices.TransactionOption" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задать `Transaction` атрибут в директиве в ASPX-файле. При запросе страницы динамически создаваемый класс задает свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryUpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Обновляет указанный экземпляр модели, используя значения, предоставленные поставщиком значений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Учебник ряда на использование привязки модели для Web Forms, см. [привязки модели и веб-форм](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUpdateModel(Of TModel As Class) (model As TModel) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual bool TryUpdateModel(TModel model);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Тип модели.</typeparam>
        <param name="model">Модель.</param>
        <summary>Обновляет заданный экземпляр модели, используя значения из элемента управления с привязкой к данным.</summary>
        <returns>Значение <see langword="true" />, если привязка модели выполнена успешно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод должен вызываться только из метода, который задается с помощью элемента управления с привязкой к данным `UpdateMethod` или `InsertMethod` свойства.  
  
 Учебник ряда на использование привязки модели для Web Forms, см. [привязки модели и веб-форм](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUpdateModel(Of TModel As Class) (model As TModel, valueProvider As IValueProvider) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual bool TryUpdateModel(TModel model, System::Web::ModelBinding::IValueProvider ^ valueProvider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Тип модели.</typeparam>
        <param name="model">Модель.</param>
        <param name="valueProvider">Поставщик значений.</param>
        <summary>Обновляет экземпляр модели, используя значения, предоставленные указанным поставщиком значений.</summary>
        <returns>Значение <see langword="true" />, если привязка модели выполнена успешно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Учебник ряда на использование привязки модели для Web Forms, см. [привязки модели и веб-форм](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UICulture">
      <MemberSignature Language="C#" Value="public string UICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UICulture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property UICulture As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UICulture { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает идентификатор интерфейса пользователя (UI) для объекта <see cref="T:System.Threading.Thread" />, связанного со страницей.</summary>
        <value>Идентификатор UI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство является ярлыком для <xref:System.Threading.Thread.CurrentThread%2A> свойства. Культура является свойством выполняющегося потока  
  
 Задать `UICulture` атрибут в директиве в ASPX-файле. При запросе страницы динамически создаваемый класс устанавливает значение этого свойства. Кроме того, можно также задать значение <xref:System.Web.UI.Page.UICulture%2A> свойства в файле Web.config.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.LCID" />
        <altmember cref="P:System.Web.UI.Page.Culture" />
      </Docs>
    </Member>
    <Member MemberName="UniqueFilePathSuffix">
      <MemberSignature Language="C#" Value="protected internal virtual string UniqueFilePathSuffix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueFilePathSuffix" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UniqueFilePathSuffix" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property UniqueFilePathSuffix As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::String ^ UniqueFilePathSuffix { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает уникальный суффикс для добавления к пути файла для браузеров с кэшем.</summary>
        <value>Возвращает уникальный суффикс, добавляемый к пути файла. Значение по умолчанию равно "__ufps=" плюс уникальное число из 6 цифр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.UniqueFilePathSuffix%2A> Свойство возвращает строку, которая добавляется в конец пути к файлу при необходимости для кэширование браузеров. Строка используется для идентификации пути файла, связанного с конкретным запросом.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnobtrusiveValidationMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UnobtrusiveValidationMode" />
      <MemberSignature Language="VB.NET" Value="Public Property UnobtrusiveValidationMode As UnobtrusiveValidationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::UnobtrusiveValidationMode UnobtrusiveValidationMode { System::Web::UI::UnobtrusiveValidationMode get(); void set(System::Web::UI::UnobtrusiveValidationMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.UnobtrusiveValidationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, используется ли малозаметный JavaScript для проверки на стороне клиента.</summary>
        <value>Значение <see langword="true" />, если используется малозаметный JavaScript; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void UnregisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UnregisterRequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterRequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Элемент управления <see cref="T:System.Web.UI.Control" />, для которого отменяется сохранение состояния элемента управления.</param>
        <summary>Отменяет сохранение состояния элемента управления для указанного элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы управления сервера состояния элемента управления необходимо вызвать метод <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> при каждом запросе во время перед сохраняется состояние. Регистрация состояния элемента управления не переносятся из запроса к запросу во время обратной передачи. Используйте <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> метод, чтобы гарантировать, что состояние элемента управления не сохраняется для элементов управления, которые больше не необходимо сохранить для обратной передачи.  
  
 На внутреннем уровне <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> метод вызывается при использовании <xref:System.Web.UI.Control.RemovedControl%2A> метод, чтобы удалить элемент из коллекции элементов управления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <see cref="T:System.Web.UI.Control" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
        <altmember cref="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Обновляет указанный экземпляр модели, используя значения, предоставленные поставщиком значений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Учебник ряда на использование привязки модели для Web Forms, см. [привязки модели и веб-форм](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateModel(Of TModel As Class) (model As TModel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual void UpdateModel(TModel model);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Тип модели.</typeparam>
        <param name="model">Модель.</param>
        <summary>Обновляет заданный экземпляр модели, используя значения из элемента управления с привязкой к данным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод должен вызываться только из метода, который задается с помощью элемента управления с привязкой к данным `UpdateMethod` или `InsertMethod` свойства.  
  
 Учебник ряда на использование привязки модели для Web Forms, см. [привязки модели и веб-форм](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateModel(Of TModel As Class) (model As TModel, valueProvider As IValueProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual void UpdateModel(TModel model, System::Web::ModelBinding::IValueProvider ^ valueProvider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Тип модели.</typeparam>
        <param name="model">Модель.</param>
        <param name="valueProvider">Поставщик значений.</param>
        <summary>Обновляет указанный экземпляр модели, используя значения, предоставленные указанным поставщиком значений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Учебник ряда на использование привязки модели для Web Forms, см. [привязки модели и веб-форм](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.User" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает сведения о пользователе, производящем запрос страницы.</summary>
        <value>Объект <see cref="T:System.Security.Principal.IPrincipal" />, представляющий пользователя, производящего запрос страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Principal.IPrincipal> Объект представляет контекст безопасности пользователя, от лица которого выполняется код, включая удостоверение пользователя и любые роли, к которым они принадлежат.  
  
 Это свойство использует <xref:System.Web.HttpContext> объекта <xref:System.Web.HttpContext.User%2A> свойства, чтобы определить, откуда поступил запрос.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Web.UI.Page.User%2A> свойство для доступа к данным проверки подлинности и удостоверение текущего пользователя. Если пользователь не прошел проверку подлинности, он перенаправляется на страницу входа.  
  
 [!code-csharp[Page_User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_User/CS/page_user.cs.aspx#1)]
 [!code-vb[Page_User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_User/VB/page_user.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Security.Principal.IPrincipal" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Требует, чтобы проверочные элементы управления, содержащиеся на странице, выполняли проверку связанных с ними сведений.</summary>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Validate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Validate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Требует, чтобы проверочные элементы управления, содержащиеся на странице, выполняли проверку связанных с ними сведений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, когда пользователь щелкает любой серверный элемент управления ASP.NET с `CausesValidation` свойство `true`, которое используется по умолчанию. К ним относятся <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.WebControls.ImageButton>, и <xref:System.Web.UI.WebControls.LinkButton> веб-серверные элементы управления, <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, и <xref:System.Web.UI.HtmlControls.HtmlButton> серверные элементы управления HTML и элементов управления, которые можно автоматически передаваться обратно серверу, например <xref:System.Web.UI.WebControls.TextBox>, <xref:System.Web.UI.WebControls.CheckBox>, <xref:System.Web.UI.WebControls.ListControl>, и <xref:System.Web.UI.WebControls.BulletedList> элементов управления.  
  
 Чтобы отключить проверку для любого элемента управления button на странице, значение элемента управления button `CausesValidation` свойства `false`.  
  
 При вызове этого метода, он проходит по проверяющие элементы управления, содержащихся в <xref:System.Web.UI.ValidatorCollection> объекта, связанного с <xref:System.Web.UI.Page.Validators%2A?displayProperty=nameWithType> свойства и вызывает логику проверки для каждого проверяющего элемента управления в текущей группе проверки. Группа проверки определяется элементом управления, который передал страницу сервера. Если группа проверки не указана, то будет использоваться группа проверки.  
  
> [!NOTE]
>  Поведение проверки страницы изменилось. В [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)], элементы управления больше не вызов <xref:System.Web.UI.Page.Validate?displayProperty=nameWithType> метода, они использовать <xref:System.Web.UI.Page.Validate%28System.String%29?displayProperty=nameWithType> метод вместо него. Если вы используете <xref:System.Web.UI.Page.Validate?displayProperty=nameWithType> метод [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] страницы, группы проверки учитываются и проверяются все элементы управления.  
  
   
  
## Examples  
 В следующем примере кода вызывается <xref:System.Web.UI.Page.Validate%2A> определен метод страницы в сценарии с несколько различных групп проверки.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Web.UI.Page.Validate" /> Метода не используется [! INCLUDE[vstecasplong](~/includes/vstecasplong-MD.MD)]. При использовании [! INCLUDE[vstecasplong](~/includes/vstecasplong-MD.MD)] переопределить <see cref="M:System.Web.UI.Page.Validate(System.String)" /> метод, чтобы изменить поведение проверки страницы.</para>
        </block>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Validate (validationGroup As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Validate(System::String ^ validationGroup);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">Имя группы проверки для проверяемых элементов управления.</param>
        <summary>Требует, чтобы проверочные элементы управления в указанной группе проверки осуществили проверку связанных с ними сведений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, когда пользователь щелкает любой серверный элемент управления ASP.NET с `CausesValidation` свойство `true`, которое используется по умолчанию. К ним относятся <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.WebControls.ImageButton>, и <xref:System.Web.UI.WebControls.LinkButton> веб-серверные элементы управления, <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, и <xref:System.Web.UI.HtmlControls.HtmlButton> серверные элементы управления HTML и элементов управления, которые можно автоматически передаваться обратно серверу, например <xref:System.Web.UI.WebControls.TextBox>, <xref:System.Web.UI.WebControls.CheckBox>, <xref:System.Web.UI.WebControls.ListControl>, и <xref:System.Web.UI.WebControls.BulletedList> элементов управления.  
  
 Чтобы отключить проверку для любого элемента управления button на странице, значение элемента управления button `CausesValidation` свойства `false`.  
  
 <xref:System.Web.UI.Page.Validate%2A> Метод проверяет указанной группе. После вызова метода <xref:System.Web.UI.Page.Validate%2A> метод на группу проверки <xref:System.Web.UI.Page.IsValid%2A> метод будет возвращать `true` только в том случае, если указанной группе и группа проверки элемента управления, который приводит к отправке на сервер страницы являются допустимыми.  
  
   
  
## Examples  
 В следующем примере кода вызывается <xref:System.Web.UI.Page.Validate%2A> определен метод страницы в сценарии с несколько различных групп проверки.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ValidateRequestMode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ValidateRequestMode As ValidateRequestMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ValidateRequestMode ValidateRequestMode { System::Web::UI::ValidateRequestMode get(); void set(System::Web::UI::ValidateRequestMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, проверяет ли страница полученный из браузера клиентский ввод на предмет потенциально опасных значений.</summary>
        <value>Значение, указывающее, проверяет ли страница клиентский ввод. Значение по умолчанию: <see cref="F:System.Web.UI.ValidateRequestMode.Enabled" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение <xref:System.Web.UI.ValidateRequestMode.Inherit> не используется в <xref:System.Web.UI.Page> класса, так как не требуется наследовать.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Validators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection Validators { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ValidatorCollection Validators" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Validators" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Validators As ValidatorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ValidatorCollection ^ Validators { System::Web::UI::ValidatorCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию всех проверочных элементов управления, содержащихся на запрашиваемой странице.</summary>
        <value>Коллекция проверочных элементов управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для управления методы и свойства <xref:System.Web.UI.ValidatorCollection> объект, связанный с текущим <xref:System.Web.UI.Page> экземпляра. Эта коллекция содержит все проверочные элементы управления, содержащихся на странице.  
  
 Вызов <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> метод вызывает логику проверки должно выполняться для каждого сервера проверяющего элемента управления в текущей группе проверки. Если любой из этих элементов управления не проходят, <xref:System.Web.UI.Page.IsValid%2A?displayProperty=nameWithType> возвращает `false`.  
  
 Дополнительные сведения об элементах управления проверки см. в разделе [проверяющие элементы управления ASP.NET](http://msdn.microsoft.com/library/fa2aa14d-a461-492e-9a79-c990904613ef).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
      </Docs>
    </Member>
    <Member MemberName="VerifyRenderingInServerForm">
      <MemberSignature Language="C#" Value="public virtual void VerifyRenderingInServerForm (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void VerifyRenderingInServerForm(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.VerifyRenderingInServerForm(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void VerifyRenderingInServerForm(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления ASP.NET, который должен находиться в элементе управления <see cref="T:System.Web.UI.HtmlControls.HtmlForm" />.</param>
        <summary>Подтверждает, что элемент управления <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> отображается для указанного серверного элемента управления ASP.NET во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы управления, которые должны быть внутри `<form runat=server>` теги могут вызвать этот метод до отображения, чтобы сообщение об ошибке отображается при их размещении за пределами тегов. Этот метод следует вызывать элементы управления, которые зависят от зарегистрированных блоков сценариев или отправку данных назад в переопределении <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> метод. Страницы с другим способом отображения элементов серверной формы могут переопределять этот метод создаст исключение в различных условиях.  
  
 Серверные элементы управления, обратную или использовать клиентский сценарий не будет работать, если они не заключены в <xref:System.Web.UI.HtmlControls.HtmlForm> серверного элемента управления (<`form runat="server">`) тегов. Эти элементы управления можно вызывать этот метод при отображении, чтобы предоставить сообщение об ошибке, если они не заключены в <xref:System.Web.UI.HtmlControls.HtmlForm> элемента управления.  
  
 При разработке пользовательского серверного элемента управления, чаще всего для вызова этого метода при переопределении `Render` метода для любых входных тегов. Это особенно важно в том случае, если элемент управления вызывает <xref:System.Web.UI.Page.GetPostBackEventReference%2A>, или если он выдает клиентского скрипта. Составной серверный элемент управления не нужно вызывать этот метод.  
  
   
  
## Examples  
 В следующем примере кода переопределяется <xref:System.Web.UI.Page.Render%2A?displayProperty=nameWithType> метод серверного элемента управления. Когда этот элемент управления записывает его содержимое страницы, он использует <xref:System.Web.UI.Page.VerifyRenderingInServerForm%2A> метод, чтобы убедиться в том, что элемент управления отображается между открывающим и закрывающим тегами элемента <xref:System.Web.UI.HtmlControls.HtmlForm> элемента управления.  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#3)]
 [!code-vb[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/vb/testlinkbutton.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Указанный серверный элемент управления не содержится между открывающим и закрывающим тегами серверного элемента управления <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> во время выполнения.</exception>
        <exception cref="T:System.ArgumentNullException">Проверяемый элемент управления имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewStateEncryptionMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateEncryptionMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewStateEncryptionMode As ViewStateEncryptionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ViewStateEncryptionMode ViewStateEncryptionMode { System::Web::UI::ViewStateEncryptionMode get(); void set(System::Web::UI::ViewStateEncryptionMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateEncryptionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает режим шифрования состояния представления.</summary>
        <value>Одно из значений <see cref="T:System.Web.UI.ViewStateEncryptionMode" />. Значение по умолчанию — <see cref="F:System.Web.UI.ViewStateEncryptionMode.Auto" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> Свойство нельзя задать в коде. Его можно установить только в директиве или в < элемент файла конфигурации. Значения, установленные в директиву переопределения любого значения, заданного в файле конфигурации.  
  
 Синтаксис для этого свойства в директиве выглядит следующим образом:  
  
```vb  
<%@ Page Language="VB" ViewStateEncryptionMode="Always" %>  
```  
  
```csharp  
<%@ Page Language="C#" ViewStateEncryptionMode="Always" %>  
```  
  
 Ниже приведен синтаксис для этого свойства в файле конфигурации:  
  
```vb  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
```csharp  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
 Разработчикам пользовательского элемента управления может потребоваться проверить значение этого свойства в коде до сохранения потенциально конфиденциальных данных в состоянии представления в их управления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Присвоенное значение не является членом перечисления <see cref="T:System.Web.UI.ViewStateEncryptionMode" />.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Web.UI.Page.ViewStateEncryptionMode" /> можно задавать только до или во время этапа <see langword="PreRender" /> жизненного цикла страницы.</exception>
        <altmember cref="T:System.Web.UI.ViewStateEncryptionMode" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateUserKey">
      <MemberSignature Language="C#" Value="public string ViewStateUserKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ViewStateUserKey" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateUserKey" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewStateUserKey As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ViewStateUserKey { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Присваивает пользователю идентификатор в переменной состояния представления, связанной с текущей страницей.</summary>
        <value>Идентификатор отдельного пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр <xref:System.Web.UI.Page.ViewStateUserKey%2A> свойство может помочь предотвратить атаки на приложение от злоумышленников. Это достигается присвоением идентификатора переменной состояния представления для отдельных пользователей, чтобы они не могут использовать переменную для создания атаки. Дополнительные сведения о веб-атак и что делать, чтобы предотвратить их см. в разделе [занять преимущества из встроенных функций ASP.NET для отразить Off атак](http://go.microsoft.com/fwlink/?LinkId=163557).  
  
 Это свойство можно задать любое строковое значение, такие как имя проверить подлинность пользователя или <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> значение.  
  
> [!NOTE]
>  Необходимо задать это свойство во время `Page_Init` фазы обработки страницы. Задание этого свойства во время `Page_Load` этапа создает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Доступ к свойству <see cref="P:System.Web.UI.Page.ViewStateUserKey" /> был осуществлен слишком поздно во время обработки страницы.</exception>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, отображается ли объект <see cref="T:System.Web.UI.Page" />.</summary>
        <value>
          <see langword="true" />, если объект <see cref="T:System.Web.UI.Page" /> должен быть отображен; иначе — <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере задается <xref:System.Web.UI.Page.Visible%2A> свойства `false` скрыть отображаемое содержимое страницы. При первом запросе этой страницы, источник данных заполняется и отображается на странице. Когда пользователь нажимает кнопку, `HideButton_Click` обработчик событий скрывает все отображаемое содержимое страницы.  
  
 [!code-csharp[Page_Visible#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_Visible/CS/page_visible.cs.aspx#1)]
 [!code-vb[Page_Visible#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_Visible/VB/page_visible.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.UI.TemplateControl" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
  </Members>
</Type>