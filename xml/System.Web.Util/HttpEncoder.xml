<Type Name="HttpEncoder" FullName="System.Web.Util.HttpEncoder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4e35efb72622eb52376091974f022482dc3d28df" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30610068" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HttpEncoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi HttpEncoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Util.HttpEncoder" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpEncoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpEncoder" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Web.Services</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет логику кодирования и декодирования.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс содержит логику, используемый методами в классах, таких как кодирования и декодирования <xref:System.Web.HttpUtility>, <xref:System.Web.HttpServerUtility>, и <xref:System.Net.HttpResponseHeader>.  
  
 Можно наследовать от <xref:System.Web.Util.HttpEncoder> класса и переопределить его поведение для настройки по умолчанию кодирования и декодирования поведения ASP.NET. Затем установите <xref:System.Web.Configuration.HttpRuntimeSection.EncoderType%2A> свойство <xref:System.Web.Configuration.HttpRuntimeSection> класса, чтобы настроить пользовательский класс.  
  
 Пользовательский класс для кодирования и декодирования, который является производным от <xref:System.Web.Util.HttpEncoder> можно переопределить встроенных ASP.NET кодирования и декодирования поведение или изменить только выбранные его аспекты.  
  
 Можно настроить пользовательский тип кодировки для в ASP.NET, чтобы заменить или дополнить кодирования следующее поведение:  
  
-   Кодировка HTML  
  
-   Кодировка атрибута HTML  
  
-   Кодирование URL-адресов  
  
-   Кодировка URL-путь  
  
-   Имя заголовка HTTP и заголовок значение кодировки  
  
 По умолчанию приложения ASP.NET настроены для использования <xref:System.Web.Security.AntiXss.AntiXssEncoder> типа для всех выходных кодировки.  
  
 В следующем примере из показан файл Web.config уровня приложения как <xref:System.Web.Security.AntiXss.AntiXssEncoder> тип задается для приложения ASP.NET:  
  
 `<httpRuntime requestValidationMode="4.5" encoderType="System.Web.Security.AntiXss.AntiXssEncoder, System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>`  
  
 Параметр конфигурации в примере устанавливается <xref:System.Web.Security.AntiXss.AntiXssEncoder> класса для выполнения всех выходных данных кодировку в приложении. Дополнительные сведения см. в разделе <xref:System.Web.Security.AntiXss.AntiXssEncoder> Общие сведения о классе.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>При создании пользовательского кодировщика класса и переопределить базовые методы базового класса, производного декодера исключение может любой из переопределенных методов. Однако в следующих случаях создания такого исключения может привести к непредвиденному поведению в ASP.NET:  
  
-   При создании платформой ASP.NET страница ошибки, вызванные необрабатываемое исключение, вызванное исключение из пользовательского кодировщика, ASP.NET не пытается закодировать вывод сообщения об ошибке, вызывая пользовательский кодировщик. Это позволяет избежать ошибки рекурсивной.  
  
-   Когда ASP.NET отправляет заголовки HTTP для служб IIS, ASP.NET не имеет возможности для необработанных исключений. Таким образом будут отображаться стандартной страницы ошибок для ASP.NET (если параметры конфигурации позволяет эту страницу для отображения).</para>
    </block>
    <altmember cref="T:System.Web.HttpUtility" />
    <altmember cref="T:System.Web.HttpServerUtility" />
    <altmember cref="T:System.Web.Configuration.HttpRuntimeSection" />
    <altmember cref="T:System.Web.Security.AntiXss.AntiXssEncoder" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpEncoder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Web.Util.HttpEncoder" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.Util.HttpEncoder Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Util.HttpEncoder Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.Util.HttpEncoder.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpEncoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Util::HttpEncoder ^ Current { System::Web::Util::HttpEncoder ^ get(); void set(System::Web::Util::HttpEncoder ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Util.HttpEncoder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает тип <see cref="T:System.Web.Util.HttpEncoder" />, который будет использован в приложении.</summary>
        <value>Ссылка на тип кодирования-декодирования, который будет использован.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если производный <xref:System.Web.Util.HttpEncoder> в файле конфигурации указан тип <xref:System.Web.Util.HttpEncoder.Current%2A> свойство возвращает ссылку на пользовательский тип. Тем не менее, если используется не пользовательский кодировщик, свойство возвращает ссылку на значение по умолчанию ASP.NET <xref:System.Web.Util.HttpEncoder> экземпляра.  
  
 <xref:System.Web.Util.HttpEncoder.Current%2A> Свойство не является потокобезопасным. Если установлено только в приложении `Application_Start` метода, так как `Application_Start` выполняется в одном потоке.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Экземпляр кодировщика, назначаемый данному свойству, имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Web.Util.HttpEncoder Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Util.HttpEncoder Default" />
      <MemberSignature Language="DocId" Value="P:System.Web.Util.HttpEncoder.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As HttpEncoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Util::HttpEncoder ^ Default { System::Web::Util::HttpEncoder ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Util.HttpEncoder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает ссылку на кодировщик ASP.NET по умолчанию.</summary>
        <value>Ссылка на кодировщик по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Распространенные проблемы кодирования, ASP.NET по умолчанию — <xref:System.Web.Util.HttpEncoder.UrlEncode%2A> поведение преобразует пробелы в символ «+». Исторически символ «+» был соглашение о Интернет для кодирования пробельные символы в URL-адрес в форме более удобной для чтения. Тем не менее, в соответствии со стандартами, пробел должен кодироваться как «% 20» и вместо как символ «+». ASP.NET позволяет реализовать более совместимый кодирования алгоритм стандартов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderNameValueEncode">
      <MemberSignature Language="C#" Value="protected internal virtual void HeaderNameValueEncode (string headerName, string headerValue, out string encodedHeaderName, out string encodedHeaderValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void HeaderNameValueEncode(string headerName, string headerValue, [out] string&amp; encodedHeaderName, [out] string&amp; encodedHeaderValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.HeaderNameValueEncode(System.String,System.String,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub HeaderNameValueEncode (headerName As String, headerValue As String, ByRef encodedHeaderName As String, ByRef encodedHeaderValue As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void HeaderNameValueEncode(System::String ^ headerName, System::String ^ headerValue, [Runtime::InteropServices::Out] System::String ^ % encodedHeaderName, [Runtime::InteropServices::Out] System::String ^ % encodedHeaderValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="headerName" Type="System.String" />
        <Parameter Name="headerValue" Type="System.String" />
        <Parameter Name="encodedHeaderName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="encodedHeaderValue" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="headerName">Имя HTTP-заголовка, которое необходимо закодировать.</param>
        <param name="headerValue">Значение HTTP-заголовка, которое необходимо закодировать.</param>
        <param name="encodedHeaderName">Этот метод возвращает кодированное имя для использования в HTTP-заголовке. Этот параметр передается неинициализированным.</param>
        <param name="encodedHeaderValue">Этот метод возвращает кодированное значение для использования в HTTP-заголовке. Этот параметр передается неинициализированным.</param>
        <summary>Кодирует имя и значение заголовка в строку, которая может быть использована в HTTP-заголовке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Util.HttpEncoder.HeaderNameValueEncode%2A> Метод принимает входные строки из `headerName` и `headerValue` параметры и кодирует их. Закодированные значения возвращаются как выходные параметры.  
  
 <xref:System.Web.Util.HttpEncoder.HeaderNameValueEncode%2A> Метод использует следующую логику для кодирования имен заголовков и значений:  
  
-   Все символы Юникода, значение которого меньше, чем символ ASCII 32, за исключением символа ASCII 9, URL-адреса в формате `%NN` где `N` символы представляют шестнадцатеричные значения.  
  
-   Символ ASCII 9 (символ горизонтальной табуляции) не является URL-адреса.  
  
-   Символ ASCII 127 кодируется как `%7F`.  
  
-   Все остальные символы не кодируются.  
  
    > [!NOTE]
    >  Несмотря на то, что этот метод может использоваться для значений Юникода, обычно используется для значений в диапазоне ASCII.  
  
 Реализация по умолчанию <xref:System.Web.Util.HttpEncoder.HeaderNameValueEncode%2A> метод возвращает значение `headerValue` в `encodedHeaderValue` Если `headerValue` — `null` или является пустой строкой. Аналогичным образом, реализация по умолчанию возвращает значение `headerName` в `encodedHeaderName` Если `headerName` — `null` или является пустой строкой.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlAttributeEncode">
      <MemberSignature Language="C#" Value="protected internal virtual void HtmlAttributeEncode (string value, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void HtmlAttributeEncode(string value, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.HtmlAttributeEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub HtmlAttributeEncode (value As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void HtmlAttributeEncode(System::String ^ value, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="value">Кодируемая строка.</param>
        <param name="output">Модуль записи текста, в который необходимо записать закодированное значение.</param>
        <summary>Кодирует входящее значение в строку, которая может быть вставлена в HTML-атрибут, ограниченный одинарными или двойными кавычками.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Util.HttpEncoder.HtmlAttributeEncode%2A> Метод кодирует символы с помощью стандартных сущностей HTML. Например `<` (левая угловая скобка) кодируется как `&lt;` и `\` (обратная косая черта) кодируется как `&#92;`.  
  
 Можно безопасно использовать <xref:System.Web.Util.HttpEncoder.HtmlAttributeEncode%2A> в одиночных кавычках и двойные кавычки атрибутов. Значения необходимо заключать в кавычки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="output" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="protected internal virtual void HtmlDecode (string value, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void HtmlDecode(string value, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub HtmlDecode (value As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void HtmlDecode(System::String ^ value, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="value">Декодируемая строка.</param>
        <param name="output">Модуль записи текста, в который необходимо записать декодированное значение.</param>
        <summary>Декодирует значение из строки в кодировке HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены последовательности символов, которые может декодировать логика декодирования ASP.NET.  
  
|Последовательность символов|Правило|  
|------------------------|----------|  
|`&#NNN;` (десятичные коды символов ASCII).|Декодируется как указанный знак ASCII. Последовательность символов начинается с первой цифры после символа # и завершается точкой с запятой.|  
|`&#xZZ;` (шестнадцатеричные коды символов ASCII).|Декодируется как указанный знак ASCII. Кодированной форме символ с помощью шестнадцатеричных символов, а не значение десятичного числа. Последовательность символов начинается с первой цифры после символа # и завершается точкой с запятой.|  
|Именованные сущности HTML.|Декодируется как эквивалентный знак ASCII.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="output" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="protected internal virtual void HtmlEncode (string value, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void HtmlEncode(string value, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub HtmlEncode (value As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void HtmlEncode(System::String ^ value, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="value">Кодируемая строка.</param>
        <param name="output">Модуль записи текста, в который необходимо записать закодированное значение.</param>
        <summary>Зашифровывает строку в строку в кодировке HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены последовательности символов, которые может декодировать логика кодирования ASP.NET.  
  
|Знак|Кодируется как|  
|---------------|----------------|  
|`<` (левая угловая скобка)|`&lt;`|  
|`>` (правая угловая скобка)|`&gt;`|  
|`"` (двойные кавычки)|`&quot;`|  
|`&` (амперсанд)|`&amp;`|  
|`\` (обратная косая черта)|`&#92;`|  
|Знаки ASCII от 160 до 255.|`&#NNN;`, где `NNN` — код из трех цифр десятичного знака|  
  
 При переопределении <xref:System.Web.Util.HttpEncoder.HtmlEncode%2A> метода, должны создаваться выходные данные, также можно безопасно в двойных кавычках или одиночные кавычки атрибутов HTML. Это обеспечивает соблюдение синтаксического анализа Razor обработчика, где разметки и кода могут быть объединены, таких как \<тег attr =»@value«>. Кроме того @ оператор не является контекстно зависимые при обработке обработчиком Razor, поэтому он вызывает <xref:System.Web.Util.HttpEncoder.HtmlEncode%2A> вместо <xref:System.Web.Util.HttpEncoder.HtmlAttributeEncode%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="output" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="JavaScriptStringEncode">
      <MemberSignature Language="C#" Value="protected internal virtual string JavaScriptStringEncode (string value);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string JavaScriptStringEncode(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.JavaScriptStringEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function JavaScriptStringEncode (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ JavaScriptStringEncode(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Кодируемая строка.</param>
        <summary>Кодирует строку.</summary>
        <returns>Закодированная строка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодировка URL гарантирует, что все браузеры правильную передачу текста в строках URL-адрес. Такие символы, как знак вопроса (?), амперсанд (&), косая черта (/) и пробелы могут обрезать или обозревателем. Таким образом эти символы должны быть закодированы.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="protected internal virtual byte[] UrlEncode (byte[] bytes, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance unsigned int8[] UrlEncode(unsigned int8[] bytes, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.UrlEncode(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function UrlEncode (bytes As Byte(), offset As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ UrlEncode(cli::array &lt;System::Byte&gt; ^ bytes, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, который необходимо закодировать.</param>
        <param name="offset">Позиция в массиве <c>bytes</c>, с которой начинается кодирование.</param>
        <param name="count">Количество кодируемых элементов массива <c>bytes</c>.</param>
        <summary>Кодирует массив недопустимых в URL-адресе символов в шестнадцатеричный эквивалент сущности знака.</summary>
        <returns>Массив кодируемых символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Util.HttpEncoder.UrlEncode%2A> Метод вызывается методом несколько методов кодирования URL-адрес в <xref:System.Web.HttpUtility> класса.  
  
 <xref:System.Web.Util.HttpEncoder.UrlEncode%2A> Метод кодирует в URL-адрес любой символ, не входящий в набор ASCII символов, которое считается безопасным URL-адрес. Пробелы кодируются в формате ASCII "`+"` символов. Безопасные URL-адреса символы включают символы ASCI (от A до Z и-z), цифры (0-9) и некоторые знаки препинания. В следующей таблице перечислены знаки пунктуации, которые считаются безопасными URL-адрес символами ASCII.  
  
|Знак|Описание:|  
|---------------|-----------------|  
|-|Дефис|  
|_|Символ подчеркивания|  
|.|Период (точка)|  
|!|Восклицательный знак|  
|*|Звездочка|  
|(|Открывающая скобка|  
|)|Закрывающая круглая скобка|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> меньше нуля или больше, чем длина массива <paramref name="bytes" />.  
  
 - или -  
  
 <paramref name="count" /> меньше нуля, или <paramref name="count" /> плюс <paramref name="offset" /> больше, чем длина массива <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="protected internal virtual string UrlPathEncode (string value);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string UrlPathEncode(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.UrlPathEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function UrlPathEncode (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ UrlPathEncode(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Кодируемая строка.</param>
        <summary>Кодирует часть URL-адреса.</summary>
        <returns>Строка в URL-кодировке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Web.Util.HttpEncoder.UrlPathEncode%2A> вызывается методом <xref:System.Web.HttpUtility.UrlPathEncode%2A>. <xref:System.Web.HttpUtility.UrlPathEncode%2A> Метод выполняет следующие действия:  
  
-   Применяет логику кодирования <xref:System.Web.Util.HttpEncoder.UrlPathEncode%2A> метод только части пути URL-адреса (что исключает строки запроса). Метод предполагает, что URL-адрес кодируется как строка UTF-8.  
  
-   Кодирует отличные от пробелов, чтобы в результирующую строку, закодированную используется только подмножество первых 128 символов ASCII. Любые символы Юникода значение 128 и меньше, 32 и меньше, в кодировке URL.  
  
-   Кодирует пробелы как % 20.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>