<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="89381694149c6783ea59e91d2ae890826502a5b5" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30610598" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Инкапсулирует все связанные с НТТР сведения об отдельном НТТР-запросе.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, наследующие <xref:System.Web.IHttpModule> и <xref:System.Web.IHttpHandler> интерфейсы предоставляются ссылку на <xref:System.Web.HttpContext> объект для текущего HTTP-запроса. Объект предоставляет доступ к встроенным <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A>, и <xref:System.Web.HttpContext.Server%2A> свойства запроса.  
  
   
  
## Examples  
 Проект Visual Studio Web сайта с исходным кодом доступен по следующему адресу: [загрузить](http://go.microsoft.com/fwlink/?LinkId=192422).  
  
 Следующий пример демонстрирует доступ, отображая свойства <xref:System.Web.HttpContext> объекта. Контекст текущего запроса HTTP осуществляется с помощью <xref:System.Web.UI.Page.Context%2A> свойство <xref:System.Web.UI.Page> объекта.  
  
 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Web.HttpContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">Объект <see cref="T:System.Web.HttpWorkerRequest" /> для текущего HTTP-запроса.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Web.HttpContext" /> с заданным объектом рабочего запроса.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">Объект <see cref="T:System.Web.HttpRequest" /> для текущего HTTP-запроса.</param>
        <param name="response">Объект <see cref="T:System.Web.HttpResponse" /> для текущего HTTP-запроса.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Web.HttpContext" />, используя указанные объекты запроса и ответа.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Принимает запрос <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="userFunc">Пользовательская функция.</param>
        <summary>Принимает запрос <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> с помощью заданной пользовательской функции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода эквивалентен вызову <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A> перегрузка метода и передача `null` для `options` параметра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="userFunc" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Запрос не является запросом <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" />
      </Parameters>
      <Docs>
        <param name="userFunc">Пользовательская функция.</param>
        <param name="options">Объект параметров.</param>
        <summary>Принимает запрос <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> с помощью заданной пользовательской функции и объекта параметров.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="userFunc" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Запрос не является запросом <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">Объект <see cref="T:System.Exception" />, добавляемый в коллекцию исключений.</param>
        <summary>Добавляет исключение в коллекцию исключений для текущего HTTP-запроса.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">Объект контекста HTTP.</param>
        <summary>Создает виртуальное событие, происходящее при завершении HTTP-части запроса.</summary>
        <returns>Токен подписки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает перед <xref:System.Web.WebSockets.AspNetWebSocket> начинает соединение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="callback" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает массив ошибок, накопившихся в ходе обработки HTTP-запроса.</summary>
        <value>Массив объектов <see cref="T:System.Exception" /> для текущего HTTP-запроса.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, разрешены ли асинхронные операции в ходе обработки запроса ASP.NET, когда они не ожидаются.</summary>
        <value>
          Значение <see langword="false" />, если платформа ASP.NET создает исключение, когда асинхронный интерфейс API используется в момент, когда это не предусмотрено; в противном случае — значение <see langword="true" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот флаг не установлен `true`, ASP.NET будет вызывать исключение при обнаружении неправильного использования асинхронных API приложения. Это может произойти при попытке вызвать асинхронный метод на этапе выполнения запроса конвейер обработки, где асинхронные операции не ожидается, или если по-прежнему невыполненные асинхронной операции при асинхронной модуль или обработчик уведомляет о завершении. Это поведение предназначен как средство подстраховки, уведомляющее на раннем этапе при написании асинхронного кода, который не умещается предполагается шаблонов и может иметь отрицательное побочные эффекты.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.HttpApplicationState" /> для текущего HTTP-запроса.</summary>
        <value>Объект <see cref="T:System.Web.HttpApplicationState" /> для текущего HTTP-запроса.  
  
 Чтобы получить объект <see cref="T:System.Web.HttpApplication" /> для текущего HTTP-запроса, используйте свойство <see cref="P:System.Web.HttpContext.ApplicationInstance" />. (В платформе ASP.NET свойство, обозначающее текущий экземпляр <see cref="T:System.Web.HttpApplication" />, имеет имя <see langword="ApplicationInstance" /> вместо <see langword="Application" />, что позволяет избежать путаницы между ASP.NET и классической платформой ASP. В классической платформе ASP свойство <see langword="Application" /> относится к глобальному словарю состояний приложения.)</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Web.HttpApplication" /> для текущего HTTP-запроса.</summary>
        <value>Объект <see cref="T:System.Web.HttpApplication" /> для текущего HTTP-запроса.  
  
 В платформе ASP.NET свойство, обозначающее текущий экземпляр <see cref="T:System.Web.HttpApplication" />, имеет имя <see langword="ApplicationInstance" /> вместо <see langword="Application" />, что позволяет избежать путаницы между ASP.NET и классической платформой ASP. В классической платформе ASP свойство <see langword="Application" /> относится к глобальному словарю состояний приложения.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Веб-приложение выполняется под управлением IIS 7.0 в интегрированном режиме, однако была предпринята попытка изменить отличное от NULL значение свойства на значение <see langword="null" />.</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект, содержащий флаги, которые относятся к асинхронному режиму предварительной загрузки.</summary>
        <value>Объект, содержащий флаги, которые относятся к асинхронному режиму предварительной загрузки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Первый раз, доступ к этому свойству объект, содержащий флаги для асинхронному режиму предварительной загрузки загружается из <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> в файле конфигурации.  
  
 Хотя это свойство может быть задано программным путем, изменение значения свойства действует, только если это свойство установлено до шага `ExecuteRequestHandler` в конвейере запросов ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Web.Caching.Cache" /> для текущего домена приложения.</summary>
        <value>Контекст <see cref="T:System.Web.Caching.Cache" /> для текущего домена приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имеется один экземпляр <xref:System.Web.Caching.Cache> класс домена приложения. В результате <xref:System.Web.Caching.Cache> объект, возвращаемый <xref:System.Web.HttpContext.Cache%2A> свойство <xref:System.Web.Caching.Cache> объекта для всех запросов в домене приложения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все ошибки текущего HTTP-запроса.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Web.HttpContext" /> для текущего HTTP-запроса.</summary>
        <value>Экземпляр <see cref="T:System.Web.HttpContext" /> для текущего HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство является статическим свойством <xref:System.Web.HttpContext> класса. Свойства хранилищ <xref:System.Web.HttpContext> экземпляр, который применяется для текущего запроса. Свойства этого экземпляра являются свойствами нестатических <xref:System.Web.HttpContext> класса.  
  
 Можно также использовать <xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType> свойство для доступа к <xref:System.Web.HttpContext> объект для текущего HTTP-запроса.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Web.HttpContext.Current%2A> свойство для доступа к <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> и <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> методы и <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> свойства. В примере создаются три настраиваемых исключения при помощи <xref:System.Web.HttpContext.AddError%2A> метод и использует <xref:System.Web.HttpContext.AllErrors%2A> свойство для загрузки этих исключений в массив. Он записывает в него массив страницы, содержащей и использует <xref:System.Web.HttpContext.ClearError%2A> метод, чтобы удалить все ошибки <xref:System.Web.UI.Page.Context%2A> свойство.  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Web.IHttpHandler" />, представляющий выполняющийся в данный момент обработчик.</summary>
        <value>Объект <see cref="T:System.Web.IHttpHandler" />, представляющий выполняющийся в данный момент обработчик.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обработчик выполняться в данный момент, на который ссылается <xref:System.Web.HttpContext.CurrentHandler%2A> свойство может отличаться от обработчика, на который ссылается <xref:System.Web.HttpContext.Handler%2A> свойство. Это может произойти при запросе с помощью другой обработчик <xref:System.Web.HttpServerUtility.Execute%2A> метода или <xref:System.Web.HttpServerUtility.Transfer%2A> метод. Когда выполняться в данный момент обработчик завершает обработку, ранее определенный обработчик восстанавливается.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение <see cref="T:System.Web.RequestNotification" />, указывающее на текущее обрабатываемое событие <see cref="T:System.Web.HttpApplication" />.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Web.RequestNotification" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.CurrentNotification%2A> Свойства требуется режим интегрированного конвейера в [!INCLUDE[iisver](~/includes/iisver-md.md)] и по крайней мере .NET Framework версии 3.0. Если она доступна, свойство возвращает <xref:System.Web.RequestNotification> значение. Значение <xref:System.Web.HttpContext.CurrentNotification%2A> свойство указывает, какое событие в <xref:System.Web.HttpApplication> экземпляр в данный момент обрабатывает запрос.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> Не планируется задать. Вместо этого задается путем [!INCLUDE[iisver](~/includes/iisver-md.md)] во время обработки запроса в конвейере ASP.NET. Параметр <xref:System.Web.HttpContext.CurrentNotification%2A> свойства приведет к ошибке компиляции.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> впервые появился в платформе .NET Framework версии 3.5.  Дополнительные сведения см. в статье [Версии и зависимости платформы .NET Framework](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Web.HttpContext.CurrentNotification%2A> свойство, чтобы определить, какие события <xref:System.Web.HttpApplication> объект, обрабатывающего текущий запрос обрабатывается. В примере обработчик событий обрабатывает несколько событий <xref:System.Web.HttpApplication> объекта и <xref:System.Web.HttpContext.CurrentNotification%2A> свойство определяет, какой код вызывается для каждого обрабатываемого события.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Для операции требуется режим интегрированного конвейера в [!INCLUDE[iisver](~/includes/iisver-md.md)] и как минимум платформа .NET Framework версии 3.0.</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" />
      </Parameters>
      <Docs>
        <param name="target">Объект, метод <see cref="M:System.IDisposable.Dispose" /> которого должен вызываться при завершении части соединения <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> запроса.</param>
        <summary>Позволяет методу <see cref="M:System.IDisposable.Dispose" /> объекта вызываться при завершении части соединения <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> этого запроса.</summary>
        <returns>Токен подписки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IDisposable.Dispose%2A> Целевого объекта вызывается после части HTTP запроса и <xref:System.Web.WebSockets.AspNetWebSocket> завершил подключение. <xref:System.Web.HttpContext> Объект недоступен для проверки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает первую ошибку (при наличии таковой), возникшую в ходе обработки НТТР-запроса.</summary>
        <value>Первый объект <see cref="T:System.Exception" /> для текущего процесса HTTP-запроса или ответа; в противном случае — значение <see langword="null" />, если во время обработки HTTP-запроса ошибки не были накоплены. Значение по умолчанию: <see langword="null" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Тег конфигурации приложения, для которого запрашиваются сведения.</param>
        <summary>Возвращает запрашиваемые сведения о конфигурации для текущего приложения.</summary>
        <returns>Объект, содержащий сведения о конфигурации. (Приводит возвращаемый раздел конфигурации к соответствующему типу конфигурации перед использованием).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Web.HttpContext.GetAppConfig%2A> не рекомендуется к использованию. Используйте <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A> метод <xref:System.Web.Configuration.WebConfigurationManager> класса, чтобы получить сведения о конфигурации для текущего приложения.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Тег конфигурации, для которого запрашиваются сведения.</param>
        <summary>Возвращает запрашиваемые сведения о конфигурации для текущего HTTP-запроса.</summary>
        <returns>Указанный объект <see cref="T:System.Configuration.ConfigurationSection" />, <see langword="null" />, если раздел не существует, или внутренний объект, если раздел не доступен во время выполнения. (Приводит возвращаемый объект к соответствующему типу конфигурации перед использованием.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Web.HttpContext.GetConfig%2A> не рекомендуется к использованию. Используйте <xref:System.Web.HttpContext.GetSection%2A> метод, чтобы получить сведения о конфигурации для текущего HTTP-запроса.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает ресурс на уровне приложения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classKey">Строка, представляющая свойство <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> запрошенного объекта ресурса.</param>
        <param name="resourceKey">Строка, представляющая свойство <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> запрошенного объекта ресурса.</param>
        <summary>Получает объект ресурса на уровне приложения на основе указанных свойств <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> и <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />.</summary>
        <returns>Объект <see cref="T:System.Object" />, представляющий запрошенный объект ресурса уровня приложения; в противном случае — значение NULL, если объект ресурса не найден или найден, но у него отсутствует нужное свойство.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetGlobalResourceObject%2A> Метод возвращает глобальных ресурсов с помощью языка и региональных параметров, который указан в <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> свойство.  
  
> [!NOTE]
>  В некоторых редактирования средах, таких как [!INCLUDE[vwprvw](~/includes/vwprvw-md.md)], редактор может вызывать во время разработки <xref:System.Resources.MissingManifestResourceException> исключение, если используется точка (.) в глобальном имени ключа ресурса. Однако это не влияет на возможность изменения и сохранения файла и ошибку можно игнорировать.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Объект ресурса с указанным параметром <paramref name="classKey" /> не был найден.  
  
 \- или -  
  
 Главная сборка не содержит ресурсов для нейтральных языка и региональных параметров и данные ресурсы необходимы из-за отсутствия соответствующей вспомогательной сборки.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="classKey">Строка, представляющая свойство <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> запрошенного объекта ресурса.</param>
        <param name="resourceKey">Строка, представляющая свойство <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> запрошенного объекта ресурса.</param>
        <param name="culture">Строка, представляющая объект <see cref="T:System.Globalization.CultureInfo" /> запрошенного ресурса.</param>
        <summary>Получает объект ресурса на уровне приложения на основе заданных свойств <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> и <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> и объекта <see cref="T:System.Globalization.CultureInfo" />.</summary>
        <returns>Объект <see cref="T:System.Object" />, представляющий запрошенный объект ресурса на уровне приложения, локализованный для указанного языка и региональных параметров; в противном случае — <see langword="null" />, если объект ресурса не найден или найден, но у него отсутствует нужное свойство.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo> Представляет язык и региональные параметры, для которого ресурс локализован. Если ресурс не локализован для этого языка и региональных параметров, поиска будет располагаться резервного процесса для определения подходящего ресурса. Дополнительные сведения см. в статье [Упаковка и развертывание ресурсов](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
> [!NOTE]
>  В некоторых средах редактирования, например Visual Web Developer, редактор может вызывать во время разработки <xref:System.Resources.MissingManifestResourceException> исключение, если используется точка (.) в глобальном имени ключа ресурса. Однако это не влияет на возможность изменения и сохранения файла и ошибку можно игнорировать.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Объект ресурса с указанным для него параметром <paramref name="classKey" /> не был найден.  
  
 \- или -  
  
 Главная сборка не содержит ресурсов для нейтральных языка и региональных параметров и данные ресурсы необходимы из-за отсутствия соответствующей вспомогательной сборки.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает ресурс на уровне страницы.</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Свойство <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> для объекта локального ресурса.</param>
        <param name="resourceKey">Строка, представляющая свойство <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> запрошенного объекта ресурса.</param>
        <summary>Получает объект ресурса на уровне страницы на основе заданных свойств <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> и <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />.</summary>
        <returns>Объект <see cref="T:System.Object" />, представляющий запрошенный объект ресурса на уровне страницы; в противном случае — значение <see langword="null" />, если найден подходящий объект ресурса, но не параметр <paramref name="resourceKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetLocalResourceObject%2A> Метод возвращает локальный ресурс с помощью языка и региональных параметров, который указан в <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Объект ресурса с указанным для него параметром <paramref name="virtualPath" /> не был найден.</exception>
        <exception cref="T:System.ArgumentException">Указанный параметр <paramref name="virtualPath" /> не находится в корневом каталоге текущего приложения.</exception>
        <exception cref="T:System.InvalidOperationException">Класс ресурсов для страницы не был найден.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Свойство <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> для объекта локального ресурса.</param>
        <param name="resourceKey">Строка, представляющая свойство <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> запрошенного объекта ресурса.</param>
        <param name="culture">Строка, представляющая объект <see cref="T:System.Globalization.CultureInfo" /> запрошенного объекта ресурса.</param>
        <summary>Получает объект ресурса на уровне страницы на основе заданных свойств <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> и <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> и объекта <see cref="T:System.Globalization.CultureInfo" />.</summary>
        <returns>Объект <see cref="T:System.Object" />, представляющий запрошенный объект локального ресурса, который локализован для указанного языка и региональных параметров; в противном случае — значение <see langword="null" />, если найден подходящий объект ресурса, но не параметр <paramref name="resourceKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ресурс не локализован для этого языка и региональных параметров, поиска будет располагаться резервного процесса для определения подходящего ресурса. Дополнительные сведения см. в статье [Упаковка и развертывание ресурсов](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Объект ресурса с указанным для него параметром <paramref name="virtualPath" /> не был найден.</exception>
        <exception cref="T:System.ArgumentException">Указанный параметр <paramref name="virtualPath" /> не находится в корневом каталоге текущего приложения.</exception>
        <exception cref="T:System.InvalidOperationException">Класс ресурсов для страницы не был найден.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">Путь к разделу конфигурации (в формате XPath) и имя элемента конфигурации.</param>
        <summary>Получает указанный раздел конфигурации для конфигурации текущего приложения, заданной по умолчанию.</summary>
        <returns>Указанный объект <see cref="T:System.Configuration.ConfigurationSection" />, <see langword="null" />, если раздел не существует, или внутренний объект, если раздел не доступен во время выполнения.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Web.IHttpHandler" />, отвечающий за обработку HTTP-запроса.</summary>
        <value>Объект <see cref="T:System.Web.IHttpHandler" />, отвечающий за обработку HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Handler%2A> Свойство содержит ссылку на обработчик, который обрабатывает HTTP-запроса. Обработчик можно указать с помощью элемента или с помощью пользовательского обработчика, определенного в коде пользователя. Дополнительные сведения об обработчиках см. в разделе [обработчики HTTP-данных и общие сведения о модулях HTTP](http://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b).  
  
 Ссылка на <xref:System.Web.HttpContext.Handler%2A> свойство оставаться неизменным даже после текущей страницы был изменен серверного метода, такие как <xref:System.Web.HttpServerUtility.Execute%2A> метода или <xref:System.Web.HttpServerUtility.Transfer%2A> метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, включены ли настраиваемые ошибки для текущего HTTP-запроса.</summary>
        <value>
          Значение <see langword="true" />, если настраиваемые ошибки включены; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, выполняется ли текущий HTTP-запрос в режиме отладки.</summary>
        <value>
          Значение <see langword="true" />, если запрос выполняется в режиме отладки; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, представляющее текущую точку обработки в конвейере ASP.NET сразу после завершения обработки события <see cref="T:System.Web.HttpApplication" />.</summary>
        <value>
          Значение <see langword="true" />, если настраиваемые ошибки включены; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.IsPostNotification%2A> Свойство поддерживается только в интегрированном режиме [!INCLUDE[iisver](~/includes/iisver-md.md)] и по крайней мере .NET Framework 3.0. Если она доступна, свойство возвращает логическое значение, указывающее, является ли событие в <xref:System.Web.HttpApplication> завершает обработку.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> Не планируется задать. Вместо этого она предоставляется [!INCLUDE[iisver](~/includes/iisver-md.md)] для среды выполнения ASP.NET для каждого уведомления. Параметр <xref:System.Web.HttpContext.IsPostNotification%2A> свойства приведет к ошибке компиляции.  
  
 В сценариях, где несколько событий <xref:System.Web.HttpApplication> объекта обрабатываются один обработчик событий, можно использовать <xref:System.Web.HttpContext.IsPostNotification%2A> свойство в сочетании с <xref:System.Web.RequestNotification> перечисления для точного определения, где текущего жизненного цикла приложения — запрос.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> впервые появился в платформе .NET Framework версии 3.5.  Дополнительные сведения см. в статье [Версии и зависимости платформы .NET Framework](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Web.HttpContext.IsPostNotification%2A> свойство, чтобы определить, когда событие <xref:System.Web.HttpApplication> объект завершил обработку всех обработчиков связанного события. Обработчике события в этом примере обрабатывает несколько событий <xref:System.Web.HttpApplication> объекта и <xref:System.Web.HttpContext.IsPostNotification%2A> свойство используется для определения, какой код вызывается после обработки определенного события.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Для операции требуется режим интегрированного конвейера в [!INCLUDE[iisver](~/includes/iisver-md.md)] и как минимум платформа .NET Framework 3.0.</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, является ли запрос запросом <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>
          Значение <see langword="true" />, если запрос является запросом <see cref="T:System.Web.WebSockets.AspNetWebSocket" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает `true` Если запрос содержит начальные <xref:System.Web.WebSockets.AspNetWebSocket> подтверждения и `WebSocket` модуль служб IIS является активным.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, обновляется ли HTTP-соединение до соединения <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>
          Значение <see langword="true" />, если соединение обновляется; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию ключей и значений, которую можно использовать для систематизации данных и обмена ими между интерфейсами <see cref="T:System.Web.IHttpModule" /> и <see cref="T:System.Web.IHttpHandler" /> во время выполнения HTTP-запроса.</summary>
        <value>Коллекция ключей и значений <see cref="T:System.Collections.IDictionary" />, доступ к отдельному значению в которой можно получить с помощью указанного ключа.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ссылку на экземпляр службы инструментирования страниц для данного запроса.</summary>
        <value>Экземпляр службы инструментирования страниц для данного запроса.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Web.IHttpHandler" /> для родительского обработчика.</summary>
        <value>Экземпляр <see cref="T:System.Web.IHttpHandler" /> или значение <see langword="null" />, если предыдущий обработчик не найден.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.PreviousHandler%2A> Свойства соответствует последнему обработчика до выполнения текущего запроса.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Web.Profile.ProfileBase" /> для текущего профиля пользователя.</summary>
        <value>Объект <see cref="T:System.Web.Profile.ProfileBase" />, если файл конфигурации приложения содержит определение для свойств профиля; в противном случае — значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Web.HttpContext.Profile%2A> свойство используется для постоянного хранения структурированных данных с помощью API типобезопасным. Когда <xref:System.Web.HttpContext.Profile%2A> доступ к свойству, но значение не существует, возвращается пустой экземпляр; `null` не возвращается.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
      </Parameters>
      <Docs>
        <param name="handler">Объект, который обрабатывает запрос.</param>
        <summary>Позволяет указать обработчик запроса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если задать `handler` для `null`, обработчик по умолчанию используется для обработки запроса. Можно задать `handler` обработчик синхронный или асинхронный обработчик. Необходимо реализовать обработчик <xref:System.Web.IHttpHandler> интерфейса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /> был вызван после того, как произошло событие <see cref="E:System.Web.HttpApplication.MapRequestHandler" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.HttpRequest" /> для текущего HTTP-запроса.</summary>
        <value>Объект <see cref="T:System.Web.HttpRequest" /> для текущего HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Request%2A> Свойство обеспечивает программный доступ к свойствам и методам <xref:System.Web.HttpRequest> класса. Так как страницы ASP.NET содержат ссылки по умолчанию <xref:System.Web> пространства имен (которого содержит <xref:System.Web.HttpContext> класса), можно ссылаться на члены <xref:System.Web.HttpRequest> на странице ASPX без использования полного имени класса ссылку <xref:System.Web.HttpContext>. Например, можно использовать `Request.Browser` для получения возможностей клиентского браузера. Тем не менее если вы хотите использовать члены <xref:System.Web.HttpRequest> с выделенным кодом ASP.NET, необходимо включить ссылку на <xref:System.Web> имен в модуль и полную ссылку на контекст текущий активный запрос ответ и в класс <xref:System.Web> , которую требуется использовать. Например, на странице кода необходимо указать полное доменное имя `HttpContext.Current.Request.Browser`.  
  
> [!NOTE]
>  ASP.NET будет вызывать исключение при попытке использовать это свойство при <xref:System.Web.HttpRequest> объект недоступен. Например это будет значение true в методе Application_Start файл Global.asax, или в методе, который вызывается из метода Application_Start. В это время HTTP-запрос еще была создана.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Веб-приложение выполняется под управлением IIS 7 в интегрированном режиме.</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Web.HttpResponse" /> для текущего HTTP-ответа.</summary>
        <value>Объект <see cref="T:System.Web.HttpResponse" /> для текущего HTTP-ответа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Response%2A> Свойство обеспечивает программный доступ к свойствам и методам <xref:System.Web.HttpResponse> класса. Так как страницы ASP.NET содержат ссылки по умолчанию <xref:System.Web> пространства имен (которого содержит <xref:System.Web.HttpContext> класса), можно ссылаться на члены <xref:System.Web.HttpContext> на странице ASPX без использования полного имени класса ссылку <xref:System.Web.HttpContext>. Например, можно использовать `Response.Write("some output")` для записи выходных данных в поток вывода НТТР. Тем не менее если вы хотите использовать члены <xref:System.Web.HttpResponse> с выделенным кодом ASP.NET, необходимо включить ссылку на <xref:System.Web> имен в модуль и полные ссылки на контекст текущего активного запроса или ответа и класс в <xref:System.Web> , которую требуется использовать. Например, на странице кода необходимо указать полное доменное имя `HttpContext.Current.Response.Write("some output")`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Веб-приложение выполняется под управлением IIS 7 в интегрированном режиме.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Перенаправляет запрос ресурса по пути, отличному от указанного в запрошенном URL-адресе. <see cref="Overload:System.Web.HttpContext.RewritePath" /> используется в состоянии сеанса без куки-файлов, чтобы отделять ИД сеансов от URL-адресов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Внутренний путь перезаписи.</param>
        <summary>Перезаписывает URL-адрес, используя заданный путь.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%28System.String%29> Метод перенаправляет запрос ресурса в пути, отличному от указанного запрошенного URL-адреса. При наличии для сброса виртуального пути, чтобы правильно обработать запросы от клиента к ресурсам сервера, используйте перегрузку этого метода, принимающего `rebaseClientPath` параметр и задать для параметра `false`.  
  
 Переписывание URL-адресов полезно в том случае, если вы хотите изменить структуру страниц в веб-приложении, и вы хотели бы убедиться, люди, которые добавили старые URL-адреса можно по-прежнему использовать их после перемещения страниц. Переписывание URL-адресов позволяет прозрачно перенаправлять запросы на новое расположение страницы.  
  
 Если требуется, чтобы сайт мог использовать URL-адреса, которые более понятны и оптимизированы поисковых, более надежна, чем является использование маршрутизации ASP.NET. Дополнительные сведения см. в разделе [маршрутизация ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Web.HttpContext.RewritePath%2A> метод, чтобы реагировать на URL-адреса, которые не отражают структуры файлов на веб-сайте веб-сайта. Первый блок кода является веб-страницу ASP.NET с именем RewritePath.aspx. Он требует строку запроса. Если имя узла — WebSite1 URL-адрес `http://localhost/WebSite1/RewritePath.aspx?page=1` отображает «Страница 1» в браузере. Блок кода, следующего веб-странице — `Application_BeginRequest` обработчика событий в файле Global.asax. Этот код перехватывает запросы для URL-адресов, таких как `http://localhost/WebSite1/page1` и преобразует их в форму, которая необходима для RewritePath.aspx до их обработки. Таким образом, URL-адрес `http://localhost/WebSite1/page1` вызывает RewritePath.aspx с параметром строки запроса, который отображает «Страница 1» в браузере. Если URL-адрес, например `http://localhost/WebSite1/page1` поступает, перегрузку <xref:System.Web.HttpContext.RewritePath%2A> вызывается, можно указать значение для <xref:System.Web.HttpRequest.PathInfo%2A> свойства, а также запрос строковый параметр.  
  
 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Путь, указанный в параметре <paramref name="path" />, отсутствует в корневом каталоге текущего приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Внутренний путь перезаписи.</param>
        <param name="rebaseClientPath">
          Значение <see langword="true" /> для сброса виртуального пути; значение <see langword="false" /> для сохранения виртуального пути без изменений.</param>
        <summary>Перезаписывает URL-адрес, используя заданный путь и логическое значение, которое указывает, был ли изменен виртуальный путь к ресурсам сервера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> Метод вызывается методом <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType> метод с `rebaseClientPath` равным `true`. Чтобы убедиться, что виртуальный путь, который используется для создания путей к ресурсам, не изменен, задайте `rebaseClientPath` параметр `false`. Типичный сценарий, в котором может потребоваться задать `rebaseClientPath` для `false` когда необходимо перезаписать URL-адрес, а также при применении темы, а перенаправление URL-адрес для ресурса, расположенного в папку, отличную от запрошенного ресурса.  
  
 Переписывание URL-адресов полезно в том случае, если вы хотите изменить структуру страниц в веб-приложении, и вы хотели бы убедиться, люди, которые добавили старые URL-адреса можно по-прежнему использовать их после перемещения страниц. Переписывание URL-адресов позволяет прозрачно перенаправлять запросы на новое расположение страницы.  
  
 Если требуется, чтобы сайт мог использовать URL-адреса, которые более понятны и оптимизированы поисковых, более надежна, чем является использование маршрутизации ASP.NET. Дополнительные сведения см. в разделе [маршрутизация ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Пример кода см. в разделе <xref:System.Web.HttpContext.RewritePath%28System.String%29> перегрузки метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Путь, указанный в параметре <paramref name="path" />, отсутствует в корневом каталоге текущего приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">Внутренний путь перезаписи.</param>
        <param name="pathInfo">Дополнительные сведения о пути для ресурса. Дополнительные сведения см. в разделе <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Строка запроса.</param>
        <summary>Перезаписывает URL-адрес, используя заданный путь, сведения о пути и данные строки запроса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%2A> Метод перенаправляет запрос ресурса на другой ресурс без изменения URL-адрес.  
  
 `filePath` Параметр включает в себя `pathInfo` содержимое параметра. URL-адрес http://www.microsoft.com/virdir/page.html/tail, `filePath` параметр http://www.microsoft.com/virdir/page.htmlи `pathInfo` параметр является префиксом tail.  
  
 Переписывание URL-адресов полезно в том случае, если вы хотите изменить структуру страниц в веб-приложении, и вы хотели бы убедиться, люди, которые добавили старые URL-адреса можно по-прежнему использовать их после перемещения страниц. Переписывание URL-адресов позволяет прозрачно перенаправлять запросы на новое расположение страницы.  
  
 Если требуется, чтобы сайт мог использовать URL-адреса, которые более понятны и оптимизированы поисковых, более надежна, чем является использование маршрутизации ASP.NET. Дополнительные сведения см. в разделе [маршрутизация ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Пример кода, включая пример перегрузка метода в разделе <xref:System.Web.HttpContext.RewritePath%28System.String%29> перегрузки метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Путь, указанный в параметре <paramref name="path" />, отсутствует в корневом каталоге текущего приложения.</exception>
        <exception cref="T:System.Web.HttpException">Путь, указанный в параметре <paramref name="filePath" />, отсутствует в корневом каталоге текущего приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filePath">Виртуальный путь к ресурсу, обслуживающему запрос.</param>
        <param name="pathInfo">Дополнительные сведения о пути, используемые для перенаправления URL-адреса. Дополнительные сведения см. в разделе <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Строка запроса, используемая для перенаправления URL-адреса.</param>
        <param name="setClientFilePath">
          Значение <see langword="true" /> для присвоения пути к файлу, используемому для ресурсов клиента, в качестве значения параметра <c>filePath</c>; в противном случае значение <see langword="false" />.</param>
        <summary>Перезаписывает URL-адрес, используя заданный виртуальный путь, сведения о пути, данные строки запроса и логическое значение, которое указывает, был ли задан путь к файлу клиента как путь перезаписи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `filePath` Параметр включает в себя содержимое `pathInfo` параметра. URL-адрес http://www.microsoft.com/virdir/page.html/tail, `filePath` параметр http://www.microsoft.com/virdir/page.htmlи `pathInfo` параметр является префиксом tail.  
  
 Чтобы убедиться, что виртуальный путь, который используется для создания путей к ресурсам, не изменен, задайте `setClientFilePath` параметр `false`. Типичный сценарий, в котором может потребоваться задать `setClientFilePath` для `false` когда необходимо перезаписать URL-адрес, а также при применении темы, а перенаправление URL-адрес для ресурса, расположенного в папку, отличную от запрошенного ресурса.  
  
 Переписывание URL-адресов полезно в том случае, если вы хотите изменить структуру страниц в веб-приложении, и вы хотели бы убедиться, люди, которые добавили старые URL-адреса можно по-прежнему использовать их после перемещения страниц. Переписывание URL-адресов позволяет прозрачно перенаправлять запросы на новое расположение страницы.  
  
 Если требуется, чтобы сайт мог использовать URL-адреса, которые более понятны и оптимизированы поисковых, более надежна, чем является использование маршрутизации ASP.NET. Дополнительные сведения см. в разделе [маршрутизация ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Пример кода см. в разделе <xref:System.Web.HttpContext.RewritePath%28System.String%29> перегрузки метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Путь, указанный в параметре <paramref name="path" />, отсутствует в корневом каталоге текущего приложения.</exception>
        <exception cref="T:System.Web.HttpException">Путь, указанный в параметре <paramref name="filePath" />, отсутствует в корневом каталоге текущего приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Web.HttpServerUtility" />, предоставляющий методы, используемые при обработке веб-запросов.</summary>
        <value>Объект <see cref="T:System.Web.HttpServerUtility" /> для текущего HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Server%2A> Свойство обеспечивает программный доступ к свойствам и методам <xref:System.Web.HttpServerUtility> класса. Так как страницы ASP.NET содержат ссылки по умолчанию <xref:System.Web> пространства имен (которого содержит <xref:System.Web.HttpContext> класса), можно ссылаться на члены <xref:System.Web.HttpContext> на странице ASPX без использования полного имени класса ссылку <xref:System.Web.HttpContext>. Например, можно использовать `Server.CreateObject("MyCOMComponent")` для создания экземпляра COM-объекта на сервере. Тем не менее если вы хотите использовать члены <xref:System.Web.HttpServerUtility> с выделенным кодом ASP.NET, необходимо включить ссылку на <xref:System.Web> имен в модуль и полную ссылку на контекст текущий активный запрос ответ и в класс <xref:System.Web> , которую требуется использовать. Например, на странице кода необходимо указать полное доменное имя `HttpContext.Current.Server.CreateObject("MyCOMComponent")`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.SessionState.HttpSessionState" /> для текущего HTTP-запроса.</summary>
        <value>Объект <see cref="T:System.Web.SessionState.HttpSessionState" /> для текущего HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Session%2A> Свойство обеспечивает программный доступ к свойствам и методам <xref:System.Web.SessionState.HttpSessionState> класса.  
  
 Чтобы использовать состояние сеанса, необходимо включить его. Сведения о том, как включить состояние сеанса в разделе **состояние сеанса Настройка** в [Общие сведения о состоянии сеанса ASP.NET](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
 Сведения о том, как сохранить значения в состоянии сеанса см. в разделе [как: сохранить значения в состоянии сеанса](http://msdn.microsoft.com/library/a6cb2e3a-df49-4b12-9d9a-eed45541c165). Сведения о том, как считывать значения из состояния сеанса см. в разделе [как: чтение значений из состояния сеанса](http://msdn.microsoft.com/library/2ef449bc-5c17-4785-b7cf-378c601af8f5).  
  
   
  
## Examples  
 В следующих примерах способ сохранения значений в состоянии сеанса и способа чтения значений состояния сеанса.  
  
 Для этих примеров требуются:  
  
-   Приложение ASP.NET, состоянии сеанса.  
  
-   Класс страницы Web Forms, имеющего доступ к <xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType> свойства или любой класс, имеет доступ к <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> свойство.  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">Одно из значений перечисления, которое задает необходимый тип поведения состояния сеанса.</param>
        <summary>Задает тип поведения состояния сеанса, который необходим для поддержки HTTP-запроса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В реализации по умолчанию ASP.NET обработчика HTTP-данных запроса указывает, требуются ли состояние сеанса, реализовав <xref:System.Web.SessionState.IRequiresSessionState> интерфейса или <xref:System.Web.SessionState.IReadOnlySessionState> интерфейса. <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> Метод и <xref:System.Web.SessionState.SessionStateBehavior> перечисления позволяют обеспечить более подробные сведения о какой тип поддержки состояния сеанса необходима для обработки запроса. Дополнительные сведения см. в описании перечисления <xref:System.Web.SessionState.SessionStateBehavior>.  
  
 <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> Метод должен вызываться перед <xref:System.Web.HttpApplication.AcquireRequestState> событий конвейера. Вызовы, которые выполняются во время или после этого события приведет к <xref:System.InvalidOperationException> исключения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод был вызван после того, как произошло событие <see cref="E:System.Web.HttpApplication.AcquireRequestState" />.</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, должен ли объект <see cref="T:System.Web.Security.UrlAuthorizationModule" /> пропускать проверку авторизации текущего запроса.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Web.Security.UrlAuthorizationModule" /> должен пропускать проверку авторизации; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.SkipAuthorization%2A> Свойство предназначено для расширенного использования в модулях проверки подлинности, которые необходимы для перенаправления на страницу, разрешены анонимные подключения. Установить оба модуля проверки подлинности и модуль проверки подлинности Passport <xref:System.Web.HttpContext.SkipAuthorization%2A> при перенаправлении на страницу настроенного входа. Установка <xref:System.Web.HttpContext.SkipAuthorization%2A> требует `ControlPrincipal` установить флаг. Сведения о `ControlPrincipal` флаг см. в разделе <xref:System.Security.Permissions.SecurityPermissionFlag>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">Тип службы <see cref="T:System.Web.HttpContext" />, необходимый для задания поставщика услуг.</param>
        <summary>Возвращает объект текущего типа службы.</summary>
        <returns>Объект <see cref="T:System.Web.HttpContext" />; в противном случае — значение <see langword="null" />, если служба не найдена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод полезен для получения доступа к базовому объекту <xref:System.Web.HttpWorkerRequest> объекта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должна ли среда выполнения ASP.NET вызывать метод <see cref="M:System.Threading.Thread.Abort" /> в потоке, обслуживающем этот запрос, при истечении времени ожидания запроса.</summary>
        <value>
          <see langword="true" /> если метод <see cref="M:System.Threading.Thread.Abort" /> будет вызываться, когда истекает время ожидания потока; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обработчики и модули, которые используют <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> свойство для реализации совместной отмены может потребоваться отключить <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> поведение, которое выполняется в ASP.NET по умолчанию при истечении времени ожидания запроса. Присвоение этому свойству `false` может помочь вам обеспечить выполнение процедуры отмены и очистки не прерывалось ASP.NET.  
  
 Если это свойство имеет значение `false`, ASP.NET не будет отображать автоматически на страницу ошибок «Истекло время ожидания запроса» при возникновении тайм-аута. Приложение отвечает за настройку содержимого отклика соответствующим образом.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает начальную метку времени текущего HTTP-запроса.</summary>
        <value>Метка времени текущего HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отметка времени, возвращаемые <xref:System.Web.HttpContext.Timestamp%2A> свойство представляет локальное время сервера и устанавливается во время создания экземпляра <xref:System.Web.HttpContext> объекта. Местное время равно времени в формате UTC, а также смещение относительно UTC.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Web.TraceContext" /> для текущего HTTP-ответа.</summary>
        <value>Объект <see cref="T:System.Web.TraceContext" /> для текущего HTTP-ответа.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает сведения о безопасности для текущего HTTP-запроса.</summary>
        <value>Сведения о безопасности для текущего HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.User%2A> Свойство обеспечивает программный доступ к свойствам и методам <xref:System.Security.Principal.IPrincipal> интерфейса.  
  
 Так как страницы ASP.NET содержат ссылки по умолчанию <xref:System.Web> пространства имен (которого содержит <xref:System.Web.HttpContext> класса), можно ссылаться на члены <xref:System.Web.HttpContext> на странице ASPX без использования полного имени класса ссылку <xref:System.Web.HttpContext>. Например, можно использовать `User.Identity.Name` для получения имени пользователя, от лица которого текущий процесс выполняется. Тем не менее если вы хотите использовать члены <xref:System.Security.Principal.IPrincipal> с выделенным кодом ASP.NET, необходимо включить ссылку на <xref:System.Web> имен в модуль и полную ссылку на контекст текущий активный запрос ответ и в класс <xref:System.Web> , которую требуется использовать. Например, на странице кода необходимо указать полное доменное имя `HttpContext.Current.User.Identity.Name`.  
  
   
  
## Examples  
 Приведенный ниже показано, как получить доступ к свойствам текущего пользователя через <xref:System.Web.HttpContext.User%2A> свойство. Эти свойства используются для установки заголовка веб-страницы.  
  
 Если приложение использует проверку подлинности Windows, имя пользователя содержит домен. Например заголовок страницы будет «Домашняя страница для домен\имя_пользователя».  
  
 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает согласованный протокол, который был отправлен с сервера клиенту для соединения <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>Согласованный протокол.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает упорядоченный список протоколов, запрашиваемых клиентом.</summary>
        <value>Запрошенные протоколы или значение <see langword="null" />, если это не запрос <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> или если список не существует.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>